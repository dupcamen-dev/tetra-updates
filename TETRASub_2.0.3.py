# -*- coding: utf-8 -*-
# README: Post-fill pipeline & PriceSource overview
# - PriceSource keeps unified entry/current prices: WS cache first (ticker/mark/book), single REST fallback.
# - OrderPlacementService places SL/TP only via Algo API with normalization + trigger clamp against immediate fire.
# - handle_filled_event is the sole ORDER_TRADE_UPDATE(FILLED) entry point: extracts entry/current price, places SL/TP instantly, updates local state, then plays open sound once an Algo order is confirmed.
from concurrent.futures import ThreadPoolExecutor

import os
import subprocess
import sys
import time
import warnings

# Reduce noisy Qt deprecation warnings (keeps console clean on Windows)
warnings.filterwarnings("ignore", category=DeprecationWarning)

# --- FPS targets (UI paint/update) ---
# Best-effort. On a 60Hz monitor, visual refresh will still be limited to 60Hz.
BOOK_FORCE_REPAINT_MS = 8        # ~120 FPS
ORDERBOOK_UI_FRAME_MS = 16       # ~60 FPS
PRINTS_UI_FRAME_MS = 4           # ~250 FPS flush cadence

# ------------------- Windows: run GUI without console (pythonw) -------------------
# If started via python.exe (double-click / file association), Windows may spawn a console
# window and keep re-showing it. The most reliable way to prevent this is to relaunch
# the script using pythonw.exe (GUI subsystem).
def _relaunch_with_pythonw():
    try:
        if os.name != 'nt':
            return
        if os.environ.get('TETRA_SHOW_CONSOLE', '').strip().lower() in ('1','true','yes','on'):
            return
        if os.environ.get('TETRA_PYW_RELAUNCHED', '') == '1':
            return
        base = os.path.basename(sys.executable).lower()
        if base == 'pythonw.exe':
            return
        if base != 'python.exe':
            return
        pythonw = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
        if not os.path.exists(pythonw):
            return
        args = [pythonw] + sys.argv
        env = os.environ.copy()
        env['TETRA_PYW_RELAUNCHED'] = '1'
        try:
            flags = subprocess.DETACHED_PROCESS | subprocess.CREATE_NEW_PROCESS_GROUP
        except Exception:
            flags = 0x00000008  # DETACHED_PROCESS
        subprocess.Popen(args, env=env, cwd=os.getcwd(), close_fds=True, creationflags=flags)
        os._exit(0)
    except Exception:
        return

# Optional: relaunch with pythonw.exe to fully suppress console window.
# Disabled by default because some Win10/PySide6 setups can render a blank window on pythonw.
# Enable via env: TETRA_RELAUNCH_PYTHONW=1
if os.environ.get('TETRA_RELAUNCH_PYTHONW','').strip().lower() in ('1','true','yes','on'):
    _relaunch_with_pythonw()


# ------------------- Windows: hide the extra console window -------------------
# If the script is started via python.exe by double-click (common on Win10),
# Windows spawns a console window. We hide it immediately to keep only the GUI.
def _hide_windows_console_window():
    try:
        import os
        # Set TETRA_SHOW_CONSOLE=1 to keep console visible (debug).
        if os.environ.get('TETRA_SHOW_CONSOLE', '').strip().lower() in ('1', 'true', 'yes', 'on'):
            return
        if os.name != 'nt':
            return
        import ctypes
        hwnd = ctypes.windll.kernel32.GetConsoleWindow()
        if hwnd:
            # 0 = SW_HIDE
            ctypes.windll.user32.ShowWindow(hwnd, 0)
        try:
            ctypes.windll.kernel32.FreeConsole()
        except Exception:
            pass
    except Exception:
        return

# Hide console ASAP (Windows only). Safe no-op on other OS.
_hide_windows_console_window()

# Enable high-resolution Windows timer so Qt PreciseTimer can achieve <15ms intervals.
# This is critical for ~120 FPS prints animation on many Win10 systems.
def _enable_windows_high_res_timer():
    try:
        import os
        if os.name != 'nt':
            return
        # Allow disabling via env: TETRA_HIRES_TIMER=0
        if os.environ.get('TETRA_HIRES_TIMER', '').strip().lower() in ('0', 'false', 'no', 'off'):
            return
        import ctypes
        try:
            winmm = ctypes.WinDLL('winmm')
            winmm.timeBeginPeriod(1)
            # Ensure we end the period on process exit
            try:
                import atexit
                def _end():
                    try:
                        winmm.timeEndPeriod(1)
                    except Exception:
                        pass
                atexit.register(_end)
            except Exception:
                pass
        except Exception:
            pass
    except Exception:
        pass

_enable_windows_high_res_timer()


import math
import copy
import threading
import multiprocessing as mp

# On Windows, ensure multiprocessing child processes do NOT spawn console windows.
# This prevents black console pop-ups when we use spawn-based worker processes (renderers, etc.).
def _mp_use_pythonw_if_available():
    try:
        if os.name != 'nt':
            return
        base = os.path.basename(sys.executable).lower()
        if base == 'pythonw.exe':
            return
        pythonw = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
        if not os.path.exists(pythonw):
            return
        try:
            mp.set_executable(pythonw)
        except Exception:
            pass
    except Exception:
        pass
# Hotkeys: layout-independent matching (physical keys) for Windows.
# If True, letter hotkeys (A-Z, 0-9) are matched by the physical key position (scan code),
# so they work even when the keyboard layout is Ukrainian / Russian / etc.
HOTKEYS_PHYSICAL_KEYS = True

# Auto-center will keep spread near the middle even if it is already visible.
ORDERBOOK_CENTER_TOLERANCE_ROWS = 1
PENDING_WALL_RANGE_PCT = 0.01   # 1%
PENDING_WALL_OFFSET_TICKS = 1    # на 1 тик за wall

# Windows Set-1 scan codes for US QWERTY. (Qt: QKeyEvent.nativeScanCode()).
_US_SCANCODE_TO_USKEY = {
    0x01: "ESC",
    0x0F: "TAB",
    0x1C: "ENTER",
    0x0E: "BACKSPACE",
    0x39: "SPACE",
    0x2A: "SHIFT",  # LSHIFT
    0x36: "SHIFT",  # RSHIFT
    0x1D: "CTRL",   # LCTRL
    0x38: "ALT",    # LALT
    # digits
    0x02: "1", 0x03: "2", 0x04: "3", 0x05: "4", 0x06: "5",
    0x07: "6", 0x08: "7", 0x09: "8", 0x0A: "9", 0x0B: "0",
    # letters
    0x1E: "A", 0x30: "B", 0x2E: "C", 0x20: "D", 0x12: "E",
    0x21: "F", 0x22: "G", 0x23: "H", 0x17: "I", 0x24: "J",
    0x25: "K", 0x26: "L", 0x32: "M", 0x31: "N", 0x18: "O",
    0x19: "P", 0x10: "Q", 0x13: "R", 0x1F: "S", 0x14: "T",
    0x16: "U", 0x2F: "V", 0x11: "W", 0x2D: "X", 0x15: "Y",
    0x2C: "Z",
}
_US_USKEY_TO_SCANCODE = {v: k for k, v in _US_SCANCODE_TO_USKEY.items()}

def _native_scancode_from_keyevent(ev):
    try:
        return int(ev.nativeScanCode())
    except Exception:
        return None

def _us_key_from_keyevent(ev):
    sc = _native_scancode_from_keyevent(ev)
    if sc is None:
        return None
    return _US_SCANCODE_TO_USKEY.get(int(sc))

def _normalize_hotkey_str(s):
    try:
        s = str(s or "").strip().upper()
    except Exception:
        return ""
    # common aliases
    if s == " ":
        return "SPACE"
    if s in ("ESCAPE",):
        return "ESC"
    if s in ("RETURN",):
        return "ENTER"
    return s


_mp_use_pythonw_if_available()

import datetime
import pytz
import ctypes
import asyncio
import inspect
import signal
import atexit
import uuid
import hashlib
import heapq
from pathlib import Path

from queue import Queue, Empty, Full
from binance.client import Client
from binance import ThreadedWebsocketManager
from binance.exceptions import BinanceAPIException
UMFutures = None
import traceback
import re
from datetime import datetime, timedelta, timezone
import requests
import json

# --- Performance/renderer hints (must be set BEFORE importing Qt) ---
try:
    # Windows 10 часто падає в Software OpenGL; ANGLE (D3D11) дає значно вищий FPS
    if os.name == 'nt':
        os.environ.setdefault('QT_OPENGL', 'angle')
        os.environ.setdefault('QT_ANGLE_PLATFORM', 'd3d11')
        os.environ.setdefault('QT_OPENGL_ES', '1')
except Exception:
    pass
try:
    # Трошки менше GIL-перемикань -> стабільніший рендер
    import sys as _sys
    _sys.setswitchinterval(0.005)
except Exception:
    pass
# ---------------------------------------------------------------

import platform
from urllib.parse import urlencode, quote
from PySide6.QtWidgets import (
    QApplication,
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPlainTextEdit,
    QLabel,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QTableView,
    QFormLayout,
    QSpinBox,
    QDoubleSpinBox,
    QComboBox,
    QSplitter,
    QLineEdit,
    QHeaderView,
    QDialog,
    QScrollArea,
    QCheckBox,
    QAbstractSpinBox,
    QFrame,
    QGridLayout,
    QSizePolicy,
    QMessageBox,
    QFileDialog,
    QTabBar,
    QTabWidget,
    QStackedWidget,
    QSlider,
    QAbstractItemView,
    QStyledItemDelegate,
)
from PySide6.QtOpenGLWidgets import QOpenGLWidget
from PySide6.QtCore import Qt, QTimer, Signal, QObject, QPointF, QRect, QRectF, QEvent, QPropertyAnimation, QEasingCurve, QAbstractAnimation, QAbstractTableModel, QModelIndex
from PySide6.QtGui import QPicture, QPainter, QPainterPath, QIcon, QColor, QBrush, QPen, QLinearGradient, QGradient, QFont, QFontMetrics, QPalette, QCursor, QSurfaceFormat, QStaticText, QTransform
import pyqtgraph as pg
from pyqtgraph.graphicsItems.DateAxisItem import DateAxisItem
from job_kill_on_close import enable_kill_on_parent_close
from killer import launch_self_killer
from single_instance import ensure_single_instance

# Low-latency executor injected for price handling
_PRICE_EXECUTOR = ThreadPoolExecutor(
    max_workers=min(32, max(4, (os.cpu_count() or 4) * 2))
)
_price_pending_lock = threading.Lock()
_price_pending = set()
_windows_sync_thread_lock = threading.Lock()
_windows_sync_thread_started = False
_last_daily_reset_date = None
# Registry for algo orders (algoId -> meta) for unified futures conditional API
algo_order_registry = {}


class PriceSource:
    """Centralized entry/current price provider (WS first, REST fallback)."""

    def __init__(self):
        self._lock = threading.Lock()
        self._mark = {}  # symbol -> (price, ts)
        self._last = {}  # symbol -> (price, ts)
        self._bidask = {}  # symbol -> (bid, ask, ts)

    @staticmethod
    def _now():
        return time.time()

    @staticmethod
    def _symbol(sym):
        try:
            return (sym or "").upper()
        except Exception:
            return sym

    def update_ws_price(self, symbol, price=None, bid=None, ask=None, mark=None):
        sym = self._symbol(symbol)
        ts = self._now()
        with self._lock:
            if mark is not None:
                try:
                    self._mark[sym] = (float(mark), ts)
                except Exception:
                    self._mark[sym] = (mark, ts)
            if price is not None:
                try:
                    self._last[sym] = (float(price), ts)
                except Exception:
                    self._last[sym] = (price, ts)
            if bid is not None or ask is not None:
                self._bidask[sym] = (bid, ask, ts)
        # keep legacy caches in sync for existing consumers
        try:
            if price is not None:
                symbol_prices[sym] = {
                    'price': float(price),
                    'ts': ts,
                    'bid': symbol_prices.get(sym, {}).get('bid'),
                    'ask': symbol_prices.get(sym, {}).get('ask'),
                }
            if bid is not None or ask is not None:
                symbol_prices[sym] = {
                    'price': symbol_prices.get(sym, {}).get('price'),
                    'ts': ts,
                    'bid': bid if bid is not None else symbol_prices.get(sym, {}).get('bid'),
                    'ask': ask if ask is not None else symbol_prices.get(sym, {}).get('ask'),
                }
        except Exception:
            pass

    def get_current_price(self, symbol, prefer_ws=True, ws_wait_s=0.15, price_kind="mark"):
        sym = self._symbol(symbol)
        now_ts = self._now()
        price = None
        source = None
        try:
            kind = str(price_kind or "mark").lower().strip()
        except Exception:
            kind = "mark"
        if kind in ("contract", "last", "ticker"):
            kind = "last"
        elif kind in ("mid", "bidask", "book"):
            kind = "mid"
        else:
            kind = "mark"
        with self._lock:
            if kind == "mid":
                ba = self._bidask.get(sym)
                if ba and (now_ts - ba[2]) <= PRICE_STALE_SEC and ba[0] and ba[1]:
                    price = (float(ba[0]) + float(ba[1])) / 2.0
                    source = "WS:mid"
            if price is None and kind == "mark":
                mark = self._mark.get(sym)
                if mark and (now_ts - mark[1]) <= PRICE_STALE_SEC:
                    price = mark[0]
                    source = "WS:mark"
            if price is None:
                last = self._last.get(sym)
                if last and (now_ts - last[1]) <= PRICE_STALE_SEC:
                    price = last[0]
                    source = "WS:last"
            if price is None and kind != "mid":
                ba = self._bidask.get(sym)
                if ba and (now_ts - ba[2]) <= PRICE_STALE_SEC and ba[0] and ba[1]:
                    price = (float(ba[0]) + float(ba[1])) / 2.0
                    source = "WS:mid"
        if price is None and prefer_ws and kind != "last":
            end = now_ts + float(ws_wait_s or 0)
            while price is None and time.time() < end:
                try:
                    cached = symbol_prices.get(sym)
                    if cached and (time.time() - cached.get('ts', 0)) <= PRICE_STALE_SEC:
                        price = cached.get('price')
                        source = "WS:legacy"
                        break
                except Exception:
                    break
                time.sleep(0.02)

        if price is None:
            try:
                if kind == "last":
                    resp = signed_request(client.futures_symbol_ticker, symbol=sym)
                    price = float(resp.get('price'))
                    source = "REST:ticker"
                else:
                    resp = signed_request(client.futures_mark_price, symbol=sym)
                    price = float(resp.get('markPrice'))
                    source = "REST:mark"
                symbol_prices[sym] = {'price': price, 'ts': time.time()}
            except Exception:
                price = None
        if price is None:
            try:
                if kind == "last":
                    resp = signed_request(client.futures_mark_price, symbol=sym)
                    price = float(resp.get('markPrice'))
                    source = "REST:mark"
                else:
                    resp = signed_request(client.futures_symbol_ticker, symbol=sym)
                    price = float(resp.get('price'))
                    source = "REST:ticker"
                symbol_prices[sym] = {'price': price, 'ts': time.time()}
            except Exception:
                price = None

        if source and price is not None:
            try:
                log_message(f"[PRICE] {sym} current={price} source={source}")
            except Exception:
                pass
        return price, source

    def get_cached_price(self, symbol, max_age=None, price_kind="mark"):
        sym = self._symbol(symbol)
        now_ts = self._now()
        if max_age is None:
            max_age = PRICE_STALE_SEC
        price = None
        source = None
        try:
            kind = str(price_kind or "mark").lower().strip()
        except Exception:
            kind = "mark"
        if kind in ("contract", "last", "ticker"):
            kind = "last"
        elif kind in ("mid", "bidask", "book"):
            kind = "mid"
        else:
            kind = "mark"
        with self._lock:
            if kind == "mid":
                ba = self._bidask.get(sym)
                if ba and (now_ts - ba[2]) <= max_age and ba[0] and ba[1]:
                    price = (float(ba[0]) + float(ba[1])) / 2.0
                    source = "WS:mid"
            if price is None and kind == "mark":
                mark = self._mark.get(sym)
                if mark and (now_ts - mark[1]) <= max_age:
                    price = mark[0]
                    source = "WS:mark"
            if price is None:
                last = self._last.get(sym)
                if last and (now_ts - last[1]) <= max_age:
                    price = last[0]
                    source = "WS:last"
            if price is None and kind != "mid":
                ba = self._bidask.get(sym)
                if ba and (now_ts - ba[2]) <= max_age and ba[0] and ba[1]:
                    price = (float(ba[0]) + float(ba[1])) / 2.0
                    source = "WS:mid"
        if price is None:
            try:
                cached = symbol_prices.get(sym)
                if cached and (now_ts - cached.get('ts', 0)) <= max_age:
                    price = cached.get('price')
                    source = "WS:legacy"
            except Exception:
                pass
        return price, source

    def get_entry_price(self, evt, symbol=None, order_id=None):
        o = evt.get('o', {}) if isinstance(evt, dict) else {}
        sym = self._symbol(symbol or o.get('s') or o.get('symbol'))
        oid = order_id or o.get('i') or o.get('orderId')
        candidates = [
            o.get('ap'), o.get('avgPrice'), o.get('avgprice'),
            o.get('L'), o.get('lastFilledPrice'),
            o.get('p'), o.get('price'),
        ]
        entry = None
        for c in candidates:
            try:
                v = float(c)
                if v > 0:
                    entry = v
                    break
            except Exception:
                continue
        source = "EVENT"
        if (entry is None or entry <= 0) and sym and oid:
            try:
                resp = signed_request(client.futures_get_order, symbol=sym, orderId=oid)
                entry = float(resp.get('avgPrice') or resp.get('price') or resp.get('stopPrice') or 0)
                source = "REST:get_order"
            except Exception as e:
                try:
                    log_message(f"[PRICE] entry REST fallback failed for {sym}: {e}")
                except Exception:
                    pass
        if entry is not None and entry > 0:
            try:
                log_message(f"[PRICE] entry {sym}={entry} source={source}")
            except Exception:
                pass
        return entry, source


class OrderPlacementService:
    """Single Algo-order submitter with normalization, clamp, retries."""

    def __init__(self, price_source: PriceSource):
        self.price_source = price_source
        self._filter_cache = {}

    def _filters(self, symbol):
        sym = (symbol or "").upper()
        cached = self._filter_cache.get(sym)
        if cached:
            return cached
        tick = 0.0
        step = 0.0
        qty_prec = 0
        price_prec = 0
        info = get_exchange_info_cached()
        for s in info.get("symbols", []):
            if s.get("symbol") == sym:
                for f in s.get("filters", []):
                    if f.get("filterType") == "PRICE_FILTER":
                        try:
                            tick = float(f.get("tickSize"))
                            price_prec = int(round(-math.log10(tick), 0))
                        except Exception:
                            tick = 0.0
                    elif f.get("filterType") == "LOT_SIZE":
                        try:
                            step = float(f.get("stepSize"))
                            qty_prec = int(round(-math.log10(step), 0))
                        except Exception:
                            step = 0.0
                break
        if tick == 0:
            tick = 10 ** (-price_prec or 8)
        if step == 0:
            step = 10 ** (-qty_prec or 0)
        self._filter_cache[sym] = {
            "tick": tick,
            "step": step,
            "qty_prec": qty_prec,
            "price_prec": price_prec
        }
        return self._filter_cache[sym]

    @staticmethod
    def _round(value, step):
        try:
            if step <= 0:
                return value
            return round(round(float(value) / step) * step, 12)
        except Exception:
            return value

    def _clamp_trigger(self, side, entry_price, current_price, trigger, tick):
        """
        Clamp trigger slightly away from current price to avoid Binance
        immediate-trigger rejections, but only in the "wrong side" cases.
        If price has already crossed the intended SL level, the caller
        should close the position at market instead of clamping here.
        """
        try:
            ep = float(entry_price or 0)
            cp = float(current_price or 0)
            tr = float(trigger or 0)
        except Exception:
            return trigger, False
        # small technical buffer only; do not override business logic
        eps_pct = max(0.0002, (tick / ep) * 1.5 if ep else 0.0002)
        adjusted = tr
        clamped = False
        side_up = (side or "").upper()
        if side_up == "BUY":  # closing SHORT via STOP BUY
            # Guard against obviously wrong stops placed below both entry and current
            guard = min(cp, ep) * (1 + eps_pct)
            if adjusted < guard:
                adjusted = guard
                clamped = True
        else:  # SELL stop for LONG
            # Guard against obviously wrong stops placed above both entry and current
            guard = max(cp, ep) * (1 - eps_pct)
            if adjusted > guard:
                adjusted = guard
                clamped = True
        return adjusted, clamped

    def place_conditional(self, spec):
        """
        spec keys:
          kind: 'SL'|'TP'
          symbol, side (BUY/SELL), position_side, trigger, price (optional), quantity, close_position(bool),
          entry_price, current_price, working_type, reduce_only(optional)
        """
        sym = (spec.get('symbol') or "").upper()
        side = spec.get('side')
        kind = (spec.get('kind') or "TP").upper()
        try:
            if kind in ("SL", "TP") and (not spec.get("manual")) and (not bool(globals().get("bot_running", False))):
                return None
        except Exception:
            pass
        pos_side = spec.get('position_side') or "BOTH"
        trigger_raw = spec.get('trigger')
        qty_raw = spec.get('quantity')
        close_position = bool(spec.get('close_position'))
        entry_price = spec.get('entry_price')
        current_price = spec.get('current_price')
        working_type = spec.get('working_type') or "MARK_PRICE"
        reduce_only = bool(spec.get('reduce_only', kind == "TP" and not close_position))

        filt = self._filters(sym)
        tick = filt.get("tick") or 0.0
        step = filt.get("step") or 0.0
        qty_norm = None if qty_raw is None else max(self._round(qty_raw, step), 0.0)
        trigger = trigger_raw
        clamped = False
        order_type = "TAKE_PROFIT_MARKET" if kind == "TP" else "STOP_MARKET"
        if kind == "SL":
            trigger, clamped = self._clamp_trigger(side, entry_price, current_price, trigger_raw, tick)
        trigger_norm = self._round(trigger, tick)
        price_norm = None

        tp_guarded = False
        if kind == "TP":
            # TP "immediate trigger" protection:
            # - If TP is already reached (by MARK/LAST), close by MARKET (partial/full) instead of placing TP.
            # - Otherwise guard trigger away from the most conservative current price to reduce -2021.
            cp_candidates = []
            cp_min = None
            cp_max = None
            cp_best = None
            cp_best_src = None
            try:
                cp_given = float(current_price)
                if cp_given > 0:
                    cp_candidates.append(cp_given)
            except Exception:
                cp_given = None
            try:
                cp_best, cp_best_src = self.price_source.get_current_price(sym)
                if cp_best is not None:
                    cp_best = float(cp_best)
                    if cp_best > 0:
                        cp_candidates.append(cp_best)
            except Exception:
                cp_best = None
                cp_best_src = None
            try:
                if cp_candidates:
                    cp_min = min(cp_candidates)
                    cp_max = max(cp_candidates)
            except Exception:
                cp_min = None
                cp_max = None

            tr_norm_val = None
            try:
                tr_norm_val = float(trigger_norm)
            except Exception:
                tr_norm_val = None

            tp_immediate = False
            side_up = ""
            try:
                side_up = (side or "").upper()
            except Exception:
                side_up = ""

            try:
                if (reduce_only or close_position) and tr_norm_val is not None and cp_min is not None and cp_max is not None:
                    if side_up == "SELL":  # closing LONG, TP reached if price >= trigger
                        tp_immediate = bool(float(cp_max) >= float(tr_norm_val))
                    elif side_up == "BUY":  # closing SHORT, TP reached if price <= trigger
                        tp_immediate = bool(float(cp_min) <= float(tr_norm_val))
            except Exception:
                tp_immediate = False

            if tp_immediate:
                try:
                    cp_used = cp_max if side_up == "SELL" else cp_min
                    src_part = f" src={cp_best_src}" if cp_best_src else ""
                    log_message(
                        f"[TP IMMEDIATE] {sym} side={side} current={cp_used}{src_part} "
                        f"trigger_norm={tr_norm_val} -> closing by MARKET instead of placing TP"
                    )
                except Exception:
                    pass
                try:
                    pos_side_state = 'LONG' if side_up == "SELL" else 'SHORT'
                    qty_to_close = None
                    if not close_position:
                        try:
                            if qty_norm is not None and float(qty_norm) > 0:
                                qty_to_close = qty_norm
                        except Exception:
                            qty_to_close = None
                    if 'safe_close_position' in globals():
                        safe_close_position(sym, pos_side_state, qty=qty_to_close)
                except Exception as close_err:
                    try:
                        log_message(f"[TP IMMEDIATE ERR] close failed for {sym}: {close_err}")
                    except Exception:
                        pass
                return None

            # If not reached yet, guard trigger away from current price (use max/min across candidates).
            try:
                if tr_norm_val is not None and cp_min is not None and cp_max is not None:
                    if side_up == "SELL":  # closing LONG
                        guard = float(cp_max) + (tick or 0.0)
                        if float(tr_norm_val) <= float(guard):
                            trigger_norm = guard
                            tp_guarded = True
                    elif side_up == "BUY":  # BUY to close SHORT
                        guard = float(cp_min) - (tick or 0.0)
                        if guard > 0 and float(tr_norm_val) >= float(guard):
                            trigger_norm = guard
                            tp_guarded = True
            except Exception:
                pass

        if clamped:
            try:
                log_message(f"[CLAMP] {sym} {kind} raw={trigger_raw} -> clamped={trigger_norm} reason=immediate-trigger-guard")
            except Exception:
                pass
        if tp_guarded:
            try:
                log_message(f"[CLAMP] {sym} {kind} guarded away from current price: trigger={trigger_raw} -> {trigger_norm}")
            except Exception:
                pass

        pre_log_payload = {
            "kind": kind,
            "side": side,
            "trigger": trigger_raw,
            "trigger_norm": trigger_norm,
            "qty": qty_raw,
            "qty_norm": qty_norm,
            "close": close_position,
            "reduce_only": reduce_only
        }
        try:
            log_message(f"[{kind} REQ] {sym} {side} trigger={trigger_raw} qty={qty_raw} -> normalized={pre_log_payload}")
        except Exception:
            pass
        # Якщо на момент виставлення SL ціна вже перетнула рівень,
        # не ставимо Algo-ордер, а одразу закриваємо позицію по ринку.
        if kind == "SL":
            immediate = False
            cp_val = None
            tr_val = None
            try:
                if current_price is not None:
                    cp_val = float(current_price)
            except Exception:
                cp_val = None
            try:
                if trigger_norm is not None:
                    tr_val = float(trigger_norm)
            except Exception:
                tr_val = None
            try:
                if cp_val is not None and tr_val is not None:
                    side_up = (side or "").upper()
                    # SELL закриває LONG -> спрацювання коли ціна вже <= SL
                    if side_up == "SELL" and cp_val <= tr_val:
                        immediate = True
                    # BUY закриває SHORT -> спрацювання коли ціна вже >= SL
                    elif side_up == "BUY" and cp_val >= tr_val:
                        immediate = True
            except Exception:
                immediate = False
            if immediate:
                try:
                    log_message(
                        f"[SL IMMEDIATE] {sym} side={side} entry={entry_price} current={cp_val} "
                        f"trigger_norm={tr_val} -> closing by MARKET instead of placing SL")
                except Exception:
                    pass
                try:
                    # Мапимо сторону закриття у сторону позиції для safe_close_position
                    try:
                        side_up = (side or "").upper()
                    except Exception:
                        side_up = ""
                    pos_side_state = 'LONG' if side_up == 'SELL' else 'SHORT'
                    if 'safe_close_position' in globals():
                        safe_close_position(sym, pos_side_state, qty=qty_norm)
                except Exception as close_err:
                    try:
                        log_message(f"[SL IMMEDIATE ERR] close failed for {sym}: {close_err}")
                    except Exception:
                        pass
                return None

        attempt = 0
        last_err = None
        while attempt < 3:
            attempt += 1
            try:
                resp = create_conditional_order(
                    symbol=sym,
                    side=side,
                    order_type=order_type,
                    quantity=None if close_position else qty_norm,
                    stop_price=trigger_norm,
                    price=price_norm,
                    client_oid=_unique_client_order_id(kind.lower()),
                    reduce_only=reduce_only,
                    position_side=pos_side,
                    working_type=working_type,
                    close_position=close_position
                )
                try:
                    log_message(f"[ALGO OK] type={kind} resp={resp}")
                except Exception:
                    pass
                return resp
            except BinanceAPIException as be:
                last_err = be
                be_code = getattr(be, "code", None)
                retryable = getattr(be, "status_code", 0) in (418, 429, 409, 500, 503)
                try:
                    log_message(f"[ALGO ERR] code={getattr(be, 'code', None)} msg={getattr(be, 'message', be)} payload={pre_log_payload} attempt={attempt}")
                except Exception:
                    pass
                # Binance error -2021: "Order would immediately trigger."
                # If SL placement is rejected this way, treat it as already-hit stop
                # and close by MARKET immediately (otherwise the position remains unprotected).
                if kind == "SL" and be_code == -2021:
                    try:
                        log_message(
                            f"[SL REJECTED] {sym} code=-2021 would immediately trigger "
                            f"(cur={current_price} trigger={trigger_norm}) -> closing by MARKET"
                        )
                    except Exception:
                        pass
                    try:
                        try:
                            side_up = (side or "").upper()
                        except Exception:
                            side_up = ""
                        pos_side_state = 'LONG' if side_up == 'SELL' else 'SHORT'
                        if 'safe_close_position' in globals():
                            safe_close_position(sym, pos_side_state, qty=qty_norm)
                    except Exception as close_err:
                        try:
                            log_message(f"[SL REJECTED ERR] close failed for {sym}: {close_err}")
                        except Exception:
                            pass
                    return None
                # If TP placement is rejected as already-triggered, treat it as already-hit TP
                # and close by MARKET (partial/full) instead of retrying.
                if kind == "TP" and be_code == -2021:
                    try:
                        log_message(
                            f"[TP REJECTED] {sym} code=-2021 would immediately trigger "
                            f"(cur={current_price} trigger={trigger_norm}) -> closing by MARKET"
                        )
                    except Exception:
                        pass
                    try:
                        try:
                            side_up = (side or "").upper()
                        except Exception:
                            side_up = ""
                        pos_side_state = 'LONG' if side_up == 'SELL' else 'SHORT'
                        qty_to_close = None if close_position else qty_norm
                        if 'safe_close_position' in globals():
                            safe_close_position(sym, pos_side_state, qty=qty_to_close)
                    except Exception as close_err:
                        try:
                            log_message(f"[TP REJECTED ERR] close failed for {sym}: {close_err}")
                        except Exception:
                            pass
                    return None
                if not retryable:
                    break
                time.sleep(min(1.5 * attempt, 4))
            except Exception as e:
                last_err = e
                try:
                    log_message(f"[ALGO ERR] {sym} {kind} unexpected: {e}")
                except Exception:
                    pass
                time.sleep(min(1.5 * attempt, 4))
        if last_err:
            raise last_err
        return None

    def _self_test(self):
        """Dry-run clamp tests without network."""
        cases = [
            {"kind": "SL", "side": "BUY", "entry": 100, "cur": 99.7, "trigger": 99.45, "tick": 0.01},
            {"kind": "SL", "side": "SELL", "entry": 100, "cur": 100.3, "trigger": 100.55, "tick": 0.01},
        ]
        for c in cases:
            tr, cl = self._clamp_trigger(c["side"], c["entry"], c["cur"], c["trigger"], c["tick"])
            try:
                log_message(f"[SELFTEST] {c['kind']} {c['side']} raw={c['trigger']} -> {tr} clamped={cl}")
            except Exception:
                pass


# Global instances
price_source = PriceSource()
order_placement_service = OrderPlacementService(price_source)


def run_post_fill_self_tests():
    """Manual clamp sanity tests (dry-run)."""
    try:
        order_placement_service._self_test()
    except Exception as e:
        try:
            log_message(f"[SELFTEST] post-fill clamp failed: {e}")
        except Exception:
            pass

def _pnl_snapshot_path(path=None):
    try:
        return path or PNL_SNAPSHOT_FILE
    except Exception:
        return PNL_SNAPSHOT_FILE


def save_pnl_snapshot_to_file(path=None, balance_override=None):
    """Persist today's PnL percent and balance so intra-day restarts keep drawdown/profit."""
    try:
        target = _pnl_snapshot_path(path)
        if not target:
            return False
        if balance_override is None:
            bal = get_balance()
        else:
            try:
                bal = float(balance_override)
            except Exception:
                bal = get_balance()
        pnl = current_pnl_percent_display
        if pnl is None and initial_balance:
            try:
                pnl = ((bal - initial_balance) / initial_balance) * 100
            except Exception:
                pnl = 0.0
        date_str = _kyiv_now().strftime("%Y-%m-%d")
        payload = {"date": date_str, "pnl_percent": float(pnl or 0.0), "balance": float(bal or 0.0)}
        d = os.path.dirname(target)
        if d and not os.path.exists(d):
            os.makedirs(d, exist_ok=True)
        with open(target, "w", encoding="utf-8") as fh:
            json.dump(payload, fh, ensure_ascii=False, indent=2)
        log_message(f"[PNL_SNAPSHOT] Saved {payload}")
        return True
    except Exception as e:
        try:
            log_message(f"[PNL_SNAPSHOT] Save failed: {e}")
        except Exception:
            pass
        return False


def load_pnl_snapshot_from_file(path=None):
    """Load PnL snapshot; if same day, restore current_pnl_percent_display and adjust initial_balance."""
    global current_pnl_percent_display, initial_balance
    try:
        target = _pnl_snapshot_path(path)
        if not target or not os.path.exists(target):
            return False
        with open(target, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        date_str = str(data.get("date") or "")
        today = _kyiv_now().strftime("%Y-%m-%d")
        if date_str != today:
            return False
        pnl = float(data.get("pnl_percent") or 0.0)
        bal = float(data.get("balance") or 0.0)
        current_pnl_percent_display = pnl
        if bal > 0 and pnl != -100.0:
            try:
                init = bal / (1 + pnl / 100.0)
                if init > 0:
                    initial_balance = init
            except Exception:
                pass
        log_message(f"[PNL_SNAPSHOT] Loaded {pnl:.2f}% for today from {target}")
        return True
    except Exception as e:
        try:
            log_message(f"[PNL_SNAPSHOT] Load failed: {e}")
        except Exception:
            pass
        return False

TELEGRAM_TOKEN = ""

# список підключених користувачів
TELEGRAM_USERS = set()

# ---- Config files: settings locator + telegram users (TXT) ----
if getattr(sys, "frozen", False):
    BASE_DIR = os.path.dirname(os.path.abspath(sys.executable))
else:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DEFAULT_SETTINGS_FILE = os.path.join(BASE_DIR, "bot_settings.txt")
SETTINGS_LOCATION_FILE = os.path.join(BASE_DIR, "settings_location.txt")
SETTINGS_FILE = DEFAULT_SETTINGS_FILE

TELEGRAM_USERS_FILE = os.path.join(BASE_DIR, "telegram_ids.txt")
TELEGRAM_POLLING_ENABLED = True
TELEGRAM_LEVEL_SCREENSHOT_ENABLED = True
TELEGRAM_LEVEL_SCREENSHOT_DIR = os.path.join(BASE_DIR, "telegram_screens")
TELEGRAM_LEVEL_SCREENSHOT_TIMEOUT = 4.0
TELEGRAM_LEVEL_SCREENSHOT_DELAY_SEC = 2.5

# --- Stability / sequencing (to avoid freezes on SL/TP close + screenshots) ---
POST_TRADE_ACTIONS_SERIAL = True
POST_TRADE_ACTION_GAP_SEC = 0.12   # small pause between heavy post-trade actions
SCREENSHOT_FAST_MODE = True        # skip forced chart refresh / heavy UI ops when capturing
SCREENSHOT_DROP_IF_BUSY = True     # drop low-priority screenshot requests if one is already running
SCREENSHOT_QUEUE_MAX = 1           # how many queued screenshot requests are allowed
LOG_DIR = os.path.join(BASE_DIR, "logs")
PNL_SNAPSHOT_FILE = os.path.join(BASE_DIR, "pnl_snapshot.txt")
WINDOWS_TIME_SYNC_ENABLED = True
AUTO_ELEVATE = True
WINDOWS_TIME_SYNC_INTERVAL = 10
WINDOWS_TIME_SYNC_LOGS_ENABLED = True
SOUND_ENABLED = True
TRADE_OPEN_SOUND_FILE = ""
TRADE_CLOSE_SOUND_FILE = ""
LAST_UPDATE_ID = None
APP_ICON_FILE = os.path.join(BASE_DIR, "ChatGPT-Image-22-лист.-2025-р._-14_08_02.ico")
EQUITY_HISTORY_LIMIT = 5000
EQUITY_MIN_BALANCE_DELTA = 1e-6
equity_history = []
# In-memory recent logs buffer for GPT advisor context
from collections import deque, defaultdict
recent_logs = deque(maxlen=1200)
closed_trades = deque(maxlen=1000)  # list of dicts: {symbol, side, qty, entry, exit, pnl_abs, pnl_pct, hold_min, ts}
advisor_suggestions = deque(maxlen=500)
equity_history_lock = threading.Lock()
last_recorded_equity_balance = None
DEFAULT_EQUITY_HISTORY_FILE = os.path.join(BASE_DIR, "equity_history.json")
DEFAULT_TRADE_JOURNAL_FILE = os.path.join(BASE_DIR, "trade_journal.json")
# Global stop event to terminate background loops on exit
shutdown_event = threading.Event()
shutdown_complete_event = threading.Event()
SHUTDOWN_FORCE_EXIT_SEC = 6.0
EQUITY_HISTORY_FILE = DEFAULT_EQUITY_HISTORY_FILE
TRADE_JOURNAL_FILE = DEFAULT_TRADE_JOURNAL_FILE
SETTINGS_HISTORY_FILE = os.path.join(BASE_DIR, "settings_history.json")
SETTINGS_HISTORY_LIMIT = 100
settings_history = []
settings_history_lock = threading.Lock()
_singleton_handle = None

# Глобальний бекоф для REST (-1003 Too many requests та HTML-помилок)
REST_BACKOFF_UNTIL = 0.0
REST_ERROR_BACKOFF = 60.0
REST_REQUEST_TIMEOUT = 5.0  # seconds for REST calls to avoid hanging forever

# WebSocket activity tracking
LAST_WS_MESSAGE_TS = 0.0
# Track specifically user-stream messages to detect silent expiry
LAST_USER_WS_MESSAGE_TS = 0.0
WS_STALE_TIMEOUT = 120.0  # seconds without WS messages considered stale
# Connection state tracking (log only on transitions)
_connection_state_lock = threading.Lock()
_connection_state = None  # None=unknown, True=connected, False=disconnected
_last_conn_ok_ts = 0.0
_last_conn_log_ts = 0.0
CONN_DISCONNECT_GRACE_SEC = 5.0
CONN_LOG_MIN_INTERVAL_SEC = 2.0
_reconnect_resync_lock = threading.Lock()
_reconnect_resync_in_progress = False
_connection_watchdog_started = False
# Periodic user-stream refresh (0 = disabled). Binance listenKey expires ~60m
USER_STREAM_REFRESH_SECS = 1500  # 25 minutes
ENABLE_PRICE_WS = True  # enable per-symbol price WS
# Enable legacy TWM-based websockets; plus manual user stream like BanV2
USE_WS = True
# Enable manual Futures user data stream (listenKey + websocket-client)
# In the old version only the ThreadedWebsocketManager user stream was used.
# To match that behavior and avoid extra reconnect logs, keep this disabled by default.
USE_MANUAL_USER_STREAM = True

# Optional background supervisors (keep disabled to mimic old code)
ENABLE_WS_WATCHDOG = False
ENABLE_USER_STREAM_SUPERVISOR = False
ENABLE_ORDERS_POLL_SUPERVISOR = False

# --- Click trading & hotkeys ---
CLICK_TRADING_ENABLED = False
CLICK_ENTRY_NOTIONAL_USD = 50.0
CLICK_ENTRY_PRESET_VALUES_DEFAULT = [15.0, 200.0, 300.0, 400.0, 500.0]
CLICK_ENTRY_PRESET_VALUES = list(CLICK_ENTRY_PRESET_VALUES_DEFAULT)
CLICK_ENTRY_PRESET_ACTIVE = 0
HOTKEY_CLOSE_AND_CANCEL = "D"
HOTKEY_FORCE_CENTER = "SHIFT"
HOTKEY_CANCEL_ALL = "SPACE"
HOTKEY_PENDING_ORDER = "V"
HOTKEY_STOPLOSS_CLICK = "C"
CLICK_TRADING_MIN_CLICK_INTERVAL_MS = 40




LAST_POSITION_SYNC_TS = 0.0  # last time we synced positions from REST
IS_WINDOWS = platform.system().lower().startswith("win")

# Lock to protect TELEGRAM_USERS in multithreaded context
telegram_users_lock = threading.Lock()

SETTINGS_KEYS = [
    "HARD_SL_OFFSET_PCT",
    "API_KEY",
    "API_SECRET",
    "TOP_N_GROWTH",
    "TOP_N_FALL",
    "TOP_N_VOLUME",
    "TOP_N_NATR",
    "NATR_PERIOD",
    "NATR_1M_MIN",
    "LEVEL_WINDOW",
    "LEVEL_PRECISION",
    "TOLERANCE",
    "MIN_TOUCHES",
    "MIN_INTERVAL",
    "MIN_LEVEL_FRESHNESS_BARS",
    "RR_MIN",
    "RR_MAX",
    "TP_PARTS",
    "TP_WEIGHT_POWER",
    "TRAILING_NATR_FACTOR",
    "TRAILING_MIN_PERCENT",
    "TRAILING_MAX_PERCENT",
    "FALLBACK_TRAILING_PERCENT",
    "TEMP_WIDEN_THRESHOLD_PCT",
    "TEMP_WIDEN_AMOUNT_PCT",
    "MONITOR_INTERVAL",
    "PRICE_POLL_INTERVAL",
    "TRAIL_CHECK_MIN_INTERVAL",
    "MAX_CLOSE_RETRIES",
    "PRICE_STALE_SEC",
    "ERROR_RETRY_INTERVAL",
    "CONSECUTIVE_LOSS_PROTECTION",
    "CONSECUTIVE_LOSS_H",
    "LOSS_CLOSE_BAN_MINUTES",
    "PROFIT_STOP_ENABLED",
    "PROFIT_STOP_THRESHOLD_PERCENT",
    "LOSS_STOP_ENABLED",
    "LOSS_STOP_THRESHOLD_PERCENT",
    "MAX_CONCURRENT_PENDING",
    "MAX_CONCURRENT_POSITIONS",
    "CAPACITY_COOLDOWN_SEC",
    "PNL_SNAPSHOT_FILE",
    "MIN_STOP_BUFFER_PCT",
    "STOP_NATR_BUFFER_FACTOR",
    "FAST_APPROACH_MIN_BUFFER",
    "DYN_MIN_LEVEL_DISTANCE",
    "DYN_MAX_LEVEL_DISTANCE",
    "DYN_NATR_FACTOR",
    "DYN_VOL_FACTOR",
    "DYN_VOL_WINDOW",
    "CHART_CANDLE_LIMIT",
    "CHART_REST_RECONCILE_SEC",
    {"key": "CANDLE_WS_INTERVAL", "label": "CHART_INTERVAL"},
    "ORDERBOOK_TICK_MULT",
    "ORDERBOOK_AUTO_CENTER",
    "ORDERBOOK_LADDER_LEVELS",
    "ORDERBOOK_LEVELS",
    "ORDERBOOK_FULL_DEPTH",
    "ORDERBOOK_REST_SEED_LIMIT",
    "ORDERBOOK_SHOW_DEPTH_BARS",
    "ORDERBOOK_VOL_IN_USD",
    "ORDERBOOK_VOL_COMPACT",
    "ORDERBOOK_VOL_COL_WIDTH",
    "ORDERBOOK_UI_FRAME_MS",
    "ORDERBOOK_EMIT_INTERVAL",
    "PRINTS_UI_FRAME_MS",
    "PRINTS_TAPE_FRAME_MS",
    "PRINTS_EMIT_INTERVAL",
    "PRINTS_MIN_NOTIONAL_USD",
    "PRINTS_TEXT_MIN_NOTIONAL_USD",
    "PRINTS_AGG_WINDOW_MS_EXTRA",
    "PRINTS_SPEED_MULT",
    "PRINTS_SPEED_AUTO",
    "CLICK_ENTRY_PRESET_VALUES",
    "CLICK_ENTRY_PRESET_ACTIVE",
    "GUI_USE_OPENGL",
    "GUI_OPENGL_ANTIALIAS",
    "DISPLAY_NOTIONAL_USD",
    # --- GPT advisor settings ---
    "GPT_ENABLED",
    {"key": "GPT_API_KEY", "label": "GPT API Key", "secret": True},
    {"key": "GPT_BASE_URL", "label": "GPT Base URL"},
    {"key": "GPT_MODEL", "label": "GPT Model"},
    {"key": "GPT_ADVISOR_INTERVAL", "label": "GPT advisor interval, s"},
    {"key": "GPT_FORCE_JSON", "label": "GPT force JSON"},
    {"key": "GPT_MAX_TOKENS", "label": "GPT max tokens"},
    "GPT_AUTO_APPLY",
    {"key": "GPT_TIMEOUT_SEC", "label": "GPT timeout, s"},
    # --- Advisor gate (pause requests) ---
    {"key": "ADVISOR_GATE_ENABLED", "label": "Advisor gate enabled"},
    {"key": "ADVISOR_GATE_MIN_WINRATE_PCT", "label": "Gate min winrate, %"},
    {"key": "ADVISOR_GATE_IDLE_HOURS", "label": "Gate idle hours"},
    {"key": "ADVISOR_GATE_MAX_DRAWDOWN_PCT", "label": "Gate max drawdown, %"},
    # --- Risk / sizing ---
    "HARD_SL_OFFSET_PCT",
    "STOP_LOSS_MIN_PCT",
    "STOP_LOSS_MAX_PCT",
    "USE_LEGACY_POSTFILL_PIPELINE",
    "MIN_POS_NOTIONAL_MULT",
    "MAX_POS_NOTIONAL_MULT",
    "MAX_APPROACH_PERCENT",
    "MIN_MULTI",
    "MAX_MULTI",
    "POS_VOL_FACTOR",
    "POS_VOL_WINDOW",
    "VOLUME_24H_THRESHOLD",
    "AMERICA_MULTI_MIN",
    "AMERICA_MULTI_MAX",
    "ASIA_MULTI_MIN",
    "ASIA_MULTI_MAX",
    "EUROPE_MULTI_MIN",
    "EUROPE_MULTI_MAX",
    "RESERVE_MULTI_MIN",
    "RESERVE_MULTI_MAX",
    "LOG_DIR",
    "SOUND_ENABLED",
    "TRADE_OPEN_SOUND_FILE",
    "TRADE_CLOSE_SOUND_FILE",
    "TELEGRAM_USERS_FILE",
    "TELEGRAM_LEVEL_SCREENSHOT_ENABLED",
    "TELEGRAM_LEVEL_SCREENSHOT_DIR",
    "EQUITY_HISTORY_FILE",
    "TRADE_JOURNAL_FILE",
    "WINDOWS_TIME_SYNC_ENABLED",
    "WINDOWS_TIME_SYNC_INTERVAL",
    "TELEGRAM_TOKEN",
    "CLICK_TRADING_ENABLED",
    "CLICK_ENTRY_NOTIONAL_USD",
    "HOTKEY_CLOSE_AND_CANCEL",
    "HOTKEY_FORCE_CENTER",
    "HOTKEY_CANCEL_ALL",
    "HOTKEY_PENDING_ORDER",
    "HOTKEY_STOPLOSS_CLICK",
]

# Settings keys that must stay code-default and be stripped from settings files.
SETTINGS_LOCKED_KEYS = set()

_TRUE_STRINGS = {'1', 'true', 'yes', 'y', 'on', 't', 'так', 'да'}


def _normalize_numeric_string(value: str) -> str:
    return value.strip().replace(' ', '').replace('_', '').replace(',', '.')


def _coerce_setting_value(key, value):
    cur = globals().get(key)
    # Hard clamps for ultra-smooth UI (prevents old settings from forcing low FPS)
    try:
        if key == 'PRINTS_TAPE_FRAME_MS':
            try:
                v = int(float(value))
            except Exception:
                v = int(cur) if isinstance(cur, int) else 8
            return max(0, min(v, 8))
        if key == 'PRINTS_UI_FRAME_MS':
            try:
                v = int(float(value))
            except Exception:
                v = int(cur) if isinstance(cur, int) else 8
            return max(0, min(v, 16))
    except Exception:
        pass
    if cur is None:
        return value
    if value is None:
        return "" if isinstance(cur, str) else cur
    if isinstance(cur, bool):
        if isinstance(value, str):
            return value.strip().lower() in _TRUE_STRINGS
        return bool(value)
    if isinstance(cur, int) and not isinstance(cur, bool):
        if isinstance(value, str):
            cleaned = _normalize_numeric_string(value)
            if cleaned == "":
                return cur
            value = float(cleaned)
        return int(value)
    if isinstance(cur, float):
        if isinstance(value, str):
            cleaned = _normalize_numeric_string(value)
            if cleaned == "":
                return cur
            value = float(cleaned)
        return float(value)
    if isinstance(cur, str):
        return "" if value is None else str(value)
    return value


def _set_setting_value(key, value, silent=False):
    if key not in globals():
        return
    try:
        globals()[key] = _coerce_setting_value(key, value)
    except Exception:
        if silent:
            return
        raise


def _iter_setting_keys():
    """Yield normalized setting keys (strings) from SETTINGS_KEYS which may contain dict entries."""
    try:
        for item in SETTINGS_KEYS:
            if isinstance(item, str):
                yield item
            elif isinstance(item, dict):
                k = item.get("key")
                if isinstance(k, str) and k:
                    yield k
    except Exception:
        # Fallback: nothing
        return


def _strip_locked_settings_keys(payload, persist=False, source=""):
    """Remove locked settings from a loaded settings dict (and optionally persist the cleanup)."""
    try:
        locked = set(globals().get("SETTINGS_LOCKED_KEYS") or [])
    except Exception:
        locked = set()
    if (not locked) or (not isinstance(payload, dict)):
        return payload, False
    removed = [k for k in locked if k in payload]
    if not removed:
        return payload, False
    for k in removed:
        payload.pop(k, None)
    if persist:
        try:
            save_settings_atomic(payload, SETTINGS_FILE)
        except Exception:
            pass
    try:
        msg = f"[SETTINGS] removed locked keys from {source}: {removed}" if source else f"[SETTINGS] removed locked keys: {removed}"
        log_message(msg)
    except Exception:
        pass
    return payload, True


def _apply_settings_dict(data, silent=False):
    if not isinstance(data, dict):
        return
    for key in _iter_setting_keys():
        if key in data:
            _set_setting_value(key, data[key], silent=silent)
    # Load advisor allow-map if present (persisted per-key AI toggle)
    try:
        amap = data.get('ADVISOR_ALLOWED_MAP')
        if isinstance(amap, dict):
            # sanitize: only keep string keys that exist; coerce to bool
            cleaned = {}
            for k, v in amap.items():
                if isinstance(k, str) and (k in globals()):
                    cleaned[k] = bool(v)
            globals()['ADVISOR_ALLOWED_MAP'] = cleaned
    except Exception:
        pass


def _apply_prints_agg_extra():
    try:
        base = int(globals().get("PRINTS_AGG_WINDOW_MS_BASE", globals().get("PRINTS_AGG_WINDOW_MS", 0) or 0) or 0)
    except Exception:
        base = 0
    try:
        extra = int(globals().get("PRINTS_AGG_WINDOW_MS_EXTRA", 0) or 0)
    except Exception:
        extra = 0
    try:
        if base < 0:
            base = 0
    except Exception:
        base = 0
    try:
        if extra < 0:
            extra = 0
    except Exception:
        extra = 0
    try:
        globals()["PRINTS_AGG_WINDOW_MS"] = int(base) + int(extra)
    except Exception:
        pass


def _normalize_settings_path(path):
    try:
        if path is None:
            return None
        s = str(path).strip()
    except Exception:
        return None
    if not s:
        return None
    try:
        s = os.path.expandvars(os.path.expanduser(s))
    except Exception:
        pass
    try:
        if not os.path.isabs(s):
            s = os.path.join(BASE_DIR, s)
    except Exception:
        pass
    try:
        return os.path.abspath(s)
    except Exception:
        return None


def _secret_fingerprint(value):
    try:
        if value is None:
            return "none"
        s = str(value)
        if not s:
            return "empty"
        h = hashlib.sha256(s.encode("utf-8")).hexdigest()
        return f"sha256:{h[:10]} len={len(s)}"
    except Exception:
        return "error"


def resolve_settings_file_path():
    """If a locator file exists, override SETTINGS_FILE before loading."""
    global SETTINGS_FILE
    try:
        candidate_raw = None
        if os.path.exists(SETTINGS_LOCATION_FILE):
            with open(SETTINGS_LOCATION_FILE, "r", encoding="utf-8") as fh:
                candidate_raw = fh.read().strip()

        candidate = _normalize_settings_path(candidate_raw)
        if candidate:
            candidate_dir = os.path.dirname(candidate)
            if os.path.exists(candidate) or (candidate_dir and os.path.isdir(candidate_dir)):
                SETTINGS_FILE = candidate
                return

            # Locator points to a non-existent folder (common after moving to another PC).
            SETTINGS_FILE = DEFAULT_SETTINGS_FILE
            try:
                persist_settings_file_path(DEFAULT_SETTINGS_FILE)
            except Exception:
                pass
            return

        SETTINGS_FILE = DEFAULT_SETTINGS_FILE
    except Exception:
        SETTINGS_FILE = DEFAULT_SETTINGS_FILE


def persist_settings_file_path(path):
    try:
        normalized = _normalize_settings_path(path) or os.path.abspath(DEFAULT_SETTINGS_FILE)
        to_write = normalized
        try:
            rel = os.path.relpath(normalized, start=BASE_DIR)
            if rel and not rel.startswith("..") and not os.path.isabs(rel):
                to_write = rel
        except Exception:
            pass
        with open(SETTINGS_LOCATION_FILE, "w", encoding="utf-8") as fh:
            fh.write(to_write)
        return normalized
    except Exception:
        return path


def preload_settings():
    resolve_settings_file_path()
    try:
        if not os.path.exists(SETTINGS_FILE):
            return
        with open(SETTINGS_FILE, "r", encoding="utf-8") as f:
            payload = json.load(f)
        payload, _ = _strip_locked_settings_keys(payload, persist=True, source="preload")
        _apply_settings_dict(payload, silent=True)
    except Exception:
        # fail silently during early bootstrap
        pass


def save_settings_atomic(data, path=None):
    """Save settings (dict) atomically to SETTINGS_FILE (JSON)."""
    try:
        p = path or SETTINGS_FILE
        d = os.path.dirname(p)
        if d and not os.path.exists(d):
            os.makedirs(d, exist_ok=True)
        tmp = p + ".tmp"
        with open(tmp, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
            f.flush()
            os.fsync(f.fileno())
        os.replace(tmp, p)
        log_message(f"💾 Збережено налаштування у {p}")
    except Exception as e:
        log_message(f"❌ Помилка при збереженні налаштувань: {e}")


# ---- end of injected utilities ----



# --- Tick storage (для 5s-бара) ---
# symbol_ticks: symbol -> deque of (ts, price). Заповнюється у price update handler.
symbol_ticks = defaultdict(lambda: deque(maxlen=1200))

# --- Candle cache for GUI chart (maintained via WS) ---
CANDLE_WS_INTERVAL = "5m"
CHART_INTERVAL_OPTIONS = ("1m", "3m", "5m", "15m", "30m", "1h", "2h", "4h", "1d")
CHART_CANDLE_LIMIT = 450  # default number of candles shown in GUI
CANDLE_CACHE_TTL = 20  # seconds to keep cached candles fresh (REST-based)
CANDLE_REST_RETRY_SEC = 60
CHART_REST_RECONCILE_SEC = 300
KLINE_RESUBSCRIBE_STALE_SEC = 10  # resubscribe kline if no updates for this long
KLINE_REST_SEED_ON_EMPTY = True
candle_cache = {}
candle_cache_lock = threading.Lock()
kline_histories = {}
kline_socket_keys = {}
kline_last_update_ts = {}
KLINE_REST_RECONCILE_TS = {}
KLINE_REST_RECONCILE_INFLIGHT = set()
KLINE_REST_RECONCILE_LOCK = threading.Lock()
KLINE_SEED_INFLIGHT = set()
KLINE_SEEDED = set()
KLINE_SEED_LOCK = threading.Lock()
CHART_REST_SEEDED = set()
CHART_REST_SEED_LOCK = threading.Lock()
candle_rest_failures = {}
# Kline caches are keyed by (SYMBOL, INTERVAL) to prevent timeframe mix-ups (e.g., chart shows 1m while settings are 5m)
def _kline_key(symbol, interval=None):
    sym = (symbol or "").upper()
    if not sym:
        return ("", "")
    if interval is None:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    try:
        interval = str(interval).strip()
    except Exception:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    if not interval:
        interval = "5m"
    return (sym, interval)

# --- Trade markers for chart screenshots ---
chart_trade_lock = threading.Lock()
chart_trade_state = {}  # symbol -> {'trade_id': int, 'events': [], 'sl_marks': [], 'close_lines': []}
chart_trade_focus = {}  # symbol -> trade_id to render (or None)
CHART_TRADE_MAX_EVENTS = 200
CHART_TRADE_MAX_SL = 20
CHART_TRADE_MAX_CLOSE = 20
CHART_TRADE_MARKER_MIN_SIZE = 10
CHART_TRADE_MARKER_MAX_SIZE = 16
CHART_TRADE_MARKER_GAMMA = 0.6  # <1 softens size growth for large positions
chart_trade_clear_queue = {}
chart_trade_clear_lock = threading.Lock()
_chart_trade_clear_thread_started = False
book_pos_clear_until = {}
book_pos_clear_lock = threading.Lock()
BOOK_POS_CLEAR_SEC = 2.0


def _chart_trade_triangle_symbol(up=True):
    path = QPainterPath()
    if up:
        path.moveTo(0.0, -0.6)
        path.lineTo(0.6, 0.6)
        path.lineTo(-0.6, 0.6)
    else:
        path.moveTo(0.0, 0.6)
        path.lineTo(0.6, -0.6)
        path.lineTo(-0.6, -0.6)
    path.closeSubpath()
    return path


CHART_TRADE_TRI_UP = _chart_trade_triangle_symbol(up=True)
CHART_TRADE_TRI_DOWN = _chart_trade_triangle_symbol(up=False)
last_close_fill_cache = {}
last_close_entry_cache = {}
last_close_fill_lock = threading.Lock()
last_close_entry_lock = threading.Lock()


def _chart_trade_state_get(symbol):
    sym = (symbol or "").upper()
    with chart_trade_lock:
        st = chart_trade_state.get(sym)
        if not st:
            st = {'trade_id': 0, 'events': [], 'sl_marks': [], 'close_lines': []}
            chart_trade_state[sym] = st
        return st


def _chart_trade_new_id(symbol):
    sym = (symbol or "").upper()
    with chart_trade_lock:
        st = chart_trade_state.get(sym)
        if not st:
            st = {'trade_id': 0, 'events': [], 'sl_marks': [], 'close_lines': []}
            chart_trade_state[sym] = st
        try:
            st['trade_id'] = int(st.get('trade_id', 0) or 0) + 1
        except Exception:
            st['trade_id'] = 1
        return st['trade_id']


def _chart_trade_current_id(symbol):
    sym = (symbol or "").upper()
    with chart_trade_lock:
        st = chart_trade_state.get(sym) or {}
        try:
            return int(st.get('trade_id', 0) or 0)
        except Exception:
            return 0


def chart_trade_set_focus(symbol, trade_id=None):
    sym = (symbol or "").upper()
    with chart_trade_lock:
        if trade_id is None:
            chart_trade_focus.pop(sym, None)
        else:
            chart_trade_focus[sym] = int(trade_id)


def chart_trade_get_snapshot(symbol):
    sym = (symbol or "").upper()
    with chart_trade_lock:
        st = chart_trade_state.get(sym) or {}
        events = list(st.get('events') or [])
        sl_marks = list(st.get('sl_marks') or [])
        close_lines = list(st.get('close_lines') or [])
        focus_id = chart_trade_focus.get(sym)
    return events, sl_marks, close_lines, focus_id


def chart_trade_clear(symbol):
    sym = (symbol or "").upper()
    with chart_trade_lock:
        chart_trade_state.pop(sym, None)
        chart_trade_focus.pop(sym, None)


def _chart_trade_clear_worker():
    while True:
        try:
            time.sleep(1.0)
            now = time.time()
            with chart_trade_clear_lock:
                items = list(chart_trade_clear_queue.items())
            for sym, info in items:
                try:
                    clear_at = float(info.get("at") or 0.0)
                except Exception:
                    clear_at = 0.0
                if not clear_at or now < clear_at:
                    continue
                try:
                    target_id = int(info.get("trade_id") or 0)
                except Exception:
                    target_id = 0
                cur_id = _chart_trade_current_id(sym)
                if target_id and cur_id == target_id:
                    chart_trade_clear(sym)
                with chart_trade_clear_lock:
                    chart_trade_clear_queue.pop(sym, None)
        except Exception:
            pass


def chart_trade_schedule_clear(symbol, delay_sec=60):
    sym = (symbol or "").upper()
    if not sym:
        return
    try:
        trade_id = _chart_trade_current_id(sym)
    except Exception:
        trade_id = 0
    if not trade_id:
        return
    try:
        clear_at = time.time() + float(delay_sec or 60.0)
    except Exception:
        clear_at = time.time() + 60.0
    with chart_trade_clear_lock:
        chart_trade_clear_queue[sym] = {"at": clear_at, "trade_id": int(trade_id)}
    global _chart_trade_clear_thread_started
    if not _chart_trade_clear_thread_started:
        _chart_trade_clear_thread_started = True
        threading.Thread(target=_chart_trade_clear_worker, daemon=True).start()


def book_schedule_pos_clear(symbol, delay_sec=None):
    sym = (symbol or "").upper()
    if not sym:
        return
    if delay_sec is None:
        delay_sec = BOOK_POS_CLEAR_SEC
    try:
        clear_at = time.time() + float(delay_sec or 0.0)
    except Exception:
        clear_at = time.time() + BOOK_POS_CLEAR_SEC
    with book_pos_clear_lock:
        book_pos_clear_until[sym] = clear_at


def chart_trade_record_event(symbol, side, price, ts=None, kind=None, trade_id=None, qty=None):
    try:
        if not symbol or price is None:
            return
        sym = (symbol or "").upper()
        try:
            price_f = float(price)
        except Exception:
            return
        if price_f <= 0:
            return
        if ts is None:
            ts = time.time()
        try:
            ts_f = float(ts)
        except Exception:
            ts_f = time.time()
        with chart_trade_lock:
            st = chart_trade_state.get(sym)
            if not st:
                st = {'trade_id': 0, 'events': [], 'sl_marks': [], 'close_lines': []}
                chart_trade_state[sym] = st
            if trade_id is None:
                trade_id = int(st.get('trade_id', 0) or 0)
            if not trade_id:
                try:
                    st['trade_id'] = int(st.get('trade_id', 0) or 0) + 1
                except Exception:
                    st['trade_id'] = 1
                trade_id = st['trade_id']
            side_norm = str(side or '').upper()
            if side_norm not in ('BUY', 'SELL'):
                try:
                    side_norm = _side_to_api(side_norm) or side_norm
                except Exception:
                    pass
            ev = {
                'ts': ts_f,
                'price': price_f,
                'side': side_norm,
                'kind': kind,
                'trade_id': int(trade_id),
            }
            try:
                qty_f = abs(float(qty or 0.0))
                if qty_f > 0:
                    ev['qty'] = qty_f
            except Exception:
                pass
            st['events'].append(ev)
            if len(st['events']) > CHART_TRADE_MAX_EVENTS:
                st['events'] = st['events'][-CHART_TRADE_MAX_EVENTS:]
    except Exception:
        pass


def chart_trade_record_sl(symbol, price, ts=None, trade_id=None):
    try:
        if not symbol or price is None:
            return
        sym = (symbol or "").upper()
        try:
            price_f = float(price)
        except Exception:
            return
        if price_f <= 0:
            return
        if ts is None:
            ts = time.time()
        try:
            ts_f = float(ts)
        except Exception:
            ts_f = time.time()
        with chart_trade_lock:
            st = chart_trade_state.get(sym)
            if not st:
                st = {'trade_id': 0, 'events': [], 'sl_marks': [], 'close_lines': []}
                chart_trade_state[sym] = st
            if trade_id is None:
                trade_id = int(st.get('trade_id', 0) or 0)
            if not trade_id:
                try:
                    st['trade_id'] = int(st.get('trade_id', 0) or 0) + 1
                except Exception:
                    st['trade_id'] = 1
                trade_id = st['trade_id']
            st['sl_marks'] = [m for m in (st.get('sl_marks') or []) if m.get('trade_id') != int(trade_id)]
            st['sl_marks'].append({'ts': ts_f, 'price': price_f, 'trade_id': int(trade_id)})
            if len(st['sl_marks']) > CHART_TRADE_MAX_SL:
                st['sl_marks'] = st['sl_marks'][-CHART_TRADE_MAX_SL:]
    except Exception:
        pass


def _chart_trade_find_entry_event(symbol, trade_id=None):
    try:
        sym = (symbol or "").upper()
        with chart_trade_lock:
            st = chart_trade_state.get(sym) or {}
            evs = list(st.get('events') or [])
        if trade_id is not None:
            evs = [e for e in evs if e.get('trade_id') == int(trade_id)]
        if not evs:
            return None
        entry_evs = []
        for e in evs:
            kind = str(e.get('kind') or '').upper()
            if kind.startswith('ENTRY'):
                entry_evs.append(e)
        if entry_evs:
            return sorted(entry_evs, key=lambda x: float(x.get('ts', 0) or 0))[0]
        return sorted(evs, key=lambda x: float(x.get('ts', 0) or 0))[0]
    except Exception:
        return None


def _chart_trade_find_close_event(symbol, trade_id=None):
    try:
        sym = (symbol or "").upper()
        with chart_trade_lock:
            st = chart_trade_state.get(sym) or {}
            evs = list(st.get('events') or [])
        if trade_id is not None:
            evs = [e for e in evs if e.get('trade_id') == int(trade_id)]
        if not evs:
            return None
        close_kinds = ('CLOSE', 'TP_MKT', 'TP')
        close_evs = [e for e in evs if str(e.get('kind') or '').upper() in close_kinds]
        if close_evs:
            return sorted(close_evs, key=lambda x: float(x.get('ts', 0) or 0))[-1]
        return None
    except Exception:
        return None


def chart_trade_record_close_line(symbol, entry_price, entry_ts, close_price, close_ts, pct_val, trade_id=None):
    try:
        if not symbol:
            return
        sym = (symbol or "").upper()
        ep = float(entry_price or 0.0)
        cp = float(close_price or 0.0)
        if ep <= 0 or cp <= 0:
            return
        if entry_ts is None:
            entry_ts = time.time()
        if close_ts is None:
            close_ts = time.time()
        try:
            entry_ts_f = float(entry_ts)
        except Exception:
            entry_ts_f = time.time()
        try:
            close_ts_f = float(close_ts)
        except Exception:
            close_ts_f = time.time()
        try:
            pct_f = float(pct_val)
        except Exception:
            pct_f = 0.0
        with chart_trade_lock:
            st = chart_trade_state.get(sym)
            if not st:
                st = {'trade_id': 0, 'events': [], 'sl_marks': [], 'close_lines': []}
                chart_trade_state[sym] = st
            if trade_id is None:
                trade_id = int(st.get('trade_id', 0) or 0)
            if not trade_id:
                try:
                    st['trade_id'] = int(st.get('trade_id', 0) or 0) + 1
                except Exception:
                    st['trade_id'] = 1
                trade_id = st['trade_id']
            st['close_lines'] = [ln for ln in (st.get('close_lines') or []) if ln.get('trade_id') != int(trade_id)]
            st['close_lines'].append({
                'entry_ts': entry_ts_f,
                'entry_price': ep,
                'close_ts': close_ts_f,
                'close_price': cp,
                'pct': pct_f,
                'trade_id': int(trade_id),
            })
            if len(st['close_lines']) > CHART_TRADE_MAX_CLOSE:
                st['close_lines'] = st['close_lines'][-CHART_TRADE_MAX_CLOSE:]
    except Exception:
        pass


def _get_or_create_kline_history(symbol, interval=None):
    sym = (symbol or "").upper()
    if not sym:
        return []
    key = _kline_key(sym, interval)
    hist = kline_histories.get(key)
    if hist is None:
        hist = []
        kline_histories[key] = hist
    return hist


def _update_kline_history(symbol, candles, interval=None):
    sym = (symbol or "").upper()
    if not sym:
        return
    key = _kline_key(sym, interval)
    with candle_cache_lock:
        hist = kline_histories.get(key)
        if hist is None:
            hist = []
            kline_histories[key] = hist
        hist[:] = candles[-CHART_CANDLE_LIMIT:]
        candle_cache[key] = {'ts': time.time(), 'data': hist.copy(), 'interval': key[1]}


def _reset_kline_cache(symbol=None):
    try:
        if symbol:
            sym = (symbol or "").upper()
            if not sym:
                return
            with candle_cache_lock:
                for k in list(kline_histories.keys()):
                    try:
                        if isinstance(k, tuple) and k and k[0] == sym:
                            kline_histories.pop(k, None)
                    except Exception:
                        continue
                for k in list(candle_cache.keys()):
                    try:
                        if isinstance(k, tuple) and k and k[0] == sym:
                            candle_cache.pop(k, None)
                    except Exception:
                        continue
                for k in list(candle_rest_failures.keys()):
                    try:
                        if isinstance(k, tuple) and k and k[0] == sym:
                            candle_rest_failures.pop(k, None)
                    except Exception:
                        continue
                for k in list(kline_last_update_ts.keys()):
                    try:
                        if isinstance(k, tuple) and k and k[0] == sym:
                            kline_last_update_ts.pop(k, None)
                    except Exception:
                        continue
                for k in list(KLINE_REST_RECONCILE_TS.keys()):
                    try:
                        if isinstance(k, tuple) and k and k[0] == sym:
                            KLINE_REST_RECONCILE_TS.pop(k, None)
                    except Exception:
                        continue
            try:
                with KLINE_SEED_LOCK:
                    for key in list(KLINE_SEED_INFLIGHT):
                        try:
                            if isinstance(key, tuple) and key and key[0] == sym:
                                KLINE_SEED_INFLIGHT.discard(key)
                        except Exception:
                            continue
                    for key in list(KLINE_SEEDED):
                        try:
                            if isinstance(key, tuple) and key and key[0] == sym:
                                KLINE_SEEDED.discard(key)
                        except Exception:
                            continue
            except Exception:
                pass
            return

        with candle_cache_lock:
            kline_histories.clear()
            candle_cache.clear()
            candle_rest_failures.clear()
            kline_last_update_ts.clear()
            KLINE_REST_RECONCILE_TS.clear()
        try:
            with KLINE_SEED_LOCK:
                KLINE_SEED_INFLIGHT.clear()
                KLINE_SEEDED.clear()
        except Exception:
            pass
    except Exception:
        pass


def _handle_kline_stream_message(msg):
    try:
        global LAST_WS_MESSAGE_TS
        try:
            LAST_WS_MESSAGE_TS = time.time()
        except Exception:
            pass
        payload = msg
        if isinstance(msg, dict):
            try:
                if isinstance(msg.get('data'), dict):
                    payload = msg.get('data')
            except Exception:
                payload = msg
        if isinstance(payload, (bytes, bytearray)):
            try:
                payload = json.loads(payload.decode("utf-8"))
            except Exception:
                return
        elif isinstance(payload, str):
            try:
                payload = json.loads(payload)
            except Exception:
                return
        if not isinstance(payload, dict):
            return
        data = payload.get('k') or {}
        sym = (data.get('s') or payload.get('s') or "").upper()
        if not sym:
            return
        interval = data.get('i')
        expected_interval = None
        try:
            entry = kline_socket_keys.get(sym)
            if isinstance(entry, dict):
                expected_interval = entry.get("interval")
        except Exception:
            expected_interval = None
        if not expected_interval:
            expected_interval = globals().get("CANDLE_WS_INTERVAL", "5m")
        if interval != expected_interval:
            return
        try:
            _emit_ws_status("chart", f"LIVE {sym} {interval}")
        except Exception:
            pass
        ts = float(data.get('t') or 0) / 1000.0
        open_p = float(data.get('o') or 0.0)
        close_p = float(data.get('c') or 0.0)
        low_p = float(data.get('l') or 0.0)
        high_p = float(data.get('h') or 0.0)
        candle = (ts, open_p, close_p, low_p, high_p)
        key = _kline_key(sym, interval)
        with candle_cache_lock:
            hist = kline_histories.get(key)
            if hist is None:
                hist = []
                kline_histories[key] = hist
            if hist and abs(hist[-1][0] - ts) < 1e-6:
                hist[-1] = candle
            else:
                hist.append(candle)
            if len(hist) > CHART_CANDLE_LIMIT:
                hist[:] = hist[-CHART_CANDLE_LIMIT:]
            candle_cache[key] = {'ts': time.time(), 'data': hist.copy(), 'interval': key[1]}
            kline_last_update_ts[key] = time.time()
    except Exception:
        pass


def _seed_kline_history_from_rest(symbol, interval=None, limit=None, respect_backoff=True):
    if interval is None:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    sym = symbol.upper()
    requested = int(limit) if limit else CHART_CANDLE_LIMIT
    lim = max(requested, CHART_CANDLE_LIMIT)
    now = time.time()
    key = _kline_key(sym, interval)
    if respect_backoff and (now - candle_rest_failures.get(key, 0) < CANDLE_REST_RETRY_SEC):
        with candle_cache_lock:
            entry = candle_cache.get(key)
            return entry.get('data', []) if entry else []
    try:
        klines = signed_request(client.futures_klines, symbol=sym, interval=interval, limit=lim)
    except Exception as e:
        candle_rest_failures[key] = now
        log_message(f"⚠️ Не вдалося отримати {interval} свічки для {sym}: {e}")
        with candle_cache_lock:
            entry = candle_cache.get(key)
            return entry.get('data', []) if entry else []

    candles = []
    for row in klines:
        try:
            ts = float(row[0]) / 1000.0
            open_p = float(row[1])
            high_p = float(row[2])
            low_p = float(row[3])
            close_p = float(row[4])
            candles.append((ts, open_p, close_p, low_p, high_p))
        except Exception:
            continue

    _update_kline_history(sym, candles, interval=interval)
    return candles


def _schedule_kline_rest_reconcile(symbol, interval=None, limit=None, force=False):
    sym = (symbol or "").upper()
    if not sym:
        return
    if interval is None:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    try:
        interval = str(interval).strip()
    except Exception:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    try:
        every_sec = float(globals().get("CHART_REST_RECONCILE_SEC", 60) or 60.0)
    except Exception:
        every_sec = 60.0
    if every_sec <= 0 and not force:
        return
    key = (sym, interval)
    now = time.time()
    with KLINE_REST_RECONCILE_LOCK:
        if key in KLINE_REST_RECONCILE_INFLIGHT:
            return
        last_ts = KLINE_REST_RECONCILE_TS.get(key, 0.0) or 0.0
        if not force and every_sec > 0 and (now - last_ts) < every_sec:
            return
        KLINE_REST_RECONCILE_INFLIGHT.add(key)
        KLINE_REST_RECONCILE_TS[key] = now

    def _worker():
        try:
            _seed_kline_history_from_rest(sym, interval=interval, limit=limit, respect_backoff=True)
        finally:
            with KLINE_REST_RECONCILE_LOCK:
                KLINE_REST_RECONCILE_INFLIGHT.discard(key)
                KLINE_REST_RECONCILE_TS[key] = time.time()

    threading.Thread(target=_worker, daemon=True).start()


def _publish_full_orderbook(symbol, state):
    """Publish computed full-depth state to GUI-friendly (bids/asks lists).

    Uses ORDERBOOK_LEVELS top levels each side. Throttles emissions by ORDERBOOK_EMIT_INTERVAL.
    """
    symbol = (symbol or '').upper()
    if not symbol or not isinstance(state, dict):
        return
    try:
        bids_map = state.get('bids') or {}
        asks_map = state.get('asks') or {}
    except Exception:
        bids_map, asks_map = {}, {}
    try:
        limit_n = int(globals().get('ORDERBOOK_LEVELS', ORDERBOOK_LEVELS) or ORDERBOOK_LEVELS)
    except Exception:
        limit_n = int(ORDERBOOK_LEVELS or 1000)
    if limit_n <= 0:
        limit_n = 1000
    try:
        bids_prices = sorted(bids_map.keys(), reverse=True)
    except Exception:
        bids_prices = []
    try:
        asks_prices = sorted(asks_map.keys())
    except Exception:
        asks_prices = []
    bids = []
    asks = []
    try:
        for p in bids_prices[:limit_n]:
            try:
                q = float(bids_map.get(p) or 0.0)
            except Exception:
                q = 0.0
            if q <= 0:
                continue
            bids.append((float(p), q))
    except Exception:
        bids = []
    try:
        for p in asks_prices[:limit_n]:
            try:
                q = float(asks_map.get(p) or 0.0)
            except Exception:
                q = 0.0
            if q <= 0:
                continue
            asks.append((float(p), q))
    except Exception:
        asks = []
    if not bids and not asks:
        return
    now_ts = time.time()
    try:
        with orderbook_lock:
            orderbook_state[symbol] = {'symbol': symbol, 'bids': bids, 'asks': asks, 'ts': now_ts}
    except Exception:
        return
    # throttle emits to avoid GUI overload
    try:
        last_emit = orderbook_emit_ts.get(symbol, 0.0)
    except Exception:
        last_emit = 0.0
    try:
        min_gap = float(globals().get('ORDERBOOK_EMIT_INTERVAL', ORDERBOOK_EMIT_INTERVAL) or ORDERBOOK_EMIT_INTERVAL)
    except Exception:
        min_gap = float(ORDERBOOK_EMIT_INTERVAL or 0.02)
    if min_gap < 0:
        min_gap = 0.0
    if min_gap == 0 or (now_ts - last_emit) >= min_gap:
        try:
            orderbook_emit_ts[symbol] = now_ts
        except Exception:
            pass
        try:
            _emit_orderbook(symbol)
        except Exception:
            pass


def _rest_fill_orderbook_state_async(symbol, reason='init', limit_override=None):
    """Initial REST fill for the visible book so it is never empty before WS diffs.

    This does NOT clear any GUI cache; it only publishes a fresh snapshot.
    """
    sym = (symbol or '').upper()
    if not sym:
        return

    def _worker():
        # Throttle burst REST fills (startup may call subscribe multiple times)
        try:
            now = time.time()
            last = orderbook_rest_fill_last_ts.get(sym, 0.0)
            if (now - last) < float(globals().get('ORDERBOOK_REST_FILL_THROTTLE_SEC', ORDERBOOK_REST_FILL_THROTTLE_SEC) or ORDERBOOK_REST_FILL_THROTTLE_SEC):
                return
            orderbook_rest_fill_last_ts[sym] = now
        except Exception:
            pass

        try:
            if limit_override is not None:
                limit_n = int(limit_override)
            else:
                limit_n = int(globals().get('ORDERBOOK_LEVELS', ORDERBOOK_LEVELS) or ORDERBOOK_LEVELS)
        except Exception:
            limit_n = int(ORDERBOOK_LEVELS or 1000)
        try:
            ob = _fetch_orderbook_rest(sym, limit_override=limit_n)
        except Exception:
            ob = None
        if not ob:
            return
        bids, asks = ob
        now_ts = time.time()
        try:
            with orderbook_lock:
                orderbook_state[sym] = {'symbol': sym, 'bids': bids or [], 'asks': asks or [], 'ts': now_ts}
        except Exception:
            return
        try:
            orderbook_emit_ts[sym] = 0.0
        except Exception:
            pass
        try:
            _emit_orderbook(sym)
        except Exception:
            pass
        try:
            log_message(f'[OB][REST_FILL] {sym} filled via REST ({reason}) bids={len(bids or [])} asks={len(asks or [])}')
        except Exception:
            pass

    threading.Thread(target=_worker, daemon=True).start()


def orderbook_rest_reconcile_loop():
    """Periodic REST reconciliation (once per minute by default).

    Ensures the internal full-orderbook state stays aligned even if WS diffs were missed.
    """
    while not shutdown_event.is_set():
        try:
            sym = (orderbook_socket_symbol or '').upper()
            if not sym or not _use_full_orderbook(sym):
                time.sleep(0.5)
                continue
            try:
                interval = float(globals().get('ORDERBOOK_REST_RECONCILE_SEC', 60.0) or 60.0)
            except Exception:
                interval = 60.0
            if interval <= 0:
                time.sleep(1.0)
                continue
            now = time.time()
            try:
                last = float(orderbook_rest_reconcile_ts.get(sym, 0.0) or 0.0)
            except Exception:
                last = 0.0
            if (now - last) >= interval:
                orderbook_rest_reconcile_ts[sym] = now
                try:
                    _seed_full_orderbook_async(sym, force=True)
                except Exception:
                    pass
            time.sleep(0.5)
        except Exception:
            try:
                log_message('[OB][REST_RECON] loop error:\n' + traceback.format_exc())
            except Exception:
                pass
            time.sleep(0.5)


def _ensure_orderbook_reconcile_thread():
    global _orderbook_reconcile_thread_started
    try:
        if _orderbook_reconcile_thread_started:
            return
    except Exception:
        pass
    _orderbook_reconcile_thread_started = True
    try:
        threading.Thread(target=orderbook_rest_reconcile_loop, daemon=True).start()
    except Exception:
        _orderbook_reconcile_thread_started = False



def ensure_kline_subscription(symbol, interval=None):
    if interval is None:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    try:
        interval = str(interval).strip()
    except Exception:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    sym = (symbol or "").upper()
    if not sym:
        return
    try:
        if (
            _manual_kline_ws_symbol == sym
            and _manual_kline_ws_interval == interval
            and _manual_kline_ws_thread
            and _manual_kline_ws_thread.is_alive()
        ):
            return
    except Exception:
        pass
    existing = kline_socket_keys.get(sym)
    if isinstance(existing, dict):
        if not existing.get("key"):
            kline_socket_keys.pop(sym, None)
            existing = None
    if existing:
        existing_interval = None
        started = None
        if isinstance(existing, dict):
            existing_interval = existing.get("interval")
            started = existing.get("started")
        stale = False
        try:
            stale_sec = float(globals().get("KLINE_RESUBSCRIBE_STALE_SEC", 10) or 10.0)
        except Exception:
            stale_sec = 10.0
        if stale_sec > 0:
            now = time.time()
            last_update = kline_last_update_ts.get(_kline_key(sym, (existing_interval or interval)), 0.0) or 0.0
            if last_update and started and last_update < started:
                last_update = 0.0
            if last_update > 0:
                if (now - last_update) > stale_sec:
                    stale = True
            elif started and (now - started) > stale_sec:
                stale = True
        if existing_interval == interval and not stale:
            return
        stop_kline_subscription(sym)
        if existing_interval != interval:
            _reset_kline_cache(sym)
    ensure_twm_started()
    if twm is None:
        _manual_kline_ws_start(sym, interval)
        return
    try:
        if hasattr(twm, "start_futures_kline_socket"):
            key = twm.start_futures_kline_socket(
                callback=_handle_kline_stream_message,
                symbol=sym,
                interval=interval
            )
        else:
            key = None
        if key is None:
            try:
                if hasattr(twm, "start_futures_socket"):
                    stream = f"{sym.lower()}@kline_{interval}"
                    key = twm.start_futures_socket(_handle_kline_stream_message, stream)
            except Exception:
                key = None
        if key is None:
            try:
                if hasattr(twm, "start_socket"):
                    stream = f"{sym.lower()}@kline_{interval}"
                    key = twm.start_socket(_handle_kline_stream_message, stream)
            except Exception:
                key = None
        if key:
            kline_socket_keys[sym] = {"key": key, "interval": interval, "started": time.time()}
            log_message(f"[WS] Kline stream started for {sym} ({interval})")
            try:
                _emit_ws_status("chart", f"ON {sym} {interval}", force=True)
            except Exception:
                pass
        else:
            try:
                _emit_ws_status("chart", "OFF", force=True)
            except Exception:
                pass
            _manual_kline_ws_start(sym, interval)
    except Exception as e:
        log_message(f"[WS] Failed to start kline stream for {sym}: {e}")
        try:
            _emit_ws_status("chart", "OFF", force=True)
        except Exception:
            pass
        _manual_kline_ws_start(sym, interval)
    _schedule_manual_kline_ws_fallback(sym, interval)


def stop_kline_subscription(symbol):
    sym = (symbol or "").upper()
    if not sym:
        return
    try:
        if _manual_kline_ws_symbol == sym:
            _manual_kline_ws_stop_all()
    except Exception:
        pass
    entry = kline_socket_keys.pop(sym, None)
    if not entry:
        return
    key = entry.get("key") if isinstance(entry, dict) else entry
    if not key:
        return
    try:
        if twm:
            twm.stop_socket(key)
    except Exception:
        pass
    try:
        _emit_ws_status("chart", "OFF", force=True)
    except Exception:
        pass


def get_chart_candles(symbol, interval=None, limit=None, force_refresh=False, allow_rest=True, rest_seed_on_empty=True):
    """Return candles for GUI chart using cached WS data when available, else REST."""
    if interval is None:
        interval = globals().get("CANDLE_WS_INTERVAL", "5m")
    try:
        sym = (symbol or "").upper()
        if not sym:
            return []
        now = time.time()
        key = _kline_key(sym, interval)
        # 1) Спробувати взяти свіже кешоване значення
        with candle_cache_lock:
            entry = candle_cache.get(key)
            if (
                entry
                and entry.get("data")
                and not force_refresh
                and (now - entry.get("ts", 0)) <= CANDLE_CACHE_TTL
            ):
                data = entry["data"]
                if limit:
                    return data[-int(limit):]
                return data

        if not allow_rest:
            data = None
            try:
                with candle_cache_lock:
                    entry = candle_cache.get(key)
                    if entry and entry.get("data"):
                        data = entry["data"]
            except Exception:
                data = None
            out = []
            if data:
                if limit:
                    out = data[-int(limit):]
                else:
                    out = data
            try:
                if rest_seed_on_empty and KLINE_REST_SEED_ON_EMPTY:
                    requested = int(limit) if limit else CHART_CANDLE_LIMIT
                    if requested <= 0:
                        requested = CHART_CANDLE_LIMIT
                    need_seed = (not data) or (len(data) < requested)
                    if need_seed:
                        seed_key = (sym, str(interval))
                        with KLINE_SEED_LOCK:
                            if seed_key not in KLINE_SEEDED and seed_key not in KLINE_SEED_INFLIGHT:
                                KLINE_SEED_INFLIGHT.add(seed_key)
                                def _seed():
                                    try:
                                        candles = _seed_kline_history_from_rest(
                                            sym, interval=interval, limit=requested, respect_backoff=True
                                        )
                                        if candles:
                                            try:
                                                with KLINE_SEED_LOCK:
                                                    KLINE_SEEDED.add(seed_key)
                                            except Exception:
                                                pass
                                    finally:
                                        try:
                                            with KLINE_SEED_LOCK:
                                                KLINE_SEED_INFLIGHT.discard(seed_key)
                                        except Exception:
                                            pass
                                threading.Thread(target=_seed, daemon=True).start()
            except Exception:
                pass
            return out

        # 2) Якщо кеш порожній/застарілий — тягнемо з REST
        requested = int(limit) if limit else CHART_CANDLE_LIMIT
        candles = _seed_kline_history_from_rest(
            sym, interval=interval, limit=requested, respect_backoff=not force_refresh
        )
        if candles:
            if limit:
                return candles[-int(limit):]
            return candles

        # 3) Якщо REST впав — віддаємо те, що лишилось у кеші (якщо є)
        with candle_cache_lock:
            entry = candle_cache.get(key)
            if entry and entry.get("data"):
                data = entry["data"]
                if limit:
                    return data[-int(limit):]
                return data
        return []
    except Exception:
        log_message("⚠️ get_chart_candles error:\n" + traceback.format_exc())
        return []


def trim_all_kline_histories():
    try:
        with candle_cache_lock:
            for key, hist in kline_histories.items():
                if not hist:
                    continue
                if len(hist) > CHART_CANDLE_LIMIT:
                    hist[:] = hist[-CHART_CANDLE_LIMIT:]
                candle_cache[key] = {'ts': time.time(), 'data': hist.copy(), 'interval': (key[1] if isinstance(key, tuple) and len(key) > 1 else None)}
    except Exception:
        pass

# --- ТВОЯ ФИЧА С СОКРАЩЕНИЕМ ТРЕЙЛИНГА ПРИ ОТКАТЕ  ---
RETRA_PERIOD_BARS = 2
MIN_TRAIL_ADJUST_INTERVAL = 8.0
RETRA_ALPHA = 0.1
MAX_REDUCTION_RATIO = 0.3
# MIN_TRAIL_PCT will reuse TRAILING_MIN_PERCENT if defined later, otherwise set default
try:
    MIN_TRAIL_PCT = TRAILING_MIN_PERCENT
except NameError:
    MIN_TRAIL_PCT = 0.08

_last_retra_adjust_ts = {}

# Fast-approach protection settings
FAST_LOOKBACK_S = 10
FAST_PRICE_PCT_THRESH = 0.002
FAST_WIDEN_MULTIPLIER = 2.5
FAST_COOLDOWN_S = 10

# Defaults fallback
FALLBACK_TRAILING_PERCENT = 0.5

# ------------------- Telegram users (збереження у .txt) -------------------
def load_telegram_users():
    """Завантажує chat_id з файлу в TELEGRAM_USERS"""
    global TELEGRAM_USERS
    TELEGRAM_USERS = set()
    if os.path.exists(TELEGRAM_USERS_FILE):
        try:
            with open(TELEGRAM_USERS_FILE, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        TELEGRAM_USERS.add(line)
        except Exception as e:
            # Keep silent to avoid spawning/logging into a console window on Windows
            pass


def save_telegram_users():
    """Зберігає TELEGRAM_USERS у файл"""
    try:
        with open(TELEGRAM_USERS_FILE, "w", encoding="utf-8") as f:
            for uid in TELEGRAM_USERS:
                f.write(uid + "\n")
    except Exception as e:
        # Keep silent to avoid spawning/logging into a console window on Windows
        pass


def register_user(chat_id):
    """Додає chat_id у список і зберігає його"""
    TELEGRAM_USERS.add(str(chat_id))
    save_telegram_users()


def send_telegram_message(text, pin=False):
    if not TELEGRAM_TOKEN:
        try:
            log_message("⚠️ TELEGRAM_TOKEN is empty — skip send_telegram_message.")
        except Exception:
            pass
        return False
    if not TELEGRAM_USERS:
        try:
            log_message("⚠️ TELEGRAM_USERS is empty — skip send_telegram_message.")
        except Exception:
            pass
        return False
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    pin_url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/pinChatMessage"
    any_ok = False
    for chat_id in list(TELEGRAM_USERS):
        payload = {"chat_id": chat_id, "text": text, "parse_mode": "HTML"}
        try:
            resp = requests.post(url, data=payload, timeout=5)
            if resp is None or resp.status_code != 200:
                code = getattr(resp, 'status_code', None)
                body = getattr(resp, 'text', '') if resp is not None else ''
                # якщо чат недоступний/видалений — виписуємо з TELEGRAM_USERS без спаму
                if code in (400, 403) and ('chat not found' in body.lower() or 'kicked' in body.lower()):
                    TELEGRAM_USERS.discard(str(chat_id))
                    save_telegram_users()
                    log_message(f"ℹ️ Видалено недійсний chat_id {chat_id} (telegram {code}).")
                else:
                    try:
                        log_message(f"⚠️ Telegram send failed for {chat_id}: status={code} body={body}")
                    except Exception:
                        pass
                continue
            if pin:
                message_id = None
                try:
                    data = resp.json() if resp is not None else {}
                    message_id = (data.get('result') or {}).get('message_id')
                except Exception:
                    message_id = None
                if message_id:
                    try:
                        requests.post(
                            pin_url,
                            data={"chat_id": chat_id, "message_id": message_id, "disable_notification": True},
                            timeout=5
                        )
                    except Exception:
                        pass
            any_ok = True
        except Exception as e:
            try:
                log_message(f"❌ send_telegram_message error for {chat_id}: {e}")
            except Exception:
                print(f"Telegram send error {chat_id}: {e}")
    return any_ok


def _truncate_telegram_caption(text, max_len=900):
    try:
        s = str(text or "")
    except Exception:
        return ""
    if len(s) <= max_len:
        return s
    return s[: max_len - 3] + "..."


def send_telegram_photo(image_path, caption=None, pin=False):
    if not TELEGRAM_TOKEN:
        try:
            log_message("WARN TELEGRAM_TOKEN is empty - skip send_telegram_photo.")
        except Exception:
            pass
        return False
    if not TELEGRAM_USERS:
        try:
            log_message("WARN TELEGRAM_USERS is empty - skip send_telegram_photo.")
        except Exception:
            pass
        return False
    if not image_path or not os.path.exists(image_path):
        try:
            log_message(f"WARN send_telegram_photo missing file: {image_path}")
        except Exception:
            pass
        return False

    try:
        with open(image_path, "rb") as f:
            image_bytes = f.read()
    except Exception as e:
        try:
            log_message(f"WARN send_telegram_photo read failed: {e}")
        except Exception:
            pass
        return False

    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendPhoto"
    pin_url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/pinChatMessage"
    any_ok = False
    cap = _truncate_telegram_caption(caption) if caption else None
    for chat_id in list(TELEGRAM_USERS):
        payload = {"chat_id": chat_id}
        if cap:
            payload["caption"] = cap
        files = {"photo": (os.path.basename(image_path) or "chart.png", image_bytes)}
        try:
            resp = requests.post(url, data=payload, files=files, timeout=10)
            if resp is None or resp.status_code != 200:
                code = getattr(resp, "status_code", None)
                body = getattr(resp, "text", "") if resp is not None else ""
                if code in (400, 403) and ("chat not found" in body.lower() or "kicked" in body.lower()):
                    TELEGRAM_USERS.discard(str(chat_id))
                    save_telegram_users()
                    log_message(f"WARN removed invalid chat_id {chat_id} (telegram {code}).")
                else:
                    try:
                        log_message(f"WARN Telegram photo send failed for {chat_id}: status={code} body={body}")
                    except Exception:
                        pass
                continue
            if pin:
                message_id = None
                try:
                    data = resp.json() if resp is not None else {}
                    message_id = (data.get('result') or {}).get('message_id')
                except Exception:
                    message_id = None
                if message_id:
                    try:
                        requests.post(
                            pin_url,
                            data={"chat_id": chat_id, "message_id": message_id, "disable_notification": True},
                            timeout=5
                        )
                    except Exception:
                        pass
            any_ok = True
        except Exception as e:
            try:
                log_message(f"WARN send_telegram_photo error for {chat_id}: {e}")
            except Exception:
                pass
    return any_ok


def send_telegram_photo_async(image_path, caption=None, pin=False):
    """Fire-and-forget Telegram sendPhoto to avoid blocking trading logic."""
    try:
        threading.Thread(
            target=send_telegram_photo,
            args=(image_path,),
            kwargs={"caption": caption, "pin": pin},
            daemon=True,
        ).start()
        return True
    except Exception:
        try:
            return bool(send_telegram_photo(image_path, caption=caption, pin=pin))
        except Exception:
            return False


def send_telegram_message_async(text, pin=False):
    """Fire-and-forget Telegram send to avoid blocking trading logic."""
    try:
        threading.Thread(
            target=send_telegram_message,
            args=(text,),
            kwargs={"pin": pin},
            daemon=True,
        ).start()
        return True
    except Exception:
        try:
            return bool(send_telegram_message(text, pin=pin))
        except Exception:
            return False


def _telegram_notify_once(symbol: str, field: str, text: str, *, pin: bool = False, with_ts: bool = True) -> bool:
    """Send a Telegram message once per position-cycle for this symbol."""
    should_send = True
    try:
        should_send, _cycle = _pos_event_try_mark(symbol, field)
    except Exception:
        should_send = True
    if not should_send:
        return False
    try:
        msg = f"{time.strftime('%H:%M:%S')} | {text}" if with_ts else str(text)
        send_telegram_message_async(msg, pin=pin)
        return True
    except Exception:
        return False


def telegram_poll_updates_loop():
    """Background long-poll loop that listens for /start and /stop commands."""
    global LAST_UPDATE_ID
    if not TELEGRAM_TOKEN:
        log_message("ℹ️ TELEGRAM_TOKEN not provided; telegram polling disabled.")
        return
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/getUpdates"
    while TELEGRAM_POLLING_ENABLED and not shutdown_event.is_set():
        try:
            params = {'timeout': 30}
            if LAST_UPDATE_ID is not None:
                params['offset'] = LAST_UPDATE_ID + 1
            resp = requests.get(url, params=params, timeout=40)
            try:
                data = resp.json() if resp and resp.content else {}
            except Exception:
                data = {}
            for upd in data.get('result', []):
                try:
                    LAST_UPDATE_ID = int(upd.get('update_id', LAST_UPDATE_ID))
                except Exception:
                    pass
                msg = upd.get('message') or upd.get('channel_post') or {}
                if not msg:
                    continue
                chat = msg.get('chat', {})
                cid = chat.get('id')
                text = (msg.get('text') or '').strip()
                if not cid or not text:
                    continue
                if text.startswith('/start'):
                    register_user(cid)
                    try:
                        requests.post(
                            f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage",
                            data={"chat_id": cid, "text": "Ви підписані на сповіщення.", "parse_mode": "HTML"},
                            timeout=5
                        )
                    except Exception:
                        pass
                elif text.startswith('/stop'):
                    TELEGRAM_USERS.discard(str(cid))
                    save_telegram_users()
                    try:
                        requests.post(
                            f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage",
                            data={"chat_id": cid, "text": "Ви відписані від сповіщень.", "parse_mode": "HTML"},
                            timeout=5
                        )
                    except Exception:
                        pass
        except Exception as e:
            try:
                log_message(f"⚠️ Telegram poll error: {e}")
            except Exception:
                pass
        time.sleep(2)


# Load users at module import
try:
    load_telegram_users()
except Exception:
    pass


class PendingRelocator:
    """Monitors pending orders per-symbol and relocates them to closer horizontal levels."""

    # configuration (tune as needed)
    RELOCATE_MIN_IMPROVEMENT = 0.0035  # relative improvement (0.1% = 0.001)
    RELOCATE_MIN_INTERVAL = 8  # seconds min between relocations for same order
    RELOCATE_MAX_MOVES_PER_HOUR = 1
    RELOCATE_POLL_INTERVAL = 300  # how often to poll (seconds)

    # Uses bot-level LEVEL_WINDOW and LEVEL_PRECISION if present

    def __init__(self, bot):
        self.bot = bot
        # Symbol -> pending dict {'orderId','stopPrice','side','qty','meta','last_relocate_ts'}
        self.pending_orders = {}
        # Symbol -> thread & event
        self._threads = {}
        self._stop_events = {}
        # Lock for thread-safe access
        self._lock = threading.Lock()

    # ---------------- utilities ----------------
    @staticmethod
    def _relative_distance(a, b):
        return abs(a - b) / ((a + b) / 2.0) if (a + b) != 0 else float('inf')

    def _get_current_price(self, symbol):
        try:
            r = self.bot.client.futures_symbol_ticker(symbol=symbol)
            return float(r['price'])
        except Exception:
            # fallback to bot cache or wrapper if available
            if hasattr(self.bot, 'get_price_from_cache'):
                return float(self.bot.get_price_from_cache(symbol))
            raise

    def _is_position_open(self, symbol):
        try:
            pos_info = self.bot.client.futures_position_information(symbol=symbol)
            for p in pos_info:
                if p.get('symbol') == symbol:
                    amt = float(p.get('positionAmt', 0))
                    return abs(amt) > 0.0
            return False

        except Exception:
            # if we can't fetch positions, play safe and return False
            return False

    def _cancel_order_safe(self, symbol, order_id):
        try:
            self.bot.client.futures_cancel_order(symbol=symbol, orderId=order_id)
            return True
        except Exception as e:
            try:
                self.bot.log_message(f"PendingRelocator.cancel failed for {symbol} {order_id}: {e}")
            except Exception:
                print(f"PendingRelocator.cancel failed for {symbol} {order_id}: {e}")
            return False

    def _record_move(self, meta):
        now = time.time()
        mts = meta.setdefault('move_timestamps', [])
        mts.append(now)
        cutoff = now - 3600
        meta['move_timestamps'] = [t for t in mts if t >= cutoff]

    def _can_move_more(self, meta):
        mts = meta.get('move_timestamps', [])
        return len([t for t in mts if t >= time.time() - 3600]) < self.RELOCATE_MAX_MOVES_PER_HOUR

    # ---------------- core loop ----------------
    def _relocator_loop(self, symbol, stop_event):
        bot = self.bot
        bot.log_message(f"PendingRelocator started for {symbol}")
        time.sleep(30)
        while not stop_event.is_set():
            try:
                with self._lock:
                    p = self.pending_orders.get(symbol)
                if not p:
                    break

                # --- QUICK VERIFY: чи ордер ще існує у bookkeeping або на біржі? ---
                try:
                    oid = p.get('orderId')
                    if not oid:
                        bot.log_message(
                            f"PendingRelocator: no orderId/bookkeeping for {symbol} -> stop relocator")
                        with self._lock:
                            self.pending_orders.pop(symbol, None)
                        break

                    # Always verify exchange order status: the position might already be opened+closed by the time we poll,
                    # while local bookkeeping still holds the old orderId.
                    try:
                        if getattr(bot, 'client', None) is not None:
                            o = bot.client.futures_get_order(symbol=symbol, orderId=oid)
                            status = (o.get('status') or '').upper()
                            if status in ('CANCELED', 'EXPIRED', 'FILLED', 'REJECTED'):
                                bot.log_message(
                                    f"PendingRelocator: exchange order {oid} status={status} -> stop relocator for {symbol}")
                                with self._lock:
                                    self.pending_orders.pop(symbol, None)
                                break
                    except Exception as e:
                        bot.log_message(f"⚠️ PendingRelocator: exchange check failed for {symbol}: {e}")
                except Exception as e:
                    bot.log_message(f"⚠️ PendingRelocator verification error for {symbol}: {e}")

                # If a position opened, stop relocating for this symbol.
                if self._is_position_open(symbol):
                    bot.log_message(f"PendingRelocator: position opened for {symbol} — stopping relocator")
                    try:
                        _emit_rest_fill_event(symbol, {
                            'orderId': p.get('orderId'),
                            'side': p.get('side'),
                            'type': p.get('meta', {}).get('stop_type') or p.get('type'),
                            'stopPrice': p.get('stopPrice'),
                            'origQty': p.get('qty')
                        }, status_hint='FILLED')
                    except Exception as __e_rf:
                        try:
                            bot.log_message(f"⚠️ PendingRelocator: не вдалося надіслати FILLED для {symbol}: {__e_rf}")
                        except Exception:
                            pass
                    # Cleanup pending_orders entry if still present
                    with self._lock:
                        self.pending_orders.pop(symbol, None)
                    break

                order_id = p.get('orderId')
                pending_price = float(p.get('stopPrice'))
                qty = p.get('qty')
                side = p.get('side')
                meta = p.setdefault('meta', {})

                try:
                    current_price = self._get_current_price(symbol)
                except Exception as e:
                    try:
                        bot.log_message(f"PendingRelocator: failed to fetch price for {symbol}: {e}")
                    except Exception:
                        print(f"PendingRelocator: failed to fetch price for {symbol}: {e}")
                    time.sleep(self.RELOCATE_POLL_INTERVAL)
                    continue

                # Obtain raw levels from bot and normalize to float values.
                levels = []
                raw_levels = []
                if hasattr(bot, 'find_horizontal_levels'):
                    try:
                        raw_levels = bot.find_horizontal_levels(symbol, window=getattr(bot, 'LEVEL_WINDOW', 100),
                                                                precision=getattr(bot, 'LEVEL_PRECISION', 5))
                    except Exception as e:
                        try:
                            bot.log_message(f"PendingRelocator: find_horizontal_levels failed for {symbol}: {e}")
                        except Exception:
                            print(f"PendingRelocator: find_horizontal_levels failed for {symbol}: {e}")
                        raw_levels = []

                # Normalize various possible return formats into numeric level list
                if raw_levels:
                    for it in raw_levels:
                        val = None
                        # tuple/list: (level, ...)
                        if isinstance(it, (list, tuple)) and len(it) > 0:
                            val = it[0]
                        elif isinstance(it, dict):
                            # common keys
                            for k in ('price', 'level', 'value'):
                                if k in it:
                                    try:
                                        val = it[k]
                                        break
                                    except Exception:
                                        pass
                            if val is None:
                                # pick first numeric value in dict values
                                for v in it.values():
                                    if isinstance(v, (int, float)):
                                        val = v
                                        break
                        else:
                            val = it
                        # try convert to float
                        try:
                            if val is not None:
                                levels.append(float(val))
                        except Exception:
                            # skip non-numeric entries
                            continue

                # Throttled logging: report level-search activity at most once per 60 seconds
                try:
                    now_log = time.time()
                    m_last = meta.setdefault('last_level_log_ts', 0)
                    if (now_log - m_last) >= 60.0:
                        try:
                            best_preview = None
                            if levels:
                                best_preview = min(levels, key=lambda x: abs(current_price - x))
                            try:
                                levels_formatted = ','.join([f"{lv:.8f}" for lv in levels[:10]])
                            except Exception:
                                levels_formatted = str(levels)
                            bot.log_message(
                                f"🕵️‍♂️ Пошук кращого рівня на {symbol}: ціна ={current_price:.8f}, знайдено рівнів ={len(levels)}, рівні =[{levels_formatted}], найкращий ={best_preview}")
                        except Exception:
                            try:
                                print(
                                    f"🕵️‍♂️ Пошук кращого рівня на {symbol}: ціна ={current_price}, рівні={len(levels)}")
                            except Exception:
                                pass
                                pass
                        meta['last_level_log_ts'] = now_log
                except Exception:
                    pass
                if not levels:
                    time.sleep(self.RELOCATE_POLL_INTERVAL)
                    continue

                # Ensure pending_price is numeric
                try:
                    pending_price = float(
                        p.get('stopPrice', p.get('stop_price', p.get('stopprice', p.get('stopPrice')))))
                except Exception:
                    try:
                        bot.log_message(
                            f"PendingRelocator: pending_price for {symbol} is not numeric: {p.get('stopPrice')}")
                    except Exception:
                        print(f"PendingRelocator: pending_price for {symbol} is not numeric: {p.get('stopPrice')}")
                    time.sleep(self.RELOCATE_POLL_INTERVAL)
                    continue

                # choose numeric best level
                best_level = min(levels, key=lambda x: abs(current_price - x))
                cur_dist = self._relative_distance(current_price, pending_price)
                new_dist = self._relative_distance(current_price, best_level)

                now = time.time()
                last_move = p.get('last_relocate_ts', 0)

                # decide relocation using unified compute_stop_price and atomic replace

                try:

                    # determine price precision for the symbol

                    try:

                        _, price_precision = get_symbol_precision(symbol)

                    except Exception:

                        price_precision = 8

                    # compute what the new stop would be for best_level using unified logic

                    new_stop, new_buffer = compute_stop_price(symbol, best_level, current_price, price_precision)

                    if new_stop is None:

                        bot.log_message(f"Relocator: cannot compute new_stop for {symbol} -> skip")

                    else:

                        # compute improvement relative to pending distance to level

                        try:

                            pending_dist = abs(pending_price - best_level)

                            new_dist = abs(new_stop - best_level)

                            improvement = (pending_dist - new_dist) / pending_dist if pending_dist > 0 else 0.0

                        except Exception:

                            improvement = 0.0

                        bot.log_message(
                            f"Relocator check {symbol}: pending_price={pending_price}, best_level={best_level}, new_stop={new_stop}, buffer={new_buffer:.4%}, improvement={improvement:.4%}")

                        now = time.time()

                        last_move = p.get('last_relocate_ts', 0)

                        if improvement >= self.RELOCATE_MIN_IMPROVEMENT and (
                                now - last_move) >= self.RELOCATE_MIN_INTERVAL and self._can_move_more(meta):

                            # Create new order first using module-level place_pending_order if available (so adaptive rules apply)

                            new_order = None

                            prev_oid = None

                            try:

                                # Prefer module-level function

                                mod_fn = globals().get('place_pending_order')

                                if callable(mod_fn):

                                    try:

                                        new_order = mod_fn(symbol, best_level)

                                    except TypeError:

                                        try:

                                            new_order = mod_fn(symbol=symbol, level=best_level)

                                        except Exception:

                                            new_order = None

                                else:

                                    # fallback to bot adapter's place_pending_order if present

                                    if hasattr(bot, 'place_pending_order') and callable(bot.place_pending_order):

                                        try:

                                            new_order = bot.place_pending_order(symbol=symbol, side=side, qty=qty,
                                                                                stop_price=new_stop, meta=meta)

                                        except TypeError:

                                            try:

                                                new_order = bot.place_pending_order(symbol=symbol, side=side, qty=qty,
                                                                                    stopPrice=new_stop,
                                                                                    pending_meta=meta)

                                            except Exception:

                                                new_order = None

                            except Exception as e:

                                bot.log_message(f"Relocator: failed to place relocated order for {symbol}: {e}")

                                new_order = None

                            if isinstance(new_order, dict) and new_order.get('orderId') is not None:

                                new_oid = new_order.get('orderId')

                                new_stop_price = float(new_order.get('stopPrice')) if new_order.get(
                                    'stopPrice') not in (None, '') else float(new_stop)

                                # atomically update global bookkeeping so main loop won't create duplicates

                                try:

                                    with orders_lock:

                                        prev_oid = active_orders.get(symbol)

                                        active_orders[symbol] = new_oid

                                        pending_meta[symbol] = {
                                            'stop_side': side,
                                            'stop_price': new_stop_price,
                                            'level': best_level,
                                            'quantity': qty,
                                            'natr': meta.get('natr') if isinstance(meta, dict) else None,
                                            'max_level_distance': meta.get('max_level_distance') if isinstance(meta, dict) else None
                                        }

                                except Exception:

                                    pass

                                # update relocator's local entry

                                with self._lock:

                                    self.pending_orders[symbol] = {

                                        'orderId': new_oid,

                                        'stopPrice': new_stop_price,

                                        'side': side,
            'ts_ms': int(self._ts_ms(item) or (time.time() * 1000.0)),
            'qty_sum': float(qty),
            'agg_count': 1,

                                        'qty': qty,

                                        'meta': meta,

                                        'last_relocate_ts': now

                                    }

                                # cancel previous order on exchange (now that bookkeeping is updated)

                                try:

                                    if order_id:

                                        if prev_oid and str(prev_oid) != str(new_oid):
                                            self._cancel_order_safe(symbol, prev_oid)
                                            time.sleep(0.20)

                                        try:

                                            self._cancel_order_safe(symbol, order_id)

                                        except Exception:

                                            pass
                                        time.sleep(0.15)

                                except Exception:

                                    pass

                                try:

                                    self._record_move(meta)

                                except Exception:

                                    pass

                                try:
                                    bot.log_message(
                                        f"PendingRelocator: relocating {symbol}: {pending_price} -> {new_stop_price} (impr {improvement:.4%})")
                                except Exception:
                                    pass

                            else:

                                bot.log_message(
                                    f"Relocator: failed to place relocated pending for {symbol} at {best_level}")

                except Exception as e:

                    bot.log_message(f"Relocator loop error while handling relocate for {symbol}: {e}")
            except Exception as e:
                try:
                    bot.log_message(f"PendingRelocator error for {symbol}: {e}")
                except Exception:
                    print(f"PendingRelocator error for {symbol}: {e}")
            time.sleep(self.RELOCATE_POLL_INTERVAL)

        bot.log_message(f"PendingRelocator stopped for {symbol}")

    # ---------------- public API ----------------
    def register_pending_order(self, symbol, pending_info):
        """Register a pending order and ensure the relocator thread runs for that symbol.
        pending_info must contain: 'orderId', 'stopPrice' (float), 'side', 'qty', 'meta' (optional)
        """
        with self._lock:
            pending_info.setdefault('meta', {})
            pending_info.setdefault('last_relocate_ts', 0)
            self.pending_orders[symbol] = pending_info

        # start relocator thread for symbol if not already running
        self.start_relocator_for(symbol)

    def unregister_pending_order(self, symbol):
        """Stop monitoring a pending order and remove it from registry."""
        self.stop_relocator_for(symbol)
        with self._lock:
            self.pending_orders.pop(symbol, None)

    def start_relocator_for(self, symbol):
        if symbol in self._threads and self._threads[symbol].is_alive():
            return
        stop_event = threading.Event()
        t = threading.Thread(target=self._relocator_loop, args=(symbol, stop_event), daemon=True)
        self._stop_events[symbol] = stop_event
        self._threads[symbol] = t
        t.start()

    def stop_relocator_for(self, symbol):
        ev = self._stop_events.get(symbol)
        if ev:
            ev.set()
        th = self._threads.get(symbol)
        if th and th.is_alive():
            th.join(timeout=0.5)
        self._stop_events.pop(symbol, None)
        self._threads.pop(symbol, None)
        with self._lock:
            self.pending_orders.pop(symbol, None)


# ------------------ End of PendingRelocator block ------------------

relocator = None  # lazily created

try:
    from zoneinfo import ZoneInfo

except Exception:
    ZoneInfo = None
relocator = None  # will be created lazily when placing the first pending order

# ------------------- Налаштування -------------------
API_KEY = ''
API_SECRET = ''
TOP_N_GROWTH = 25
TOP_N_FALL = 3
TOP_N_VOLUME = 20
TOP_N_NATR = 20
NATR_PERIOD = 14
NATR_1M_MIN = 0.5  # Фільтр по натру
LEVEL_WINDOW = 200
LEVEL_PRECISION = 5
TOLERANCE = 0.002
MIN_TOUCHES = 2
MIN_INTERVAL = 6
MIN_LEVEL_FRESHNESS_BARS = 6  # min 5m bars between last touch of level and current price
# Замінено статичні TP на динамічні (RR-only)
# Параметри RR-дисертизації
RR_MIN = 0.6
RR_MAX = 4.0
FAKE_RR_MIN = 0.6
FAKE_RR_MAX = 4.0
TP_PARTS = 8
TP_WEIGHT_POWER = -0.2

VOLUME_24H_THRESHOLD = 250_000_000

# Default behaviour toggles
TRADE_FAKE_BREAKOUTS = False
# Trade mode options: 'real'
TRADE_MODE = 'real'
FAKE_MODE_LEVEL_OFFSET_PCT = 0.003  # pending orders in explicit fake mode sit 0.3% beyond the level

# --- Dynamic max_level_distance settings ---
DYN_MIN_LEVEL_DISTANCE = 0.035  # 1.5 %
DYN_MAX_LEVEL_DISTANCE = 0.045  # 2.5 %
DYN_NATR_FACTOR = 1.0
DYN_VOL_FACTOR = 3.0
DYN_VOL_WINDOW = 24
# --- Historical breakout analysis settings ---
HIST_BREAK_LOOKBACK = 200          # how many closed 5m bars to inspect for historical breakouts
HIST_BREAK_LOOKAHEAD_BARS = 0      # legacy knob; not used after simplification
HIST_MIN_BREAKOUT_SAMPLES = 1       # min number of classified breakouts before enforcement
HIST_BREAK_CACHE_TTL = 200          # seconds to cache per-symbol results
# Пороги класифікації пробій/закол
HIST_REAL_MOVE_THRESHOLD = 0.01     # >=1% за рівнем - пробій
HIST_FAKE_RETRACE_PCT = 0.0055      # <1% за рівнем і відкат >0.55% назад - закол
HIST_DEADBAND_PCT = None            # deadband for historical cross classification (fallback to TOLERANCE)
CONFIRM_BARS = 1                    # consecutive closes beyond deadband to confirm real break
FAKE_LOOKAHEAD = 3                  # bars to wait for confirmation before marking fake
DEBUG_VIS_DEADBAND = False          # draw deadband bounds for debug
HIST_BIAS_PREVIEW_LEVELS = 0        # how many historical levels to include in logs (0 = unlimited)
HIST_SEGMENT_COLORS = {
    'real': '#2ecc71',
    'fake': '#e74c3c',
    'unknown': '#7f8c8d'
}

# --- GPT Advisor defaults ---
GPT_ENABLED = False
GPT_API_KEY = ''
GPT_BASE_URL = 'https://api.openai.com/v1'
GPT_MODEL = 'gpt-4o-mini'
GPT_ADVISOR_INTERVAL = 900  # seconds between advisor runs
# Backoff for rate limits/errors
GPT_BACKOFF_INITIAL = 60      # 1 min
GPT_BACKOFF_MAX = 3600        # 60 min cap
_gpt_backoff_until = 0.0
_gpt_backoff_sec = GPT_BACKOFF_INITIAL
GPT_FORCE_JSON = False
GPT_MAX_TOKENS = 192
GPT_TIMEOUT_SEC = 120
GPT_MANUAL_SUPPRESS_SEC = 8  # do not overwrite manual result within this window
_advisor_last_manual_ts = 0.0
GPT_AUTO_APPLY = False
_advisor_last_applied_sig = None
GPT_RECENT_LOG_LINES = 40
GPT_INCLUDE_LOGS = False

# Prompt compaction controls
GPT_COMPACT_GLOSSARY = True
GPT_PROMPT_MAX_CHARS = 8000

# Verbose logging for advisor apply
ADVISOR_APPLY_VERBOSE = True
GPT_LOG_FILTER = (
     "ERROR|Error|Traceback|PnL|PROFIT_STOP|LOSS_STOP|BREAKEVEN|MARKET close|AUTO-APPLY|ADVISOR"
     "|збиток|прибут|PnL|PROFIT_STOP|LOSS_STOP|BREAKEVEN|Закрито|MARKET close|AUTO-APPLY|ADVISOR"
)

# Advisor gate: pause GPT requests until conditions are met
ADVISOR_GATE_ENABLED = False
ADVISOR_GATE_MIN_WINRATE_PCT = 60.0
ADVISOR_GATE_IDLE_HOURS = 4.0
ADVISOR_GATE_MAX_DRAWDOWN_PCT = 5.0

# Hide keys from GPT prompt (not blocked for manual Apply)
ADVISOR_HIDE_KEYS = { 'MIN_TOUCHES', 'TRAILING_STOP_PERCENT' }

# Keys that are never allowed to be changed by AI
ADVISOR_FORBIDDEN_KEYS = {
    'API_KEY', 'API_SECRET', 'TELEGRAM_TOKEN', 'TELEGRAM_USERS_FILE', 'LOG_DIR',
    'EQUITY_HISTORY_FILE', 'TRADE_JOURNAL_FILE', 'SETTINGS_FILE', 'GPT_API_KEY'
}

# Per-setting allow/deny map for AI advisor (persisted). True = allowed, False = blocked.
# If empty or missing, the whitelist logic below is used as a default.
ADVISOR_ALLOWED_MAP = {}

# Strict whitelist of keys the advisor can see and change
ADVISOR_ALLOWED_KEYS = [
    'TOP_N_GROWTH','TOP_N_FALL','TOP_N_VOLUME','TOP_N_NATR',
    'RR_MIN','RR_MAX',
    'MIN_INTERVAL','TOLERANCE','LEVEL_WINDOW',
    'TRAILING_NATR_FACTOR','TRAILING_MIN_PERCENT','TRAILING_MAX_PERCENT',
    'FALLBACK_TRAILING_PERCENT',
    'TP_PARTS','TP_WEIGHT_POWER',
    'TEMP_WIDEN_THRESHOLD_PCT','TEMP_WIDEN_AMOUNT_PCT','MONITOR_INTERVAL',
    'MIN_STOP_BUFFER_PCT',
    'DYN_MIN_LEVEL_DISTANCE','DYN_MAX_LEVEL_DISTANCE',
    'VOLUME_24H_THRESHOLD',
    'AMERICA_MULTI_MIN','AMERICA_MULTI_MAX','ASIA_MULTI_MIN','ASIA_MULTI_MAX','EUROPE_MULTI_MIN','EUROPE_MULTI_MAX','RESERVE_MULTI_MIN','RESERVE_MULTI_MAX',
    'HARD_SL_OFFSET_PCT'
]

# Event to trigger advisor runs (startup and after each trade close)
advisor_trigger_event = threading.Event()

breakout_bias_cache = {}
hist_preview_levels = {}
hist_preview_lock = threading.Lock()


def update_hist_preview_levels(symbol, entry_data):
    """Store detector-prepared preview structures for plotting (1:1 with detection)."""
    if not symbol:
        return
    prepared = []
    if entry_data:
        for entry in entry_data:
            if not isinstance(entry, dict):
                continue
            try:
                lvl = float(entry.get('level'))
            except Exception:
                continue
            copy_entry = entry.copy()
            copy_entry['level'] = lvl
            prepared.append(copy_entry)
    with hist_preview_lock:
        hist_preview_levels[symbol.upper()] = prepared


def get_hist_preview_levels(symbol):
    if not symbol:
        return []
    with hist_preview_lock:
        data = hist_preview_levels.get(symbol.upper(), [])
        return [item.copy() for item in data]


def _get_historical_breakout_bias_v2(symbol, level, tolerance=None):
    """
    V2 historical breakout detector.
    - Uses the same `find_horizontal_levels` detector shape as live (WS/open candle aware).
    - Counts multiple breakout attempts per level (wick-based), not just the first cross.
    - Returns (bias, stats) with `stats['preview']` suitable for chart plotting.
    """
    sym = (str(symbol).upper() if symbol else "")
    if not sym:
        return None, {}

    try:
        target_level = float(level)
    except Exception:
        return None, {}

    try:
        tol_base = abs(float(tolerance if tolerance is not None else globals().get('TOLERANCE', 0.0)))
    except Exception:
        tol_base = abs(float(globals().get('TOLERANCE', 0.0) or 0.0))

    try:
        deadband_pct = globals().get('HIST_DEADBAND_PCT')
        if deadband_pct is None:
            deadband_pct = tol_base
        deadband_pct = abs(float(deadband_pct))
    except Exception:
        deadband_pct = float(tol_base or 0.0)

    try:
        fake_lookahead = int(globals().get('FAKE_LOOKAHEAD', 3) or 3)
    except Exception:
        fake_lookahead = 3
    fake_lookahead = max(1, min(fake_lookahead, 50))

    try:
        precision = int(globals().get("LEVEL_PRECISION", 5) or 5)
    except Exception:
        precision = 5

    try:
        min_fresh_bars = int(globals().get("MIN_LEVEL_FRESHNESS_BARS", 0) or 0)
    except Exception:
        min_fresh_bars = 0
    min_fresh_bars = max(0, min_fresh_bars)

    try:
        hist_real_move = abs(float(globals().get('HIST_REAL_MOVE_THRESHOLD', 0.01) or 0.01))
    except Exception:
        hist_real_move = 0.01
    try:
        hist_fake_retrace = abs(float(globals().get('HIST_FAKE_RETRACE_PCT', 0.0055) or 0.0055))
    except Exception:
        hist_fake_retrace = 0.0055

    # Approximate entry trigger with the bot's minimum stop buffer (STOP_MARKET).
    try:
        entry_trigger_pct = abs(float(globals().get('MIN_STOP_BUFFER_PCT', 0.002) or 0.002))
    except Exception:
        entry_trigger_pct = 0.002
    entry_trigger_pct = max(entry_trigger_pct, float(tol_base or 0.0))

    try:
        min_samples_required = int(globals().get('HIST_MIN_BREAKOUT_SAMPLES', 1) or 1)
    except Exception:
        min_samples_required = 1
    if min_samples_required < 1:
        min_samples_required = 1

    def _select_entries(entries, target):
        if not entries:
            return []
        try:
            tgt = float(target)
        except Exception:
            tgt = target_level
        return sorted(entries, key=lambda it: abs(tgt - float(it.get('level', tgt) or tgt)))

    def _aggregate_stats(sorted_entries):
        preview_entries = []
        latest_entry = None
        latest_ts = None

        if sorted_entries:
            for entry in sorted_entries:
                if not isinstance(entry, dict):
                    continue
                stats_entry = entry.get('stats') or {}
                try:
                    fake_val = int(stats_entry.get('fake', 0) or 0)
                    real_val = int(stats_entry.get('real', 0) or 0)
                except Exception:
                    fake_val = 0
                    real_val = 0
                if fake_val <= 0 and real_val <= 0:
                    continue
                ts_val = entry.get('display_ts') or entry.get('first_ts') or '-'
                try:
                    ts_dt = datetime.strptime(ts_val, '%Y-%m-%d %H:%M') if ts_val and ts_val != '-' else None
                except Exception:
                    ts_dt = None
                if ts_dt and (latest_ts is None or ts_dt > latest_ts):
                    latest_ts = ts_dt
                    latest_entry = {
                        'level': entry.get('level'),
                        'bias': entry.get('bias'),
                        'stats': stats_entry,
                        'display_ts': ts_val
                    }

                preview_entry = {
                    'level': entry.get('level'),
                    'bias': entry.get('bias'),
                    'stats': stats_entry,
                    'display_ts': ts_val
                }
                preview_entries.append(preview_entry)
                if HIST_BIAS_PREVIEW_LEVELS > 0 and len(preview_entries) >= HIST_BIAS_PREVIEW_LEVELS:
                    break

        total_fake = sum(int(item.get('stats', {}).get('fake', 0) or 0) for item in preview_entries)
        total_real = sum(int(item.get('stats', {}).get('real', 0) or 0) for item in preview_entries)
        total_samples = total_fake + total_real

        if total_samples >= min_samples_required:
            if total_fake > total_real:
                imbalance_bias = 'fake'
            elif total_real > total_fake:
                imbalance_bias = 'real'
            else:
                imbalance_bias = None
        else:
            imbalance_bias = None

        latest_bias = None
        if latest_entry:
            stats_entry = latest_entry.get('stats') or {}
            try:
                lf = int(stats_entry.get('fake', 0) or 0)
                lr = int(stats_entry.get('real', 0) or 0)
            except Exception:
                lf = 0
                lr = 0
            if (lf + lr) >= min_samples_required:
                if lf > lr:
                    latest_bias = 'fake'
                elif lr > lf:
                    latest_bias = 'real'

        stats = {
            'fake': total_fake,
            'real': total_real,
            'total': total_fake + total_real,
            'level_samples': preview_entries,
            'imbalance_bias': imbalance_bias,
            'latest_bias': latest_bias
        }
        if preview_entries:
            stats['primary_level'] = preview_entries[0]
        if latest_entry:
            stats['latest_entry'] = latest_entry
        return stats

    # Fetch candles (closed+last open for detector shape)
    try:
        lookback = int(globals().get('HIST_BREAK_LOOKBACK', HIST_BREAK_LOOKBACK) or HIST_BREAK_LOOKBACK)
    except Exception:
        lookback = HIST_BREAK_LOOKBACK
    try:
        window = int(globals().get('LEVEL_WINDOW', LEVEL_WINDOW) or LEVEL_WINDOW)
    except Exception:
        window = LEVEL_WINDOW
    lookback = max(50, int(lookback or 0))
    window = max(50, int(window or 0))

    limit = max(lookback, window) + 5
    try:
        klines = signed_request(client.futures_klines, symbol=sym, interval="5m", limit=limit)
    except Exception:
        klines = None
    if not klines or len(klines) < 10:
        return None, {'preview': []}

    # Closed candles for outcome classification (exclude last open candle)
    closed_klines = klines[:-1] if len(klines) > 1 else list(klines)
    ts_list = []
    highs = []
    lows = []
    closes = []
    for row in closed_klines:
        try:
            ts_list.append(float(row[0]) / 1000.0)
            highs.append(float(row[2]))
            lows.append(float(row[3]))
            closes.append(float(row[4]))
        except Exception:
            continue
    if len(closes) < 5:
        return None, {'preview': []}

    # Detect levels using the same input shape as live: `window` klines where the last candle is open.
    subset_len = min(len(klines), window)
    level_subset = list(klines[-subset_len:]) if subset_len > 0 else []
    if len(level_subset) < 3:
        return None, {'preview': []}

    try:
        min_touches = int(globals().get('MIN_TOUCHES', MIN_TOUCHES) or MIN_TOUCHES)
    except Exception:
        min_touches = MIN_TOUCHES
    try:
        min_interval = int(globals().get('MIN_INTERVAL', MIN_INTERVAL) or MIN_INTERVAL)
    except Exception:
        min_interval = MIN_INTERVAL

    try:
        levels_data, _, _ = find_horizontal_levels(
            sym,
            precision=precision,
            tolerance=tol_base,
            min_touches=min_touches,
            min_interval=min_interval,
            allow_broken=True,          # include later-broken levels for unbiased stats
            return_details=True,
            apply_distance_filter=True, # match live relevance filter
            klines_override=level_subset,
            debug_rejections=False
        )
    except Exception:
        levels_data = []

    if not levels_data:
        now_ts = time.time()
        breakout_bias_cache[sym] = {'ts': now_ts, 'entries': [], 'preview': []}
        update_hist_preview_levels(sym, [])
        return None, {'preview': []}

    required_touches_for_eval = max(2, int(min_touches or 2))

    # Map detector's "subset closed candle indices" -> global closed candle indices
    subset_closed_count = max(1, len(level_subset) - 1)
    subset_offset = max(0, len(closed_klines) - subset_closed_count)

    def _idx_to_str(idx):
        try:
            ts = ts_list[idx]
            return datetime.fromtimestamp(ts, tz=timezone.utc).strftime('%Y-%m-%d %H:%M')
        except Exception:
            return None

    def _is_inside_close(close_val, lvl_val):
        try:
            upper = lvl_val * (1 + deadband_pct)
            lower = lvl_val * (1 - deadband_pct)
            return (close_val >= lower) and (close_val <= upper)
        except Exception:
            return False

    def _classify_events_for_level(lvl_val, is_support, start_idx):
        """Return (events, fake_count, real_count). Wick-based thresholds."""
        events = []
        fake_count = 0
        real_count = 0
        if start_idx is None:
            return events, fake_count, real_count
        try:
            idx = int(start_idx)
        except Exception:
            idx = 0
        if idx < 0:
            idx = 0
        if idx >= len(closes):
            return events, fake_count, real_count

        if is_support:
            direction = 'down'
            trigger = lvl_val * (1 - entry_trigger_pct)
            real_thr = lvl_val * (1 - hist_real_move)
            fake_thr = lvl_val * (1 + hist_fake_retrace)
        else:
            direction = 'up'
            trigger = lvl_val * (1 + entry_trigger_pct)
            real_thr = lvl_val * (1 + hist_real_move)
            fake_thr = lvl_val * (1 - hist_fake_retrace)

        max_events = 12  # safety cap per level
        while idx < len(closes) and len(events) < max_events:
            crossed = False
            if is_support:
                try:
                    crossed = lows[idx] <= trigger
                except Exception:
                    crossed = False
            else:
                try:
                    crossed = highs[idx] >= trigger
                except Exception:
                    crossed = False

            if not crossed:
                idx += 1
                continue

            cross_idx = idx
            look_end = min(len(closes), cross_idx + fake_lookahead + 1)

            idx_real = None
            idx_fake = None
            extreme = None

            for j in range(cross_idx, look_end):
                if is_support:
                    try:
                        extreme = lows[j] if extreme is None else min(extreme, lows[j])
                    except Exception:
                        pass
                    try:
                        if idx_real is None and lows[j] <= real_thr:
                            idx_real = j
                    except Exception:
                        pass
                    try:
                        if idx_fake is None and highs[j] >= fake_thr:
                            idx_fake = j
                    except Exception:
                        pass
                else:
                    try:
                        extreme = highs[j] if extreme is None else max(extreme, highs[j])
                    except Exception:
                        pass
                    try:
                        if idx_real is None and highs[j] >= real_thr:
                            idx_real = j
                    except Exception:
                        pass
                    try:
                        if idx_fake is None and lows[j] <= fake_thr:
                            idx_fake = j
                    except Exception:
                        pass

                if idx_real is not None and idx_fake is not None:
                    break

            status = 'unknown'
            end_idx = look_end - 1
            if idx_real is not None and (idx_fake is None or idx_real <= idx_fake):
                status = 'real'
                end_idx = idx_real
                real_count += 1
            elif idx_fake is not None:
                status = 'fake'
                end_idx = idx_fake
                fake_count += 1

            break_ts = None
            break_price = None
            try:
                break_ts = ts_list[cross_idx]
            except Exception:
                break_ts = None
            try:
                break_price = lows[cross_idx] if is_support else highs[cross_idx]
            except Exception:
                break_price = None

            end_ts = None
            try:
                end_ts = ts_list[end_idx] if 0 <= end_idx < len(ts_list) else ts_list[-1]
            except Exception:
                end_ts = None

            events.append({
                'status': status,
                'direction': direction,
                'break_idx': cross_idx,
                'break_ts': break_ts,
                'break_price': break_price,
                'end_idx': end_idx,
                'end_ts': end_ts,
                'extreme': extreme
            })

            # Advance and wait for reset (close back inside band) before counting another attempt.
            idx = end_idx + 1
            while idx < len(closes):
                try:
                    if _is_inside_close(closes[idx], lvl_val):
                        break
                except Exception:
                    pass
                idx += 1

        return events, fake_count, real_count


    # Build per-level stats and chart preview (one line per level + per-event markers).
    entries = []
    preview_data = []
    last_ts = ts_list[-1] if ts_list else None

    for item in levels_data or []:
        if not isinstance(item, (list, tuple)) or not item:
            continue
        lvl_raw = item[0]
        role = item[1] if len(item) > 1 else None
        meta = item[2] if len(item) > 2 and isinstance(item[2], dict) else {}

        touches_local = meta.get('touch_indices', []) if isinstance(meta, dict) else []
        if not isinstance(touches_local, list) or len(touches_local) < required_touches_for_eval:
            continue

        try:
            lvl_val = float(meta.get('level_value', lvl_raw))
        except Exception:
            try:
                lvl_val = float(lvl_raw)
            except Exception:
                continue
        try:
            lvl_val = round(lvl_val, precision)
        except Exception:
            pass

        try:
            is_support = bool(meta.get('support')) if isinstance(meta, dict) else (str(role).lower() == 'support')
        except Exception:
            is_support = (str(role).lower() == 'support')

        # Map touch indices to the global closed-candle indices
        touches_global = []
        for idx_local in touches_local:
            try:
                gi = subset_offset + int(idx_local)
            except Exception:
                continue
            if 0 <= gi < len(ts_list):
                touches_global.append(gi)
        if len(touches_global) < required_touches_for_eval:
            continue

        first_touch_local = None
        try:
            first_touch_local = meta.get('first_touch_index') if isinstance(meta, dict) else None
        except Exception:
            first_touch_local = None
        if first_touch_local is None:
            first_touch_local = touches_local[0]
        try:
            first_touch_idx = subset_offset + int(first_touch_local)
        except Exception:
            first_touch_idx = touches_global[0]

        # Freshness anchor for historical evaluation: enforce the minimum interval from the 2nd touch to breakout.
        anchor_touch_idx = touches_global[1] if len(touches_global) > 1 else None
        if anchor_touch_idx is None:
            continue

        # Touch points for plotting/numbering
        touch_points = []
        for gi in touches_global:
            try:
                price_val = lows[gi] if is_support else highs[gi]
            except Exception:
                price_val = None
            if price_val is None:
                continue
            touch_points.append({'idx': gi, 'ts': ts_list[gi], 'price': price_val})

        start_search = anchor_touch_idx + min_fresh_bars
        if start_search <= anchor_touch_idx:
            start_search = anchor_touch_idx + 1

        events, fake_cnt, real_cnt = _classify_events_for_level(lvl_val, is_support, start_search)

        total_cnt = int(fake_cnt) + int(real_cnt)
        if fake_cnt > real_cnt:
            bias = 'fake'
        elif real_cnt > fake_cnt:
            bias = 'real'
        else:
            bias = None

        # Plot line end: stop at the first real breakout trigger, otherwise extend to latest candle.
        end_ts = last_ts
        try:
            for ev in events:
                if ev.get('status') == 'real' and ev.get('break_ts') is not None:
                    end_ts = float(ev.get('break_ts'))
                    break
        except Exception:
            end_ts = last_ts

        # Start timestamp: prefer mapped candle ts
        start_ts = None
        try:
            if 0 <= first_touch_idx < len(ts_list):
                start_ts = ts_list[first_touch_idx]
        except Exception:
            start_ts = None
        if start_ts is None:
            try:
                start_ts = float(meta.get('first_touch_ts')) if isinstance(meta, dict) else None
            except Exception:
                start_ts = None

        first_ts_str = _idx_to_str(first_touch_idx) or '-'
        display_ts_str = first_ts_str
        try:
            if events:
                last_ev_ts = None
                for ev in events:
                    if ev.get('break_ts') is not None:
                        last_ev_ts = ev.get('break_ts')
                if last_ev_ts is not None:
                    display_ts_str = datetime.fromtimestamp(float(last_ev_ts), tz=timezone.utc).strftime('%Y-%m-%d %H:%M')
        except Exception:
            display_ts_str = first_ts_str

        # Samples payload (for logs/telegram)
        samples = []
        try:
            touch_ts_str = _idx_to_str(anchor_touch_idx) or first_ts_str or '-'
        except Exception:
            touch_ts_str = first_ts_str or '-'
        for ev in (events or [])[:5]:
            st = ev.get('status')
            if st not in ('real', 'fake'):
                continue
            try:
                bts = ev.get('break_ts')
                ts_str = datetime.fromtimestamp(float(bts), tz=timezone.utc).strftime('%Y-%m-%d %H:%M') if bts else '-'
            except Exception:
                ts_str = '-'
            try:
                samples.append({
                    'ts': ts_str,
                    'touch_ts': touch_ts_str,
                    'type': st,
                    'break_price': ev.get('break_price'),
                    'extreme': ev.get('extreme'),
                    'direction': ev.get('direction')
                })
            except Exception:
                pass

        entries.append({
            'level': lvl_val,
            'bias': bias,
            'first_ts': first_ts_str,
            'display_ts': display_ts_str,
            'stats': {
                'fake': int(fake_cnt),
                'real': int(real_cnt),
                'total': int(total_cnt),
                'samples': samples
            }
        })

        preview_data.append({
            'level': lvl_val,
            'status': (bias or 'unknown'),
            'bias': bias,
            'role': meta.get('role') if isinstance(meta, dict) else role,
            'is_support': bool(is_support),
            'touch_points': touch_points,
            'start_ts': start_ts,
            'end_ts': end_ts,
            'events': events
        })

    # Reduce plotted clutter: if HIST_BIAS_PREVIEW_LEVELS is set, show only the closest N levels.
    try:
        max_preview = int(HIST_BIAS_PREVIEW_LEVELS or 0)
    except Exception:
        max_preview = 0
    if max_preview > 0 and len(preview_data) > max_preview:
        try:
            preview_data = sorted(preview_data, key=lambda it: abs(float(it.get('level', target_level) or target_level) - target_level))[:max_preview]
        except Exception:
            preview_data = preview_data[:max_preview]

    now_ts = time.time()
    breakout_bias_cache[sym] = {'ts': now_ts, 'entries': entries, 'preview': preview_data}
    update_hist_preview_levels(sym, preview_data)

    sorted_entries = _select_entries(entries, target_level)
    if not sorted_entries:
        return None, {'preview': preview_data}

    stats = _aggregate_stats(sorted_entries)
    stats['preview'] = preview_data
    bias_out = stats.get('imbalance_bias')
    if not bias_out:
        primary = stats.get('primary_level') or (sorted_entries[0] if sorted_entries else None)
        if isinstance(primary, dict):
            bias_out = primary.get('bias')
    return bias_out, stats


def get_historical_breakout_bias(symbol, level, tolerance=None):
    '''Return breakout statistics and preview structures for historical levels near `level`.'''
    return None, {}
    try:
        # Prefer V2 (keeps old logic as fallback).
        bias_v2, stats_v2 = _get_historical_breakout_bias_v2(symbol, level, tolerance=tolerance)
        if stats_v2:
            return bias_v2, stats_v2
    except Exception:
        pass
    try:
        target_level = float(level)
    except Exception:
        return None, {}

    try:
        tol_base = abs(float(tolerance if tolerance is not None else TOLERANCE))
    except Exception:
        tol_base = TOLERANCE

    deadband_pct = HIST_DEADBAND_PCT if HIST_DEADBAND_PCT is not None else tol_base
    try:
        deadband_pct = float(deadband_pct)
    except Exception:
        deadband_pct = float(tol_base) if tol_base is not None else 0.0
    try:
        confirm_bars = int(globals().get('CONFIRM_BARS', 1) or 1)
    except Exception:
        confirm_bars = 1
    confirm_bars = max(1, min(confirm_bars, 2))
    try:
        fake_lookahead = int(globals().get('FAKE_LOOKAHEAD', 3) or 3)
    except Exception:
        fake_lookahead = 3
    try:
        precision = int(globals().get("LEVEL_PRECISION", 5) or 5)
    except Exception:
        precision = 5
    try:
        min_fresh_bars = int(globals().get("MIN_LEVEL_FRESHNESS_BARS", 0) or 0)
    except Exception:
        min_fresh_bars = 0

    def _select_entries(entries, target):
        if not entries:
            return []
        return sorted(entries, key=lambda it: abs(target - it.get('level', target)))

    def _aggregate_stats(entries, sorted_entries):
        preview_entries = []
        latest_entry = None
        latest_ts = None
        try:
            min_samples_required = int(globals().get('HIST_MIN_BREAKOUT_SAMPLES', 1))
        except Exception:
            min_samples_required = 1
        if min_samples_required < 1:
            min_samples_required = 1

        if sorted_entries:
            for entry in sorted_entries:
                if not isinstance(entry, dict):
                    continue
                stats_entry = entry.get('stats') or {}
                fake_val = stats_entry.get('fake', 0)
                real_val = stats_entry.get('real', 0)
                if fake_val <= 0 and real_val <= 0:
                    continue
                ts_val = entry.get('display_ts') or entry.get('first_ts') or '-'
                try:
                    ts_dt = datetime.strptime(ts_val, '%Y-%m-%d %H:%M') if ts_val != '-' else None
                except Exception:
                    ts_dt = None
                if ts_dt and (latest_ts is None or ts_dt > latest_ts):
                    latest_ts = ts_dt
                    latest_entry = {
                        'level': entry.get('level'),
                        'bias': entry.get('bias'),
                        'stats': stats_entry,
                        'display_ts': ts_val
                    }

                preview_entry = {
                    'level': entry.get('level'),
                    'bias': entry.get('bias'),
                    'stats': stats_entry,
                    'display_ts': ts_val
                }
                preview_entries.append(preview_entry)
                if HIST_BIAS_PREVIEW_LEVELS > 0 and len(preview_entries) >= HIST_BIAS_PREVIEW_LEVELS:
                    break

        total_fake = sum(item.get('stats', {}).get('fake', 0) for item in preview_entries)
        total_real = sum(item.get('stats', {}).get('real', 0) for item in preview_entries)
        total_samples = total_fake + total_real
        if total_samples >= min_samples_required:
            if total_fake > total_real:
                imbalance_bias = 'fake'
            elif total_real > total_fake:
                imbalance_bias = 'real'
            else:
                imbalance_bias = None
        else:
            imbalance_bias = None

        latest_bias = None
        if latest_entry:
            stats_entry = latest_entry.get('stats') or {}
            lf = stats_entry.get('fake', 0)
            lr = stats_entry.get('real', 0)
            if (lf + lr) >= min_samples_required:
                if lf > lr:
                    latest_bias = 'fake'
                elif lr > lf:
                    latest_bias = 'real'

        stats = {
            'fake': total_fake,
            'real': total_real,
            'total': total_fake + total_real,
            'level_samples': preview_entries,
            'imbalance_bias': imbalance_bias,
            'latest_bias': latest_bias
        }
        if preview_entries:
            stats['primary_level'] = preview_entries[0]
        if latest_entry:
            stats['latest_entry'] = latest_entry
        return stats

    limit = HIST_BREAK_LOOKBACK + 5
    try:
        klines = signed_request(client.futures_klines, symbol=symbol, interval="5m", limit=limit)
    except Exception:
        klines = None
    if not klines or len(klines) < 5:
        return None, {}

    closed_count = max(1, len(klines) - 1)
    closed_klines = klines[:closed_count]
    ts_list = []
    highs = []
    lows = []
    closes = []
    for row in closed_klines:
        try:
            ts_list.append(float(row[0]) / 1000.0)
            highs.append(float(row[2]))
            lows.append(float(row[3]))
            closes.append(float(row[4]))
        except Exception:
            continue
    if len(closes) < 3:
        return None, {}

    subset_len = min(len(closed_klines), LEVEL_WINDOW)
    level_subset = closed_klines[-subset_len:]
    subset_offset = len(closed_klines) - subset_len

    levels_data, _, _ = find_horizontal_levels(
        symbol,
        window=len(level_subset),
        precision=LEVEL_PRECISION,
        tolerance=tol_base,
        min_touches=MIN_TOUCHES,
        min_interval=MIN_INTERVAL,
        allow_broken=True,
        return_details=True,
        apply_distance_filter=False,
        klines_override=level_subset,
        debug_rejections=False
    )

    required_touches_for_break = max(2, MIN_TOUCHES)
    entries = []
    preview_data = []
    last_close = closes[-1] if closes else None

    def _state(val, lvl_val):
        upper = lvl_val * (1 + deadband_pct)
        lower = lvl_val * (1 - deadband_pct)
        if val > upper:
            return 'above'
        if val < lower:
            return 'below'
        return 'inside'

    def _idx_to_str(idx):
        try:
            ts = ts_list[idx]
            return datetime.fromtimestamp(ts, tz=timezone.utc).strftime('%Y-%m-%d %H:%M')
        except Exception:
            return None

    for item in levels_data:
        if not isinstance(item, (list, tuple)) or not item:
            continue
        lvl_raw = item[0]
        meta = item[2] if len(item) > 2 and isinstance(item[2], dict) else {}
        touches_local = meta.get('touch_indices', [])
        if len(touches_local) < required_touches_for_break:
            continue
        touches_global = [subset_offset + idx for idx in touches_local]
        first_touch_idx = subset_offset + (meta.get('first_touch_index') or touches_local[0])
        second_touch_idx = touches_global[1] if len(touches_global) > 1 else None
        anchor_touch_idx = second_touch_idx
        if anchor_touch_idx is None:
            continue

        # FIX: breakout level coercion
        try:
            level_value = round(float(meta.get('level_value', lvl_raw)), precision)
        except Exception:
            try:
                level_value = round(float(lvl_raw), precision)
            except Exception:
                # skip non-numeric level
                continue
        is_support = True if last_close is None else level_value <= last_close

        touch_points = []
        for idx in touches_global:
            if idx >= len(ts_list):
                continue
            price = lows[idx] if is_support else highs[idx]
            touch_points.append({
                'idx': idx,
                'ts': ts_list[idx],
                'price': price
            })

        status = 'neutral'
        break_idx = None
        break_price = None
        end_idx = len(ts_list) - 1 if ts_list else None

        if anchor_touch_idx is not None and anchor_touch_idx < len(closes):
            start_search = anchor_touch_idx + min_fresh_bars
            if start_search <= anchor_touch_idx:
                start_search = anchor_touch_idx + 1
            if start_search < len(closes):
                prev_state = _state(closes[start_search - 1], level_value) if start_search - 1 >= 0 else 'inside'
                for idx in range(start_search, len(closes)):
                    cur_state = _state(closes[idx], level_value)
                    if prev_state == 'inside' and cur_state in ('above', 'below'):
                        direction_state = cur_state
                        cross_idx = idx
                        consec = 0
                        look_end = min(len(closes), cross_idx + fake_lookahead + 1)
                        j = cross_idx
                        while j < look_end:
                            st_j = _state(closes[j], level_value)
                            if st_j == 'inside' or (st_j != direction_state):
                                status = 'fake'
                                break_idx = cross_idx
                                break_price = closes[cross_idx]
                                end_idx = j
                                break
                            consec += 1
                            if consec >= confirm_bars:
                                status = 'real'
                                break_idx = j
                                break_price = closes[j]
                                end_idx = j
                                break
                            j += 1
                        if status == 'neutral':
                            status = 'fake'
                            break_idx = cross_idx
                            break_price = closes[cross_idx]
                            end_idx = look_end - 1
                        break
                    prev_state = cur_state

        try:
            start_ts = ts_list[first_touch_idx] if first_touch_idx < len(ts_list) else None
        except Exception:
            start_ts = None
        try:
            end_ts = ts_list[end_idx] if end_idx is not None and end_idx < len(ts_list) else (ts_list[-1] if ts_list else None)
        except Exception:
            end_ts = None
        try:
            break_ts = ts_list[break_idx] if break_idx is not None and break_idx < len(ts_list) else None
        except Exception:
            break_ts = None

        preview_entry = {
            "level": level_value,
            "touch_indices": touches_global,
            "touch_points": touch_points,
            "start_idx": first_touch_idx,
            "end_idx": end_idx,
            "status": status,
            "break_idx": break_idx,
            "break_price": break_price,
            "break_ts": break_ts,
            "second_touch_idx": second_touch_idx,
            "anchor_touch_idx": anchor_touch_idx,
            "min_fresh_bars": min_fresh_bars,
            "is_support": is_support,
            "start_ts": start_ts,
            "end_ts": end_ts
        }
        preview_data.append(preview_entry)

        fake_count = 1 if status == 'fake' else 0
        real_count = 1 if status == 'real' else 0
        total = fake_count + real_count

        break_ts_str = None
        if break_ts is not None:
            try:
                break_ts_str = datetime.fromtimestamp(break_ts, tz=timezone.utc).strftime('%Y-%m-%d %H:%M')
            except Exception:
                break_ts_str = None
        first_touch_ts = _idx_to_str(first_touch_idx)

        sample_payload = {}
        if total > 0:
            sample_payload = {
                'ts': break_ts_str or '-',
                'touch_ts': _idx_to_str(anchor_touch_idx) or _idx_to_str(second_touch_idx) or first_touch_ts or '-',
                'type': status,
                'break_price': break_price
            }

        entries.append({
            'level': level_value,
            'bias': status if status in ('real', 'fake') else None,
            'first_ts': first_touch_ts,
            'display_ts': break_ts_str or first_touch_ts or '-',
            'stats': {
                'fake': fake_count,
                'real': real_count,
                'total': total,
                'samples': [sample_payload] if total > 0 else []
            }
        })

    now_ts = time.time()
    breakout_bias_cache[symbol] = {'ts': now_ts, 'entries': entries, 'preview': preview_data}
    update_hist_preview_levels(symbol, preview_data)

    sorted_entries = _select_entries(entries, target_level)
    if not sorted_entries:
        return None, {'preview': preview_data}
    stats = _aggregate_stats(entries, sorted_entries)
    stats['preview'] = preview_data
    bias = stats.get('imbalance_bias')
    if not bias:
        primary = stats.get('primary_level') or sorted_entries[0]
        bias = primary.get('bias')
    return bias, stats

def _hist_ts_to_epoch(ts_str):
    if not ts_str or ts_str == '-':
        return None
    try:
        dt = datetime.strptime(ts_str, '%Y-%m-%d %H:%M')
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.timestamp()
    except Exception:
        return None


def get_historical_level_segments(symbol, refresh_level=None):
    return []
    """Return detector-prepared preview segments (no recomputation)."""
    if not symbol:
        return []
    sym = symbol.upper()
    try:
        cache_entry = breakout_bias_cache.get(sym)
        now_ts = time.time()
        if (not cache_entry) or ((now_ts - cache_entry.get('ts', 0)) > HIST_BREAK_CACHE_TTL):
            target = refresh_level
            if target is None:
                try:
                    target = get_last_price(sym) or 0.0
                except Exception:
                    target = 0.0
            try:
                get_historical_breakout_bias(sym, target or 0.0)
            except Exception:
                pass
    except Exception:
        pass

    preview = None
    try:
        preview = (breakout_bias_cache.get(sym) or {}).get('preview')
    except Exception:
        preview = None
    if not preview:
        try:
            preview = get_hist_preview_levels(sym)
        except Exception:
            preview = []
    else:
        preview = [dict(item) for item in preview if isinstance(item, dict)]
    return preview or []


# --- Concurrency limits for simultaneous trades ---
MAX_CONCURRENT_PENDING = 2  # max pending stop orders tracked by the bot (None = unlimited)
MAX_CONCURRENT_POSITIONS = 2  # max simultaneously open positions (None = unlimited)
CAPACITY_COOLDOWN_SEC = 60  # wait duration before re-checking capacity when limits hit

def _clamp(x, lo, hi):
    try:
        if x is None:
            return lo
        x = float(x)
        if x < lo:
            return lo
        if x > hi:
            return hi
        return x
    except Exception:
        return lo


def _limit_reached(count, limit):
    """Return True if a numeric limit is set (>=0) and the count already meets/exceeds it."""
    try:
        if limit is None:
            return False
        limit_val = float(limit)
        if limit_val < 0:
            return False
        return float(count) >= limit_val
    except Exception:
        return False


def get_dynamic_max_level_distance(symbol, closes, natr=None,
                                   min_dist=None,
                                   max_dist=None,
                                   natr_factor=None,
                                   vol_factor=None,
                                   vol_window=None):
    """Return a dynamic max distance (decimal fraction, e.g. 0.03 = 3%).

    NOTE: This variant uses **only** volatility estimated from `closes` (std of returns)
    to compute the dynamic max distance. The `natr` argument is accepted for compatibility
    but deliberately ignored. This ensures distance calculations are consistent and based
    solely on recent price returns (closes).
    - Estimate vol from the last `vol_window` closed returns.
    - cand = vol * vol_factor
    - Clamped to [min_dist, max_dist].
    """
    def _coerce_float(value, fallback):
        try:
            if value is None:
                raise ValueError
            return float(value)
        except Exception:
            try:
                return float(fallback)
            except Exception:
                return fallback

    def _coerce_int(value, fallback):
        try:
            if value is None:
                raise ValueError
            return int(value)
        except Exception:
            try:
                return int(fallback)
            except Exception:
                return fallback

    # Pull the latest globals each call so runtime setting edits take effect.
    min_default = _coerce_float(globals().get('DYN_MIN_LEVEL_DISTANCE'), 0.015)
    max_default = _coerce_float(globals().get('DYN_MAX_LEVEL_DISTANCE'), 0.025)
    vol_factor_default = _coerce_float(globals().get('DYN_VOL_FACTOR'), 3.0)
    vol_window_default = _coerce_int(globals().get('DYN_VOL_WINDOW'), 24)

    min_dist = _coerce_float(min_dist, min_default)
    max_dist = _coerce_float(max_dist, max_default)
    vol_factor = _coerce_float(vol_factor, vol_factor_default)
    vol_window = _coerce_int(vol_window, vol_window_default)

    cand = None
    try:
        # use only closes-derived volatility
        if closes and len(closes) >= 2:
            rets = []
            L = len(closes)
            start = max(1, L - int(vol_window))
            for i in range(start, L):
                prev = closes[i - 1]
                if prev and prev != 0:
                    rets.append((closes[i] - prev) / prev)
            if rets:
                mean = sum(rets) / len(rets)
                var = sum((r - mean) ** 2 for r in rets) / len(rets)
                vol = var ** 0.5
                cand = float(vol) * float(vol_factor)
    except Exception:
        cand = None

    if cand is None or not isinstance(cand, (int, float)):
        cand = min_dist

    return _clamp(cand, min_dist, max_dist)


# ВАЖЛИВО: глобального трейлінгу за замовчуванням немає — беремо per-position NATR
# Стоп лосс
TRAILING_NATR_FACTOR = 0.8
TRAILING_MIN_PERCENT = 0.4  # мінімальний трейл у %
TRAILING_MAX_PERCENT = 1.8
FAKE_TRAILING_NATR_FACTOR = 0.8
FAKE_TRAILING_MIN_PERCENT = 0.4
FAKE_TRAILING_MAX_PERCENT = 0.8
FAKE_FALLBACK_TRAILING_PERCENT = 0.5
# Нове обмеження для розширення трейлінгу при fast-approach
MAX_APPROACH_PERCENT = 2

# NOTE: HARD_SL_OFFSET_PCT is now used as a *risk anchor* for sizing (legacy hard-SL offset).
# The actual hard SL is computed from local swing highs/lows when HARD_SL_MODE == "swing".
HARD_SL_OFFSET_PCT = 0.0055  # 0.55% baseline risk anchor (legacy hard SL offset)

# Hard SL mode:
# - "swing": place SL behind recent local swing high/low (pattern-based)
# - "offset": legacy entry +/- HARD_SL_OFFSET_PCT
HARD_SL_MODE = "swing"
HARD_SL_SWING_INTERVAL = "1m"
HARD_SL_SWING_LOOKBACK = 60
HARD_SL_SWING_PIVOT_LEFT = 2
HARD_SL_SWING_PIVOT_RIGHT = 2
HARD_SL_SWING_BUFFER_TICKS = 2
HARD_SL_SWING_BUFFER_PCT = 0.0005
HARD_SL_MIN_DIST_PCT = 0.001
# Hard SL distance bounds (fractions of entry). Used to clamp swing/offset/meta stops and map stop width -> position size.
STOP_LOSS_MIN_PCT = 0.002  # 0.2%
STOP_LOSS_MAX_PCT = 0.04   # 4%

# Single-entry only: use ENTRY2 (STOP_MARKET) at the level.
DUAL_ENTRY_ENABLED = False
DUAL_ENTRY_SPLIT = 0.5
DUAL_ENTRY_ENTRY2_SL_DIVISOR = 1.0
DUAL_ENTRY_RESIZE_AFTER_ENTRY1 = False
DUAL_ENTRY_REANCHOR_SL_AFTER_ENTRY2 = False

# Position notional clamps (USDT): notional ≈ qty * entry_est.
# - If MIN_POS_NOTIONAL_MULT > 0 and computed notional < balance*MIN_POS_NOTIONAL_MULT -> raise size up to min (increases risk).
# - If MAX_POS_NOTIONAL_MULT > 0 and computed notional > balance*MAX_POS_NOTIONAL_MULT -> cap size down.
# ENTRY1 disabled (single-entry only).
ENABLE_ENTRY1_INSTANT = False
ENTRY1_FORCE_CODE_DEFAULTS = False
ENTRY1_MODE = "off"
ENTRY1_EXPIRE_SEC = 0  # disable ENTRY1 expiry timeout (no auto-expire)
ENTRY1_ATR_FILTER_ENABLED = True
ENTRY1_MAX_DISTANCE_ATR = 0.35  # allow ENTRY1 only if |price-level| <= X * ATR(14) on 5m
ENTRY1_MICRO_INTERVALS = ("1m", "3m")
ENTRY1_MICRO_LOOKBACK = 90
ENTRY1_SWING_ENABLED = True
ENTRY1_SWING_INTERVALS = ("1m",)
ENTRY1_PIVOT_LEFT = 2
ENTRY1_PIVOT_RIGHT = 2
ENTRY1_MIN_PIVOTS = 2  # min pivot lows/highs for HL/LH series detection
ENTRY1_STOP_BUFFER_TICKS = 2
ENTRY1_STOP_BUFFER_PCT = 0.0003
ENTRY1_TRIGGER_BUFFER_TICKS = 1
ENTRY1_TRIGGER_BUFFER_PCT = 0.0
ENTRY1_SWEEP_WINDOW = 12  # last N micro bars to search for a sweep wick
ENTRY1_SWEEP_MIN_BREAK_ATR = 0.10  # sweep must exceed this fraction of ATR(5m)
ENTRY1_PREFER_SWEEP = True
ENTRY1_PENDING_REPLACE_MIN_GAP = 15  # seconds: min delay between cancel/replace of ENTRY1 STOP_MARKET in micro_pending
ENTRY1_PENDING_REPLACE_TICKS = 1     # min ticks of stopPrice change to replace
USE_LEGACY_POSTFILL_PIPELINE = False  # legacy post-fill SL placer (disabled by default; handle_filled_event is canonical)

MIN_POS_NOTIONAL_MULT = 0.0
MAX_POS_NOTIONAL_MULT = 0.0
# Binance Algo conditional orders require notional >= 5 USDT (unless reduce-only).
ALGO_MIN_NOTIONAL_USDT = 5.0

# ---- TEMPORARY WIDEN TRAILING CONFIG ----
TEMP_WIDEN_THRESHOLD_PCT = 1  # percent profit to trigger temp widen
TEMP_WIDEN_AMOUNT_PCT = -0.5
TEMP_WIDEN_SECONDS = 10  # duration seconds for the temporary widen

# плече

# Dynamic position multiplier bounds and params
MIN_MULTI = None  # динамічно залежить від часу
MAX_MULTI = None  # maximum allowed multiplier
POS_VOL_FACTOR = 20  # higher -> more aggressive reduction on vol
POS_VOL_WINDOW = 14  # window for vol estimation (returns)

AMERICA_MULTI_MIN = 2.0
AMERICA_MULTI_MAX = 3.0
ASIA_MULTI_MIN = 2.0
ASIA_MULTI_MAX = 3.0
EUROPE_MULTI_MIN = 2.0
EUROPE_MULTI_MAX = 3.0
RESERVE_MULTI_MIN = 2.0
RESERVE_MULTI_MAX = 3.0


def get_current_multiplier_settings():
    """Повертає MIN/MAX мультиплікатори залежно від торгової сесії (час Києва)."""
    try:
        now_kyiv = _kyiv_now()
        hour = now_kyiv.hour

        log_message(f"ℹ️ Поточний час Київ: {now_kyiv.strftime('%H:%M:%S')}, година: {hour}")

        if 15 <= hour <= 19:
            return AMERICA_MULTI_MIN, AMERICA_MULTI_MAX

        if 2 <= hour <= 9:
            return ASIA_MULTI_MIN, ASIA_MULTI_MAX

        if 10 <= hour <= 14:
            return EUROPE_MULTI_MIN, EUROPE_MULTI_MAX

        return RESERVE_MULTI_MIN, RESERVE_MULTI_MAX

    except Exception as e:
        log_message(f"⚠️ DEBUG: помилка в get_current_multiplier_settings: {e}")
        return RESERVE_MULTI_MIN, RESERVE_MULTI_MAX

def get_dynamic_position_multiplier(symbol, closes, natr=None, base=None,
                                    min_multi=None, max_multi=None,
                                    vol_factor=None, vol_window=None):
    """
    Return a dynamic POSITION multiplier based on volatility and time of day.
    Автоматично встановлює min_multi та max_multi на основі часу доби у Києві.
    """
    # Якщо min_multi або max_multi не задані, отримуємо поточні значення по часу
    if min_multi is None or max_multi is None:
        current_min, current_max = get_current_multiplier_settings()
        if min_multi is None:
            min_multi = current_min
        if max_multi is None:
            max_multi = current_max

    if vol_factor is None:
        vol_factor = globals().get('POS_VOL_FACTOR', 20)
    if vol_window is None:
        vol_window = globals().get('POS_VOL_WINDOW', 14)

    vol = None

    # 1) If NATR provided, use it (natr is percent -> convert to decimal)
    try:
        if natr is not None:
            vol = float(natr) / 100.0
    except Exception:
        vol = None

    # 2) Fallback: estimate volatility from closes (std of returns over vol_window)
    try:
        if vol is None and closes and len(closes) >= 2:
            L = len(closes)
            start = max(1, L - int(vol_window))
            rets = []
            for i in range(start, L):
                prev = closes[i - 1]
                if prev and prev != 0:
                    rets.append((closes[i] - prev) / prev)
            if rets:
                mean = sum(rets) / len(rets)
                var = sum((r - mean) ** 2 for r in rets) / len(rets)
                vol = var ** 0.5
    except Exception:
        vol = None

    # If still no vol estimate, assume very low volatility so we allow maximum multiplier
    if vol is None or not isinstance(vol, (int, float)):
        vol = 0.0

    # scale: higher vol -> smaller scale (bounded (0,1])
    try:
        scale = 1.0 / (1.0 + float(vol) * float(vol_factor))
    except Exception:
        scale = 1.0

    # Use max_multi as the "ceiling" (lowest vol => max_multi * 1.0)
    try:
        cand = float(max_multi) * float(scale)
    except Exception:
        cand = float(min_multi)

    # clamp to bounds
    try:
        if cand < float(min_multi):
            cand = float(min_multi)
        if cand > float(max_multi):
            cand = float(max_multi)
    except Exception:
        cand = float(min_multi)

    return cand


# максимальний трейл у %
FALLBACK_TRAILING_PERCENT = 0.5  # якщо NATR не доступний

# Інтервали
MONITOR_INTERVAL = 200  # монітор ордерів: 1 раз на 5 хвилин
PRICE_POLL_INTERVAL = 1
TRAIL_CHECK_MIN_INTERVAL = 0.0  # секунда; мінімальний інтервал між перевірками trailing на один символ
TRAIL_KEEPALIVE_INTERVAL = 1.0  # секунда; частота резервних перевірок trailing even без WS
last_trail_check_ts = {}  # symbol -> last_check_time (epoch float)
# Suppress trail logging after position closed to avoid noisy messages
TRAIL_SUPPRESS_AFTER_CLOSE = 10  # seconds to suppress TRAIL CHECK logs after a confirmed close
trailing_suppressed_until = {}  # symbol -> timestamp until which TRAIL CHECK logs suppressed
# Control whether to print logs to stdout (set False to avoid filling terminal). GUI console still updated if present.
LOG_TO_STDOUT = False
# Optional per-symbol trail-log throttling: minimum seconds between TRAIL CHECK logs (0 disables)
TRAIL_LOG_INTERVAL = 1  # set >0 to reduce TRAIL CHECK verbosity further
TRAIL_LOG_DELTA_PCT = 0.0  # minimum absolute pct change to force a new TRAIL CHECK log when within interval
last_trail_log_ts = {}  # symbol -> last trail-log time
last_trail_log_value = {}  # symbol -> last logged diff value (percentage)
# Order-distance monitor log throttling
ORDER_MONITOR_LOG_INTERVAL = 200  # seconds between distance logs per symbol
ORDER_MONITOR_LOG_DELTA_PCT = 0.1  # min absolute pct change to force a log
last_monitor_log_ts = {}  # symbol -> last log time
last_monitor_log_value = {}  # symbol -> last logged diff value (percentage)


def _initialize_tracked_position(symbol, side, qty, entry_price, meta=None, trigger_trailing=True, reason="init"):
    """Populate open_positions entry, compute trailing %, subscribe price feed, optionally run trailing check."""
    try:
        qty = abs(float(qty or 0))
    except Exception:
        qty = 0.0
    if qty <= 0:
        return None
    try:
        entry_price = float(entry_price or 0.0)
    except Exception:
        entry_price = 0.0
    meta = meta or {}
    fallback_trailing_pct = FALLBACK_TRAILING_PERCENT
    meta_natr = meta.get('natr') if isinstance(meta, dict) else None
    if meta_natr in (None, 0):
        try:
            meta_natr = calculate_natr(symbol)
        except Exception:
            meta_natr = 0.0
    natr_factor = TRAILING_NATR_FACTOR
    min_trail = TRAILING_MIN_PERCENT
    max_trail = TRAILING_MAX_PERCENT
    trailing_pct = compute_trailing_pct_from_natr(
        meta_natr,
        natr_factor=natr_factor,
        min_pct=min_trail,
        max_pct=max_trail
    )
    if trailing_pct is None:
        trailing_pct = fallback_trailing_pct
    side_state = _norm_side(side)
    pos_set(
        symbol,
        qty=qty,
        side=side_state,
        entry_price=entry_price,
        max_price=entry_price if side_state == 'LONG' else None,
        min_price=entry_price if side_state == 'SHORT' else None,
        trailing_percent=trailing_pct,
        base_trailing_percent=trailing_pct,
        pre_fast_trail=trailing_pct,
        last_retra_pct=0.0,
        fallback_trailing_percent=fallback_trailing_pct,
        trail_start_ts=time.time(),
        tp_filled=0,
        sl_order_id=None,
        closing=False,
    )
    try:
        subscribe_price(symbol)
    except Exception:
        pass
    current_price = None
    cached = symbol_prices.get(symbol)
    if cached and (time.time() - cached.get('ts', 0)) <= PRICE_STALE_SEC:
        current_price = cached.get('price')
    if current_price is None:
        current_price = get_last_price(symbol)
    try:
        pos = pos_get(symbol) or {}
        ref_price = current_price or entry_price or 0.0
        api_side = _side_to_api(side_state or side)
        if api_side == 'BUY':
            pos_set(symbol, max_price=ref_price if ref_price else pos.get('max_price', entry_price))
        else:
            pos_set(symbol, min_price=ref_price if ref_price else pos.get('min_price', entry_price))
    except Exception:
        pass
    try:
        log_message(
            f"ℹ️ Initialized trailing state for {symbol} ({reason}): side={side} qty={qty} entry={entry_price} trailing%={trailing_pct:.4f}")
    except Exception:
        pass
    if trigger_trailing and trailing_pct:
        try:
            trailing_stop_check(symbol)
        except Exception as exc:
            try:
                log_message(f"⚠️ trailing_stop_check init error for {symbol}: {exc}")
            except Exception:
                pass
    return trailing_pct


def sync_open_positions_from_exchange(trigger_trailing=True):
    """Populate open_positions from the exchange so trailing logic works immediately after (re)start."""
    global LAST_POSITION_SYNC_TS
    try:
        positions = signed_request(client.futures_position_information)
    except Exception as e:
        log_message(f"⚠️ Не вдалося синхронізувати позиції з біржею: {e}")
        return
    if not positions:
        return
    active_symbols = set()
    for item in positions:
        try:
            amt = float(item.get('positionAmt') or 0)
        except Exception:
            continue
        if abs(amt) <= 0:
            continue
        symbol = item.get('symbol')
        if not symbol:
            continue
        active_symbols.add(symbol)
        entry = item.get('entryPrice') or 0
        side = 'BUY' if amt > 0 else 'SELL'
        qty = abs(amt)
        # For positions that were not tracked locally (or had zero qty), use REST sync helper
        # to emit a synthetic ORDER_TRADE_UPDATE(FILLED) so that the unified post-fill pipeline
        # (handle_filled_event) runs: SL/TP placement, balance snapshot, etc.
        try:
            prev = pos_get(symbol) or {}
            try:
                prev_qty = float(prev.get('qty', 0.0) or 0.0)
            except Exception:
                prev_qty = 0.0
        except Exception:
            prev = {}
            prev_qty = 0.0
        if prev_qty <= eps:
            sync_ok = False
            try:
                sync_ok = bool(rest_sync_position(symbol, reason="REST_INIT"))
            except Exception:
                sync_ok = False
            if not sync_ok:
                _initialize_tracked_position(symbol, side, qty, entry, meta={}, trigger_trailing=trigger_trailing, reason="sync")
        else:
            # Already tracked: update qty/entry without resetting trailing/SL state.
            try:
                prev_side_state = _norm_side((prev or {}).get('side'))
                cur_side_state = _norm_side(side)
                if prev_side_state and cur_side_state and prev_side_state != cur_side_state:
                    # Position flipped direction — re-init local trailing state.
                    _initialize_tracked_position(
                        symbol,
                        side,
                        qty,
                        entry,
                        meta={},
                        trigger_trailing=trigger_trailing,
                        reason="sync_flip",
                    )
                else:
                    pos_set(symbol, qty=qty, side=side, entry_price=entry)
                    try:
                        subscribe_price(symbol)
                    except Exception:
                        pass
            except Exception:
                pass
    # remove stale locals that no longer exist on the exchange
    with positions_lock:
        stale = [sym for sym in open_positions.keys() if sym not in active_symbols]
        for sym in stale:
            open_positions.pop(sym, None)
            try:
                _pos_event_mark_closed(sym)
            except Exception:
                pass

    LAST_POSITION_SYNC_TS = time.time()


def _extract_entry_like_order(order):
    """Extract minimal pending-entry meta from a non-reduceOnly STOP/STOP_MARKET order."""
    if not isinstance(order, dict):
        return None
    otype = (order.get('type') or order.get('orderType') or "").upper()
    if otype not in ("STOP", "STOP_MARKET"):
        return None
    try:
        if _to_bool(order.get('reduceOnly')) or _to_bool(order.get('closePosition')):
            return None
    except Exception:
        pass
    symbol = order.get('symbol')
    side = order.get('side')
    if not symbol or not side:
        return None
    stop_raw = order.get('stopPrice') or order.get('triggerPrice') or order.get('price')
    if stop_raw in (None, "", 0, "0"):
        return None
    try:
        stop_price = float(stop_raw)
    except Exception:
        stop_price = stop_raw
    try:
        qty_raw = order.get('origQty') or order.get('origQuantity') or order.get('quantity') or 0
        qty_val = float(qty_raw)
    except Exception:
        qty_val = 0.0
    order_id = order.get('orderId') or order.get('algoId')
    if order_id is None:
        return None
    meta = {
        'stop_side': side,
        'stop_price': stop_price,
        'quantity': qty_val,
        'level': stop_price,
        'restored': True,
    }
    return symbol, order_id, meta


def _normalize_open_order_for_book(order):
    """Normalize open order fields for orderbook markers.

    Supports both REST openOrders and WS ORDER_TRADE_UPDATE objects.
    For trigger-based orders we prefer stop/trigger/activation prices.
    """
    if not isinstance(order, dict):
        return None
    sym = order.get('symbol') or order.get('s')
    if not sym:
        return None
    side = (order.get('side') or order.get('S') or "").upper()
    otype = (
        order.get('type')
        or order.get('orderType')
        or order.get('o')
        or order.get('origType')
        or order.get('algoType')
        or ""
    )
    otype = str(otype).upper()
    try:
        reduce_only = _to_bool(order.get('reduceOnly') or order.get('R'))
    except Exception:
        reduce_only = False
    try:
        close_position = _to_bool(order.get('closePosition') or order.get('cp'))
    except Exception:
        close_position = False

    # choose first meaningful price among candidates (skip zeros)
    price_raw = None
    candidates = [
        order.get('stopPrice'),
        order.get('sp'),
        order.get('triggerPrice'),
        order.get('activationPrice'),
        order.get('activatePrice'),
        order.get('workingPrice'),
        order.get('price'),
        order.get('p'),
    ]
    for c in candidates:
        if c in (None, "", 0, 0.0, "0", "0.0"):
            continue
        price_raw = c
        break
    if price_raw in (None, "", 0, 0.0, "0", "0.0"):
        return None
    try:
        price = float(price_raw)
    except Exception:
        return None

    algo_id = order.get('algoId') or order.get('algo_id') or order.get('algoID')
    order_id = order.get('orderId') or order.get('i') or order.get('id')
    if order_id is None and algo_id is not None:
        order_id = algo_id
    qty = None
    for k in ('origQty', 'origQuantity', 'quantity', 'q', 'qty', 'amount', 'size'):
        try:
            v = order.get(k)
        except Exception:
            v = None
        if v in (None, "", 0, 0.0, "0", "0.0"):
            continue
        try:
            qty = float(v)
            break
        except Exception:
            qty = None
    ts = None
    for k in ("updateTime", "time", "T", "transactTime", "E"):
        try:
            v = order.get(k)
        except Exception:
            v = None
        if v in (None, ""):
            continue
        ts = v
        break
    try:
        if ts is None:
            ts = time.time()
        else:
            ts = float(ts)
            if ts > 1e12 or ts > 1e10:
                ts = ts / 1000.0
    except Exception:
        ts = time.time()
    return {
        "symbol": str(sym).upper(),
        "price": price,
        "side": side,
        "type": otype,
        "reduce_only": bool(reduce_only),
        "close_position": bool(close_position),
        "order_id": order_id,
        "algo_id": algo_id,
        "qty": qty,
        "notional": abs(float(qty) * float(price)) if qty is not None else None,
        "ts": ts,
    }



def _update_open_orders_cache_from_ws(order_obj, status=None):
    if not isinstance(order_obj, dict):
        return
    try:
        force_add = bool(order_obj.get("_force_add") or order_obj.get("force_add") or order_obj.get("_force_show"))
    except Exception:
        force_add = False
    status_val = status or order_obj.get('X') or order_obj.get('x') or order_obj.get('status')
    status_val = str(status_val or "").upper()
    order_id = order_obj.get('orderId') or order_obj.get('i') or order_obj.get('algoId') or order_obj.get('id')
    norm = _normalize_open_order_for_book(order_obj)
    sym = None
    if isinstance(norm, dict):
        sym = norm.get("symbol")
    if not sym:
        sym = order_obj.get('symbol') or order_obj.get('s')
        if sym:
            try:
                sym = str(sym).upper()
            except Exception:
                pass
    if not sym:
        return
    remove = status_val in ('CANCELED', 'EXPIRED', 'REJECTED', 'FILLED')
    if not remove:
        try:
            if (not force_add) and norm and _should_suppress_order_after_cancel_all(sym, norm.get("ts")):
                return
        except Exception:
            pass
        try:
            oid = None
            aid = None
            if isinstance(norm, dict):
                oid = norm.get("order_id") or norm.get("orderId") or norm.get("id")
                aid = norm.get("algo_id") or norm.get("algoId")
            if (not force_add) and _should_suppress_order_id(oid or order_id, aid):
                return
        except Exception:
            pass
        if force_add and isinstance(norm, dict):
            try:
                norm["ts"] = time.time()
            except Exception:
                pass
    updated = False
    with open_orders_cache_lock:
        existing = list(open_orders_cache.get(sym) or [])
        if remove:
            if order_id is not None:
                existing = [
                    o for o in existing
                    if str(o.get('order_id') or o.get('orderId') or o.get('id') or "") != str(order_id)
                ]
                updated = True
            if norm and order_id is None:
                try:
                    price_val = float(norm.get("price"))
                except Exception:
                    price_val = None
                side_val = str(norm.get("side") or "").upper()
                type_val = str(norm.get("type") or "").upper()
                if price_val is not None:
                    def _same_order(item):
                        try:
                            if float(item.get("price")) != price_val:
                                return False
                        except Exception:
                            return False
                        if side_val and str(item.get("side") or "").upper() != side_val:
                            return False
                        if type_val and str(item.get("type") or "").upper() != type_val:
                            return False
                        return True
                    existing = [o for o in existing if not _same_order(o)]
                    updated = True
        else:
            if norm:
                if order_id is not None:
                    existing = [
                        o for o in existing
                        if str(o.get('order_id') or o.get('orderId') or o.get('id') or "") != str(order_id)
                    ]
                try:
                    price_val = float(norm.get("price"))
                except Exception:
                    price_val = None
                side_val = str(norm.get("side") or "").upper()
                type_val = str(norm.get("type") or "").upper()
                try:
                    qty_val = float(norm.get("qty") or 0.0)
                except Exception:
                    qty_val = 0.0
                if price_val is not None:
                    try:
                        tol = max(abs(float(price_val)) * 1e-9, 1e-9)
                    except Exception:
                        tol = 1e-9
                    def _is_local_dup(item):
                        try:
                            if not bool(item.get("local")):
                                return False
                        except Exception:
                            return False
                        try:
                            if abs(float(item.get("price")) - float(price_val)) > tol:
                                return False
                        except Exception:
                            return False
                        if side_val and str(item.get("side") or "").upper() != side_val:
                            return False
                        if type_val and str(item.get("type") or "").upper() != type_val:
                            return False
                        if qty_val > 0:
                            try:
                                if abs(float(item.get("qty") or 0.0) - float(qty_val)) > max(float(qty_val) * 1e-6, 1e-9):
                                    return False
                            except Exception:
                                return False
                        return True
                    existing = [o for o in existing if not _is_local_dup(o)]
                existing.append(norm)
                updated = True
        if updated:
            open_orders_cache[sym] = existing
            try:
                global open_orders_cache_ts
                open_orders_cache_ts = time.time()
            except Exception:
                pass
    if updated and gui_bus is not None:
        ob_snapshot = None
        try:
            with orderbook_lock:
                ob_snapshot = orderbook_state.get(sym)
        except Exception:
            ob_snapshot = None
        if ob_snapshot is not None:
            try:
                gui_bus.orderbook_signal.emit(ob_snapshot)
            except Exception:
                pass


def purge_closeposition_sl_markers(symbol, algo_ids=None):
    sym = (symbol or "").upper()
    if not sym:
        return
    try:
        ids = {str(a) for a in (algo_ids or []) if a not in (None, "")}
    except Exception:
        ids = set()
    use_ids = bool(ids)
    with open_orders_cache_lock:
        items = list(open_orders_cache.get(sym) or [])
        if not items:
            return
        kept = []
        for it in items:
            try:
                otype = str(it.get("type") or "").upper()
            except Exception:
                otype = ""
            try:
                close_pos = _to_bool(it.get("close_position"))
            except Exception:
                close_pos = False
            if otype in ("STOP", "STOP_MARKET") and close_pos:
                if use_ids:
                    try:
                        oid = it.get("algo_id") or it.get("algoId") or it.get("order_id") or it.get("orderId") or it.get("id")
                    except Exception:
                        oid = None
                    if oid is not None and str(oid) in ids:
                        continue
                    kept.append(it)
                    continue
                continue
            kept.append(it)
        open_orders_cache[sym] = kept
        try:
            global open_orders_cache_ts
            open_orders_cache_ts = time.time()
        except Exception:
            pass


def _local_order_is_dup(local_item, existing_list):
    try:
        price_val = float(local_item.get("price"))
    except Exception:
        return False
    side_val = str(local_item.get("side") or "").upper()
    type_val = str(local_item.get("type") or "").upper()
    try:
        qty_val = float(local_item.get("qty") or 0.0)
    except Exception:
        qty_val = 0.0
    try:
        tol = max(abs(float(price_val)) * 1e-9, 1e-9)
    except Exception:
        tol = 1e-9
    for item in existing_list or []:
        try:
            p0 = float(item.get("price"))
        except Exception:
            continue
        try:
            if abs(float(p0) - float(price_val)) > tol:
                continue
        except Exception:
            continue
        if side_val and str(item.get("side") or "").upper() != side_val:
            continue
        if type_val and str(item.get("type") or "").upper() != type_val:
            continue
        if qty_val > 0:
            try:
                if abs(float(item.get("qty") or 0.0) - float(qty_val)) > max(float(qty_val) * 1e-6, 1e-9):
                    continue
            except Exception:
                continue
        return True
    return False


def _order_item_key(item):
    if not isinstance(item, dict):
        return None
    try:
        aid = item.get("algo_id") or item.get("algoId")
    except Exception:
        aid = None
    if aid not in (None, ""):
        return f"algo:{aid}"
    try:
        oid = item.get("order_id") or item.get("orderId") or item.get("id")
    except Exception:
        oid = None
    if oid not in (None, ""):
        return f"oid:{oid}"
    try:
        price_val = float(item.get("price"))
    except Exception:
        price_val = None
    try:
        side_val = str(item.get("side") or "").upper()
    except Exception:
        side_val = ""
    try:
        type_val = str(item.get("type") or "").upper()
    except Exception:
        type_val = ""
    qty_val = None
    try:
        qty_val = float(item.get("qty")) if item.get("qty") is not None else None
    except Exception:
        qty_val = None
    if price_val is None or not side_val:
        return None
    if qty_val is not None and qty_val > 0:
        return f"p:{price_val:.10f}:{side_val}:{type_val}:{qty_val:.8f}"
    return f"p:{price_val:.10f}:{side_val}:{type_val}"


def _merge_recent_cached_orders(sym, book_list, grace_sec=None):
    try:
        grace = float(
            grace_sec
            if grace_sec is not None
            else (globals().get("OPEN_ORDERS_CACHE_GRACE_SEC", 0.0) or 0.0)
        )
    except Exception:
        grace = 0.0
    if grace <= 0:
        return book_list
    try:
        with open_orders_cache_lock:
            prev_items = list(open_orders_cache.get(sym) or [])
    except Exception:
        prev_items = []
    if not prev_items:
        return book_list
    try:
        now_ts = time.time()
    except Exception:
        now_ts = 0.0
    merged = list(book_list or [])
    seen = set()
    for it in merged:
        key = _order_item_key(it)
        if key:
            seen.add(key)
    for it in prev_items:
        try:
            if bool(it.get("local")):
                continue
        except Exception:
            pass
        try:
            if _should_suppress_order_id(
                it.get("order_id") or it.get("orderId") or it.get("id"),
                it.get("algo_id") or it.get("algoId"),
            ):
                continue
        except Exception:
            pass
        try:
            ts_val = float(it.get("ts") or 0.0)
        except Exception:
            ts_val = 0.0
        if ts_val <= 0:
            continue
        if (now_ts - ts_val) > grace:
            continue
        key = _order_item_key(it)
        if key and key in seen:
            continue
        merged.append(it)
        if key:
            seen.add(key)
    return merged


def _merge_cached_orders_after_ts(existing_list, book_list, since_ts):
    try:
        cutoff = float(since_ts or 0.0)
    except Exception:
        cutoff = 0.0
    try:
        grace = float(globals().get("OPEN_ORDERS_CACHE_GRACE_SEC", 0.0) or 0.0)
    except Exception:
        grace = 0.0
    if grace > 0 and cutoff > 0:
        cutoff = max(0.0, cutoff - grace)
    if cutoff <= 0:
        return book_list
    merged = list(book_list or [])
    seen = set()
    for it in merged:
        key = _order_item_key(it)
        if key:
            seen.add(key)
    for it in existing_list or []:
        try:
            if _should_suppress_order_id(
                it.get("order_id") or it.get("orderId") or it.get("id"),
                it.get("algo_id") or it.get("algoId"),
            ):
                continue
        except Exception:
            pass
        try:
            ts_val = float(it.get("ts") or 0.0)
        except Exception:
            ts_val = 0.0
        if ts_val <= cutoff:
            continue
        key = _order_item_key(it)
        if key and key in seen:
            continue
        merged.append(it)
        if key:
            seen.add(key)
    return merged


def _merge_cached_orders_keep(existing_list, book_list):
    merged = list(book_list or [])
    seen = set()
    for it in merged:
        key = _order_item_key(it)
        if key:
            seen.add(key)
    for it in existing_list or []:
        key = _order_item_key(it)
        if key and key in seen:
            continue
        merged.append(it)
        if key:
            seen.add(key)
    return merged


def _merge_local_orders_for_symbol(sym, book_list):
    try:
        if not bool(globals().get("OPEN_ORDERS_USE_LOCAL_MARKERS", False)):
            return book_list
    except Exception:
        pass
    try:
        sym_u = (sym or "").upper()
    except Exception:
        sym_u = ""
    if not sym_u:
        return book_list
    locals_list = []
    try:
        with open_orders_cache_lock:
            for it in open_orders_cache.get(sym_u, []) or []:
                try:
                    if bool(it.get("local")):
                        locals_list.append(it)
                except Exception:
                    continue
    except Exception:
        locals_list = []
    if not locals_list:
        return book_list
    merged = list(book_list or [])
    for loc in locals_list:
        if not _local_order_is_dup(loc, merged):
            merged.append(loc)
    return merged


def _merge_local_orders_into_book_map(book_map):
    if not isinstance(book_map, dict):
        return book_map
    try:
        if not bool(globals().get("OPEN_ORDERS_USE_LOCAL_MARKERS", False)):
            return book_map
    except Exception:
        pass
    local_map = {}
    try:
        with open_orders_cache_lock:
            for sym, items in (open_orders_cache or {}).items():
                locals_list = []
                for it in items or []:
                    try:
                        if bool(it.get("local")):
                            locals_list.append(it)
                    except Exception:
                        continue
                if locals_list:
                    local_map[str(sym).upper()] = locals_list
    except Exception:
        local_map = {}
    if not local_map:
        return book_map
    for sym, locals_list in local_map.items():
        merged = list(book_map.get(sym) or [])
        for loc in locals_list:
            if not _local_order_is_dup(loc, merged):
                merged.append(loc)
        if merged:
            book_map[sym] = merged
    return book_map


def _mark_cancel_all_suppress(symbol):
    sym = (symbol or "").upper()
    if not sym:
        return
    try:
        now_ts = time.time()
    except Exception:
        now_ts = 0.0
    try:
        with _cancel_all_suppress_lock:
            _cancel_all_suppress[sym] = now_ts
    except Exception:
        pass


def _should_suppress_order_after_cancel_all(symbol, order_ts):
    sym = (symbol or "").upper()
    if not sym:
        return False
    try:
        with _cancel_all_suppress_lock:
            ts_mark = _cancel_all_suppress.get(sym)
    except Exception:
        ts_mark = None
    if not ts_mark:
        return False
    try:
        now_ts = time.time()
    except Exception:
        now_ts = 0.0
    try:
        if (now_ts - float(ts_mark or 0.0)) > float(CANCEL_ALL_SUPPRESS_SEC or 0.0):
            try:
                with _cancel_all_suppress_lock:
                    _cancel_all_suppress.pop(sym, None)
            except Exception:
                pass
            return False
    except Exception:
        return False
    try:
        ts_val = float(order_ts or 0.0)
    except Exception:
        ts_val = 0.0
    if ts_val <= 0:
        return True
    return ts_val <= float(ts_mark or 0.0)


def _mark_cancel_ids_suppress(order_ids=None, algo_ids=None):
    try:
        ttl = float(CANCEL_SINGLE_SUPPRESS_SEC or 0.0)
    except Exception:
        ttl = 0.0
    if ttl <= 0:
        return
    try:
        now_ts = time.time()
    except Exception:
        now_ts = 0.0
    keys = []
    for oid in (order_ids or []):
        try:
            oid_s = str(oid)
        except Exception:
            oid_s = ""
        if not oid_s or oid_s.startswith("local-"):
            continue
        keys.append(f"oid:{oid_s}")
    for aid in (algo_ids or []):
        try:
            aid_s = str(aid)
        except Exception:
            aid_s = ""
        if not aid_s or aid_s.startswith("local-"):
            continue
        keys.append(f"algo:{aid_s}")
    if not keys:
        return
    try:
        with _cancel_single_suppress_lock:
            for key in keys:
                _cancel_single_suppress[key] = now_ts
    except Exception:
        pass


def _should_suppress_order_id(order_id=None, algo_id=None):
    try:
        ttl = float(CANCEL_SINGLE_SUPPRESS_SEC or 0.0)
    except Exception:
        ttl = 0.0
    if ttl <= 0:
        return False
    keys = []
    try:
        if algo_id not in (None, ""):
            keys.append(f"algo:{str(algo_id)}")
    except Exception:
        pass
    try:
        if order_id not in (None, ""):
            oid_s = str(order_id)
            if oid_s and not oid_s.startswith("local-"):
                keys.append(f"oid:{oid_s}")
    except Exception:
        pass
    if not keys:
        return False
    try:
        now_ts = time.time()
    except Exception:
        now_ts = 0.0
    try:
        with _cancel_single_suppress_lock:
            for key in keys:
                ts_mark = _cancel_single_suppress.get(key)
                if not ts_mark:
                    continue
                if (now_ts - float(ts_mark or 0.0)) > ttl:
                    _cancel_single_suppress.pop(key, None)
                    continue
                return True
    except Exception:
        return False
    return False


def _filter_suppressed_order_list(items):
    if not items:
        return items
    kept = []
    for it in items or []:
        try:
            if _should_suppress_order_id(
                it.get("order_id") or it.get("orderId") or it.get("id"),
                it.get("algo_id") or it.get("algoId"),
            ):
                continue
        except Exception:
            pass
        kept.append(it)
    return kept

def _resync_pending_orders_from_exchange():
    open_orders = []
    algo_orders = []
    open_orders_ok = True
    algo_orders_ok = True
    try:
        open_orders = signed_request(client.futures_get_open_orders) or []
    except Exception:
        open_orders = []
        open_orders_ok = False
    try:
        algo_orders = get_open_conditional_orders() or []
    except Exception:
        algo_orders = []
        algo_orders_ok = False
    if not open_orders_ok and not algo_orders_ok:
        return

    open_ids = set()
    restored_entries = []
    for o in open_orders or []:
        try:
            oid = o.get('orderId')
            if oid is not None:
                open_ids.add(str(oid))
        except Exception:
            pass
        entry = _extract_entry_like_order(o)
        if entry:
            restored_entries.append(entry)
    for o in algo_orders or []:
        try:
            oid = o.get('algoId') or o.get('orderId')
            if oid is not None:
                open_ids.add(str(oid))
        except Exception:
            pass
        entry = _extract_entry_like_order(o)
        if entry:
            restored_entries.append(entry)

    pos_with_qty = set()
    try:
        with positions_lock:
            for _sym, _pos in open_positions.items():
                if abs(float((_pos or {}).get('qty') or 0.0)) > eps:
                    pos_with_qty.add(_sym)
    except Exception:
        pos_with_qty = set()

    with orders_lock:
        if open_orders_ok and algo_orders_ok:
            for sym, oid in list(active_orders.items()):
                try:
                    if oid is None:
                        continue
                    if str(oid) not in open_ids:
                        active_orders.pop(sym, None)
                        pending_meta.pop(sym, None)
                except Exception:
                    pass
        for sym, oid, meta in restored_entries:
            if sym in pos_with_qty:
                continue
            if sym not in active_orders:
                active_orders[sym] = oid
            if sym not in pending_meta:
                pending_meta[sym] = meta


def _resync_after_reconnect():
    global _reconnect_resync_in_progress
    with _reconnect_resync_lock:
        if _reconnect_resync_in_progress:
            return
        _reconnect_resync_in_progress = True

    def _worker():
        global _reconnect_resync_in_progress
        try:
            if not bot_running:
                return
            try:
                sync_open_positions_from_exchange(trigger_trailing=True)
            except Exception:
                pass
            try:
                _resync_pending_orders_from_exchange()
            except Exception:
                pass
        finally:
            with _reconnect_resync_lock:
                _reconnect_resync_in_progress = False

    threading.Thread(target=_worker, daemon=True).start()


def _set_connection_state(connected: bool):
    global _connection_state, _last_conn_ok_ts, _last_conn_log_ts
    now = time.time()
    msg = "🌐✔️Зєднання відновлено" if connected else "🌐❌ Зєднання розірвано"
    prev_state = None
    try:
        with _connection_state_lock:
            prev_state = _connection_state
            if connected and _connection_state is True:
                _last_conn_ok_ts = now
                return
            if (not connected) and _connection_state is False:
                return
            if (not connected) and (prev_state is True) and _last_conn_ok_ts and (now - _last_conn_ok_ts) < CONN_DISCONNECT_GRACE_SEC:
                return
            _connection_state = connected
            if connected:
                _last_conn_ok_ts = now
    except Exception:
        return
    try:
        should_log = (not connected) or (prev_state is False)
        if should_log and ((not _last_conn_log_ts) or (now - _last_conn_log_ts) >= CONN_LOG_MIN_INTERVAL_SEC):
            log_message(msg)
            _last_conn_log_ts = now
    except Exception:
        pass
    if connected and prev_state is False:
        _resync_after_reconnect()


MAX_CLOSE_RETRIES = 3
PRICE_STALE_SEC = 1  # вважаємо cached price свіжим тільки якщо оновлювався за останні N сек
ERROR_RETRY_INTERVAL = 5

# ------------------- Нові налаштування захистів -------------------
# Якщо N підрядних збиткових угод -> пауза торгів на N годин (N = кількість підрядних збитків)
CONSECUTIVE_LOSS_PROTECTION = 3  # Стоп лосів підряд щоб запустити стоп торги
CONSECUTIVE_LOSS_H = 30  # пів години стоп торгів (30 хвилин)
# Якщо прибуток >= PROFIT_STOP_THRESHOLD_PERCENT від початкового депозиту -> пауза до наступної ночі 00:00 (Europe/Kyiv)
PROFIT_STOP_ENABLED = True
PROFIT_STOP_THRESHOLD_PERCENT = 5.0
# LOSS stop: if total PnL <= -LOSS_STOP_THRESHOLD_PERCENT -> pause trading until next Kyiv midnight
LOSS_STOP_ENABLED = True
LOSS_STOP_THRESHOLD_PERCENT = 10.0 # percent (positive value); triggered when total PnL <= -LOSS_STOP_THRESHOLD_PERCENT
# Additional ban after a losing close (minutes). 0 disables extra ban.
LOSS_CLOSE_BAN_MINUTES = 240

preload_settings()

try:
    os.makedirs(LOG_DIR, exist_ok=True)
except Exception:
    pass
try:
    telegram_dir = os.path.dirname(TELEGRAM_USERS_FILE)
    if telegram_dir:
        os.makedirs(telegram_dir, exist_ok=True)
except Exception:
    pass

# ------------------- Глобальні структури -------------------
# Простий стан позиції на символ
open_positions = {}  # symbol -> {qty, side, entry_price, max_price/min_price, trailing_percent, tp_filled, sl_order_id}
positions_lock = threading.Lock()
active_orders = {}  # зберігаємо активні відкладені ордери {symbol: stop_order_id}
tp_orders = {}  # зберігаємо take-profit ордери {symbol: set([tp_order_ids])}
open_orders_cache = {}  # symbol -> list of normalized open orders for UI markers
open_orders_cache_lock = threading.Lock()
open_orders_cache_ts = 0.0
OPEN_ORDERS_CACHE_TTL = 300.0
OPEN_ORDERS_CACHE_GRACE_SEC = 2.0
CANCEL_ALL_SUPPRESS_SEC = 8.0
CANCEL_SINGLE_SUPPRESS_SEC = 8.0
OPEN_ORDERS_USE_LOCAL_MARKERS = False
OPEN_ORDERS_REST_PRUNE = False
OPEN_ORDERS_REST_LIVE_SYNC = False
OPEN_ORDERS_REST_PRESTART_SYNC = True
_cancel_all_suppress = {}
_cancel_all_suppress_lock = threading.Lock()
_cancel_single_suppress = {}
_cancel_single_suppress_lock = threading.Lock()
# Keep open orders visible in the book for a long time in snapshot/WS-only modes
try:
    if bool(globals().get('WS_PLUS_ONE_SNAPSHOT', False)) or bool(globals().get('WS_ONLY_MODE', False)):
        OPEN_ORDERS_CACHE_TTL = float(globals().get('OPEN_ORDERS_CACHE_TTL_LONG', 3600.0) or 3600.0)
except Exception:
    pass

open_cond_orders_cache_ts = 0.0
OPEN_COND_ORDERS_POLL_SEC = 5.0
initial_balance = None
bot_running = False
_daily_pnl_reset_started = False
_trailing_keepalive_started = False
_user_supervisor_started = False
_orders_supervisor_started = False
_rest_watchdog_started = False
_orderbook_rest_thread_started = False
first_user_event_logged = False
rejected_symbols = set()
# temporarily banned symbols after close/cancel -> symbol -> ban_until_epoch
banned_symbols = {}  # symbol -> epoch_until (time.time()+seconds)
BAN_SECONDS = 5 * 60  # default ban duration (seconds)
# FIX: hide console flicker from self-killer (kept enabled by default, hidden window)
ENABLE_SELF_KILLER = True

eps = 1e-8


_position_event_lock = threading.Lock()
_position_event_state = {}  # SYMBOL -> per-position-cycle event dedup state
_POS_EVENT_DEFAULTS = {
    'cycle': 0,                 # increments on closed->open transition
    'is_open': False,           # last known local state
    'open_sound_cycle': -1,     # last cycle we played open sound
    'close_sound_cycle': -1,    # last cycle we played close sound
    'balance_logged_cycle': -1, # last cycle we logged "balance after close"
    'pnl_processed_cycle': -1,  # last cycle we processed pnl/loss-streak logic
}


def _pos_event_sym(symbol):
    try:
        return str(symbol).upper()
    except Exception:
        return symbol


def _pos_event_get_nolock(sym):
    st = _position_event_state.get(sym)
    if not isinstance(st, dict):
        st = dict(_POS_EVENT_DEFAULTS)
        _position_event_state[sym] = st
        return st
    for k, v in _POS_EVENT_DEFAULTS.items():
        if k not in st:
            st[k] = v
    return st


def _pos_event_get_cycle(symbol) -> int:
    sym = _pos_event_sym(symbol)
    with _position_event_lock:
        st = _pos_event_get_nolock(sym)
        try:
            return int(st.get('cycle', 0) or 0)
        except Exception:
            return 0


def _pos_event_on_qty_update(symbol, prev_qty, new_qty) -> int:
    sym = _pos_event_sym(symbol)
    try:
        prev_open = float(prev_qty or 0.0) > eps
    except Exception:
        prev_open = False
    try:
        new_open = float(new_qty or 0.0) > eps
    except Exception:
        new_open = False
    with _position_event_lock:
        st = _pos_event_get_nolock(sym)
        # Bump cycle only on a real closed->open transition, and only if we previously believed it was closed.
        if (not prev_open) and new_open and (not bool(st.get('is_open', False))):
            try:
                st['cycle'] = int(st.get('cycle', 0) or 0) + 1
            except Exception:
                st['cycle'] = 1
        st['is_open'] = bool(new_open)
        try:
            return int(st.get('cycle', 0) or 0)
        except Exception:
            return 0


def _pos_event_mark_closed(symbol) -> int:
    sym = _pos_event_sym(symbol)
    cycle = 0
    with _position_event_lock:
        st = _pos_event_get_nolock(sym)
        st['is_open'] = False
        try:
            cycle = int(st.get('cycle', 0) or 0)
        except Exception:
            cycle = 0
    try:
        chart_trade_schedule_clear(sym, delay_sec=60)
    except Exception:
        pass
    try:
        book_schedule_pos_clear(sym)
    except Exception:
        pass
    return cycle


def _pos_event_try_mark(symbol, field):
    """Mark an event field for the current cycle. Returns (should_emit, cycle)."""
    sym = _pos_event_sym(symbol)
    with _position_event_lock:
        st = _pos_event_get_nolock(sym)
        try:
            cycle = int(st.get('cycle', 0) or 0)
        except Exception:
            cycle = 0
        try:
            last = int(st.get(field, -1) or -1)
        except Exception:
            last = -1
        if last == cycle:
            return False, cycle
        st[field] = cycle
        return True, cycle


def ban_symbol(symbol, seconds=None):
    try:
        sec = seconds if seconds is not None else BAN_SECONDS
        banned_symbols[str(symbol)] = time.time() + float(sec)
        log_message(f"⛔ Symbol {symbol} banned for {int(sec)}s")
    except Exception:
        pass


def is_banned(symbol):
    try:
        if symbol is None:
            return False
        s = str(symbol)
        t = banned_symbols.get(s)
        if not t:
            return False
        if time.time() > t:
            # expired -> cleanup
            try:
                banned_symbols.pop(s, None)
            except Exception:
                pass
            return False
        return True
    except Exception:
        return False


# New metadata store: keep meta about pending stop orders so we can place TP after actual fill
pending_meta = {}  # symbol -> {'stop_side':..., 'stop_price':..., 'level':..., 'quantity':..., 'natr':...}
# pending take-profit queues (sequential release)
pending_tps = {}  # symbol -> [ (tp_price, qty, rr), ... ]
# Locks
tp_lock = threading.Lock()
orders_lock = threading.Lock()  # protects active_orders and pending_meta


def _norm_side(side):
    s = (side or '').upper()
    if s in ('BUY', 'LONG'):
        return 'LONG'
    if s in ('SELL', 'SHORT'):
        return 'SHORT'
    return None


def _side_to_api(side):
    s = _norm_side(side)
    if s == 'LONG':
        return 'BUY'
    if s == 'SHORT':
        return 'SELL'
    return None


def pos_get(symbol):
    try:
        with positions_lock:
            return open_positions.get(symbol)
    except Exception:
        return None


def pos_set(symbol, **st):
    try:
        with positions_lock:
            cur = open_positions.get(symbol, {})
            try:
                prev_qty = float(cur.get('qty', 0.0) or 0.0)
            except Exception:
                prev_qty = 0.0
            try:
                prev_side_state = _norm_side(cur.get('side'))
            except Exception:
                prev_side_state = None
            side = _norm_side(st.get('side', cur.get('side')))
            qty = float(st.get('qty', cur.get('qty', 0.0)) or 0.0)
            entry_price = float(st.get('entry_price', cur.get('entry_price', 0.0)) or 0.0)
            max_price_val = st.get('max_price', cur.get('max_price'))
            min_price_val = st.get('min_price', cur.get('min_price'))
            # Guard against accidental max/min reset on periodic REST syncs:
            # for an already-open position, peak(trough) must never go backwards.
            try:
                if prev_qty > eps and qty > eps and prev_side_state and prev_side_state == side:
                    if side == 'LONG':
                        if max_price_val in (None, 0, 0.0, ''):
                            max_price_val = cur.get('max_price')
                        else:
                            cur_max = cur.get('max_price')
                            if cur_max not in (None, 0, 0.0, ''):
                                try:
                                    max_price_val = max(float(cur_max), float(max_price_val))
                                except Exception:
                                    pass
                    elif side == 'SHORT':
                        if min_price_val in (None, 0, 0.0, ''):
                            min_price_val = cur.get('min_price')
                        else:
                            cur_min = cur.get('min_price')
                            if cur_min not in (None, 0, 0.0, ''):
                                try:
                                    min_price_val = min(float(cur_min), float(min_price_val))
                                except Exception:
                                    pass
            except Exception:
                pass
            cur.update({
                'qty': qty,
                'side': side,
                'entry_price': entry_price,
                'max_price': max_price_val,
                'min_price': min_price_val,
                'trailing_percent': st.get('trailing_percent', cur.get('trailing_percent')),
                'tp_filled': int(st.get('tp_filled', cur.get('tp_filled', 0))),
            })
            for key in (
                'base_trailing_percent',
                'trail_start_ts',
                'pre_fast_trail',
                'last_retra_pct',
                'fallback_trailing_percent',
                'closing',
                'sl_order_id',
                'sl_anchor',
                'realized_pnl',
                'hard_sl_trigger',
                'hard_sl_source',
                'dual_entry',
                'dual_entry_complete',
                'planned_qty_total',
                'planned_entry1_qty',
                'planned_entry2_qty',
                'planned_entry2_price',
                'entry1_sent',
            ):
                if key in st or key in cur:
                    cur[key] = st.get(key, cur.get(key))
            open_positions[symbol] = cur
            try:
                _pos_event_on_qty_update(symbol, prev_qty, qty)
            except Exception:
                pass
            return cur
    except Exception as e:
        try:
            log_message(f"⚠️ pos_set помилка для {symbol}: {e}")
        except Exception:
            pass
        return None


def _dual_entry_wait_state(symbol, meta=None, qty_current=None):
    """
    Returns (waiting, planned_total_qty, current_qty, qty_tol).
    waiting=True means: dual-entry is active and the position is NOT fully opened yet,
    so TP/trailing should be deferred.

    This intentionally does NOT depend on active_orders tracking, because algo orders
    (CONDITIONAL) can desync local tracking.
    """
    # Once we have observed ENTRY2/full size at least once, we must NEVER treat the position
    # as "waiting" again (important after partial TP closes reduce current qty).
    try:
        if not bool(globals().get("DUAL_ENTRY_ENABLED", False)):
            return False, None, None, None
    except Exception:
        return False, None, None, None
    pos_complete = False
    try:
        pos_complete = bool((pos_get(symbol) or {}).get('dual_entry_complete'))
    except Exception:
        pos_complete = False
    dual_entry = False
    planned_total = None

    # Prefer pending_meta (if present) for plan, but keep a copy in open_positions for robustness.
    try:
        if isinstance(meta, dict):
            dual_entry = bool(meta.get('dual_entry'))
            if dual_entry:
                try:
                    planned_total = float(meta.get('quantity_total') or 0.0)
                except Exception:
                    planned_total = None
                # If ENTRY1 wasn't sent, treat ENTRY2 as the full size.
                try:
                    entry1_sent = None
                    if 'entry1_sent' in meta:
                        entry1_sent = _to_bool(meta.get('entry1_sent'))
                    if entry1_sent is False:
                        alt = float(meta.get('entry2_qty') or meta.get('quantity') or 0.0)
                        if alt and alt > 0:
                            planned_total = alt
                except Exception:
                    pass
                if not planned_total or float(planned_total) <= 0:
                    try:
                        e1 = float(meta.get('entry1_qty') or 0.0)
                    except Exception:
                        e1 = 0.0
                    try:
                        e2 = float(meta.get('entry2_qty') or meta.get('quantity') or 0.0)
                    except Exception:
                        e2 = 0.0
                    if (e1 + e2) > 0:
                        planned_total = float(e1 + e2)
    except Exception:
        dual_entry = False
        planned_total = None

    try:
        if (not dual_entry) or (not planned_total) or float(planned_total) <= 0:
            pos = pos_get(symbol) or {}
            dual_entry = bool(pos.get('dual_entry', False))
            planned_total = float(pos.get('planned_qty_total') or 0.0)
    except Exception:
        dual_entry = False
        planned_total = 0.0

    if not dual_entry or not planned_total or float(planned_total) <= 0:
        return False, None, None, None

    try:
        if qty_current is None:
            pos = pos_get(symbol) or {}
            qty_current = abs(float(pos.get('qty') or 0.0))
        else:
            qty_current = abs(float(qty_current or 0.0))
    except Exception:
        qty_current = 0.0

    qty_tol = 0.0
    try:
        filt = order_placement_service._filters(symbol)
        step = float(filt.get("step") or 0.0)
        qty_prec = int(filt.get("qty_prec", 0) or 0)
        base = step if (step and step > 0) else (10 ** (-qty_prec or 0))
        qty_tol = max(float(base), 0.0)
    except Exception:
        qty_tol = 0.0
    if qty_tol <= 0:
        qty_tol = max(eps * 10.0, 1e-8)

    waiting = (float(qty_current) + float(qty_tol)) < float(planned_total)
    if pos_complete:
        waiting = False
    return waiting, float(planned_total), float(qty_current), float(qty_tol)


def _dual_entry_entry2_ready(symbol, meta=None, qty_current=None):
    """
    Returns (ready, planned_total, current_qty).
    ready=True only after ENTRY2 is confirmed (or dual-entry is inactive).
    """
    try:
        if not bool(globals().get("DUAL_ENTRY_ENABLED", False)):
            return True, None, qty_current
    except Exception:
        return True, None, qty_current
    dual_entry = False
    planned_total = None
    try:
        if isinstance(meta, dict) and bool(meta.get('dual_entry')):
            dual_entry = True
            try:
                planned_total = float(meta.get('quantity_total') or 0.0)
            except Exception:
                planned_total = None
            if not planned_total or float(planned_total) <= 0:
                try:
                    e1 = float(meta.get('entry1_qty') or 0.0)
                except Exception:
                    e1 = 0.0
                try:
                    e2 = float(meta.get('entry2_qty') or meta.get('quantity') or 0.0)
                except Exception:
                    e2 = 0.0
                if (e1 + e2) > 0:
                    planned_total = float(e1 + e2)
    except Exception:
        dual_entry = False
        planned_total = None

    if not dual_entry:
        try:
            pos = pos_get(symbol) or {}
            dual_entry = bool(pos.get('dual_entry', False))
            planned_total = float(pos.get('planned_qty_total') or 0.0)
        except Exception:
            dual_entry = False
            planned_total = 0.0

    if not dual_entry:
        return True, planned_total, qty_current

    try:
        st = pos_get(symbol) or {}
        entry2_pending = bool(st.get('entry2_pending'))
        entry2_filled = bool(st.get('entry2_filled'))
        if qty_current is None:
            qty_current = abs(float(st.get('qty') or 0.0))
    except Exception:
        entry2_pending = False
        entry2_filled = False
        if qty_current is None:
            qty_current = 0.0

    if entry2_filled:
        return True, planned_total, qty_current

    qty_tol = 0.0
    try:
        filt = order_placement_service._filters(symbol)
        step = float(filt.get("step") or 0.0)
        qty_prec = int(filt.get("qty_prec", 0) or 0)
        base = step if (step and step > 0) else (10 ** (-qty_prec or 0))
        qty_tol = max(float(base), 0.0)
    except Exception:
        qty_tol = 0.0
    if qty_tol <= 0:
        qty_tol = max(eps * 10.0, 1e-8)

    if planned_total and float(planned_total) > 0:
        try:
            if (float(qty_current) + float(qty_tol)) >= float(planned_total):
                try:
                    pos_set(symbol, entry2_filled=True, entry2_pending=False, dual_entry_complete=True)
                except Exception:
                    pass
                return True, planned_total, qty_current
        except Exception:
            pass

    if entry2_pending:
        return False, planned_total, qty_current

    if planned_total and float(planned_total) > 0:
        try:
            if (float(qty_current) + float(qty_tol)) < float(planned_total):
                return False, planned_total, qty_current
        except Exception:
            return False, planned_total, qty_current

    return True, planned_total, qty_current


def _derive_balance_for_notional_limits(meta, fallback_balance=None):
    """
    Derive the balance snapshot used for notional clamps.
    We prefer values stored in pending_meta (min/max_notional_usdt) so that adjustments
    use the same balance as the original sizing decision.
    """
    try:
        if isinstance(meta, dict):
            mn = meta.get('min_pos_notional_usdt')
            mm = meta.get('min_pos_notional_mult')
            if mn not in (None, "", 0) and mm not in (None, "", 0):
                mmf = float(mm)
                if mmf > 0:
                    return float(mn) / mmf
    except Exception:
        pass
    try:
        if isinstance(meta, dict):
            mx = meta.get('max_pos_notional_usdt')
            xm = meta.get('max_pos_notional_mult')
            if mx not in (None, "", 0) and xm not in (None, "", 0):
                xmf = float(xm)
                if xmf > 0:
                    return float(mx) / xmf
    except Exception:
        pass
    try:
        if fallback_balance is not None:
            return float(fallback_balance)
    except Exception:
        pass
    try:
        return float(get_balance() or 0.0)
    except Exception:
        return 0.0


def _stopmap_target_mult(stop_pct, sl_min_pct, sl_max_pct, min_mult, max_mult):
    """Map stop width -> notional multiplier (tight stop -> MAX mult, wide stop -> MIN mult)."""
    try:
        sp = float(stop_pct)
        sl_min = float(sl_min_pct)
        sl_max = float(sl_max_pct)
        mn = float(min_mult)
        mx = float(max_mult)
    except Exception:
        return None, None, None
    if sl_min <= 0:
        sl_min = 0.002
    if sl_max < sl_min:
        sl_max = sl_min
    if mn <= 0 or mx <= 0:
        return None, None, None
    # normalize mis-configured min/max
    if mn > mx:
        mn, mx = mx, mn

    sp_clamped = sp
    if sp_clamped < sl_min:
        sp_clamped = sl_min
    if sp_clamped > sl_max:
        sp_clamped = sl_max

    denom = float(sl_max) - float(sl_min)
    t = 1.0 if denom <= 1e-12 else (float(sp_clamped) - float(sl_min)) / denom
    if t < 0.0:
        t = 0.0
    elif t > 1.0:
        t = 1.0

    target = float(mx) + float(t) * (float(mn) - float(mx))
    lo_m = min(float(mn), float(mx))
    hi_m = max(float(mn), float(mx))
    if target < lo_m:
        target = lo_m
    elif target > hi_m:
        target = hi_m
    return float(target), float(sp_clamped), float(t)


def _adjust_entry2_after_entry1_fill(
    symbol,
    meta,
    tracked_oid,
    entry_price,
    sl_trigger,
    qty_entry1,
    step,
    qty_prec,
):
    """
    Dual-entry: after ENTRY1 MARKET fill we know the real entry price.
    Recompute stop% vs actual entry and adjust ENTRY2 conditional order quantity so that
    total notional matches the stopmap mapping.

    Returns updated meta dict (or the original meta on failure).
    """
    if not isinstance(meta, dict):
        return meta
    try:
        if not bool(globals().get("DUAL_ENTRY_RESIZE_AFTER_ENTRY1", True)):
            return meta
    except Exception:
        return meta
    try:
        if not bool(meta.get('dual_entry')):
            return meta
    except Exception:
        return meta
    if not tracked_oid:
        return meta
    try:
        ep = float(entry_price or 0.0)
        sl = float(sl_trigger or 0.0)
        q1 = abs(float(qty_entry1 or 0.0))
    except Exception:
        return meta
    if ep <= 0 or sl <= 0 or q1 <= eps:
        return meta

    # Config bounds
    try:
        sl_min_pct = float(globals().get("STOP_LOSS_MIN_PCT", 0.002) or 0.002)
    except Exception:
        sl_min_pct = 0.002
    try:
        sl_max_pct = float(globals().get("STOP_LOSS_MAX_PCT", 0.04) or 0.04)
    except Exception:
        sl_max_pct = 0.04

    # Notional multipliers (prefer the ones used during planning)
    try:
        min_mult = float(meta.get('min_pos_notional_mult') or globals().get("MIN_POS_NOTIONAL_MULT", 0.0) or 0.0)
    except Exception:
        min_mult = 0.0
    try:
        max_mult = float(meta.get('max_pos_notional_mult') or globals().get("MAX_POS_NOTIONAL_MULT", 0.0) or 0.0)
    except Exception:
        max_mult = 0.0
    if min_mult <= 0 or max_mult <= 0:
        return meta
    if min_mult > max_mult:
        min_mult, max_mult = max_mult, min_mult

    # Stop% based on actual ENTRY1 fill
    try:
        stop_pct_fill = abs(float(ep) - float(sl)) / float(ep)
    except Exception:
        stop_pct_fill = None
    if stop_pct_fill is None:
        return meta

    tgt_mult_fill, stop_pct_fill_clamped, _t_fill = _stopmap_target_mult(
        stop_pct_fill, sl_min_pct, sl_max_pct, min_mult, max_mult
    )
    if tgt_mult_fill is None:
        return meta

    bal_for_limits = _derive_balance_for_notional_limits(meta)
    if not bal_for_limits or float(bal_for_limits) <= 0:
        return meta

    # Quantize in step units to keep qty_total == qty1 + qty2 in allowed increments
    try:
        step_q = float(step or 0.0)
    except Exception:
        step_q = 0.0
    try:
        qp = int(qty_prec or 0)
    except Exception:
        qp = 0
    if step_q <= 0:
        step_q = 10 ** (-int(qp or 0))
    if step_q <= 0:
        step_q = 1e-8

    try:
        n1 = int(round(float(q1) / float(step_q)))
    except Exception:
        n1 = 0
    if n1 < 1:
        return meta

    target_notional_fill = float(bal_for_limits) * float(tgt_mult_fill)
    try:
        n_total_fill = int(round((float(target_notional_fill) / float(ep)) / float(step_q)))
    except Exception:
        n_total_fill = 0
    if n_total_fill < n1:
        n_total_fill = n1

    # Cap by max notional (uses the same snapshot as planning if provided in meta)
    try:
        max_notional_usdt = meta.get('max_pos_notional_usdt')
        if max_notional_usdt not in (None, "", 0):
            n_total_max = int(math.floor(((float(max_notional_usdt) / float(ep)) / float(step_q)) + 1e-12))
            if n_total_max > 0 and n_total_fill > n_total_max:
                n_total_fill = n_total_max
    except Exception:
        pass
    if n_total_fill < n1:
        n_total_fill = n1

    n2 = int(n_total_fill - n1)

    # Ensure ENTRY2 (conditional) still respects Binance Algo min-notional
    try:
        algo_min_notional = float(globals().get("ALGO_MIN_NOTIONAL_USDT", 5.0) or 5.0)
    except Exception:
        algo_min_notional = 5.0
    try:
        trigger_px = float(meta.get('stop_price') or 0.0)
    except Exception:
        trigger_px = 0.0
    if trigger_px > 0 and algo_min_notional > 0:
        try:
            n2_min = int(math.ceil(((float(algo_min_notional) / float(trigger_px)) / float(step_q)) - 1e-12))
        except Exception:
            n2_min = 1
        if n2_min < 1:
            n2_min = 1
        if n2 < n2_min:
            # Only increase if it still fits under max-notional cap (if any)
            try:
                max_notional_usdt = meta.get('max_pos_notional_usdt')
                if max_notional_usdt not in (None, "", 0):
                    n_total_max = int(math.floor(((float(max_notional_usdt) / float(ep)) / float(step_q)) + 1e-12))
                else:
                    n_total_max = None
            except Exception:
                n_total_max = None
            if n_total_max is not None and (n1 + n2_min) > int(n_total_max):
                # can't satisfy both constraints; keep the original order unchanged
                return meta
            n2 = n2_min
            n_total_fill = n1 + n2

    qty2_new = round(float(n2) * float(step_q), qp)
    qty_total_new = round(float(n_total_fill) * float(step_q), qp)

    # Old plan (for logging/debug)
    try:
        old_qty2 = float(meta.get('entry2_qty') or meta.get('quantity') or 0.0)
    except Exception:
        old_qty2 = 0.0
    try:
        old_total = float(meta.get('quantity_total') or 0.0)
    except Exception:
        old_total = 0.0

    # Compute planned stop% (vs entry_est used during planning) to explain differences in logs
    stop_pct_plan = None
    tgt_mult_plan = None
    try:
        d_abs = float(meta.get('hard_sl_stop_dist') or 0.0)
        sl_p = float(meta.get('hard_sl_trigger') or 0.0)
        side_api = str(meta.get('stop_side') or '').upper()
        if d_abs > 0 and sl_p > 0 and side_api in ("BUY", "SELL"):
            entry_plan = (sl_p + d_abs) if side_api == "BUY" else (sl_p - d_abs)
            if entry_plan and entry_plan > 0:
                stop_pct_plan = float(d_abs) / float(entry_plan)
                tgt_mult_plan, _spc, _t = _stopmap_target_mult(stop_pct_plan, sl_min_pct, sl_max_pct, min_mult, max_mult)
    except Exception:
        stop_pct_plan = None
        tgt_mult_plan = None

    # If no effective change, just persist diagnostics and return
    try:
        if abs(float(qty2_new) - float(old_qty2)) < (float(step_q) / 2.0):
            meta['stop_pct_fill'] = float(stop_pct_fill)
            meta['stop_pct_plan'] = float(stop_pct_plan) if stop_pct_plan is not None else None
            meta['stopmap_mult_fill'] = float(tgt_mult_fill)
            meta['stopmap_mult_plan'] = float(tgt_mult_plan) if tgt_mult_plan is not None else None
            return meta
    except Exception:
        pass

    # Replace conditional order: cancel old, place new (best-effort, avoid duplicates).
    cancel_failed = None
    try:
        cancel_conditional_order(symbol, tracked_oid)
    except Exception as _ce:
        # If we cannot cancel reliably, don't place a new conditional (would risk double-entry).
        cancel_failed = _ce
    if cancel_failed is not None:
        try:
            log_message(f"⚠️ [SIZE ADJUST] {symbol}: cancel ENTRY2 failed, skip resize to avoid duplicates: {cancel_failed}")
        except Exception:
            pass
        return meta
    order_type = "STOP_MARKET"
    try:
        stop_side = str(meta.get('stop_side') or '').upper()
        if stop_side not in ("BUY", "SELL"):
            stop_side = None
    except Exception:
        stop_side = None
    if not stop_side:
        return meta

    resp_new = None
    create_err = None
    try:
        client_oid = _unique_client_order_id("stp")
        resp_new = create_conditional_order(
            symbol=symbol,
            side=stop_side,
            order_type=order_type,
            quantity=float(qty2_new),
            stop_price=float(trigger_px),
            client_oid=client_oid,
            reduce_only=False,
            position_side='BOTH',
        )
    except Exception as _ne:
        create_err = _ne

    new_oid = None
    try:
        if isinstance(resp_new, dict):
            new_oid = resp_new.get('orderId') or resp_new.get('algoId')
    except Exception:
        new_oid = None
    if not new_oid:
        # Try to restore the original ENTRY2 order size if we already canceled it.
        try:
            if old_qty2 and float(old_qty2) > 0:
                client_oid = _unique_client_order_id("stp")
                resp_restore = create_conditional_order(
                    symbol=symbol,
                    side=stop_side,
                    order_type=order_type,
                    quantity=float(old_qty2),
                    stop_price=float(trigger_px),
                    client_oid=client_oid,
                    reduce_only=False,
                    position_side='BOTH',
                )
                restore_oid = None
                try:
                    if isinstance(resp_restore, dict):
                        restore_oid = resp_restore.get('orderId') or resp_restore.get('algoId')
                except Exception:
                    restore_oid = None
                if restore_oid:
                    try:
                        with orders_lock:
                            active_orders[symbol] = restore_oid
                            pending_meta[symbol] = meta
                    except Exception:
                        pass
                    try:
                        log_message(
                            f"⚠️ [SIZE ADJUST] {symbol}: resize failed ({create_err}), restored ENTRY2 qty={old_qty2} "
                            f"oid {tracked_oid}->{restore_oid}"
                        )
                    except Exception:
                        pass
                    return meta
        except Exception:
            pass
        try:
            log_message(f"⚠️ [SIZE ADJUST] {symbol}: resize failed and restore failed ({create_err}); ENTRY2 may be missing.")
        except Exception:
            pass
        return meta

    # Persist updated plan back into pending_meta / active_orders
    try:
        meta['quantity'] = float(qty2_new)
        meta['entry2_qty'] = float(qty2_new)
        meta['entry1_qty'] = float(q1)
        meta['quantity_total'] = float(qty_total_new)
        meta['stop_pct_fill'] = float(stop_pct_fill)
        meta['stop_pct_plan'] = float(stop_pct_plan) if stop_pct_plan is not None else None
        meta['stopmap_mult_fill'] = float(tgt_mult_fill)
        meta['stopmap_mult_plan'] = float(tgt_mult_plan) if tgt_mult_plan is not None else None
        meta['entry2_resized'] = True
    except Exception:
        pass
    try:
        with orders_lock:
            active_orders[symbol] = new_oid
            pending_meta[symbol] = meta
    except Exception:
        pass

    try:
        sp_plan_disp = f"{float(stop_pct_plan):.3%}" if stop_pct_plan is not None else "?"
        sp_fill_disp = f"{float(stop_pct_fill):.3%}" if stop_pct_fill is not None else "?"
        mp_disp = f"{float(tgt_mult_plan):.2f}" if tgt_mult_plan is not None else "?"
        mf_disp = f"{float(tgt_mult_fill):.2f}" if tgt_mult_fill is not None else "?"
        log_message(
            f"[SIZE ADJUST] {symbol} stop {sp_plan_disp}->{sp_fill_disp} mult {mp_disp}->{mf_disp} "
            f"qty2 {old_qty2}->{qty2_new} total {old_total}->{qty_total_new} oid {tracked_oid}->{new_oid}"
        )
    except Exception:
        pass
    return meta


def pos_clear(symbol):
    try:
        with positions_lock:
            open_positions.pop(symbol, None)
    except Exception:
        pass
    try:
        _pos_event_mark_closed(symbol)
    except Exception:
        pass


def cleanup_position(symbol, sl_order_id=None, reason=""):
    try:
        cancel_all_tps(symbol)
    except Exception:
        try:
            log_message(f"⚠️ Не вдалося скасувати TP для {symbol} при очищенні.")
        except Exception:
            pass
    try:
        with tp_lock:
            tp_orders.pop(symbol, None)
            pending_tps.pop(symbol, None)
    except Exception:
        pass
    # Stop monitoring/canceling stale pending entry orders after the position is closed.
    # Otherwise monitor_order_distance can keep logging for a symbol with no position.
    try:
        pending_oid = None
        entry1_oid = None
        with orders_lock:
            pending_oid = active_orders.get(symbol)
            try:
                pm = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                if isinstance(pm, dict):
                    entry1_oid = pm.get("entry1_order_id")
            except Exception:
                entry1_oid = None
        if pending_oid:
            try:
                signed_request(client.futures_cancel_order, symbol=symbol, orderId=pending_oid)
            except Exception:
                try:
                    cancel_conditional_order(symbol, pending_oid)
                except Exception:
                    pass
        if entry1_oid and (not pending_oid or str(entry1_oid) != str(pending_oid)):
            try:
                signed_request(client.futures_cancel_order, symbol=symbol, orderId=entry1_oid)
            except Exception:
                try:
                    cancel_conditional_order(symbol, entry1_oid)
                except Exception:
                    pass
        with orders_lock:
            active_orders.pop(symbol, None)
            pending_meta.pop(symbol, None)
    except Exception:
        pass
    try:
        if 'relocator' in globals() and relocator is not None:
            relocator.unregister_pending_order(symbol)
    except Exception:
        pass
    try:
        oid = sl_order_id
        if oid is None:
            pos = pos_get(symbol)
            if pos:
                oid = pos.get('sl_order_id')
        if oid:
            signed_request(client.futures_cancel_order, symbol=symbol, orderId=oid)
    except Exception as e:
        try:
            log_message(f"⚠️ Не вдалося скасувати SL для {symbol}: {e}")
        except Exception:
            pass
    try:
        purge_closeposition_sl_markers(symbol)
    except Exception:
        pass
    try:
        pos_clear(symbol)
    except Exception:
        pass
    try:
        if gui_bus is not None:
            try:
                sym = (symbol or "").upper()
            except Exception:
                sym = symbol
            if sym:
                ob_snapshot = None
                try:
                    with orderbook_lock:
                        ob_snapshot = orderbook_state.get(sym)
                except Exception:
                    ob_snapshot = None
                if ob_snapshot is not None:
                    gui_bus.orderbook_signal.emit(ob_snapshot)
    except Exception:
        pass
    try:
        trailing_suppressed_until[symbol] = time.time() + TRAIL_SUPPRESS_AFTER_CLOSE
    except Exception:
        pass
    try:
        unsubscribe_price(symbol)
    except Exception:
        pass
    if reason:
        pass


def rest_sync_position(symbol, reason="REST_CHECK"):
    """Легка REST-звірка позиції після подій WS."""
    try:
        prev = pos_get(symbol) or {}
        exch_amt, exch_entry = get_exchange_position(symbol)
        qty = abs(exch_amt)
        if qty <= eps:
            try:
                if prev:
                    log_message(f"ℹ️ REST-звірка: позиція відсутня для {symbol} ({reason})")
                    try:
                        # Спочатку звук закриття, потім логіка балансу/PnL
                        try:
                            try:
                                entry_price = float(prev.get('entry_price') or 0.0)
                            except Exception:
                                entry_price = 0.0
                            try:
                                side_state = _norm_side(prev.get('side'))
                            except Exception:
                                side_state = None
                            trade_id = None
                            try:
                                trade_id = _chart_trade_current_id(symbol)
                            except Exception:
                                trade_id = None
                            entry_event = None
                            try:
                                entry_event = _chart_trade_find_entry_event(symbol, trade_id)
                            except Exception:
                                entry_event = None
                            if (not entry_price) and entry_event:
                                try:
                                    entry_price = float(entry_event.get('price') or 0.0)
                                except Exception:
                                    entry_price = 0.0
                            if not side_state and entry_event:
                                ev_side = str(entry_event.get('side') or '').upper()
                                if ev_side == 'BUY':
                                    side_state = 'LONG'
                                elif ev_side == 'SELL':
                                    side_state = 'SHORT'
                            entry_ts = None
                            if entry_event:
                                try:
                                    entry_ts = float(entry_event.get('ts') or 0.0) or None
                                except Exception:
                                    entry_ts = None
                            with last_close_entry_lock:
                                last_close_entry_cache[symbol] = {
                                    'entry_price': entry_price,
                                    'side': side_state,
                                    'trade_id': trade_id,
                                    'entry_ts': entry_ts,
                                }
                        except Exception:
                            pass
                        play_trade_close_alert_once(symbol, prev.get('side'), prev.get('qty'))
                    except Exception:
                        pass
                    try:
                        pnl_trade_delta = None
                        try:
                            start_ts = None
                            try:
                                start_ts = float((prev or {}).get('trail_start_ts') or 0.0)
                            except Exception:
                                start_ts = None
                            if start_ts and start_ts > 0:
                                bd = _get_futures_pnl_window_breakdown(
                                    symbol,
                                    start_ts,
                                    max_wait_s=2.5,
                                )
                                if bd and bd.get('net_pnl') is not None:
                                    pnl_trade_delta = float(bd.get('net_pnl') or 0.0)
                        except Exception:
                            pnl_trade_delta = None
                        if pnl_trade_delta is not None:
                            safe_on_position_closed_balance_log(symbol, pnl_delta=pnl_trade_delta)
                        else:
                            safe_on_position_closed_balance_log(symbol)
                    except Exception:
                        pass
            except Exception:
                pass
            cleanup_position(symbol, reason=reason)
            return False
        side_state = _norm_side('BUY' if exch_amt > 0 else 'SELL')
        prev_qty = float(prev.get('qty', 0.0) or 0.0)
        # IMPORTANT: never reset max_price/min_price for an already-tracked position,
        # otherwise trailing max/min will "jump backwards" and trailing stops won't trigger.
        try:
            prev_side_state = _norm_side(prev.get('side'))
        except Exception:
            prev_side_state = None
        st = {
            'qty': qty,
            'side': side_state,
            'entry_price': exch_entry,
        }
        same_side = bool(prev_qty > eps and prev_side_state == side_state)
        # Seed extremes only for a fresh position/side flip, or if missing.
        if not same_side:
            if side_state == 'LONG':
                st['max_price'] = exch_entry
            elif side_state == 'SHORT':
                st['min_price'] = exch_entry
        else:
            if side_state == 'LONG':
                if prev.get('max_price') in (None, 0, 0.0, ''):
                    st['max_price'] = exch_entry
            elif side_state == 'SHORT':
                if prev.get('min_price') in (None, 0, 0.0, ''):
                    st['min_price'] = exch_entry
        pos_set(symbol, **st)
        # Dual-entry: if we observe full size via REST, mark completion so trailing isn't gated later.
        try:
            st_now = pos_get(symbol) or {}
            if _to_bool(st_now.get('dual_entry')) and (not _to_bool(st_now.get('dual_entry_complete'))):
                pm_local = None
                try:
                    with orders_lock:
                        pm_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                except Exception:
                    pm_local = None
                try:
                    de_wait, de_plan, _de_cur, _de_tol = _dual_entry_wait_state(symbol, meta=pm_local, qty_current=qty)
                except Exception:
                    de_wait, de_plan = False, None
                if (de_plan is not None and float(de_plan) > 0) and (not de_wait):
                    pos_set(symbol, dual_entry_complete=True)
                    try:
                        ensure_trailing_stop(symbol)
                    except Exception:
                        pass
        except Exception:
            pass
        # Якщо позиція була відсутня локально — згенерувати синтетичний ORDER_TRADE_UPDATE негайно
        try:
            if prev_qty <= eps:
                synthetic = {
                    'e': 'ORDER_TRADE_UPDATE',
                    'o': {
                        's': symbol,
                        'X': 'FILLED',
                        'x': 'TRADE',
                        'S': _side_to_api(side_state),
                        'o': 'MARKET',
                        'ap': exch_entry,
                        'origQty': qty,
                        'ps': 'BOTH',
                        'i': None,
                    }
                }
                _handle_user_message(synthetic)
        except Exception as syn_err:
            try:
                log_message(f"⚠️ Не вдалося синтезувати ORDER_TRADE_UPDATE для {symbol}: {syn_err}")
            except Exception:
                pass
        try:
            subscribe_price(symbol)
        except Exception:
            pass
        try:
            if not prev or abs(float(prev.get('qty', 0.0)) - qty) > eps or float(prev.get('entry_price', 0.0) or 0.0) != float(exch_entry or 0.0):
                log_message(f"ℹ️ REST-звірка: виявлено позицію {symbol} qty={qty} entry={exch_entry} ({reason})")
        except Exception:
            pass
        return True
    except Exception as e:
        try:
            log_message(f"⚠️ REST-звірка не вдалася для {symbol} ({reason}): {e}")
            log_message(traceback.format_exc())
        except Exception:
            pass
        return None


def _unique_client_order_id(prefix):
    try:
        return f"{prefix}_{int(time.time() * 1000)}_{uuid.uuid4().hex[:8]}"
    except Exception:
        return f"{prefix}_{int(time.time() * 1000)}"


# --------------- GPT Advisor helpers ---------------
def _advisor_allowed_keys():
    """Return list of setting keys that the advisor is allowed to change.
    If ADVISOR_ALLOWED_KEYS is defined, restrict to that list strictly.
    """
    try:
        forbidden = set(globals().get('ADVISOR_FORBIDDEN_KEYS') or set())
        wl = list(globals().get('ADVISOR_ALLOWED_KEYS') or [])
        if wl:
            keys = [k for k in wl if (k not in forbidden) and (k in globals())]
        else:
            keys = []
            for k in _iter_setting_keys():
                if k and k not in forbidden:
                    keys.append(k)
        # Hide keys from prompt
        hide = globals().get('ADVISOR_HIDE_KEYS', set()) or set()
        keys = [k for k in keys if k not in hide]
        # Apply per-key overrides if provided
        amap = globals().get('ADVISOR_ALLOWED_MAP') or {}
        if isinstance(amap, dict) and len(amap) > 0:
            keys = [k for k in keys if bool(amap.get(k, True))]
        return keys
    except Exception:
        return []


def get_settings_glossary(allowed_keys=None):
    """Return a compact glossary with types, ranges, and human meaning for keys.
    Only includes keys in allowed_keys if provided.
    """
    base = {
        # Core lists
        'TOP_N_GROWTH': {'type': 'int', 'desc': 'Кількість монет у топі за зростанням (кандидати на вхід).'},
        'TOP_N_FALL': {'type': 'int', 'desc': 'Кількість монет у топі за падінням.'},
        'TOP_N_VOLUME': {
            'type': 'int',
            'desc': 'Кількість монет у топі за обсягом 24h.',
            'note': 'Ефективний ліміт кандидатів = min(TOP_N_GROWTH, TOP_N_VOLUME, TOP_N_NATR).'
        },
        'TOP_N_NATR': {
            'type': 'int',
            'desc': 'Кількість монет у топі за волатильністю (NATR).',
            'note': 'Збільшення лише одного з трьох ключів вище інших не збільшить вибірку.'
        },
        'TOLERANCE': {'type': 'float', 'min': 0.0005, 'max': 0.01, 'desc': 'Допустиме відхилення ціни від рівня для торкання/входу.'},
        'LEVEL_WINDOW': {'type': 'int', 'desc': 'Скільки останніх барів використовувати для пошуку горизонтальних рівнів.'},
        # Risk/Reward
        'RR_MIN': {'type': 'float', 'min': 0.3, 'max': 1.5, 'desc': 'Мінімальний прийнятний RR(Ревард відносно задано трейлінг стоп лосу) для реальних пробоїв.'},
        'RR_MAX': {'type': 'float', 'min': 1.0, 'max': 8.0, 'desc': 'Максимальний RR(Ревард відносно задано трейлінг стоп лосу) для реальних пробоїв.'},
        # Trailing
        'TRAILING_NATR_FACTOR': {'type': 'float', 'desc': 'Множник NATR для розрахунку трейлінгу.'},
        'TRAILING_MIN_PERCENT': {'type': 'float', 'min': 0.2, 'max': 2.5, 'unit': '%', 'desc': 'Нижня межа трейлінгу.'},
        'TRAILING_MAX_PERCENT': {'type': 'float', 'min': 0.4, 'max': 3.0, 'unit': '%', 'desc': 'Верхня межа трейлінгу.'},
        'FALLBACK_TRAILING_PERCENT': {'type': 'float', 'unit': '%', 'desc': 'Запасний трейлінг %, якщо NATR недоступний.'},
        # Take-profit
        'TP_PARTS': {'type': 'int', 'desc': 'Кількість частин для поетапного TP.'},
        'TP_WEIGHT_POWER': {'type': 'float', 'desc': 'Степінь розподілу ваги TP (негативні значення віддають перевагу раннім TP).'},
        # Temp widen / monitor
        'TEMP_WIDEN_THRESHOLD_PCT': {'type': 'float', 'unit': '%', 'desc': 'Поріг прибутку для тимчасової зміни трейлінгу.'},
        'TEMP_WIDEN_AMOUNT_PCT': {'type': 'float', 'unit': '%', 'desc': 'Зміна трейлінгу під час тимчасового коригування (дельта %).'},
        'MONITOR_INTERVAL': {'type': 'int', 'unit': 'sec', 'desc': 'Інтервал моніторингу ордерів/позицій у секундах.'},
        # Stop buffers / dynamic distances
        'MIN_STOP_BUFFER_PCT': {'type': 'float', 'unit': '%', 'desc': 'Мінімальна відстань для стопа від рівня (real).'},
        'DYN_MIN_LEVEL_DISTANCE': {'type': 'float', 'unit': '%', 'desc': 'Мінімальна відстань ціни до рівня (динаміка).'},
        'DYN_MAX_LEVEL_DISTANCE': {'type': 'float', 'unit': '%', 'desc': 'Максимальна відстань ціни до рівня (динаміка).'},
        # Filters / multipliers
        'VOLUME_24H_THRESHOLD': {'type': 'float', 'unit': 'USDT', 'desc': 'Мінімальний обсяг 24h для символу.'},
        'AMERICA_MULTI_MIN': {'type': 'float', 'desc': 'Мінімальне плече для сесії Америка.'},
        'AMERICA_MULTI_MAX': {'type': 'float', 'desc': 'Максимальне плече для сесії Америка.'},
        'ASIA_MULTI_MIN': {'type': 'float', 'desc': 'Мінімальне плече для сесії Азія.'},
        'ASIA_MULTI_MAX': {'type': 'float', 'desc': 'Максимальне плече для сесії Азія.'},
        'EUROPE_MULTI_MIN': {'type': 'float', 'desc': 'Мінімальне плече для сесії Європа.'},
        'EUROPE_MULTI_MAX': {'type': 'float', 'desc': 'Максимальне плече для сесії Європа.'},
        'RESERVE_MULTI_MIN': {'type': 'float', 'desc': 'Мінімальне плече резервного режиму.'},
        'RESERVE_MULTI_MAX': {'type': 'float', 'desc': 'Максимальне плече резервного режиму.'},
        # Hard SL
        'HARD_SL_OFFSET_PCT': {'type': 'float', 'desc': 'Risk anchor for position sizing (legacy hard-SL offset fraction).'},
        'STOP_LOSS_MIN_PCT': {'type': 'float', 'desc': 'Min hard SL distance (fraction of entry, e.g. 0.002 = 0.2%).'},
        'STOP_LOSS_MAX_PCT': {'type': 'float', 'desc': 'Max hard SL distance (fraction of entry, e.g. 0.04 = 4%).'},
        # Dual entry
        # Position notional clamps
        'MIN_POS_NOTIONAL_MULT': {'type': 'float', 'desc': 'Minimum position notional = balance * x (0 disables).'},
        'MAX_POS_NOTIONAL_MULT': {'type': 'float', 'desc': 'Maximum position notional = balance * x (0 disables).'},
        # For clarity
        'MIN_INTERVAL': {
            'type': 'int', 'min': 2, 'max': 120, 'unit': 'bars',
            'desc': 'Кількість барів між торканнями при побудові рівнів (не хвилини/час).'
        },
        'MIN_LEVEL_FRESHNESS_BARS': {
            'type': 'int', 'min': 0, 'max': 300, 'unit': 'bars',
            'desc': 'Мін. 5m барів від останнього торкання рівня до поточної ціни (0 = вимкнено).'
        },
    }
    if not allowed_keys:
        return base
    return {k: v for k, v in base.items() if k in set(allowed_keys)}

def _current_settings_snapshot():
    """Collect current settings as a dict (excluding secrets/paths)."""
    snap = {}
    try:
        for k in _advisor_allowed_keys():
            if k in globals():
                snap[k] = globals().get(k)
    except Exception:
        pass
    # Remove hidden keys from snapshot so GPT does not see them
    try:
        hide = globals().get('ADVISOR_HIDE_KEYS', set()) or set()
        for hk in list(hide):
            snap.pop(hk, None)
    except Exception:
        pass
    return snap


def _record_settings_history(before: dict, after: dict, changed: dict, stats=None):
    """Append settings change snapshot (before/after) for advisor context."""
    if not isinstance(before, dict) or not isinstance(after, dict):
        return
    try:
        entry = {
            'ts': time.time(),
            'before': before,
            'after': after,
            'changed': {k: {'from': before.get(k), 'to': after.get(k)} for k in (changed or {}).keys()},
            'runtime': stats if isinstance(stats, dict) else _runtime_stats_snapshot()
        }
        with settings_history_lock:
            settings_history.append(entry)
            if len(settings_history) > SETTINGS_HISTORY_LIMIT:
                settings_history[:] = settings_history[-SETTINGS_HISTORY_LIMIT:]
        save_settings_history_to_file()
    except Exception:
        pass


def _get_settings_history_tail(n=5):
    try:
        with settings_history_lock:
            return list(settings_history[-int(n):])
    except Exception:
        return []


def _runtime_stats_snapshot(max_points=200):
    """Collect lightweight runtime stats for the advisor."""
    try:
        with equity_history_lock:
            eq = list(equity_history[-max_points:])
    except Exception:
        eq = []
    eq_balances = [p.get('balance', 0.0) for p in eq if isinstance(p, dict)]
    eq_pnls = [p.get('pnl', 0.0) for p in eq if isinstance(p, dict)]
    start_bal = eq_balances[0] if eq_balances else None
    last_bal = eq_balances[-1] if eq_balances else None
    eq_change_pct = None
    try:
        if start_bal and last_bal and start_bal != 0:
            eq_change_pct = (last_bal - start_bal) / start_bal * 100.0
    except Exception:
        eq_change_pct = None
    with positions_lock:
        pos_count = len(open_positions)
        open_pos_summary = {}
        for s, pos in open_positions.items():
            try:
                open_pos_summary[s] = {
                    'qty': pos.get('qty'),
                    'side': pos.get('side'),
                    'entry': pos.get('entry_price'),
                    'trailing_percent': pos.get('trailing_percent', pos.get('base_trailing_percent'))
                }
            except Exception:
                continue
    # Trade stats summary
    recent_trades = list(closed_trades)[-50:]
    wins = [t for t in recent_trades if t.get('pnl_abs', 0.0) > 0]
    losses = [t for t in recent_trades if t.get('pnl_abs', 0.0) < 0]
    winrate = (len(wins) / len(recent_trades) * 100.0) if recent_trades else None
    avg_win = (sum(t.get('pnl_abs', 0.0) for t in wins) / len(wins)) if wins else None
    avg_loss = (sum(abs(t.get('pnl_abs', 0.0)) for t in losses) / len(losses)) if losses else None
    profit_factor = (sum(t.get('pnl_abs', 0.0) for t in wins) / max(1e-9, sum(abs(t.get('pnl_abs', 0.0)) for t in losses))) if wins and losses else None
    hold_min = [t.get('hold_min') for t in recent_trades if isinstance(t.get('hold_min'), (int, float))]
    avg_hold_min = (sum(hold_min) / len(hold_min)) if hold_min else None

    # Advisor suggestions summary
    sugg = list(advisor_suggestions)[-10:]
    last_sugg_keys = []
    try:
        if sugg:
            last_sugg = sugg[-1]
            ch = last_sugg.get('changes') if isinstance(last_sugg, dict) else {}
            if isinstance(ch, dict):
                last_sugg_keys = list(ch.keys())
    except Exception:
        last_sugg_keys = []

    return {
        'equity_points': len(eq_balances),
        'equity_change_pct': eq_change_pct,
        'pnl_samples': eq_pnls[-20:],
        'open_positions_count': pos_count,
        'open_positions': open_pos_summary,
        'trade_stats': {
            'count_last50': len(recent_trades),
            'winrate_pct_last50': winrate,
            'avg_win_usdt': avg_win,
            'avg_loss_usdt': avg_loss,
            'profit_factor_last50': profit_factor,
            'avg_hold_min_last50': avg_hold_min,
        },
        'advisor': {
            'suggestions_total': len(advisor_suggestions),
            'last_changes_keys': last_sugg_keys
        },
        'timestamp': time.time(),
    }


def advisor_gate_allows_request():
    """Return True if GPT advisor is allowed to send a request now.
    Gate pauses requests based on recent performance/idle/drawdown, but never blocks manual Apply.
    """
    return True


def _extract_json_block(text):
    """Best-effort extraction of the first JSON object from text."""
    if not text:
        return None
    try:
        # try direct
        return json.loads(text)
    except Exception:
        pass
    # search for first {...} block
    try:
        start = text.find('{')
        end = text.rfind('}')
        if start != -1 and end != -1 and end > start:
            candidate = text[start:end+1]
            return json.loads(candidate)
    except Exception:
        return None
    return None


def _get_recent_logs_text(max_lines=200, pattern=None, unique=True):
    try:
        n = int(max_lines) if max_lines else 200
    except Exception:
        n = 200
    try:
        lines = list(recent_logs)
        if not lines:
            return ""
        # take most recent first
        lines = lines[-n:]
        if pattern:
            try:
                rx = re.compile(pattern, re.IGNORECASE)
                lines = [ln for ln in lines if rx.search(ln)]
            except Exception:
                # if regex fails, fall back to substring contains for safety
                key = str(pattern)
                lines = [ln for ln in lines if key in ln]
        if unique:
            seen = set()
            filtered = []
            for ln in reversed(lines):  # keep latest instance
                if ln not in seen:
                    seen.add(ln)
                    filtered.append(ln)
            lines = list(reversed(filtered))
        return "\n".join(lines[-n:])
    except Exception:
        return ""


def _compose_chat_url(base_url: str) -> str:
    """Return OpenAI-compatible chat completions URL.
    If base_url lacks '/vN' suffix, append '/v1' automatically.
    """
    try:
        u = (base_url or '').strip()
        if not u:
            return '/v1/chat/completions'
        u = u.rstrip('/')
        # if ends with /v<number>, keep; else append /v1
        try:
            if not re.search(r"/v\d+$", u):
                u = u + '/v1'
        except Exception:
            if not u.endswith('/v1'):
                u = u + '/v1'
        return u + '/chat/completions'
    except Exception:
        return '/v1/chat/completions'


def gpt_chat_completion(messages, model=None, api_key=None, base_url=None, timeout=None):
    try:
        # honor backoff window if any
        global _gpt_backoff_until, _gpt_backoff_sec
        now = time.time()
        try:
            if now < float(_gpt_backoff_until or 0):
                try:
                    log_message(f"?? GPT backoff active for {int(_gpt_backoff_until - now)}s")
                except Exception:
                    pass
                return None
        except Exception:
            pass
        if api_key is None:
            api_key = globals().get('GPT_API_KEY')
        if not api_key:
            return None
        if base_url is None:
            base_url = globals().get('GPT_BASE_URL') or 'https://api.openai.com/v1'
        if model is None:
            model = globals().get('GPT_MODEL') or 'gpt-4o-mini'
        url = _compose_chat_url(base_url)
        if timeout is None:
            try:
                timeout = int(globals().get('GPT_TIMEOUT_SEC', 20) or 20)
            except Exception:
                timeout = 20
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
        payload = {
            'model': model,
            'messages': messages,
            'temperature': 0.3,
            'max_tokens': int(globals().get('GPT_MAX_TOKENS', 256) or 256),
        }
        # Decide response_format based on setting and provider
        if globals().get('GPT_FORCE_JSON', True):
            try:
                # Heuristic: LM Studio prefers 'json_schema', OpenAI 'json_object'
                rf_type = 'json_object'
                bu = str(base_url or '')
                if ('127.0.0.1' in bu) or ('localhost' in bu) or ('lmstudio' in bu.lower()):
                    rf_type = 'json_schema'
                if rf_type == 'json_schema':
                    payload['response_format'] = {
                        'type': 'json_schema',
                        'json_schema': {
                            'name': 'advisor',
                            'schema': {
                                'type': 'object',
                                'properties': {
                                    'rationale': {'type': 'string'},
                                    'changes': {'type': 'object'}
                                },
                                'required': ['changes'],
                                'additionalProperties': True
                            }
                        }
                    }
                else:
                    payload['response_format'] = {'type': 'json_object'}
            except Exception:
                pass
        r = requests.post(url, headers=headers, data=json.dumps(payload), timeout=timeout)
        if r.status_code >= 400:
            # Retry once without response_format if server doesn't support
            if r.status_code == 400 and 'response_format' in payload:
                try:
                    pf = payload.pop('response_format', None)
                    r = requests.post(url, headers=headers, data=json.dumps(payload), timeout=timeout)
                except Exception:
                    pass
                # If retry succeeded -> go to success path
                if r.status_code < 400:
                    data = r.json()
                    try:
                        _gpt_backoff_sec = globals().get('GPT_BACKOFF_INITIAL', 60)
                        _gpt_backoff_until = 0.0
                        return data['choices'][0]['message']['content']
                    except Exception:
                        return None
            # Rate limit / quota
            if r.status_code == 429:
                retry_after = None
                try:
                    ra = r.headers.get('Retry-After')
                    retry_after = int(float(ra)) if ra else None
                except Exception:
                    retry_after = None
                if retry_after is None:
                    # exponential backoff with cap
                    try:
                        base = float(globals().get('GPT_BACKOFF_INITIAL', 60) or 60)
                    except Exception:
                        base = 60
                    try:
                        cap = float(globals().get('GPT_BACKOFF_MAX', 3600) or 3600)
                    except Exception:
                        cap = 3600
                    _gpt_backoff_sec = min((_gpt_backoff_sec or base) * 2, cap)
                    retry_after = int(_gpt_backoff_sec)
                _gpt_backoff_until = time.time() + max(5, retry_after)
            try:
                log_message(f"?? GPT API error {r.status_code}: {r.text[:120]}")
            except Exception:
                pass
            return None
        data = r.json()
        try:
            # reset backoff on success
            _gpt_backoff_sec = globals().get('GPT_BACKOFF_INITIAL', 60)
            _gpt_backoff_until = 0.0
            return data['choices'][0]['message']['content']
        except Exception:
            return None
    except Exception as e:
        try:
            log_message(f"?? GPT call failed: {e}")
        except Exception:
            pass
        return None


def make_gpt_recommendation(user_hint: str = None):
    """Build prompt, call GPT, return dict with changes and rationale."""
    try:
        allowed = _advisor_allowed_keys()
        settings_snapshot = _current_settings_snapshot()
        stats_snapshot = _runtime_stats_snapshot()
        history_compact = []
        # Provide a compact glossary so the model understands types/units/ranges
        glossary = {}
        try:
            glossary = get_settings_glossary(allowed) if 'get_settings_glossary' in globals() else {}
        except Exception:
            glossary = {}

        def _compact_glossary(gl: dict):
            if not isinstance(gl, dict):
                return {}
            if not globals().get('GPT_COMPACT_GLOSSARY', True):
                return gl
            out = {}
            for k, v in gl.items():
                if isinstance(v, dict):
                    out[k] = {
                        't': v.get('type'),
                        'min': v.get('min'),
                        'max': v.get('max'),
                        'u': v.get('unit'),
                        'd': v.get('desc'),
                        'n': v.get('note'),
                    }
                else:
                    out[k] = v
            return out

        def _compact_stats(st: dict):
            try:
                tr = (st or {}).get('trade_stats') or {}
                return {
                    'equity_change_pct': (st or {}).get('equity_change_pct'),
                    'open_positions_count': (st or {}).get('open_positions_count'),
                    'trade_stats': {
                        'count_last50': tr.get('count_last50'),
                        'winrate_pct_last50': tr.get('winrate_pct_last50'),
                        'profit_factor_last50': tr.get('profit_factor_last50'),
                        'avg_hold_min_last50': tr.get('avg_hold_min_last50'),
                    },
                    'timestamp': (st or {}).get('timestamp')
                }
            except Exception:
                return st
        def _compact_history(hist_list):
            out = []
            for item in hist_list or []:
                try:
                    changed_keys = list((item.get('changed') or {}).keys())
                    out.append({
                        'ts': item.get('ts'),
                        'changed': item.get('changed'),
                        'before': {k: (item.get('before') or {}).get(k) for k in changed_keys},
                        'after': {k: (item.get('after') or {}).get(k) for k in changed_keys},
                        'runtime': (item.get('runtime') or {}).get('trade_stats')
                    })
                except Exception:
                    continue
            return out

        sys_msg = {
            'role': 'system',
            'content': (
                'You are an algorithmic trading settings advisor. '
                'Use provided history of past setting changes and runtime stats. '
                'Reply ONLY with concise JSON. Rationale must be in Ukrainian.'
            )
        }
        glossary_compact = _compact_glossary(glossary)
        stats_compact = _compact_stats(stats_snapshot)
        try:
            history_compact = _compact_history(_get_settings_history_tail(5))
        except Exception:
            history_compact = []
        core = (
            "Given current settings and runtime stats, propose tuned settings. "
            "Respond ONLY with valid JSON object: {\n"
            "  \"rationale\": string (<= 400 chars, Ukrainian),\n"
            "  \"settings\": { key: value }  // MUST include ALL keys from allowed_keys, even if unchanged\n"
            "}. No extra text.\n\n"
            f"allowed_keys={json.dumps(allowed)}\n"
            f"current_settings={json.dumps(settings_snapshot)}\n"
            f"runtime_stats={json.dumps(stats_compact)}\n"
            f"settings_history_tail={json.dumps(history_compact, ensure_ascii=False)}\n"
            "language=uk\n"
            f"hidden_keys={json.dumps(list(globals().get('ADVISOR_HIDE_KEYS', set()) or set()))}\n"
            "Do NOT propose changes to hidden_keys.\n"
            "Include ALL allowed_keys under 'settings'; if a key should not change, repeat its current value.\n"
            "Do not add any keys not in allowed_keys.\n"
            "Врахуй settings_history_tail: не роби маятникових змін; якщо треба скасувати попереднє налаштування, поясни чому.\n"
            "Фокусуйся на невеликій кількості змін із чітким впливом.\n"
            "Взаємозалежність: ефективна кількість кандидатів = min(TOP_N_GROWTH, TOP_N_VOLUME, TOP_N_NATR).\n"
            "Підвищення лише одного з трьох ключів вище інших не збільшить вибірку — узгоджуйте їх разом.\n"
            "IMPORTANT: MIN_INTERVAL = number of bars between touches for building horizontal levels (not minutes).\n"
        )
        # Append glossary if there is room
        user_content = core
        # Add instruction and last closed trade snapshot for targeted analysis
        try:
            if closed_trades:
                lt = list(closed_trades)[-1]
                if isinstance(lt, dict):
                    last_trade = {
                        'symbol': lt.get('symbol'),
                        'side': lt.get('side'),
                        'entry': lt.get('entry'),
                        'exit': lt.get('exit'),
                        'pnl_abs': lt.get('pnl_abs'),
                        'pnl_pct': lt.get('pnl_pct'),
                        'hold_min': lt.get('hold_min'),
                        'ts': lt.get('ts'),
                        'reason': lt.get('reason')
                    }
                    user_content += "analyze_last_closed_trade=true\n"
                    try:
                        user_content += f"last_closed_trade={json.dumps(last_trade, ensure_ascii=False)}\n"
                    except Exception:
                        pass
        except Exception:
            pass
        try:
            max_chars = int(globals().get('GPT_PROMPT_MAX_CHARS', 8000) or 8000)
        except Exception:
            max_chars = 8000
        gloss_line = f"settings_glossary={json.dumps(glossary_compact)}\n"
        if len(user_content) + len(gloss_line) <= max_chars:
            user_content += gloss_line
        user_msg = {'role': 'user', 'content': user_content}
        # optionally include filtered recent logs
        try:
            if globals().get('GPT_INCLUDE_LOGS'):
                log_lines = int(globals().get('GPT_RECENT_LOG_LINES', 80) or 80)
                log_filter = globals().get('GPT_LOG_FILTER')
                logs_block = _get_recent_logs_text(log_lines, pattern=log_filter)
                if logs_block:
                    user_msg['content'] += f"recent_logs=\n{logs_block}\n"
        except Exception:
            pass
        messages = [sys_msg, user_msg]
        # Optional user hint from UI
        if user_hint:
            try:
                hint_txt = str(user_hint).strip()
                if hint_txt:
                    messages.append({'role': 'user', 'content': f'user_hint: {hint_txt[:2000]}'})
            except Exception:
                pass
        content = gpt_chat_completion(messages)
        if not content:
            return None
        obj = _extract_json_block(content)
        if not isinstance(obj, dict):
            return None
        # Accept either full 'settings' or classic 'changes'
        proposed_full = obj.get('settings') if isinstance(obj.get('settings'), dict) else None
        if proposed_full:
            proposed_filtered = {k: v for k, v in proposed_full.items() if k in allowed}
            # compute diff vs current snapshot
            diff = {}
            try:
                for k, v in proposed_filtered.items():
                    if settings_snapshot.get(k) != v:
                        diff[k] = v
            except Exception:
                diff = proposed_filtered
            return {
                'rationale': obj.get('rationale') or '',
                'settings': proposed_filtered,
                'changes': diff
            }
        # fallback to 'changes'
        changes = obj.get('changes') or {}
        filtered = {k: v for k, v in changes.items() if k in allowed}
        # also construct a full settings echo for UI convenience
        full_echo = dict(settings_snapshot)
        full_echo.update(filtered)
        full_echo = {k: full_echo.get(k) for k in allowed}
        return {
            'rationale': obj.get('rationale') or '',
            'settings': full_echo,
            'changes': filtered
        }
    except Exception:
        return None


def _as_float(val):
    try:
        if isinstance(val, str):
            v = val.strip().replace('%', '')
            return float(v)
        return float(val)
    except Exception:
        return None


def _as_int(val):
    try:
        if isinstance(val, str):
            v = val.strip()
            return int(float(v))
        return int(val)
    except Exception:
        return None


def _as_bool(val):
    if isinstance(val, bool):
        return val
    if isinstance(val, (int, float)):
        return val != 0
    if isinstance(val, str):
        return val.strip().lower() in {"1", "true", "t", "yes", "y", "on"}
    return None


def _specs():
    """Validation specs: type + min/max + special rules."""
    return {
        # Core
        'MIN_TOUCHES': {'type': 'int', 'min': 2, 'max': 5},
        # MIN_INTERVAL = count of bars between touches (not minutes/time)
        'MIN_INTERVAL': {'type': 'int', 'min': 2, 'max': 120},  # bars between touches
        'MIN_LEVEL_FRESHNESS_BARS': {'type': 'int', 'min': 0, 'max': 300},
        'TOLERANCE': {'type': 'float', 'min': 0.0005, 'max': 0.01},
        'LEVEL_WINDOW': {'type': 'int', 'min': 50, 'max': 1000},
        # Trailing (percent values)
        'TRAILING_MIN_PERCENT': {'type': 'float', 'min': 0.2, 'max': 2.5},
        'TRAILING_MAX_PERCENT': {'type': 'float', 'min': 0.4, 'max': 3.0},
        # RR
        'RR_MIN': {'type': 'float', 'min': 0.3, 'max': 1.5},
        'RR_MAX': {'type': 'float', 'min': 1.0, 'max': 8.0},
        # Hard SL bounds (fractions of entry)
        'STOP_LOSS_MIN_PCT': {'type': 'float', 'min': 0.0005, 'max': 0.2},
        'STOP_LOSS_MAX_PCT': {'type': 'float', 'min': 0.0005, 'max': 0.2},
        # Misc
        'CHART_CANDLE_LIMIT': {'type': 'int', 'min': 20, 'max': 5000},
    }


def _validate_and_coerce_changes(changes: dict):
    """Return (accepted, rejected) after coercion and range checks.
    Also enforce some cross-parameter constraints (e.g., RR_MIN<=RR_MAX)."""
    accepted = {}
    rejected = {}
    specs = _specs()
    try:
        locked_keys = set(globals().get("SETTINGS_LOCKED_KEYS") or [])
    except Exception:
        locked_keys = set()
    for k, v in (changes or {}).items():
        try:
            if k in locked_keys:
                rejected[k] = 'locked (code default)'
                continue
            # Explicitly disabled key
            if k == 'TRAILING_STOP_PERCENT':
                rejected[k] = 'disabled: use TRAILING_MIN_PERCENT/TRAILING_MAX_PERCENT'
                continue
            spec = specs.get(k)
            if not spec:
                # accept unknown safe-looking primitives
                accepted[k] = v
                continue
            t = spec.get('type')
            if t == 'int':
                vv = _as_int(v)
            elif t == 'float':
                vv = _as_float(v)
            elif t == 'bool':
                vv = _as_bool(v)
            else:
                vv = v
            if vv is None:
                rejected[k] = f'cannot coerce value {v!r} to {t}'
                continue
            lo = spec.get('min')
            hi = spec.get('max')
            if isinstance(vv, (int, float)) and lo is not None and vv < lo:
                vv = lo
            if isinstance(vv, (int, float)) and hi is not None and vv > hi:
                vv = hi
            accepted[k] = vv
        except Exception as e:
            rejected[k] = f'error: {e}'
    try:
        if 'RR_MIN' in accepted and 'RR_MAX' in accepted and accepted['RR_MIN'] > accepted['RR_MAX']:
            accepted['RR_MAX'] = max(accepted['RR_MIN'], _as_float(accepted['RR_MAX']))
    except Exception:
        pass
    try:
        if 'STOP_LOSS_MIN_PCT' in accepted and 'STOP_LOSS_MAX_PCT' in accepted:
            if accepted['STOP_LOSS_MIN_PCT'] > accepted['STOP_LOSS_MAX_PCT']:
                accepted['STOP_LOSS_MAX_PCT'] = float(accepted['STOP_LOSS_MIN_PCT'])
    except Exception:
        pass
    # Informative note: TOP_N_GROWTH limited by other lists
    try:
        tng = accepted.get('TOP_N_GROWTH', globals().get('TOP_N_GROWTH'))
        tnv = accepted.get('TOP_N_VOLUME', globals().get('TOP_N_VOLUME'))
        tnn = accepted.get('TOP_N_NATR', globals().get('TOP_N_NATR'))
        if all(isinstance(x, (int, float)) for x in (tng, tnv, tnn)):
            eff = min(int(tnv), int(tnn))
            if int(tng) > eff:
                try:
                    log_message(f"Advisor info: TOP_N_GROWTH({int(tng)}) > effective cap min(TOP_N_VOLUME={int(tnv)}, TOP_N_NATR={int(tnn)}) = {eff}. Selection will be limited.")
                except Exception:
                    pass
    except Exception:
        pass
    return accepted, rejected

def apply_settings_changes(changes: dict):
    """Apply a dict of setting changes safely, persist, and refresh UI/state."""
    if not isinstance(changes, dict):
        return False
    try:
        before_snapshot = _current_settings_snapshot()
        # validate + coerce
        accepted, rejected = _validate_and_coerce_changes(changes)
        # Enforce advisor allow-list (UI toggles)
        try:
            allowed_set = set(_advisor_allowed_keys())
            for k in list(accepted.keys()):
                if k not in allowed_set:
                    rejected[k] = 'not allowed for AI changes'
                    accepted.pop(k, None)
        except Exception:
            pass
        # guard against unknown globals (keys that don't exist in code)
        unknown = {}
        for k in list(accepted.keys()):
            if k not in globals():
                unknown[k] = accepted.pop(k)
        if unknown:
            try:
                for k in unknown.keys():
                    rejected[k] = 'unknown setting key (not defined in runtime)'
            except Exception:
                pass
        if rejected:
            try:
                log_message(f"⚠️ Advisor validation rejected: {rejected}")
            except Exception:
                pass
        for k, v in accepted.items():
            try:
                old_val = globals().get(k) if k in globals() else None
                _set_setting_value(k, v, silent=False)
                if globals().get('ADVISOR_APPLY_VERBOSE', True):
                    try:
                        new_val = globals().get(k)
                        log_message(f"Advisor apply: {k} {old_val!r} -> {new_val!r}")
                    except Exception:
                        pass
            except Exception:
                continue
        # Persist to file
        save_settings_to_file()
        try:
            log_message(f"✅ Settings applied: {list(accepted.keys())}")
        except Exception:
            pass
        try:
            after_snapshot = _current_settings_snapshot()
            _record_settings_history(before_snapshot, after_snapshot, accepted)
        except Exception:
            pass
        # Some direct syncs
        try:
            trim_all_kline_histories()
        except Exception:
            pass
        return True
    except Exception:
        return False


def gpt_advisor_loop():
    """Event-driven advisor: run at startup and after each closed trade."""
    # ensure first run after startup
    try:
        advisor_trigger_event.set()
    except Exception:
        pass
    while True:
        try:
            # wait for trigger (closed trade or startup)
            advisor_trigger_event.wait()
            try:
                advisor_trigger_event.clear()
            except Exception:
                pass
            if not globals().get('GPT_ENABLED'):
                continue
            if not globals().get('GPT_API_KEY'):
                continue
            # Gate only pauses requests; does not block applying suggestions
            try:
                if not advisor_gate_allows_request():
                    try:
                        log_message("GPT Advisor: paused by gate")
                    except Exception:
                        pass
                    continue
            except Exception:
                pass
            # avoid overwriting fresh manual suggestion
            try:
                if time.time() - float(globals().get('_advisor_last_manual_ts', 0.0) or 0.0) < float(globals().get('GPT_MANUAL_SUPPRESS_SEC', 8) or 8):
                    continue
            except Exception:
                pass
            rec = make_gpt_recommendation()
            if rec and gui_bus is not None:
                try:
                    pretty = json.dumps(rec, ensure_ascii=False, indent=2)
                    gui_bus.advisor_signal.emit(pretty)
                except Exception:
                    pass
        except Exception:
            pass

# Level display cache for GUI highlighting
LEVEL_DISPLAY_ROUND = 8
level_display_cache = {}
level_display_lock = threading.Lock()


def cache_level_display(symbol, level, first_touch_ts):
    try:
        if not symbol or first_touch_ts is None:
            return
        key = (symbol.upper(), round(float(level), LEVEL_DISPLAY_ROUND))
        with level_display_lock:
            level_display_cache[key] = float(first_touch_ts)
    except Exception:
        pass


def get_cached_level_display(symbol, level):
    try:
        if not symbol or level is None:
            return None
        key = (symbol.upper(), round(float(level), LEVEL_DISPLAY_ROUND))
        with level_display_lock:
            return level_display_cache.get(key)
    except Exception:
        return None

twm = None
# Guard concurrent start/stop of TWM and sockets
twm_lock = threading.RLock()
_ws_restart_in_progress = False
# symbol_prices will store (price, ts)
symbol_prices = {}  # symbol -> {'price': float, 'ts': timestamp}
ORDERBOOK_LEVELS = 1000
ORDERBOOK_LADDER_LEVELS = 1000
ORDERBOOK_ROW_HEIGHT = 13

ORDERBOOK_IMAGE_FONT_SCALE = 0.42  # smaller, more standard font for orderbook image mode
# --- B1: orderbook as image (cheap UI; avoids QTableView bottleneck) ---
ORDERBOOK_RENDER_AS_IMAGE = True
AUTO_START_BOOK_ON_LAUNCH = True  # автозапуск стакану/тейпу при старті програми
ORDERBOOK_IMAGE_PAD_ROWS = 20
ORDERBOOK_IMAGE_SCROLL_STEP_ROWS = 6
ORDERBOOK_IMAGE_PRICE_COL_W = 104

ORDERBOOK_TICK_MULT = 1
ORDERBOOK_VISIBLE_RANGE_PCT = 3.0
ORDERBOOK_SCROLL_ANIM_MS = 500
ORDERBOOK_AUTO_CENTER_INSTANT = True
# Throttle book renders during manual scroll to keep UI responsive.
ORDERBOOK_SCROLL_THROTTLE_SEC = 0.18
ORDERBOOK_SCROLL_FRAME_MS = 16
BINANCE_PING_INTERVAL_SEC = 1
ORDERBOOK_AUTO_CENTER = True
ORDERBOOK_AUTO_CENTER_EDGE_PCT = 20.0  # Auto-center only when spread is within this % of the edge
USE_ORDERBOOK_REST_FALLBACK = False
USE_MANUAL_BOOK_WS_FALLBACK = True
USE_MANUAL_PRINTS_WS_FALLBACK = True
USE_MANUAL_KLINE_WS_FALLBACK = True
MANUAL_BOOK_WS_FALLBACK_SEC = 2.0
MANUAL_PRINTS_WS_FALLBACK_SEC = 2.0
MANUAL_KLINE_WS_FALLBACK_SEC = 2.0
GUI_USE_OPENGL = True
GUI_OPENGL_ANTIALIAS = False
ORDERBOOK_SHOW_DEPTH_BARS = True
ORDERBOOK_VOL_IN_USD = True
ORDERBOOK_VOL_COMPACT = True
ORDERBOOK_VOL_COL_WIDTH = 140
ORDERBOOK_PRICE_DISPLAY_PREC = 3
ORDERBOOK_ADAPTIVE_LEVELS = True
ORDERBOOK_VISIBLE_PAD = 120
ORDERBOOK_CENTER_MIN_MS = 250
ORDERBOOK_LOW_DEPTH_PERSIST_SEC = 1.5
ORDERBOOK_LOW_DEPTH_RECOVER_COOLDOWN_SEC = 15.0
ORDERBOOK_LOW_DEPTH_MIN_RATIO = 0.1
ORDERBOOK_LOW_DEPTH_MIN_LEVELS = 20
# Hover ruler: how many pixels the orderbook blue bar bleeds into the prints area.
# Keep this small to avoid overlapping the prints-area ruler bar.
BOOK_RULER_BLEED_PX = 4

PRESTART_BALANCE_REFRESH_SEC = 60.0
# ------------------- Prestart (before Start bot) visibility modes -------------------
# WS_ONLY_MODE:
#   - 0 REST requests for seeding state
#   - you will ONLY see orders/positions that change AFTER the app starts (via WS events)
# WS_PLUS_ONE_SNAPSHOT:
#   - one lightweight REST snapshot per symbol (openOrders + position) to seed UI state
#   - after that: WS-only (no periodic REST polling)
WS_ONLY_MODE = False
WS_PLUS_ONE_SNAPSHOT = True
SNAPSHOT_INCLUDE_ALGO_ORDERS = True  # show existing STOP/TP/conditional orders too (requires Futures algo endpoints)
OPEN_ORDERS_CACHE_TTL_LONG = 3600.0  # seconds to keep cached open-orders visible in the book

PRESTART_ORDERS_REFRESH_SEC = 300.0  # fallback REST sync (WS does live updates)
PRESTART_POS_REFRESH_SEC = 5.0
PRESTART_PING_INTERVAL_SEC = 30.0
PRESTART_TIME_SYNC_SEC = 5.0
PRESTART_REST_MAX_PER_MIN = 60.0
# Prints tape/UI frame pacing (ms). Lower values = higher FPS.
# NOTE: On Windows, a high-resolution timer is enabled (winmm.timeBeginPeriod(1))
#       to improve QTimer precision.
# 0 = as fast as possible (best-effort). Used to target 120+ FPS on high-refresh displays.
PRINTS_TAPE_FRAME_MS = 8
PRINTS_SPAWN_PER_FRAME = 2
PRINTS_MAX_PENDING = 20000  # cap to prevent RAM blow-up from WS backlog
# Hard cap for on-screen bubbles. Lower = much higher FPS.
PRINTS_MAX_ACTIVE = 150
PRINTS_OVERLOAD_AT = 200
# Hide text early to keep 120+ FPS (text is the most expensive part).
PRINTS_TEXT_HIDE_AT = 12
# Only force text for large bubbles.
PRINTS_TEXT_FORCE_RADIUS = 14.0
PRINTS_MIN_NOTIONAL_USD = 0.0
PRINTS_TEXT_MIN_NOTIONAL_USD = 0.0
PRINTS_SPEED_MULT = 0.65
PRINTS_SPEED_MAX = 0.8
PRINTS_SPEED_MIN = 0.2  # lower clamp for manual & AUTO speed
PRINTS_AUTO_SPEED_MIN = 0.2  # AUTO mapping floor (1 print / 5s)
PRINTS_SPEED_REF_ONE = 0.65  # 0.65 -> baseline (1x)
PRINTS_AUTO_MAX_COUNT = 200
PRINTS_SPEED_AUTO = True
# AUTO speed mapping: based on prints count in last PRINTS_AUTO_RATE_WINDOW_S seconds
PRINTS_AUTO_RATE_WINDOW_S = 5.0
PRINTS_AUTO_COUNT_MIN_5S = 10.0
PRINTS_AUTO_COUNT_MAX_5S = 200.0
# When aggregated, draw slightly stretched ovals
PRINTS_AGG_OVAL_X = 0.9
PRINTS_AGG_OVAL_Y = 1.6
PRINTS_AGG_OVAL_Y_MAX = 6
# Adaptive Y-stretch for aggregated prints based on orderbook shift distance (rows).
PRINTS_AGG_OVAL_Y_DIST_REF = 12.0
PRINTS_AGG_OVAL_Y_ALPHA = 0.35
PRINTS_AGG_OVAL_Y_MIN_ROWS = 1.5
PRINTS_AGG_OVAL_Y_UP_ALPHA = 0.45
PRINTS_AGG_OVAL_Y_GAP_ROWS = 5.0
PRINTS_AGG_OVAL_Y_GAP_SEC = 0.1
PRINTS_AGG_OVAL_Y_DECAY_ALPHA = 0.35

PRINTS_TAPE_CORRIDOR_ROWS = 3  # clamp prints near spread (±N rows)
PRINTS_RADIUS_MIN = 15
PRINTS_RADIUS_MAX = 22
PRINTS_RADIUS_EXP = 0.85
PRINTS_TEXT_FORCE_RADIUS = 9.0
PRINTS_AGG_ENABLED = True
PRINTS_AGG_BACKLOG_MIN = 1
PRINTS_AGG_WINDOW_MS = 80
PRINTS_AGG_MAX_GROUP = 10
PRINTS_AGG_MAX_TICKS = 1.0
PRINTS_AGG_WINDOW_MS_BASE = PRINTS_AGG_WINDOW_MS
PRINTS_AGG_WINDOW_MS_EXTRA = 0
USE_ORDERBOOK_RENDER_PROCESS = False
ORDERBOOK_RENDER_QUEUE_MAX = 2
ORDERBOOK_RENDER_READER_TIMEOUT = 0.2
ORDERBOOK_RENDER_WORKERS = 8  # parallel orderbook render worker processes
ORDERBOOK_CACHE_MAX_KEYS_PER_SIDE = 25000  # 0 = unlimited; safety cap for display cache
ORDERBOOK_CACHE_PRUNE_SEC = 10.0  # prune interval when cache exceeds cap

# --- Shared Memory for orderbook bids/asks (reduce pickle/IPC overhead) ---
# We store (price, qty) pairs as interleaved float64: [p0,q0,p1,q1,...]
# Main process writes into SHM; workers read zero-copy via memoryview.cast('d').
try:
    from multiprocessing import shared_memory as _mp_shared_memory
except Exception:
    _mp_shared_memory = None

class _OrderbookSHMManager:
    def __init__(self, capacity_pairs: int = 5000):
        self.capacity_pairs = int(capacity_pairs or 5000)
        if self.capacity_pairs < 512:
            self.capacity_pairs = 512
        self._bids_shm = None
        self._asks_shm = None
        self._bids_view = None
        self._asks_view = None

    def ensure(self):
        if _mp_shared_memory is None:
            return False
        if self._bids_shm is not None and self._asks_shm is not None:
            return True
        # allocate bytes for 2*capacity float64 values
        n_f64 = self.capacity_pairs * 2
        n_bytes = int(n_f64) * 8
        self._bids_shm = _mp_shared_memory.SharedMemory(create=True, size=n_bytes)
        self._asks_shm = _mp_shared_memory.SharedMemory(create=True, size=n_bytes)
        # memoryview.cast('d') gives float64 view
        self._bids_view = self._bids_shm.buf.cast('d')
        self._asks_view = self._asks_shm.buf.cast('d')
        return True

    @property
    def bids_name(self):
        return getattr(self._bids_shm, 'name', None)

    @property
    def asks_name(self):
        return getattr(self._asks_shm, 'name', None)

    def write_pairs(self, bids, asks):
        if not self.ensure():
            return None
        cap = self.capacity_pairs
        # write bids
        b = bids or []
        a = asks or []
        b_n = 0
        a_n = 0
        try:
            for i, (p, q) in enumerate(b):
                if i >= cap:
                    break
                try:
                    self._bids_view[2*i] = float(p)
                    self._bids_view[2*i+1] = float(q)
                except Exception:
                    continue
                b_n += 1
        except Exception:
            pass
        # write asks
        try:
            for i, (p, q) in enumerate(a):
                if i >= cap:
                    break
                try:
                    self._asks_view[2*i] = float(p)
                    self._asks_view[2*i+1] = float(q)
                except Exception:
                    continue
                a_n += 1
        except Exception:
            pass
        return {
            'bids_name': self.bids_name,
            'asks_name': self.asks_name,
            'capacity_pairs': cap,
            'bids_len': b_n,
            'asks_len': a_n,
        }

    def close(self):
        try:
            if self._bids_shm is not None:
                try:
                    self._bids_shm.close()
                except Exception:
                    pass
                try:
                    self._bids_shm.unlink()
                except Exception:
                    pass
        except Exception:
            pass
        try:
            if self._asks_shm is not None:
                try:
                    self._asks_shm.close()
                except Exception:
                    pass
                try:
                    self._asks_shm.unlink()
                except Exception:
                    pass
        except Exception:
            pass
        self._bids_shm = None
        self._asks_shm = None
        self._bids_view = None
        self._asks_view = None

# Sharding: split a single render frame across all workers
USE_ORDERBOOK_RENDER_SHARDING = False
PRINTS_EMIT_SINGLE = True
PRINTS_SINGLE_EMIT_INTERVAL = 0.0
ORDERBOOK_FULL_DEPTH = True
ORDERBOOK_REST_SEED_LIMIT = 1000
PRINTS_LIMIT = 5000
ORDERBOOK_EMIT_INTERVAL = 0.02
PRINTS_EMIT_INTERVAL = 0.1
PRINTS_EMIT_PAYLOAD_MAX = 200
ORDERBOOK_REST_FALLBACK_SEC = 2.0
PRINTS_REST_FALLBACK_SEC = 2.0
ORDERBOOK_REST_RECONCILE_SEC = 60.0
try:
    pg.setConfigOptions(useOpenGL=bool(GUI_USE_OPENGL), antialias=bool(GUI_OPENGL_ANTIALIAS))
except Exception:
    pass
orderbook_lock = threading.Lock()
orderbook_state = {}  # symbol -> {'bids': [(price, qty)], 'asks': [(price, qty)], 'ts': float}
orderbook_emit_ts = {}
orderbook_pending_emit = {}  # symbol -> last snapshot to emit when GUI bus is ready
orderbook_rest_poll_ts = {}
orderbook_rest_reconcile_ts = {}
orderbook_rest_seeded = set()
orderbook_rest_seed_lock = threading.Lock()
trade_prints = {}  # symbol -> deque of prints (newest first)
trade_prints_lock = threading.Lock()
trade_prints_emit_ts = {}
trade_prints_state_ts = {}
trade_prints_rest_poll_ts = {}
orderbook_socket_key = None
orderbook_socket_symbol = None
orderbook_socket_mode = None

# --- Fast-start orderbook settings (reduce time-to-first-book) ---
ORDERBOOK_FAST_START_ENABLED = True
ORDERBOOK_FAST_START_LIMIT = 100       # quick REST seed + quick visible snapshot
ORDERBOOK_EXPAND_DEPTH_LIMIT = 1000    # background expansion for deeper book (best-effort)
ORDERBOOK_REST_FILL_THROTTLE_SEC = 1.5 # prevent burst duplicate REST fills

orderbook_rest_fill_last_ts = {}
orderbook_fast_seed_done = set()
orderbook_expand_inflight = set()
trade_socket_key = None
trade_socket_symbol = None
_manual_book_ws_app = None
_manual_book_ws_thread = None
_manual_book_ws_stop = None
_manual_book_ws_lock = threading.RLock()
_manual_book_ws_symbol = None
_manual_book_ws_connected = False
_manual_book_ws_mode = None
_manual_prints_ws_app = None
_manual_prints_ws_thread = None
_manual_prints_ws_stop = None
_manual_prints_ws_lock = threading.RLock()
_manual_prints_ws_symbol = None
_manual_prints_ws_connected = False
_manual_kline_ws_app = None
_manual_kline_ws_thread = None
_manual_kline_ws_stop = None
_manual_kline_ws_lock = threading.RLock()
_manual_kline_ws_symbol = None
_manual_kline_ws_interval = None
_manual_kline_ws_connected = False
orderbook_full_lock = threading.Lock()
orderbook_full_state = {}  # symbol -> {'bids': {price: qty}, 'asks': {price: qty}, 'last_update_id': int, 'ready': bool, 'ts': float}
orderbook_diff_buffer = {}  # symbol -> list of diff messages awaiting snapshot
orderbook_seed_inflight = set()
orderbook_force_partial = set()
orderbook_force_partial_lock = threading.Lock()
ws_status_lock = threading.Lock()
ws_status = {"book": "OFF", "prints": "OFF", "chart": "OFF"}
ws_status_emit_ts = {}

# Orderbook display cache (prevents flicker when partial updates omit levels)
orderbook_display_cache_lock = threading.Lock()
orderbook_display_cache = {}  # symbol -> {'bids': {key: (qty, ts)}, 'asks': {key: (qty, ts)}}

# Orderbook depth bar scale reference (stabilizes depth bar scaling)
# Keyed by (symbol, unit) where unit is "USD" or "QTY".
# Updated no more frequently than ORDERBOOK_DEPTH_SCALE_FREEZE_SEC.
orderbook_depth_scale_lock = threading.Lock()
orderbook_depth_scale = {}  # (sym, unit) -> {'ref': float, 'ts': float}

_orderbook_reconcile_thread_started = False


def _ws_depth_level():
    try:
        target = int(ORDERBOOK_LEVELS or 20)
    except Exception:
        target = 20
    levels = [5, 10, 20]
    for v in levels:
        if target <= v:
            return v
    return levels[-1]


def _normalize_orderbook_rest_limit(value):
    allowed = [5, 10, 20, 50, 100, 500, 1000]
    try:
        target = int(value)
    except Exception:
        target = 100
    for v in allowed:
        if target <= v:
            return v
    return allowed[-1]


def _use_full_orderbook(symbol=None):
    sym = (symbol or orderbook_socket_symbol or "").upper()
    if sym:
        try:
            with orderbook_force_partial_lock:
                if sym in orderbook_force_partial:
                    return False
        except Exception:
            pass
    try:
        if bool(globals().get("ORDERBOOK_FULL_DEPTH", False)):
            return True
    except Exception:
        pass
    try:
        return int(globals().get("ORDERBOOK_LEVELS", ORDERBOOK_LEVELS) or ORDERBOOK_LEVELS) > 20
    except Exception:
        return False


def _orderbook_rest_seeded(sym):
    if not sym:
        return False
    try:
        with orderbook_rest_seed_lock:
            return sym in orderbook_rest_seeded
    except Exception:
        return False


def _force_orderbook_partial(symbol, reason=None):
    sym = (symbol or "").upper()
    if not sym:
        return False
    already = False
    try:
        with orderbook_force_partial_lock:
            already = sym in orderbook_force_partial
            orderbook_force_partial.add(sym)
    except Exception:
        already = True
    if already:
        return True
    try:
        msg = f"[BOOK] force partial depth for {sym}"
        if reason:
            msg = f"{msg} ({reason})"
        log_message(msg)
    except Exception:
        pass
    try:
        with orderbook_full_lock:
            orderbook_full_state.pop(sym, None)
            orderbook_diff_buffer.pop(sym, None)
            orderbook_seed_inflight.discard(sym)
    except Exception:
        pass
    try:
        subscribe_orderbook(sym)
    except Exception:
        pass
    return True


def _build_orderbook_lists_from_full(state, levels):
    if not isinstance(state, dict):
        return [], []
    try:
        levels = int(levels)
    except Exception:
        levels = int(ORDERBOOK_LEVELS or 20)
    if levels <= 0:
        return [], []
    bids_map = state.get('bids') if isinstance(state.get('bids'), dict) else {}
    asks_map = state.get('asks') if isinstance(state.get('asks'), dict) else {}
    try:
        bids = heapq.nlargest(levels, bids_map.items(), key=lambda x: x[0])
    except Exception:
        bids = sorted(bids_map.items(), key=lambda x: x[0], reverse=True)[:levels]
    try:
        asks = heapq.nsmallest(levels, asks_map.items(), key=lambda x: x[0])
    except Exception:
        asks = sorted(asks_map.items(), key=lambda x: x[0])[:levels]
    bids_list = [(p, q) for p, q in bids if q and q > 0]
    asks_list = [(p, q) for p, q in asks if q and q > 0]
    return bids_list, asks_list


def _apply_depth_diff_locked(symbol, payload, state, allow_resync=True):
    """Apply a Binance USDⓈ-M Futures diff depth update to the local full orderbook.

    Sync rules follow Binance docs ("How To Manage A Local Order Book Correctly"):
    - Maintain a REST snapshot with lastUpdateId.
    - Buffer WS events until a snapshot is loaded.
    - First applied WS event must satisfy: U <= lastUpdateId <= u.
    - Thereafter, every event must satisfy: pu == last_u (previous event's u).

    Returns:
      True  -> update applied or safely ignored (stale)
      False -> out of sync, caller should trigger a reseed
    """
    if not isinstance(payload, dict) or not isinstance(state, dict):
        return False

    # Extract ids
    try:
        u_val = int(payload.get('u') or payload.get('lastUpdateId') or payload.get('last_update_id'))
    except Exception:
        return False
    try:
        U_val = payload.get('U')
        U_val = int(U_val) if U_val is not None else None
    except Exception:
        U_val = None
    try:
        pu_val = payload.get('pu')
        pu_val = int(pu_val) if pu_val is not None else None
    except Exception:
        pu_val = None

    # Snapshot id (REST)
    try:
        snap_id = state.get('snapshot_id')
        if snap_id is None:
            snap_id = state.get('last_update_id')
        snap_id = int(snap_id) if snap_id is not None else None
    except Exception:
        snap_id = None

    # Prepare maps
    bids_map = state.get('bids')
    asks_map = state.get('asks')
    if not isinstance(bids_map, dict):
        bids_map = {}
        state['bids'] = bids_map
    if not isinstance(asks_map, dict):
        asks_map = {}
        state['asks'] = asks_map

    def _apply_levels(levels, book_map):
        for price_s, qty_s in levels or []:
            try:
                # Normalize price key to avoid float-key drift that can freeze levels.
                ps = price_s
                if isinstance(ps, str) and '.' in ps:
                    try:
                        dec = len(ps.split('.', 1)[1])
                    except Exception:
                        dec = 0
                    dec = 12 if dec > 12 else dec
                    p = round(float(ps), int(dec))
                else:
                    p = float(ps)
                q = float(qty_s)
            except Exception:
                continue
            if q <= 0:
                # quantity 0 means delete level
                book_map.pop(p, None)
            else:
                book_map[p] = q

    synced = bool(state.get('synced', False))

    # Not synced yet: wait for the first event that overlaps snapshot id.
    if not synced:
        if snap_id is None:
            return False
        # Stale event -> ignore
        if u_val < snap_id:
            return True
        # Must overlap snapshot id
        if U_val is None or not (U_val <= snap_id <= u_val):
            return False
        # Apply first diff
        _apply_levels(payload.get('b') or payload.get('bids') or [], bids_map)
        _apply_levels(payload.get('a') or payload.get('asks') or [], asks_map)
        state['synced'] = True
        state['last_u'] = u_val
        state['last_update_id'] = u_val
        return True

    # Already synced: enforce chain
    try:
        prev_u = int(state.get('last_u') or state.get('last_update_id') or 0)
    except Exception:
        prev_u = 0

    # Ignore out-of-order/stale
    if u_val <= prev_u:
        return True

    # Strict chain check when pu is present (it is for USDⓈ-M futures diff depth)
    if pu_val is not None and pu_val != prev_u:
        return False

    # If pu missing, use a safer overlap check
    if pu_val is None and U_val is not None:
        if not (U_val <= (prev_u + 1) <= u_val):
            return False

    _apply_levels(payload.get('b') or payload.get('bids') or [], bids_map)
    _apply_levels(payload.get('a') or payload.get('asks') or [], asks_map)
    state['last_u'] = u_val
    state['last_update_id'] = u_val
    return True


def _seed_full_orderbook_async(symbol, force=False, seed_limit_override=None):
    """Fetch REST snapshot (limit up to 1000) and sync buffered diff-depth WS events."""
    if (not _use_full_orderbook(symbol)) and (not force):
        return
    symbol = (symbol or "").upper()
    if not symbol:
        return

    # prevent duplicate inflight
    with orderbook_full_lock:
        if symbol in orderbook_seed_inflight:
            return
        orderbook_seed_inflight.add(symbol)
        # mark state as not ready -> WS handler will buffer
        state = orderbook_full_state.get(symbol)
        if not isinstance(state, dict):
            state = {}
            orderbook_full_state[symbol] = state
        state['ready'] = False
        state['synced'] = False
        state['last_u'] = None
        # do NOT clear diff buffer here (we need overlap)

    def _worker():
        try:
            try:
                target_levels = int(globals().get('ORDERBOOK_LEVELS', ORDERBOOK_LEVELS) or ORDERBOOK_LEVELS)
            except Exception:
                target_levels = int(ORDERBOOK_LEVELS or 20)
            try:
                seed_limit = int(globals().get('ORDERBOOK_REST_SEED_LIMIT', ORDERBOOK_REST_SEED_LIMIT) or ORDERBOOK_REST_SEED_LIMIT)
            except Exception:
                seed_limit = int(ORDERBOOK_REST_SEED_LIMIT or 1000)
            seed_limit = _normalize_orderbook_rest_limit(int(seed_limit_override) if seed_limit_override is not None else max(seed_limit, target_levels))

            resp = _fetch_orderbook_rest(symbol, limit_override=seed_limit, with_update_id=True)
            if not resp:
                try:
                    log_message(f"[BOOK] REST snapshot failed for {symbol} -> fallback to PARTIAL")
                except Exception:
                    pass
                try:
                    _force_orderbook_partial(symbol, reason="REST snapshot failed")
                except Exception:
                    pass
                return

            bids, asks, update_id = resp
            try:
                update_id = int(update_id or 0)
            except Exception:
                update_id = 0

            bids_map = {}
            asks_map = {}
            for price, qty in bids or []:
                try:
                    # Normalize price key to avoid float-key drift.
                    ps = price
                    if isinstance(ps, str) and '.' in ps:
                        try:
                            dec = len(ps.split('.', 1)[1])
                        except Exception:
                            dec = 0
                        dec = 12 if dec > 12 else dec
                        p = round(float(ps), int(dec))
                    else:
                        p = float(ps)
                    q = float(qty)
                except Exception:
                    continue
                if q > 0:
                    bids_map[p] = q
            for price, qty in asks or []:
                try:
                    # Normalize price key to avoid float-key drift.
                    ps = price
                    if isinstance(ps, str) and '.' in ps:
                        try:
                            dec = len(ps.split('.', 1)[1])
                        except Exception:
                            dec = 0
                        dec = 12 if dec > 12 else dec
                        p = round(float(ps), int(dec))
                    else:
                        p = float(ps)
                    q = float(qty)
                except Exception:
                    continue
                if q > 0:
                    asks_map[p] = q

            # Move buffered diffs out under lock
            with orderbook_full_lock:
                state = orderbook_full_state.get(symbol)
                if not isinstance(state, dict):
                    state = {}
                    orderbook_full_state[symbol] = state
                state['bids'] = bids_map
                state['asks'] = asks_map
                state['snapshot_id'] = update_id
                state['last_update_id'] = update_id
                state['synced'] = False
                state['last_u'] = None
                state['ready'] = True
                state['ts'] = time.time()
                buffered = list(orderbook_diff_buffer.get(symbol, []))

            # Replay buffered events until synced
            if buffered:
                ok_any = False
                with orderbook_full_lock:
                    state = orderbook_full_state.get(symbol)
                    if isinstance(state, dict) and state.get('ready'):
                        for payload in buffered:
                            ok = _apply_depth_diff_locked(symbol, payload, state, allow_resync=False)
                            if ok:
                                ok_any = True
                                if state.get('synced'):
                                    # once synced, continue applying remaining buffered diffs
                                    continue
                            else:
                                # out of sync -> trigger reseed
                                state['ready'] = False
                                break
                # Clear the buffer regardless once we attempted replay
                with orderbook_full_lock:
                    orderbook_diff_buffer[symbol] = []

            # If we are synced, publish immediately
            with orderbook_full_lock:
                state = orderbook_full_state.get(symbol)
                ready = isinstance(state, dict) and state.get('ready') and state.get('synced')
            if ready:
                _publish_full_orderbook(symbol, state)
        finally:
            with orderbook_full_lock:
                orderbook_seed_inflight.discard(symbol)

    threading.Thread(target=_worker, daemon=True).start()


# ------------------ GUI bridge & shared state ------------------
class GuiBus(QObject):
    log_signal = Signal(str)
    balance_signal = Signal(str)
    orders_signal = Signal(list)
    chart_signal = Signal(str, float)
    equity_signal = Signal(list)
    orderbook_signal = Signal(object)
    orderbook_render_signal = Signal(object)
    orderbook_image_signal = Signal(object)
    prints_signal = Signal(object)
    ws_status_signal = Signal(str, str)
    trade_journal_signal = Signal(list)
    advisor_signal = Signal(str)  # text with suggestion JSON/rationale
    offset_signal = Signal(int)  # ms offset between local and Binance
    ping_signal = Signal(int)  # ms latency to Binance
    screenshot_signal = Signal(object)


gui_bus = None
orders_table_rows = []
orders_table_lock = threading.Lock()
current_pnl_percent_display = None


def _emit_orders_table():
    if gui_bus is None:
        return
    with orders_table_lock:
        payload = [row.copy() for row in orders_table_rows]
    try:
        gui_bus.orders_signal.emit(payload)
    except Exception:
        pass


def _emit_trade_journal():
    try:
        save_trade_journal_to_file()
    except Exception:
        pass
    if gui_bus is None:
        return
    try:
        payload = [row.copy() for row in closed_trades]
    except Exception:
        try:
            payload = list(closed_trades)
        except Exception:
            payload = []
    try:
        gui_bus.trade_journal_signal.emit(payload)
    except Exception:
        pass


def _ensure_trade_journal_tag(entry):
    if not isinstance(entry, dict):
        return
    try:
        tag_val = entry.get("tag")
    except Exception:
        tag_val = None
    if tag_val is None:
        entry["tag"] = ""
        return
    try:
        entry["tag"] = str(tag_val)
    except Exception:
        entry["tag"] = ""


def _ensure_trade_journal_uid(entry):
    if not isinstance(entry, dict):
        return None
    jid = None
    try:
        jid = entry.get("jid") or entry.get("journal_id")
    except Exception:
        jid = None
    if jid in (None, ""):
        try:
            jid = f"jid-{int(time.time() * 1000)}-{uuid.uuid4().hex[:8]}"
        except Exception:
            jid = f"jid-{time.time()}"
        entry["jid"] = jid
        return jid
    try:
        entry["jid"] = str(jid)
    except Exception:
        entry["jid"] = jid
    return entry.get("jid")


def _emit_orderbook(symbol):
    # NOTE: On slower PCs, REST snapshot may arrive before GUI bus is created/connected.
    # Cache the latest snapshot and emit it later once GUI is ready.
    global orderbook_pending_emit
    if gui_bus is None:
        try:
            with orderbook_lock:
                payload = orderbook_state.get(symbol)
                if payload:
                    orderbook_pending_emit[symbol] = dict(payload)
        except Exception:
            pass
        return
    try:
        with orderbook_lock:
            payload = orderbook_state.get(symbol)
            if payload:
                payload = dict(payload)
    except Exception:
        payload = None
    if not payload:
        return
    try:
        gui_bus.orderbook_signal.emit(payload)
    except Exception:
        pass


def _flush_pending_orderbooks():
    """Emit any cached orderbook snapshots that arrived before GUI was ready."""
    global orderbook_pending_emit
    if gui_bus is None:
        return
    try:
        items = list(orderbook_pending_emit.items())
        orderbook_pending_emit.clear()
    except Exception:
        return
    for _sym, _payload in items:
        try:
            gui_bus.orderbook_signal.emit(_payload)
        except Exception:
            pass


def _emit_prints(symbol):
    if gui_bus is None:
        return
    try:
        with trade_prints_lock:
            dq = trade_prints.get(symbol)
            if dq:
                try:
                    max_out = int(globals().get('PRINTS_EMIT_PAYLOAD_MAX', 200) or 200)
                except Exception:
                    max_out = 200
                try:
                    import itertools
                    payload = list(itertools.islice(dq, 0, max_out))
                except Exception:
                    payload = list(dq)[:max_out]
            else:
                payload = []
    except Exception:
        payload = []
    try:
        mn = float(globals().get('PRINTS_MIN_NOTIONAL_USD', 0.0) or 0.0)
    except Exception:
        mn = 0.0
    if mn > 0 and payload:
        try:
            payload = [p for p in payload if float(p.get('notional', abs(float(p.get('price',0))*float(p.get('qty',0))) )) >= mn]
        except Exception:
            pass
    try:
        gui_bus.prints_signal.emit({'symbol': symbol, 'prints': payload})
    except Exception:
        pass


def _emit_ws_status(name, status, force=False):
    if not name:
        return
    try:
        now = time.time()
    except Exception:
        now = 0.0
    try:
        with ws_status_lock:
            prev = ws_status.get(name)
            last_ts = ws_status_emit_ts.get(name, 0.0)
            if (not force) and prev == status and (now - last_ts) < 0.5:
                return
            ws_status[name] = status
            ws_status_emit_ts[name] = now
    except Exception:
        pass
    if gui_bus is None:
        return
    try:
        gui_bus.ws_status_signal.emit(str(name), str(status))
    except Exception:
        pass


def _trade_journal_is_duplicate(prev, entry, ts_window=2.0, pnl_tol=1e-6):
    try:
        prev_sym = (prev.get('symbol') or '').upper()
    except Exception:
        prev_sym = None
    try:
        new_sym = (entry.get('symbol') or '').upper()
    except Exception:
        new_sym = None
    if prev_sym and new_sym and prev_sym != new_sym:
        return False
    try:
        prev_ts = float(prev.get('ts') or 0.0)
    except Exception:
        prev_ts = 0.0
    try:
        new_ts = float(entry.get('ts') or 0.0)
    except Exception:
        new_ts = 0.0
    if prev_ts and new_ts and abs(prev_ts - new_ts) > ts_window:
        return False
    prev_pnl = None
    new_pnl = None
    try:
        prev_pnl = prev.get('pnl_net') if prev.get('pnl_net') is not None else prev.get('pnl_abs')
    except Exception:
        prev_pnl = None
    try:
        new_pnl = entry.get('pnl_net') if entry.get('pnl_net') is not None else entry.get('pnl_abs')
    except Exception:
        new_pnl = None
    if prev_pnl is not None and new_pnl is not None:
        try:
            if abs(float(prev_pnl) - float(new_pnl)) > pnl_tol:
                return False
        except Exception:
            return False
    return True


def record_trade_journal_entry(entry):
    if not isinstance(entry, dict):
        return None
    try:
        entry_ts = float(entry.get('ts') or time.time())
    except Exception:
        entry_ts = time.time()
    entry['ts'] = entry_ts
    try:
        entry['symbol'] = (entry.get('symbol') or "").upper()
    except Exception:
        pass
    try:
        _ensure_trade_journal_tag(entry)
    except Exception:
        pass
    try:
        _ensure_trade_journal_uid(entry)
    except Exception:
        pass
    last = None
    try:
        if closed_trades:
            last = closed_trades[-1]
    except Exception:
        last = None
    if last is not None:
        try:
            if _trade_journal_is_duplicate(last, entry):
                return last
        except Exception:
            pass
    try:
        closed_trades.append(entry)
    except Exception:
        return None
    _emit_trade_journal()
    return entry


def update_chart_target(symbol, level):
    if gui_bus is None:
        return
    try:
        gui_bus.chart_signal.emit(symbol, float(level))
    except Exception:
        pass


def request_chart_screenshot(symbol, level, timeout=None, clear_level=False, clear_markers=False, priority='normal', fast=None, fullscreen=None, force_refresh=None):
    if gui_bus is None:
        return None
    try:
        if not TELEGRAM_TOKEN or not TELEGRAM_USERS:
            return None
    except Exception:
        return None
    try:
        enabled = bool(globals().get("TELEGRAM_LEVEL_SCREENSHOT_ENABLED", True))
    except Exception:
        enabled = True
    if not enabled:
        return None
    req = {
        "symbol": symbol,
        "level": level,
        "out_dir": globals().get("TELEGRAM_LEVEL_SCREENSHOT_DIR"),
        "path": None,
        "event": threading.Event(),
        "clear_level": bool(clear_level),
        "clear_markers": bool(clear_markers),
        "priority": str(priority or 'normal'),
        "fast": (bool(globals().get("SCREENSHOT_FAST_MODE", True)) if fast is None else bool(fast)),
        "fullscreen": (False if fullscreen is None else bool(fullscreen)),
        "force_refresh": (None if force_refresh is None else bool(force_refresh)),
    }
    try:
        gui_bus.screenshot_signal.emit(req)
    except Exception:
        return None
    try:
        wait_s = float(timeout if timeout is not None else globals().get("TELEGRAM_LEVEL_SCREENSHOT_TIMEOUT", 4.0))
    except Exception:
        wait_s = 4.0
    if wait_s <= 0:
        wait_s = 4.0
    if req["event"].wait(wait_s):
        return req.get("path")
    return None


def graceful_shutdown(blocking=False):
    """Best-effort shutdown: stop trading, sockets, telegram, timers; spawn self-killer on Windows."""
    global TELEGRAM_POLLING_ENABLED, WINDOWS_TIME_SYNC_ENABLED
    if getattr(graceful_shutdown, "_ran", False):
        return
    graceful_shutdown._ran = True
    try:
        shutdown_event.set()
    except Exception:
        pass
    try:
        TELEGRAM_POLLING_ENABLED = False
    except Exception:
        pass
    try:
        WINDOWS_TIME_SYNC_ENABLED = False
    except Exception:
        pass
    try:
        bot_running_flag = globals().get("bot_running", None)
        if bot_running_flag is not None:
            globals()["bot_running"] = False
    except Exception:
        pass
    try:
        stop_bot(blocking=blocking)
    except Exception as e:
        try:
            log_message(f"[shutdown] stop_bot error: {e}")
        except Exception:
            pass
    try:
        if 'twm' in globals() and twm:
            try:
                twm.stop()
            except Exception:
                pass
    except Exception:
        pass
    # FIX: hide console flicker - only spawn self-killer if explicitly enabled
    try:
        if ENABLE_SELF_KILLER:
            launch_self_killer()
    except Exception:
        pass

    # Stop low-latency executor to prevent lingering background tasks
    try:
        _PRICE_EXECUTOR.shutdown(wait=False, cancel_futures=True)
    except Exception:
        pass
    try:
        shutdown_complete_event.set()
    except Exception:
        pass


def _on_signal(*_):
    try:
        shutdown_event.set()
    except Exception:
        pass
    graceful_shutdown()
    try:
        sys.exit(0)
    except Exception:
        pass

def hard_exit(code=0):
    """Forcefully exit process after graceful shutdown best-effort (bounded wait)."""
    try:
        t = threading.Thread(target=graceful_shutdown, kwargs={"blocking": True}, daemon=True)
        t.start()
        t.join(timeout=0.5)
    except Exception:
        try:
            graceful_shutdown(blocking=True)
        except Exception:
            pass
    try:
        os._exit(code)
    except Exception:
        pass


# --- Algo order helpers via python-binance raw REST (POST/DELETE/GET /fapi/v1/algoOrder / openAlgoOrders) ---
def _contains_non_ascii(value):
    try:
        return any(ord(ch) > 127 for ch in str(value))
    except Exception:
        return False


def _algo_needs_unicode_safe(data):
    if not isinstance(data, dict):
        return False
    for key, val in data.items():
        if _contains_non_ascii(key) or _contains_non_ascii(val):
            return True
    return False


def _algo_request_unicode_safe(method, path, data):
    payload = {}
    try:
        payload = {k: v for k, v in (data or {}).items() if v is not None}
    except Exception:
        payload = {}
    try:
        if 'timestamp' not in payload:
            ts_offset = int(getattr(client, "timestamp_offset", 0) or 0)
            payload['timestamp'] = int(time.time() * 1000 + ts_offset)
    except Exception:
        payload['timestamp'] = int(time.time() * 1000)
    try:
        items = [(str(k), str(v)) for k, v in payload.items() if v is not None]
        items.sort(key=lambda x: x[0])
        qs = urlencode(items, doseq=True, quote_via=quote, safe='-_.~')
        try:
            if getattr(client, "PRIVATE_KEY", None):
                sig = client._rsa_signature(qs)
            else:
                sig = client._hmac_signature(qs)
        except Exception:
            sig = client._hmac_signature(qs)
        full_qs = f"{qs}&signature={sig}" if qs else f"signature={sig}"
    except Exception as e:
        log_message(f"⚠️ Algo Unicode-safe signing failed: {e}")
        raise
    try:
        url = client._create_futures_api_uri(path, version=1)
        timeout = getattr(client, "REQUEST_TIMEOUT", 10)
        resp = client.session.request(method, url, params=full_qs, timeout=timeout)
        return client._handle_response(resp)
    except Exception as e:
        log_message(f"⚠️ Algo Unicode-safe request error path={path}: {e}")
        raise


def _algo_request(method, path, data=None):
    """
    Thin wrapper over python-binance internal request to hit algo endpoints.
    method: "get" | "post" | "delete"
    path: e.g. "algoOrder", "openAlgoOrders"
    """
    if data is None:
        data = {}
    try:
        if _algo_needs_unicode_safe(data):
            return _algo_request_unicode_safe(method, path, data)
        return client._request_futures_api(method, path, True, data=data)
    except BinanceAPIException as be:
        try:
            resp = getattr(be, "response", None)
            snippet = ""
            if resp is not None and hasattr(resp, "text"):
                snippet = str(resp.text)[:300]
            log_message(f"⚠️ Algo API error {getattr(be, 'status_code', None)} path={path}: {snippet}")
        except Exception:
            pass
        try:
            if getattr(be, "code", None) == -1022 and _algo_needs_unicode_safe(data):
                return _algo_request_unicode_safe(method, path, data)
        except Exception:
            pass
        raise
    except Exception as e:
        try:
            log_message(f"⚠️ Algo API unexpected error path={path}: {e}")
        except Exception:
            pass
        raise


def _normalize_algo_order(o):
    if not isinstance(o, dict):
        return {}
    return {
        'orderId': o.get('algoId') or o.get('orderId'),
        'algoId': o.get('algoId') or o.get('orderId'),
        'clientOrderId': o.get('clientAlgoId') or o.get('clientOrderId'),
        'symbol': o.get('symbol'),
        'type': o.get('orderType') or o.get('type'),
        'status': o.get('algoStatus') or o.get('status'),
        'side': o.get('side'),
        'stopPrice': o.get('triggerPrice') or o.get('stopPrice') or o.get('price'),
        'price': o.get('price'),
        'reduceOnly': o.get('reduceOnly'),
        'positionSide': o.get('positionSide'),
        'updateTime': o.get('updateTime'),
    }


def create_conditional_order(symbol, side, order_type, quantity,
                             stop_price=None, price=None, client_oid=None,
                             reduce_only=False, position_side="BOTH", time_in_force="GTC",
                             activation_price=None, callback_rate=None,
                             working_type="CONTRACT_PRICE", close_position=False):
    # Якщо для *_MARKET не передано quantity і не встановлено closePosition, вмикаємо closePosition,
    # щоб уникнути -1102 "quantity missing".
    try:
        if order_type in ("STOP_MARKET", "TAKE_PROFIT_MARKET") and quantity is None and not close_position:
            close_position = True
            log_message(f"⚠️ quantity is None for {order_type} {symbol} — using closePosition=true")
    except Exception:
        pass
    tick = 0.0
    step = 0.0
    qty_prec = 0
    price_prec = 8
    try:
        filt = order_placement_service._filters(symbol)
        tick = float(filt.get("tick") or 0.0)
        step = float(filt.get("step") or 0.0)
        qty_prec = int(filt.get("qty_prec", 0) or 0)
        price_prec = int(filt.get("price_prec", 8) or 8)
    except Exception:
        tick = 0.0
        step = 0.0
        qty_prec = 0
        price_prec = 8

    def _norm_price(val):
        if val is None:
            return val
        try:
            v = float(val)
        except Exception:
            return val
        try:
            if tick and tick > 0:
                v2 = _round_to_tick(v, tick, price_prec)
                if v2 is not None:
                    v = v2
            else:
                v = round(v, int(price_prec))
        except Exception:
            pass
        return v

    def _norm_qty(val):
        if val is None:
            return val
        try:
            v = float(val)
        except Exception:
            return val
        try:
            if step and step > 0:
                v = order_placement_service._round(v, step)
            v = round(v, int(qty_prec))
        except Exception:
            pass
        return v

    quantity = _norm_qty(quantity)
    stop_price = _norm_price(stop_price)
    price = _norm_price(price)
    activation_price = _norm_price(activation_price)
    payload = {
        "algoType": "CONDITIONAL",
        "symbol": symbol,
        "side": side,
        "type": order_type,
        "positionSide": position_side or "BOTH",
        "workingType": working_type or "CONTRACT_PRICE",
    }
    if client_oid:
        payload["clientAlgoId"] = client_oid

    # close-all лише для *_MARKET
    if close_position and order_type in ("STOP_MARKET", "TAKE_PROFIT_MARKET"):
        payload["closePosition"] = "true"
    else:
        if quantity is not None:
            payload["quantity"] = quantity
        if reduce_only:
            payload["reduceOnly"] = "true"

    if order_type in ("STOP", "TAKE_PROFIT", "STOP_MARKET", "TAKE_PROFIT_MARKET"):
        payload["triggerPrice"] = stop_price

    if order_type in ("STOP", "TAKE_PROFIT"):
        payload["price"] = price
        payload["timeInForce"] = time_in_force

    if order_type == "TRAILING_STOP_MARKET":
        if activation_price is not None:
            payload["activationPrice"] = activation_price
        if callback_rate is not None:
            try:
                cr = float(callback_rate)
                if cr < 0.1 or cr > 10:
                    log_message(f"⚠️ callbackRate поза діапазоном [0.1,10]: {cr}")
                payload["callbackRate"] = cr
            except Exception:
                log_message(f"⚠️ Некоректний callbackRate: {callback_rate}")

    try:
        dbg = {k: v for k, v in payload.items()}
        log_message(f"[create_conditional_order] Payload={dbg}")
    except Exception:
        pass

    resp = _algo_request("post", "algoOrder", payload)
    try:
        log_message(f"[create_conditional_order] resp={resp}")
    except Exception:
        pass
    if isinstance(resp, dict):
        algo_id = resp.get("algoId") or resp.get("orderId")
        if algo_id:
            algo_order_registry[str(algo_id)] = {
                "symbol": symbol,
                "algoId": algo_id,
                "clientOrderId": client_oid,
                "reduceOnly": reduce_only
            }
            resp.setdefault("orderId", algo_id)
        else:
            try:
                log_message(f"⚠️ create_conditional_order: algoId відсутній у відповіді для {symbol}")
            except Exception:
                pass
    return resp


def cancel_conditional_order(symbol, algo_id):
    """
    Cancel conditional (algo) order. For already-closed/missing orders
    (-2013 / -2011) просто повертаємо None без логів-варнінгів.
    """
    if not algo_id:
        return None
    payload = {"symbol": symbol, "algoId": algo_id}
    try:
        return client._request_futures_api("delete", "algoOrder", True, data=payload)
    except BinanceAPIException as be:
        code = getattr(be, "code", None)
        if code in (-2013, -2011):
            # order does not exist / unknown order – це нормальний випадок при повторних скасуваннях
            return None
        raise


def cancel_open_closeposition_sl_orders(symbol, side=None, position_side=None):
    """
    Cancel ALL open conditional STOP orders with closePosition=true (hard SL).
    Prevents duplicates (e.g. ENTRY1 SL not canceled before ENTRY2 SL).
    Returns list of canceled algoIds.
    """
    sym = (symbol or "").upper()
    if not sym:
        return []
    side_up = (side or "").upper().strip() if side else None
    pos_side_up = (position_side or "").upper().strip() if position_side else None
    canceled = []
    try:
        open_orders = get_open_conditional_orders(sym) or []
    except Exception:
        open_orders = []
    for o in open_orders:
        try:
            o_sym = (o.get("symbol") or o.get("s") or "").upper()
            if o_sym and o_sym != sym:
                continue
            o_type = (o.get("orderType") or o.get("type") or o.get("o") or "").upper()
            if o_type not in ("STOP_MARKET", "STOP"):
                continue
            if not _to_bool(o.get("closePosition")):
                continue
            if side_up and (o.get("side") or o.get("S") or "").upper() != side_up:
                continue
            if pos_side_up and (o.get("positionSide") or o.get("ps") or "").upper() not in (pos_side_up, ""):
                continue
            oid = o.get("algoId") or o.get("orderId")
            if not oid:
                continue
            try:
                cancel_conditional_order(sym, oid)
                canceled.append(oid)
            except Exception:
                continue
        except Exception:
            continue
    return canceled


def get_conditional_order(symbol, algo_id=None):
    """Get single conditional (algo) order; None if not found (-2013/-2011)."""
    data = {}
    if symbol:
        data["symbol"] = symbol
    if algo_id is not None:
        data["algoId"] = algo_id
    try:
        return client._request_futures_api("get", "algoOrder", True, data=data)
    except BinanceAPIException as be:
        code = getattr(be, "code", None)
        if code in (-2013, -2011):
            return None
        raise


def get_open_conditional_orders(symbol=None):
    """List open conditional (algo) orders for symbol or all symbols."""
    data = {}
    if symbol:
        data["symbol"] = symbol
    try:
        return client._request_futures_api("get", "openAlgoOrders", True, data=data)
    except BinanceAPIException as be:
        code = getattr(be, "code", None)
        if code in (-2013, -2011):
            return []
        raise


def add_order_row(symbol, side, quantity, stop_price, tp_sl="-"):
    try:
        row = {
            "symbol": symbol,
            "side": side,
            "quantity": quantity,
            "stop_price": stop_price,
            "tp_sl": tp_sl
        }
        with orders_table_lock:
            orders_table_rows.append(row)
        _emit_orders_table()
    except Exception:
        pass


def remove_order_rows(predicate):
    try:
        with orders_table_lock:
            orders_table_rows[:] = [row for row in orders_table_rows if not predicate(row)]
        _emit_orders_table()
    except Exception:
        pass


def update_balance_display(balance, pnl_percent):
    global current_pnl_percent_display
    current_pnl_percent_display = pnl_percent
    text = f"Баланс: {balance:.2f} USDT | PnL: {pnl_percent:+.2f}%"
    try:
        record_equity_point(balance, pnl_percent)
    except Exception:
        pass
    if gui_bus is not None:
        try:
            gui_bus.balance_signal.emit(text)
        except Exception:
            pass


def record_equity_point(balance, pnl_percent):
    global equity_history, last_recorded_equity_balance
    try:
        bal = float(balance)
    except Exception:
        return
    try:
        pnl_val = float(pnl_percent)
    except Exception:
        pnl_val = 0.0
    try:
        last_bal = last_recorded_equity_balance
        if last_bal is not None and abs(bal - last_bal) < EQUITY_MIN_BALANCE_DELTA:
            return
        point = {
            "ts": time.time(),
            "balance": bal,
            "pnl": pnl_val
        }
        with equity_history_lock:
            equity_history.append(point)
            if len(equity_history) > EQUITY_HISTORY_LIMIT:
                equity_history = equity_history[-EQUITY_HISTORY_LIMIT:]
            snapshot = list(equity_history)
        last_recorded_equity_balance = bal
        save_equity_history_to_file()
        if gui_bus is not None:
            try:
                gui_bus.equity_signal.emit(snapshot)
            except Exception:
                pass
    except Exception:
        pass

# ------------------ Price processor (non-blocking WS -> background worker) ------------------
price_queue = Queue()
_price_pending = set()  # symbols currently queued (fast coalescing)
_price_pending_lock = threading.Lock()
_price_worker_running = False


def _price_processor_loop():
    """Low-latency price processor loop using ThreadPoolExecutor."""
    global _price_worker_running
    _price_worker_running = True
    while not shutdown_event.is_set():
        try:
            try:
                sym = price_queue.get(timeout=0.02)
            except Exception:
                continue
            # coalesce quick successive updates
            batch = {sym}
            while True:
                try:
                    more = price_queue.get_nowait()
                    batch.add(more)
                except Exception:
                    break
            for s in batch:
                try:
                    with _price_pending_lock:
                        _price_pending.discard(s)
                except Exception:
                    pass
                cached = symbol_prices.get(s)
                if not cached:
                    continue
                latest_price = cached.get('price') if isinstance(cached, dict) else cached
                if latest_price is None:
                    continue

                # adaptive adjustments if available
                try:
                    if 'apply_retracement_tightening' in globals():
                        apply_retracement_tightening(s)
                except Exception:
                    pass

                # fast-approach protection
                try:
                    with positions_lock:
                        pos = open_positions.get(s)
                        if pos:
                            try:
                                fast = False
                                # fast-approach check removed
                                if fast:
                                    if not pos.get('fast_override', False):
                                        pre = pos.get('trailing_percent', pos.get('base_trailing_percent',
                                                                                  pos.get('trailing_percent', 0.0)))
                                        new_trail = min(pos.get('max_approach_percent', pre * FAST_WIDEN_MULTIPLIER),
                                                        pre * FAST_WIDEN_MULTIPLIER)
                                        log_message(
                                            f"[FAST-APPROACH] {s}: old_trailing={pre:.4f}, new_trailing={new_trail:.4f}, multiplier={FAST_WIDEN_MULTIPLIER}, max_approach={pos.get('max_approach_percent', 'N/A')}, cooldown={pos.get('fast_cooldown_s', 5)}s, time={time.strftime('%H:%M:%S')}")
                                        pos['pre_fast_trail'] = pre
                                        pos['trailing_percent'] = new_trail
                                        pos['fast_override'] = True
                                        pos['fast_override_ts'] = time.time() + pos.get('fast_cooldown_s', 5)
                                        open_positions[s] = pos
                                else:
                                    if pos.get('fast_override', False) and time.time() > pos.get('fast_override_ts', 0):
                                        orig_trail = pos.get('pre_fast_trail', pos.get('base_trailing_percent',
                                                                                       pos.get('trailing_percent',
                                                                                               0.0)))
                                        pos['trailing_percent'] = orig_trail
                                        pos['fast_override'] = False
                                        pos.pop('pre_fast_trail', None)
                                        pos.pop('fast_override_ts', None)
                                        open_positions[s] = pos
                            except Exception:
                                pass
                except Exception:
                    pass

                # submit trailing stop check
                try:
                    if 'trailing_stop_check' in globals():
                        _PRICE_EXECUTOR.submit(trailing_stop_check, s, latest_price)
                except Exception:
                    try:
                        if 'trailing_stop_check' in globals():
                            trailing_stop_check(s, latest_price)
                    except Exception:
                        pass
        except Exception as e:
            try:
                log_message('PriceProcessor error: %s' % (e,))
                log_message(traceback.format_exc())
            except Exception:
                pass


# Start the processor thread (daemon) — safe to call multiple times (guarded by _price_worker_running)
try:
    if not _price_worker_running:
        threading.Thread(target=_price_processor_loop, daemon=True).start()
except Exception:
    pass

# ------------------ End price processor ------------------

subscribed_symbols = set()
ws_symbol_sockets = {}
user_socket_key = None

# ------------------- New runtime trackers -------------------
consecutive_losses = 0  # how many closed trades in a row were losing
trading_paused_until = 0  # epoch seconds; if time.time() < trading_paused_until -> no new entries
last_balance_snapshot = None
last_close_log_meta = {}  # symbol -> (ts, pnl_delta) to deduplicate close logs
last_balance_log_meta = {}  # symbol -> (ts, balance) to deduplicate balance logs
_last_closed_balance_call_meta = {}  # (symbol, pnl_delta_rounded) -> last_ts to deduplicate wrapper calls


def _build_trade_journal_entry_from_close(symbol, pnl_delta=None):
    sym = (symbol or "").upper()
    entry_price = None
    entry_ts = None
    close_price = None
    close_ts = None
    side_state = None
    trade_id = None
    qty_val = None

    try:
        with last_close_entry_lock:
            cached_entry = (last_close_entry_cache.get(sym) or {}).copy()
    except Exception:
        cached_entry = {}
    if cached_entry:
        entry_price = cached_entry.get('entry_price')
        entry_ts = cached_entry.get('entry_ts')
        side_state = cached_entry.get('side')
        trade_id = cached_entry.get('trade_id')

    try:
        pos = pos_get(sym) or {}
        if entry_price in (None, 0, 0.0, ''):
            entry_price = pos.get('entry_price')
        if not side_state:
            side_state = _norm_side(pos.get('side'))
        try:
            qty_val = float(pos.get('qty') or 0.0)
        except Exception:
            qty_val = None
    except Exception:
        pass

    entry_event = None
    try:
        if trade_id is None:
            trade_id = _chart_trade_current_id(sym)
        entry_event = _chart_trade_find_entry_event(sym, trade_id)
    except Exception:
        entry_event = None
    if (entry_price in (None, 0, 0.0, '')) and entry_event:
        try:
            entry_price = float(entry_event.get('price') or 0.0)
        except Exception:
            entry_price = None
    if entry_ts is None and entry_event:
        try:
            entry_ts = float(entry_event.get('ts') or 0.0) or None
        except Exception:
            entry_ts = None
    if not side_state and entry_event:
        ev_side = str(entry_event.get('side') or '').upper()
        if ev_side == 'BUY':
            side_state = 'LONG'
        elif ev_side == 'SELL':
            side_state = 'SHORT'

    try:
        with last_close_fill_lock:
            close_price, close_ts = (last_close_fill_cache.get(sym) or (None, None))
    except Exception:
        close_price, close_ts = (None, None)
    close_event = None
    try:
        close_event = _chart_trade_find_close_event(sym, trade_id)
    except Exception:
        close_event = None
    if (close_price in (None, 0, 0.0, '')) and close_event:
        try:
            close_price = float(close_event.get('price') or 0.0)
        except Exception:
            close_price = None
    if close_ts is None and close_event:
        try:
            close_ts = float(close_event.get('ts') or 0.0) or None
        except Exception:
            close_ts = None
    if close_ts is None:
        close_ts = time.time()
    if entry_ts is None:
        entry_ts = close_ts

    side_norm = _norm_side(side_state)
    pnl_pct = None
    pnl_abs = None
    try:
        ep = float(entry_price or 0.0)
        cp = float(close_price or 0.0)
        if ep > 0 and cp > 0:
            if side_norm == 'SHORT':
                pnl_pct = ((ep - cp) / ep) * 100.0
            else:
                pnl_pct = ((cp - ep) / ep) * 100.0
            if qty_val is not None and qty_val > 0:
                if side_norm == 'SHORT':
                    pnl_abs = (ep - cp) * qty_val
                else:
                    pnl_abs = (cp - ep) * qty_val
    except Exception:
        pnl_pct = None
        pnl_abs = None

    if pnl_abs is None and pnl_delta is not None:
        try:
            pnl_abs = float(pnl_delta)
        except Exception:
            pnl_abs = pnl_delta

    hold_min = None
    try:
        if entry_ts and close_ts:
            hold_min = max(0.0, (float(close_ts) - float(entry_ts)) / 60.0)
    except Exception:
        hold_min = None

    entry = {
        'ts': float(close_ts or time.time()),
        'symbol': sym,
        'side': side_norm or side_state,
        'qty': qty_val,
        'entry': entry_price,
        'exit': close_price,
        'pnl_abs': pnl_abs,
        'pnl_pct': pnl_pct,
        'hold_min': hold_min,
    }
    if pnl_delta is not None:
        entry['pnl_net'] = pnl_delta
    return entry


def record_trade_journal_from_close(symbol, pnl_delta=None):
    try:
        entry = _build_trade_journal_entry_from_close(symbol, pnl_delta=pnl_delta)
    except Exception:
        entry = None
    if not entry:
        return None
    return record_trade_journal_entry(entry)



# ----------------- Post-trade actions sequencer (prevents freeze bursts) -----------------
_post_trade_actions_q = Queue()
_post_trade_actions_started = False
_post_trade_actions_lock = threading.Lock()

def _post_trade_actions_worker_loop():
    while not shutdown_event.is_set():
        try:
            item = _post_trade_actions_q.get(timeout=0.25)
        except Exception:
            continue
        try:
            name, func, args, kwargs = item
            try:
                func(*args, **kwargs)
            except Exception as e:
                try:
                    log_message(f"⚠️ Post-trade action '{name}' failed: {e}")
                except Exception:
                    pass
        finally:
            try:
                _post_trade_actions_q.task_done()
            except Exception:
                pass
            try:
                gap = float(globals().get("POST_TRADE_ACTION_GAP_SEC", 0.12) or 0.0)
            except Exception:
                gap = 0.12
            if gap > 0:
                try:
                    time.sleep(min(0.5, max(0.0, gap)))
                except Exception:
                    pass

def submit_post_trade_action(name, func, *args, **kwargs):
    """Run heavy post-trade tasks sequentially to avoid UI stalls."""
    try:
        serial = bool(globals().get("POST_TRADE_ACTIONS_SERIAL", True))
    except Exception:
        serial = True
    if not serial:
        try:
            threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True).start()
        except Exception:
            try:
                func(*args, **kwargs)
            except Exception:
                pass
        return
    global _post_trade_actions_started
    try:
        with _post_trade_actions_lock:
            if not _post_trade_actions_started:
                t = threading.Thread(target=_post_trade_actions_worker_loop, daemon=True)
                t.start()
                _post_trade_actions_started = True
    except Exception:
        pass
    try:
        _post_trade_actions_q.put_nowait((name, func, args, kwargs))
    except Exception:
        # if queue is somehow unavailable, run in background thread
        try:
            threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True).start()
        except Exception:
            pass


def safe_on_position_closed_balance_log(symbol, pnl_delta=None):
    """
    Thin wrapper over on_position_closed_balance_log with extra dedup layer,
    so якщо її викликають кілька разів підряд з однаковими даними,
    баланс/PNL не логуються дублями.
    """
    try:
        key = (symbol, None if pnl_delta is None else round(float(pnl_delta or 0.0), 8))
    except Exception:
        key = (symbol, None)
    now_ts = time.time()
    try:
        global _last_closed_balance_call_meta
        prev_ts = None
        if isinstance(_last_closed_balance_call_meta, dict):
            prev_ts = _last_closed_balance_call_meta.get(key)
        else:
            _last_closed_balance_call_meta = {}
        if prev_ts is not None and (now_ts - float(prev_ts)) < 1.0:
            # duplicate call for same symbol/pnl within 1s -> skip
            return
        _last_closed_balance_call_meta[key] = now_ts
    except Exception:
        # on any error, fall back to direct call
        pass
    submit_post_trade_action(f"close_balance_log:{symbol}", on_position_closed_balance_log, symbol, pnl_delta=pnl_delta)


def on_position_closed_balance_log(symbol, pnl_delta=None):
    """Centralized balance & PnL logging + Telegram + loss streak handling."""
    global consecutive_losses, trading_paused_until, last_balance_snapshot, last_close_log_meta
    try:
        _pos_event_mark_closed(symbol)
    except Exception:
        pass
    new_balance = None
    try:
        new_balance = get_balance()
    except Exception as e:
        log_message(f"⚠️ Не вдалося отримати баланс після угоди: {e}")
    if new_balance is not None:
        should_log_balance = True
        try:
            should_log_balance, _cycle = _pos_event_try_mark(symbol, 'balance_logged_cycle')
        except Exception:
            should_log_balance = True
        if should_log_balance:
            bal_msg = f"💰 Баланс після угоди : {new_balance:.6f}|(Апі SC)"
            log_message(bal_msg)

    if pnl_delta is None:
        try:
            if last_balance_snapshot is not None and new_balance is not None:
                pnl_delta = new_balance - last_balance_snapshot
            last_balance_snapshot = None
        except Exception:
            pnl_delta = None
            last_balance_snapshot = None
    else:
        last_balance_snapshot = None

    if pnl_delta is None:
        return

    try:
        record_trade_journal_from_close(symbol, pnl_delta=pnl_delta)
    except Exception:
        pass

    try:
        try:
            should_process, _cycle = _pos_event_try_mark(symbol, 'pnl_processed_cycle')
            if not should_process:
                return
        except Exception:
            pass

        if pnl_delta < -1e-9:
            consecutive_losses += 1
            loss_msg = f"📉 Реалізований збиток (net): {pnl_delta:.6f} USDT | Лосів підряд = {consecutive_losses}"
            log_message(loss_msg)
            try:
                try:
                    ban_min = int(globals().get("LOSS_CLOSE_BAN_MINUTES", 240) or 0)
                except Exception:
                    ban_min = 240
                if ban_min > 0:
                    ban_symbol(symbol, ban_min * 60)
                    log_message(f"⛔ Symbol {symbol} additionally banned for {ban_min}m due to losing close")
            except Exception:
                pass
        else:
            consecutive_losses = 0
            profit_msg = f"📈 Реалізований прибуток (net): {pnl_delta:.6f} USDT |"
            log_message(profit_msg)

        try:
            if CONSECUTIVE_LOSS_PROTECTION and consecutive_losses >= int(CONSECUTIVE_LOSS_PROTECTION):
                trading_paused_until = max(trading_paused_until, time.time() + CONSECUTIVE_LOSS_H * 60)
                log_message(
                    f"ℹ️ CONSECUTIVE_LOSS_PROTECTION спрацював: {consecutive_losses} лосів поспіль : пауза {CONSECUTIVE_LOSS_H} год")
                consecutive_losses = 0
        except Exception as e:
            log_message(f"⚠️ Помилка при обробці CONSECUTIVE_LOSS_PROTECTION: {e}")
        try:
            if bool(globals().get("TELEGRAM_LEVEL_SCREENSHOT_ENABLED", True)):
                trade_id = _chart_trade_current_id(symbol)
                try:
                    entry_price = None
                    entry_ts = None
                    side_state = None
                    close_price = None
                    close_ts = None
                    try:
                        with last_close_entry_lock:
                            cached_entry = (last_close_entry_cache.get(symbol) or {}).copy()
                    except Exception:
                        cached_entry = {}
                    if cached_entry:
                        entry_price = cached_entry.get('entry_price')
                        entry_ts = cached_entry.get('entry_ts')
                        side_state = cached_entry.get('side')
                        if not trade_id:
                            trade_id = cached_entry.get('trade_id')
                    if not entry_price:
                        try:
                            pos = pos_get(symbol) or {}
                            entry_price = pos.get('entry_price')
                            if not side_state:
                                side_state = _norm_side(pos.get('side'))
                        except Exception:
                            pass
                    entry_event = None
                    try:
                        entry_event = _chart_trade_find_entry_event(symbol, trade_id)
                    except Exception:
                        entry_event = None
                    if (not entry_price) and entry_event:
                        try:
                            entry_price = float(entry_event.get('price') or 0.0)
                        except Exception:
                            entry_price = None
                    if (not side_state) and entry_event:
                        ev_side = str(entry_event.get('side') or '').upper()
                        if ev_side == 'BUY':
                            side_state = 'LONG'
                        elif ev_side == 'SELL':
                            side_state = 'SHORT'
                    if entry_ts is None and entry_event:
                        try:
                            entry_ts = float(entry_event.get('ts') or 0.0) or None
                        except Exception:
                            entry_ts = None
                    try:
                        with last_close_fill_lock:
                            close_price, close_ts = (last_close_fill_cache.get(symbol) or (None, None))
                    except Exception:
                        close_price, close_ts = None, None
                    close_event = None
                    try:
                        close_event = _chart_trade_find_close_event(symbol, trade_id)
                    except Exception:
                        close_event = None
                    if (not close_price) and close_event:
                        try:
                            close_price = float(close_event.get('price') or 0.0)
                        except Exception:
                            close_price = None
                    if close_ts is None and close_event:
                        try:
                            close_ts = float(close_event.get('ts') or 0.0) or None
                        except Exception:
                            close_ts = None
                    if not side_state and close_event:
                        ev_side = str(close_event.get('side') or '').upper()
                        if ev_side == 'SELL':
                            side_state = 'LONG'
                        elif ev_side == 'BUY':
                            side_state = 'SHORT'
                    if not close_price:
                        try:
                            close_price = float(get_last_price(symbol) or 0.0)
                        except Exception:
                            close_price = None
                    if close_ts is None:
                        close_ts = time.time()
                    if entry_ts is None:
                        entry_ts = close_ts
                    try:
                        ep = float(entry_price or 0.0)
                        cp = float(close_price or 0.0)
                    except Exception:
                        ep, cp = 0.0, 0.0
                    if ep > 0 and cp > 0:
                        # Ensure CLOSE marker exists so exit triangle is visible on chart screenshots
                        try:
                            if not close_event:
                                close_side = 'BUY' if side_state == 'SHORT' else 'SELL'
                                chart_trade_record_event(symbol, close_side, cp, ts=close_ts, kind='CLOSE', trade_id=trade_id)
                                close_event = {'ts': close_ts, 'price': cp, 'side': close_side, 'kind': 'CLOSE', 'trade_id': int(trade_id or 0)}
                        except Exception:
                            pass
                        pct = ((cp - ep) / ep) * 100.0
                        if side_state == 'SHORT':
                            pct = -pct
                        chart_trade_record_close_line(
                            symbol,
                            entry_price=ep,
                            entry_ts=entry_ts,
                            close_price=cp,
                            close_ts=close_ts,
                            pct_val=pct,
                            trade_id=trade_id,
                        )
                    try:
                        delay_sec = float(globals().get("TELEGRAM_LEVEL_SCREENSHOT_DELAY_SEC", 2.5) or 2.5)
                    except Exception:
                        delay_sec = 2.5
                    if delay_sec < 0:
                        delay_sec = 0.0
                    shot_timeout = globals().get("TELEGRAM_LEVEL_SCREENSHOT_TIMEOUT", 4.0)

                    def _shot_worker(_symbol=symbol, _trade_id=trade_id, _pnl=pnl_delta, _balance=new_balance):
                        try:
                            if _trade_id:
                                chart_trade_set_focus(_symbol, _trade_id)
                            shot_path = request_chart_screenshot(
                                _symbol,
                                None,
                                timeout=shot_timeout,
                                clear_level=True,
                                clear_markers=False,
                                priority='high',
                                fast=True,
                                fullscreen=False,
                            )
                            if shot_path:
                                caption = f"{_symbol} закрито | Збиток/Профіт: {_pnl:+.6f} USDT"
                                if _balance is not None:
                                    caption += f" | Баланс: {_balance:.6f} USDT"
                                send_telegram_photo_async(shot_path, caption=caption, pin=True)
                        finally:
                            chart_trade_set_focus(_symbol, None)

                    if delay_sec > 0:
                        threading.Timer(delay_sec, _shot_worker).start()
                    else:
                        _shot_worker()
                finally:
                    pass
        except Exception:
            pass
    except Exception:
        pass
# ------------------- Client та синхронізація часу -------------------
client = Client(API_KEY, API_SECRET)
time_offset = 0

# ------------------- Manual Futures User Stream (BanV2-style) -------------------
# Lightweight user data stream using listenKey + websocket-client without ThreadedWebsocketManager.
_user_listen_key = None
_user_ws_thread = None
_user_ws_stop = threading.Event()
_user_ws_lock = threading.RLock()
_user_ws_connected = False
_user_keepalive_thread = None
_user_manual_started = False
_user_manual_start_logged = False

def _get_listen_key() -> str | None:
    try:
        resp = client.futures_stream_get_listen_key()
        key = None
        try:
            if isinstance(resp, dict):
                key = resp.get('listenKey') or resp.get('listen_key') or resp.get('listenkey')
            elif isinstance(resp, str):
                key = resp.strip().strip('"')
        except Exception:
            key = None
        if not key:
            log_message(f"⚠️ futures_stream_get_listen_key returned unexpected payload: {resp}")
        return key
    except Exception as e:
        try:
            _set_connection_state(False)
        except Exception:
            pass
        log_message(f"❌ listenKey request failed: {e}")
        return None


def _user_ws_url(listen_key: str) -> str:
    return f"wss://fstream.binance.com/ws/{listen_key}"


def _user_ws_run(listen_key: str):
    global _user_ws_connected, LAST_WS_MESSAGE_TS, LAST_USER_WS_MESSAGE_TS
    try:
        try:
            import websocket
        except Exception:
            log_message("❌ websocket-client not installed; falling back to REST-only mode")
            return

        def on_open(ws):
            nonlocal listen_key
            global _user_ws_connected
            _user_ws_connected = True
            try:
                _set_connection_state(True)
            except Exception:
                pass

        def on_message(ws, message):
            try:
                obj = json.loads(message)
            except Exception:
                return
            try:
                LAST_WS_MESSAGE_TS = time.time()
                LAST_USER_WS_MESSAGE_TS = LAST_WS_MESSAGE_TS
            except Exception:
                pass
            try:
                if isinstance(obj, dict):
                    _handle_user_message(obj)
            except Exception:
                try:
                    log_message("⚠️ user WS message handler error\n" + traceback.format_exc())
                except Exception:
                    pass

        def on_error(ws, err):
            try:
                _set_connection_state(False)
            except Exception:
                pass

        def on_close(ws, code, reason):
            nonlocal listen_key
            global _user_ws_connected
            _user_ws_connected = False
            try:
                _set_connection_state(False)
            except Exception:
                pass

        ws_app = websocket.WebSocketApp(
            _user_ws_url(listen_key),
            on_open=on_open,
            on_message=on_message,
            on_error=on_error,
            on_close=on_close,
        )

        # run_forever will block until stop; give it ping to keep TCP alive
        while not _user_ws_stop.is_set():
            try:
                ws_app.run_forever(ping_interval=20, ping_timeout=10)
            except Exception as e:
                try:
                    _set_connection_state(False)
                except Exception:
                    pass
            # short pause before reconnect loop iteration
            if _user_ws_stop.wait(2.0):
                break
    except Exception:
        try:
            log_message("❌ user WS thread fatal error\n" + traceback.format_exc())
        except Exception:
            pass


def _user_keepalive_loop():
    global _user_listen_key
    # Keep listenKey alive and restart user socket if stale/no messages
    last_keepalive_ts = 0.0
    while not _user_ws_stop.is_set():
        try:
            time.sleep(60)
            if _user_ws_stop.is_set():
                break
            key = _user_listen_key
            # if ws not connected, try immediate restart
            try:
                if not _user_ws_connected:
                    _set_connection_state(False)
                    _manual_user_stream_restart()
                    continue
            except Exception:
                pass
            # If never started or lost, try to (re)start
            if not key:
                _manual_user_stream_start()
                continue
            # Keepalive rarely (default 25 min) to avoid REST lag
            try:
                now_k = time.time()
                ka_interval = float(globals().get('USER_KEEPALIVE_SEC', 1500.0) or 1500.0)
            except Exception:
                now_k = time.time()
                ka_interval = 1500.0
            if (now_k - float(last_keepalive_ts or 0.0)) >= float(ka_interval or 1500.0):
                try:
                    client.futures_stream_keepalive(key)
                    last_keepalive_ts = now_k
                except Exception as e:
                    try:
                        _set_connection_state(False)
                    except Exception:
                        pass
                    _manual_user_stream_restart()
                    continue
            # NOTE: Do NOT restart the manual user stream just because it is quiet.
            # Binance user stream may stay silent for long periods when there are no account events.
            # Restarts are handled only on real disconnect or keepalive error.
        except Exception:
            try:
                _set_connection_state(False)
            except Exception:
                pass


def _manual_user_stream_start():
    """Start manual user data stream if not started."""
    global _user_listen_key, _user_ws_thread, _user_keepalive_thread, _user_manual_started, _user_manual_start_logged
    if not USE_MANUAL_USER_STREAM:
        return False
    with _user_ws_lock:
        if _user_manual_started:
            return True
        _user_ws_stop.clear()
        key = _get_listen_key()
        if not key:
            return False
        _user_listen_key = key
        try:
            t = threading.Thread(target=_user_ws_run, args=(key,), daemon=True)
            t.start()
            _user_ws_thread = t
            if not _user_keepalive_thread or not _user_keepalive_thread.is_alive():
                _user_keepalive_thread = threading.Thread(target=_user_keepalive_loop, daemon=True)
                _user_keepalive_thread.start()
            # Log only once to avoid spam on reconnects/restarts
            try:
                if not _user_manual_start_logged:
                    log_message('🟢 MANUAL USER WS started')
                    _user_manual_start_logged = True
            except Exception:
                pass

            _user_manual_started = True
            return True
        except Exception as e:
            _set_connection_state(False)
            return False


def _manual_user_stream_stop():
    global _user_listen_key, _user_ws_thread, _user_manual_started
    with _user_ws_lock:
        try:
            _user_ws_stop.set()
        except Exception:
            pass
        try:
            if _user_listen_key:
                try:
                    client.futures_stream_close(_user_listen_key)
                except Exception:
                    pass
        except Exception:
            pass
        _user_listen_key = None
        _user_manual_started = False
_user_manual_start_logged = False


def _manual_user_stream_restart(reason: str = ""):
    """Restart manual user data stream (rate-limited)."""
    global _last_user_ws_restart_ts
    now_ts = time.time()
    try:
        cooldown = float(globals().get("USER_WS_RESTART_COOLDOWN_SEC", 15.0) or 15.0)
    except Exception:
        cooldown = 15.0
    try:
        last_ts = float(globals().get("_last_user_ws_restart_ts", 0.0) or 0.0)
    except Exception:
        last_ts = 0.0
    if last_ts and (now_ts - last_ts) < cooldown:
        return
    globals()["_last_user_ws_restart_ts"] = now_ts
    with _user_ws_lock:
        _manual_user_stream_stop()
        # short backoff
        try:
            time.sleep(1.0)
        except Exception:
            pass
        _manual_user_stream_start()

# --- centralized file logging (replace existing log_message definitions with this) ---

_log_file_lock = threading.Lock()

# Prefixes of log messages that should also be forwarded to Telegram.
# Keep this list minimal to avoid TG spam; key events are sent explicitly (candidate/ENTRY/SL/PNL).
TELEGRAM_FORWARD_PREFIXES: tuple[str, ...] = (
    "🔦 Монітор дистанції",
    "❌ Ордер",
    "❌ Post-place check: cancelled pending order",
)


def _maybe_forward_log_to_telegram(full_line: str, raw_msg: str) -> None:
    try:
        if not TELEGRAM_FORWARD_PREFIXES:
            return
        msg_text = str(raw_msg or "")
        if "Монітор дистанції" in msg_text:
            return
        if "Volume(5h)" in msg_text and "Levels:" in msg_text:
            return
        matched = any(msg_text.startswith(prefix) for prefix in TELEGRAM_FORWARD_PREFIXES)
        if not matched:
            return
        tg_sender = globals().get('send_telegram_message')
        if callable(tg_sender):
            tg_sender(full_line)
    except Exception:
        pass


_sound_lock = threading.Lock()
_last_sound_play = {}


def _play_sound(sound_path=None, fallback_freqs=None, key="general"):
    """Centralized sound playback with throttling and fallbacks."""
    if not globals().get("SOUND_ENABLED", True):
        return
    now = time.time()
    try:
        with _sound_lock:
            last = _last_sound_play.get(key, 0)
            if now - last < 1.0:
                return
            _last_sound_play[key] = now
    except Exception:
        pass

    path = None
    try:
        if sound_path:
            candidate = os.path.abspath(sound_path)
            if os.path.exists(candidate):
                path = candidate
    except Exception:
        path = None

    if path:
        try:
            if sys.platform.startswith("win"):
                import winsound
                ok = winsound.PlaySound(path, winsound.SND_FILENAME | winsound.SND_ASYNC)
                if ok:
                    return
            elif sys.platform.startswith("darwin"):
                proc = subprocess.Popen(["afplay", path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                if proc:
                    return
            else:
                proc = subprocess.Popen(["paplay", path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                if proc:
                    return
        except Exception:
            pass

    fallback = fallback_freqs or [(1200, 180), (1600, 180)]
    try:
        if sys.platform.startswith("win"):
            import winsound
            for freq, dur in fallback:
                winsound.Beep(int(freq), int(dur))
        else:
            print("\a", end='', flush=True)
    except Exception:
        pass


def play_trade_open_alert(symbol=None, side=None, qty=None):
    """Play a short sound cue when a new position opens (best-effort, non-blocking)."""
    try:
        _play_sound(
            globals().get("TRADE_OPEN_SOUND_FILE"),
            fallback_freqs=[(1200, 180), (1600, 180)],
            key=f"open:{symbol or ''}"
        )
    except Exception:
        pass


def play_trade_close_alert(symbol=None, side=None, qty=None):
    """Play a short sound cue when a position closes."""
    try:
        _play_sound(
            globals().get("TRADE_CLOSE_SOUND_FILE"),
            fallback_freqs=[(900, 160), (650, 160)],
            key=f"close:{symbol or ''}"
        )
    except Exception:
        pass


def play_trade_open_alert_once(symbol=None, side=None, qty=None) -> bool:
    """Open sound, but only once per position-cycle for this symbol."""
    try:
        should, _cycle = _pos_event_try_mark(symbol, 'open_sound_cycle')
        if not should:
            return False
    except Exception:
        # If dedup state isn't available, fall back to original behavior.
        should = True

    if should:
        try:
            play_trade_open_alert(symbol, side, qty)
        except Exception:
            pass
        return True
    return False


def play_trade_close_alert_once(symbol=None, side=None, qty=None) -> bool:
    """Close sound, but only once per position-cycle for this symbol."""
    try:
        _pos_event_mark_closed(symbol)
    except Exception:
        pass
    try:
        should, _cycle = _pos_event_try_mark(symbol, 'close_sound_cycle')
        if not should:
            return False
    except Exception:
        should = True

    if should:
        try:
            play_trade_close_alert(symbol, side, qty)
        except Exception:
            pass
        return True
    return False


def _get_app_icon():
    try:
        icon_path = globals().get("APP_ICON_FILE")
        if icon_path and os.path.exists(icon_path):
            ico = QIcon(icon_path)
            if not ico.isNull():
                return ico
    except Exception:
        pass
    return None


def _write_log_line_to_file(line: str) -> None:
    try:
        fname = os.path.join(LOG_DIR, time.strftime("logs_%Y-%m-%d.txt"))
        with _log_file_lock:
            with open(fname, "a", encoding="utf-8") as f:
                f.write(line)
    except Exception:
        # never raise from logger
        pass


CONNECTION_LOG_MESSAGES: tuple[str, ...] = (
    "🌐❌ Зєднання розірвано",
    "🌐✔️Зєднання відновлено",
)
SUPPRESS_LOG_PREFIXES: tuple[str, ...] = (
    "[WS]",
    "[PRICE]",
)
SUPPRESS_LOG_SUBSTRINGS: tuple[str, ...] = (
    "Telegram poll error",
    "Помилка синхронізації часу",
    "Не вдалося отримати 5m свічки",
)
NET_ERROR_MARKERS: tuple[str, ...] = (
    "name resolution",
    "getaddrinfo failed",
    "failed to resolve",
    "max retries exceeded",
    "connection aborted",
    "remote disconnected",
    "connection error",
    "new connection error",
    "connection refused",
    "network is unreachable",
    "no route to host",
    "temporarily unavailable",
    "timed out",
    "timeout",
)


def _maybe_mark_disconnected_from_log(txt: str) -> None:
    if not txt:
        return
    if txt in CONNECTION_LOG_MESSAGES:
        return
    try:
        lowered = txt.lower()
        if any(m in lowered for m in NET_ERROR_MARKERS):
            _set_connection_state(False)
    except Exception:
        pass


def _should_suppress_log_message(txt: str) -> bool:
    if not txt:
        return False
    if txt in CONNECTION_LOG_MESSAGES:
        return False
    try:
        if globals().get("_connection_state") is False:
            return True
    except Exception:
        pass
    for prefix in SUPPRESS_LOG_PREFIXES:
        if txt.startswith(prefix):
            return True
    for part in SUPPRESS_LOG_SUBSTRINGS:
        if part in txt:
            return True
    return False


def log_message(msg) -> None:
    """Unified logger: emits to GUI, optional stdout and persistent file."""
    try:
        timestamp = time.strftime('%H:%M:%S')
        line = f"{timestamp} | {msg}"
        # Lightweight filter for very часті [PRICE]-логи: пишемо їх тільки у файл,
        # але не засмічуємо GUI/консоль.
        try:
            txt = str(msg)
            _maybe_mark_disconnected_from_log(txt)
            if _should_suppress_log_message(txt):
                return
            suppress_gui = bool(txt.startswith("[PRICE]"))
        except Exception:
            suppress_gui = False

        try:
            _write_log_line_to_file(line + "\n")
        except Exception:
            pass

        # store to in-memory recent logs
        try:
            recent_logs.append(line)
        except Exception:
            pass

        if not suppress_gui:
            if gui_bus is not None:
                try:
                    gui_bus.log_signal.emit(line)
                except Exception:
                    pass

            if globals().get('LOG_TO_STDOUT', False):
                print(line)

            try:
                _maybe_forward_log_to_telegram(line, msg)
            except Exception:
                pass

    except Exception:
        try:
            print("log_message failure", msg)
        except Exception:
            pass


def _ensure_parent_dir(path: str) -> bool:
    """Create parent directory for the provided file path (if any)."""
    try:
        if not path:
            return False
        directory = os.path.dirname(os.path.abspath(path))
        if directory:
            os.makedirs(directory, exist_ok=True)
        return True
    except Exception as e:
        log_message(f"⚠️ Не вдалося створити директорію для {path}: {e}")
        return False


def save_equity_history_to_file(path: str | None = None) -> bool:
    """Persist equity history list to JSON file."""
    target = path or EQUITY_HISTORY_FILE
    if not target:
        return False
    try:
        _ensure_parent_dir(target)
        tmp_path = target + ".tmp"
        with equity_history_lock:
            payload = list(equity_history)
        with open(tmp_path, "w", encoding="utf-8") as fh:
            json.dump(payload, fh, indent=2, ensure_ascii=False)
            fh.flush()
            os.fsync(fh.fileno())
        os.replace(tmp_path, target)
        return True
    except Exception as e:
        log_message(f"⚠️ Не вдалося зберегти еквіті у {target}: {e}")
        return False


def save_trade_journal_to_file(path: str | None = None) -> bool:
    """Persist trade journal list to JSON file."""
    target = path or TRADE_JOURNAL_FILE
    if not target:
        return False
    try:
        _ensure_parent_dir(target)
        tmp_path = target + ".tmp"
        try:
            payload = list(closed_trades)
        except Exception:
            payload = []
        with open(tmp_path, "w", encoding="utf-8") as fh:
            json.dump(payload, fh, indent=2, ensure_ascii=False)
            fh.flush()
            os.fsync(fh.fileno())
        os.replace(tmp_path, target)
        return True
    except Exception as e:
        log_message(f"[TRADE_JOURNAL] Save failed for {target}: {e}")
        return False


def load_trade_journal_from_file(path: str | None = None, emit_gui: bool = False) -> bool:
    """Load trade journal from file; optionally emit to GUI."""
    target = path or TRADE_JOURNAL_FILE
    if not target or not os.path.exists(target):
        return False
    try:
        with open(target, "r", encoding="utf-8") as fh:
            data = json.load(fh)
    except FileNotFoundError:
        return False
    except Exception as e:
        log_message(f"[TRADE_JOURNAL] Load failed for {target}: {e}")
        return False
    cleaned = []
    if isinstance(data, list):
        for item in data:
            if not isinstance(item, dict):
                continue
            row = dict(item)
            try:
                row["ts"] = float(item.get("ts") or 0.0)
            except Exception:
                row["ts"] = time.time()
            try:
                row["symbol"] = (item.get("symbol") or "").upper()
            except Exception:
                pass
            try:
                row["side"] = str(item.get("side") or "").upper()
            except Exception:
                pass
            try:
                _ensure_trade_journal_tag(row)
            except Exception:
                pass
            try:
                _ensure_trade_journal_uid(row)
            except Exception:
                pass
            for key in ("qty", "entry", "exit", "pnl_abs", "pnl_pct", "pnl_net", "hold_min"):
                if item.get(key) is None:
                    continue
                try:
                    row[key] = float(item.get(key))
                except Exception:
                    pass
            cleaned.append(row)
    try:
        closed_trades.clear()
        closed_trades.extend(cleaned[-closed_trades.maxlen:])
    except Exception:
        pass
    if emit_gui and gui_bus is not None:
        try:
            gui_bus.trade_journal_signal.emit(list(closed_trades))
        except Exception:
            pass
    return True


def save_settings_history_to_file(path: str | None = None) -> bool:
    """Persist settings change history to JSON file."""
    target = path or SETTINGS_HISTORY_FILE
    if not target:
        return False
    try:
        _ensure_parent_dir(target)
        tmp_path = target + ".tmp"
        with settings_history_lock:
            payload = list(settings_history[-SETTINGS_HISTORY_LIMIT:])
        with open(tmp_path, "w", encoding="utf-8") as fh:
            json.dump(payload, fh, indent=2, ensure_ascii=False)
            fh.flush()
            os.fsync(fh.fileno())
        os.replace(tmp_path, target)
        return True
    except Exception:
        return False


def load_equity_history_from_file(path: str | None = None, emit_gui: bool = False) -> bool:
    """Load equity history from file; optionally emit to GUI."""
    global equity_history, last_recorded_equity_balance
    target = path or EQUITY_HISTORY_FILE
    if not target or not os.path.exists(target):
        return False
    try:
        with open(target, "r", encoding="utf-8") as fh:
            data = json.load(fh)
    except FileNotFoundError:
        return False
    except Exception as e:
        log_message(f"⚠️ Не вдалося прочитати еквіті з {target}: {e}")
        return False
    cleaned = []
    for item in data:
        if not isinstance(item, dict):
            continue
        try:
            cleaned.append({
                "ts": float(item.get("ts")),
                "balance": float(item.get("balance")),
                "pnl": float(item.get("pnl", 0.0))
            })
        except Exception:
            continue
    with equity_history_lock:
        equity_history = cleaned[-EQUITY_HISTORY_LIMIT:]
        snapshot = list(equity_history)
    last_recorded_equity_balance = snapshot[-1]["balance"] if snapshot else None
    if emit_gui and gui_bus is not None:
        try:
            gui_bus.equity_signal.emit(snapshot)
        except Exception:
            pass
    return True


def load_settings_history_from_file(path: str | None = None) -> bool:
    """Load persisted settings history (best effort)."""
    global settings_history
    try:
        target = path or SETTINGS_HISTORY_FILE
        if not target or not os.path.exists(target):
            return False
        with open(target, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        if not isinstance(data, list):
            return False
        with settings_history_lock:
            settings_history = data[-SETTINGS_HISTORY_LIMIT:]
        return True
    except Exception:
        return False


def _log_time_sync(msg, level="info"):
    if not WINDOWS_TIME_SYNC_LOGS_ENABLED:
        return
    prefix = "[WIN_TIME]"
    if level == "error":
        log_message(f"{prefix} {msg}")
    else:
        log_message(f"{prefix} {msg}")


def _is_admin():
    if not IS_WINDOWS:
        return False
    try:
        return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except Exception:
        return False


def ensure_admin_rights():
    """Optionally prompt for elevation and relaunch once with --elevated (AUTO_ELEVATE=True)."""
    if not IS_WINDOWS or not AUTO_ELEVATE:
        return
    if '--elevated' in sys.argv:
        return
    try:
        if _is_admin():
            return
    except Exception:
        return
    try:
        exe = sys.executable
        # prefer pythonw.exe to avoid spawning a console on elevation
        try:
            if exe.lower().endswith("python.exe"):
                candidate = exe[:-4] + "w.exe"
                if os.path.exists(candidate):
                    exe = candidate
        except Exception:
            pass
        args = subprocess.list2cmdline(sys.argv + ['--elevated'])
        rc = ctypes.windll.shell32.ShellExecuteW(None, 'runas', exe, args, None, 1)
        if int(rc) <= 32:
            _log_time_sync(f'Admin elevation failed rc={rc}')
            return
        sys.exit(0)
    except Exception as exc:
        _log_time_sync(f'Admin elevation error: {exc}', level='error')


def _run_time_sync_cmd(cmd, timeout=30):
    try:
        kwargs = dict(capture_output=True, text=True, timeout=timeout)
        if os.name == "nt":
            kwargs["creationflags"] = subprocess.CREATE_NO_WINDOW
        proc = subprocess.run(cmd, **kwargs)
        stdout = proc.stdout.strip() if proc.stdout else ""
        stderr = proc.stderr.strip() if proc.stderr else ""
        return proc.returncode, stdout, stderr
    except Exception as exc:
        return -1, "", str(exc)


def sync_windows_time_once():
    _log_time_sync("Attempting w32tm /resync")
    rc, out, err = _run_time_sync_cmd(["w32tm", "/resync"])
    _log_time_sync(f"Initial resync rc={rc} out='{out}' err='{err}'")
    if rc == 0:
        return True, "Resync ok"

    cmds = [
        ("config", ["w32tm", "/config", "/manualpeerlist:pool.ntp.org time.windows.com", "/syncfromflags:manual", "/reliable:yes", "/update"]),
        ("stop", ["net", "stop", "w32time"]),
        ("start", ["net", "start", "w32time"])
    ]
    for name, cmd in cmds:
        rc2, out2, err2 = _run_time_sync_cmd(cmd)
        _log_time_sync(f"{name}: rc={rc2} out='{out2}' err='{err2}'")
        time.sleep(0.5)

    time.sleep(1)
    rc3, out3, err3 = _run_time_sync_cmd(["w32tm", "/resync", "/rediscover"])
    _log_time_sync(f"Resync after config rc={rc3} out='{out3}' err='{err3}'")
    if rc3 == 0:
        return True, "Resync ok after config"

    rc_sc, out_sc, err_sc = _run_time_sync_cmd(["w32tm", "/stripchart", "/computer:pool.ntp.org", "/samples:3", "/dataonly"], timeout=10)
    _log_time_sync(f"stripchart rc={rc_sc} out='{out_sc}' err='{err_sc}'")
    return False, f"Failed (rc3={rc3})"


def windows_time_sync_loop():
    global _windows_sync_thread_started
    if not WINDOWS_TIME_SYNC_ENABLED or not IS_WINDOWS:
        return
    if not _is_admin():
        _log_time_sync("Time sync disabled: administrator privileges required", level="error")
        return
    _log_time_sync(f"Windows time sync loop started (interval {WINDOWS_TIME_SYNC_INTERVAL}s)")
    try:
        while WINDOWS_TIME_SYNC_ENABLED and IS_WINDOWS and _is_admin() and not shutdown_event.is_set():
            try:
                ok, msg = sync_windows_time_once()
                if ok:
                    _log_time_sync(f"Time sync OK: {msg}")
                else:
                    _log_time_sync(f"Time sync FAILED: {msg}", level="error")
            except Exception as exc:
                _log_time_sync(f"Exception in time sync loop: {exc}", level="error")
            slept = 0
            while slept < WINDOWS_TIME_SYNC_INTERVAL and not shutdown_event.is_set():
                if not WINDOWS_TIME_SYNC_ENABLED:
                    break
                time.sleep(1)
                slept += 1
    finally:
        _windows_sync_thread_started = False
        _log_time_sync("Windows time sync loop stopped")


def start_windows_time_sync():
    global _windows_sync_thread_started
    _log_time_sync(f"start_windows_time_sync called | enabled={WINDOWS_TIME_SYNC_ENABLED} is_windows={IS_WINDOWS}")
    if not WINDOWS_TIME_SYNC_ENABLED or not IS_WINDOWS:
        if WINDOWS_TIME_SYNC_ENABLED and not IS_WINDOWS:
            _log_time_sync("Time sync disabled: non-Windows platform", level="error")
        return
    if not _is_admin():
        _log_time_sync("Time sync disabled: run the bot as Administrator to enable Windows time sync", level="error")
        return
    with _windows_sync_thread_lock:
        if _windows_sync_thread_started:
            _log_time_sync("Time sync already running, skip start")
            return
        _windows_sync_thread_started = True
    threading.Thread(target=windows_time_sync_loop, daemon=True).start()


def sync_time(force_buffer_ms: int = 0):
    global time_offset
    try:
        server_time = client.futures_time()['serverTime']
        local_time = int(time.time() * 1000)
        time_offset = int(server_time - local_time)
        if force_buffer_ms:
            time_offset -= int(force_buffer_ms)
        try:
            client.timestamp_offset = int(time_offset)
            client.time_offset = int(time_offset)
        except Exception:
            pass
        # Update GUI offset indicator without spам у логах
        try:
            if gui_bus is not None:
                gui_bus.offset_signal.emit(int(time_offset))
        except Exception:
            pass
    except Exception as e:
        try:
            _set_connection_state(False)
        except Exception:
            pass
        log_message(f"❌ Помилка синхронізації часу: {e}")


sync_time()


def time_sync_loop():
    while not shutdown_event.is_set():
        try:
            sync_time()
        except Exception as e:
            log_message(f"❌ Помилка в time_sync_loop: {e}")
        try:
            interval = float(globals().get("PRESTART_TIME_SYNC_SEC", 300.0) or 300.0)
        except Exception:
            interval = 300.0
        if bot_running:
            interval = 30.0
        if interval < 5:
            interval = 5.0
        slept = 0.0
        while slept < interval and not shutdown_event.is_set():
            time.sleep(0.2)
            slept += 0.2


threading.Thread(target=time_sync_loop, daemon=True).start()


def binance_ping_loop():
    while not shutdown_event.is_set():
        start_ts = time.time()
        latency_ms = -1
        try:
            client.futures_ping()
            latency_ms = int((time.time() - start_ts) * 1000)
        except Exception:
            latency_ms = -1
        try:
            if gui_bus is not None:
                gui_bus.ping_signal.emit(int(latency_ms))
        except Exception:
            pass
        try:
            interval = float(globals().get("BINANCE_PING_INTERVAL_SEC", 10) or 10)
        except Exception:
            interval = 10
        try:
            pre_interval = float(globals().get("PRESTART_PING_INTERVAL_SEC", 30.0) or 30.0)
        except Exception:
            pre_interval = 30.0
        if not bot_running:
            interval = pre_interval
        if interval < 2:
            interval = 2
        slept = 0.0
        while slept < interval and not shutdown_event.is_set():
            time.sleep(0.2)
            slept += 0.2




# ------------------- Допоміжна функція: signed wrapper -------------------

def signed_request(func, *args, **kwargs):
    global REST_BACKOFF_UNTIL
    try:
        # Route stop/take-profit orders to algo endpoints if python-binance default is used
        stop_like_types = {'STOP', 'STOP_MARKET', 'TAKE_PROFIT', 'TAKE_PROFIT_MARKET'}
        try:
            if func == client.futures_create_order:
                otype = kwargs.get('type') or (args[0] if args else None)
                if otype in stop_like_types:
                    resp = create_conditional_order(
                        symbol=kwargs.get('symbol') or (args[1] if len(args) > 1 else None),
                        side=kwargs.get('side') or kwargs.get('stop_side') or kwargs.get('order_side'),
                        order_type=otype,
                        quantity=kwargs.get('quantity'),
                        stop_price=kwargs.get('stopPrice'),
                        price=kwargs.get('price'),
                        client_oid=kwargs.get('newClientOrderId'),
                        reduce_only=kwargs.get('reduceOnly', False),
                        position_side=kwargs.get('positionSide', 'BOTH'),
                        time_in_force=kwargs.get('timeInForce', 'GTC'),
                        close_position=kwargs.get('closePosition', False),
                        working_type=kwargs.get('workingType', 'CONTRACT_PRICE')
                    )
                    try:
                        _set_connection_state(True)
                    except Exception:
                        pass
                    return resp
            if func == client.futures_cancel_order:
                sym = kwargs.get('symbol') or (args[0] if args else None)
                oid = kwargs.get('orderId') or (args[1] if len(args) > 1 else None)
                if oid:
                    try:
                        resp = cancel_conditional_order(sym, oid)
                        try:
                            _set_connection_state(True)
                        except Exception:
                            pass
                        return resp
                    except Exception:
                        pass
            if func == client.futures_get_order:
                sym = kwargs.get('symbol') or (args[0] if args else None)
                oid = kwargs.get('orderId') or (args[1] if len(args) > 1 else None)
                try:
                    resp = get_conditional_order(sym, oid)
                    norm = _normalize_algo_order(resp)
                    if norm:
                        try:
                            _set_connection_state(True)
                        except Exception:
                            pass
                        return norm
                except Exception:
                    pass
            if func == client.futures_get_open_orders:
                base = []
                base_ok = True
                try:
                    base = func(*args, **kwargs)
                except Exception:
                    base = []
                    base_ok = False
                try:
                    sym = kwargs.get('symbol')
                    cond = get_open_conditional_orders(sym)
                    normed = [_normalize_algo_order(o) for o in (cond or [])]
                    merged = list(base or [])
                    merged.extend([n for n in normed if n])
                    if base_ok:
                        try:
                            _set_connection_state(True)
                        except Exception:
                            pass
                    return merged
                except Exception:
                    if base_ok:
                        try:
                            _set_connection_state(True)
                        except Exception:
                            pass
                    return base
        except Exception:
            pass
        # Глобальний бекоф: якщо не вийшов час — не чіпаємо REST
        if REST_BACKOFF_UNTIL and time.time() < REST_BACKOFF_UNTIL:
            raise RuntimeError("REST backoff active")
        # Не даємо REST-запитам зависати: виставляємо таймаут за замовчуванням, якщо метод підтримує timeout
        try:
            sig = inspect.signature(func)
            if "timeout" in sig.parameters:
                kwargs.setdefault("timeout", REST_REQUEST_TIMEOUT)
        except Exception:
            # якщо сигнатуру не прочитали — не чіпаємо kwargs
            pass
        resp = func(*args, **kwargs)
        try:
            _set_connection_state(True)
        except Exception:
            pass
        return resp
    except Exception as e:
        err = str(e)
        code = getattr(e, 'code', None)
        try:
            lowered = err.lower()
            net_markers = (
                "name resolution",
                "getaddrinfo failed",
                "failed to resolve",
                "max retries exceeded",
                "connection aborted",
                "remote disconnected",
                "connection error",
                "new connection error",
                "connection refused",
                "network is unreachable",
                "no route to host",
                "temporarily unavailable",
                "timed out",
                "timeout",
            )
            if any(m in lowered for m in net_markers):
                _set_connection_state(False)
        except Exception:
            pass

        # Якщо метод не приймає timeout — повторимо без нього
        if isinstance(e, TypeError) and "unexpected keyword argument" in err and "timeout" in err:
            try:
                kwargs.pop("timeout", None)
                return func(*args, **kwargs)
            except Exception:
                pass

        # Перевищення ліміту запитів (-1003)
        if '-1003' in err or code == -1003:
            REST_BACKOFF_UNTIL = time.time() + REST_ERROR_BACKOFF
            log_message(f"⚠️ REST перевищено: {e} — пауза {REST_ERROR_BACKOFF}s")
            raise

        # Binance повернув HTML-сторінку (код=0, invalid JSON) — схоже на блок/проксі/Cloudflare
        lowered = err.lower()
        html_markers = ("<!doctype html", "<html", "return to binance home page", "the page you")
        if any(m in lowered for m in html_markers) or "invalid json error message from binance" in lowered:
            REST_BACKOFF_UNTIL = time.time() + REST_ERROR_BACKOFF
            log_message(f"⚠️ Binance повернув HTML замість JSON (ймовірно блок / проксі): {e} — бекоф {REST_ERROR_BACKOFF}s")
            raise

        # Помилка часу (-1021) — синхронізуємо й пробуємо ще раз
        if 'timestamp for this request was' in lowered or 'outside of the recvwindow' in lowered or code == -1021:
            log_message("⚠️ Помилка часу від Binance — виконаємо синхронізацію і спробуємо ще раз")
            try:
                sync_time(force_buffer_ms=1200)
            except Exception as se:
                log_message(f"❌ Помилка при sync_time(): {se}")
            try:
                kwargs.update({
                    'timestamp': int(time.time() * 1000 + time_offset),
                    'recvWindow': 60000,
                })
                return func(*args, **kwargs)
            except Exception as e2:
                raise e2

        # Інші помилки передаємо далі як є
        raise


# ------------------- Utility: percent diff (consistent) -------------------

def percent_diff(a, b):
    try:
        if b == 0 or b is None:
            return float('inf')
        return abs(a - b) / float(b)
    except Exception:
        return float('inf')


# ------------------- Баланс -------------------

def get_balance():
    global initial_balance
    try:
        balance_info = signed_request(client.futures_account_balance)
        balance = float(next((b['balance'] for b in balance_info if b['asset'] == 'USDT'), 0))
        if initial_balance is None:
            if balance == 0:
                balance = 0.01
            initial_balance = balance
        return balance
    except Exception as e:
        log_message(f"❌ Помилка get_balance: {e}")
        log_message(traceback.format_exc())
        return initial_balance or 0.0


def _kyiv_now():
    try:
        if ZoneInfo:
            return datetime.now(ZoneInfo("Europe/Kyiv"))
    except Exception:
        pass
    try:
        kyiv_tz = pytz.timezone('Europe/Kiev')
        return datetime.now(pytz.utc).astimezone(kyiv_tz)
    except Exception:
        return datetime.now()


def _seconds_until_next_kyiv_reset(hour=23, minute=55, second=0):
    try:
        now = _kyiv_now()
        target = now.replace(hour=hour, minute=minute, second=second, microsecond=0)
        if now >= target:
            # If we already reset today, schedule for tomorrow to avoid spam
            try:
                if _last_daily_reset_date == now.date():
                    target = target + timedelta(days=1)
                elif (now - target).total_seconds() < 600:
                    # allow a few retries within 10 minutes if not yet reset today
                    return 5.0
                else:
                    target = target + timedelta(days=1)
            except Exception:
                target = target + timedelta(days=1)
        return max(1.0, (target - now).total_seconds())
    except Exception:
        return 60.0


def daily_pnl_reset_loop():
    global initial_balance, current_pnl_percent_display, last_recorded_equity_balance, _last_daily_reset_date
    while not shutdown_event.is_set():
        sleep_for = _seconds_until_next_kyiv_reset(23, 55, 0)
        time.sleep(sleep_for)
        for _ in range(3):
            try:
                bal = get_balance()
                if bal == 0:
                    bal = 0.01
                initial_balance = bal
                current_pnl_percent_display = 0.0
                last_recorded_equity_balance = None
                try:
                    record_equity_point(bal, 0.0)
                except Exception:
                    pass
                log_message("(23:55 Europe/Kyiv).")
                try:
                    now = _kyiv_now()
                    _last_daily_reset_date = now.date()
                except Exception:
                    pass
                break
            except Exception as e:
                try:
                    log_message(f"⚠️ Не вдалося скинути PnL: {e}")
                    log_message(traceback.format_exc())
                except Exception:
                    pass
                time.sleep(30)


def start_daily_pnl_reset():
    global _daily_pnl_reset_started
    if _daily_pnl_reset_started:
        return
    try:
        threading.Thread(target=daily_pnl_reset_loop, daemon=True).start()
        _daily_pnl_reset_started = True
        log_message("⏰ Добовий reset PnL активовано (23:55 Europe/Kyiv).")
    except Exception as e:
        try:
            log_message(f"⚠️ Не вдалося запустити добовий reset PnL: {e}")
        except Exception:
            pass


# ------------------- NATR -------------------

def calculate_natr(symbol, period=None, interval="5m"):
    if period is None:
        period = int(globals().get("NATR_PERIOD", 14))
    try:
        # use 1m klines for NATR per your request
        klines = signed_request(client.futures_klines, symbol=symbol, interval=interval, limit=period + 1)
        if not klines or len(klines) < 2:
            log_message(f"⚠️ NATR {symbol}: insufficient klines (count={0 if not klines else len(klines)})")
            return 0
        highs = [float(k[2]) for k in klines]
        lows = [float(k[3]) for k in klines]
        closes = [float(k[4]) for k in klines]
        tr = [max(highs[i] - lows[i], abs(highs[i] - closes[i - 1]), abs(lows[i] - closes[i - 1])) for i in
              range(1, len(closes))]
        if not tr:
            log_message(f"⚠️ NATR {symbol}: zero TR samples (count={len(klines)})")
            return 0
        atr = sum(tr) / len(tr)
        if closes[-1] == 0:
            log_message(f"⚠️ NATR {symbol}: last close is zero, fallback to 0")
            return 0
        natr = (atr / closes[-1]) * 100
        return natr
    except Exception as e:
        log_message(f"? ⚠️ NATR {symbol}: {e}")
        log_message(traceback.format_exc())
        return 0
# ------------------- Активні ф'ючерси -------------------

def get_active_futures_symbols():
    info = get_exchange_info_cached()
    return [s["symbol"] for s in info["symbols"] if
            s["quoteAsset"] == "USDT" and s["contractType"] == "PERPETUAL" and s["status"] == "TRADING"]


def get_volume_last_hours(symbol, hours=5):
    try:
        klines = signed_request(client.futures_klines, symbol=symbol, interval="1h", limit=hours)
        volume_usdt = sum(float(k[7]) for k in klines)
        return volume_usdt
    except Exception as e:
        log_message(f"❌ Помилка обчислення об'єму {symbol}: {e}")
        log_message(traceback.format_exc())
        return 0


# ------------------- Горизонтальні рівні -------------------


def find_horizontal_levels(symbol, window=None, precision=None, tolerance=None,
                           min_touches=None, min_interval=None, allow_broken=False,
                           return_details=False, apply_distance_filter=True, klines_override=None,
                           debug_rejections=False):
    """
    Find horizontal levels using closed candles to form levels but check breaks using both closed
    and the current (potentially open) candle. First-touch strict-origin enforced on closed bars only.
    Returns: (list_of_(level, origin_tag), local_high, local_low)
    When debug_rejections=True, emits diagnostic logs describing why candidate levels were rejected.
    """
    if window is None:
        window = globals().get("LEVEL_WINDOW", 200)
    if precision is None:
        precision = globals().get("LEVEL_PRECISION", 5)
    if tolerance is None:
        tolerance = globals().get("TOLERANCE", 0.002)
    if min_touches is None:
        min_touches = globals().get("MIN_TOUCHES", 2)
    if min_interval is None:
        min_interval = globals().get("MIN_INTERVAL", 6)
    min_freshness = int(globals().get("MIN_LEVEL_FRESHNESS_BARS", 0) or 0)
    try:
        if klines_override is not None:
            klines = list(klines_override)
        else:
            klines = signed_request(client.futures_klines, symbol=symbol, interval="5m", limit=window)
        if not klines or len(klines) < 2:
            return [], None, None

        # closed_count: number of already-closed klines used to form levels
        closed_count = max(1, len(klines) - 1)

        opens = [float(k[1]) for k in klines]
        highs = [float(k[2]) for k in klines]
        lows = [float(k[3]) for k in klines]
        closes = [float(k[4]) for k in klines]

        opens_c = opens[:closed_count]
        highs_c = highs[:closed_count]
        lows_c = lows[:closed_count]
        closes_c = closes[:closed_count]

        DOJI_REL_THRESH = 0.02

        def is_bullish_c(i):
            rng = highs_c[i] - lows_c[i]
            if rng <= 0:
                rng = 1e-12
            body = closes_c[i] - opens_c[i]
            if abs(body) / rng < DOJI_REL_THRESH:
                return False
            return body > 0

        def is_bearish_c(i):
            rng = highs_c[i] - lows_c[i]
            if rng <= 0:
                rng = 1e-12
            body = closes_c[i] - opens_c[i]
            if abs(body) / rng < DOJI_REL_THRESH:
                return False
            return body < 0

        # cluster candidate points using closed highs/lows
        all_points = highs_c + lows_c
        all_points_rounded = [round(p, precision) for p in all_points]
        clusters = {}
        for p in all_points_rounded:
            added = False
            for c in list(clusters.keys()):
                try:
                    if abs(p - c) / c <= tolerance:
                        clusters[c].append(p)
                        added = True
                        break
                except Exception:
                    if abs(p - c) <= tolerance:
                        clusters[c].append(p)
                        added = True
                        break
            if not added:
                clusters[p] = [p]

        def _enforce_spacing(indices):
            filtered = []
            for idx in indices:
                if not filtered or idx - filtered[-1] >= min_interval:
                    filtered.append(idx)
            return filtered


        def _log_rejection(reason):
            if not debug_rejections:
                return

        def _build_entry(lvl, indices, is_support):
            if len(indices) < min_touches:
                _log_rejection(
                    f"lvl={lvl:.6f} {'support' if is_support else 'resistance'} rejected: "
                    f"touches after spacing {len(indices)} < min_touches={min_touches}"
                )
                return None

            if min_freshness > 0:
                # вимірюємо свіжість від останнього ЗАКРИТОГО бару
                bars_since_last = (closed_count - 1) - indices[-1]
                if bars_since_last < min_freshness:
                    _log_rejection(
                        f"lvl={lvl:.6f} rejected: bars_since_last={bars_since_last} < min_level_freshness_bars={min_freshness}"
                    )
                    return None

            # Anchor the level to wick extremes across candidate touches (avoid averaging to bodies)
            try:
                lvl_wick = min(lows_c[i] for i in indices) if is_support else max(highs_c[i] for i in indices)
            except Exception:
                return None

            norm_local = max(abs(lvl_wick), 1e-12)
            lower_bound = lvl_wick * (1 - tolerance)
            upper_bound = lvl_wick * (1 + tolerance)

            # reject if price already broke the band between consecutive touches
            validated = [indices[0]]
            for idx in indices[1:]:
                broken_between = False
                for i in range(validated[-1] + 1, idx + 1):
                    if i >= len(highs):
                        break
                    cur_h = highs[i]
                    cur_l = lows[i]
                    if is_support:
                        if cur_l < lower_bound:
                            broken_between = True
                            break
                    else:
                        if cur_h > upper_bound:
                            broken_between = True
                            break
                if broken_between:
                    _log_rejection(
                        f"lvl={lvl:.6f} {'support' if is_support else 'resistance'} rejected: "
                        f"broken between touches (last_idx={validated[-1]}, idx={idx})"
                    )
                    return None
                validated.append(idx)

            indices = validated
            if len(indices) < min_touches:
                _log_rejection(
                    f"lvl={lvl:.6f} {'support' if is_support else 'resistance'} rejected: "
                    f"touches after validation {len(indices)} < min_touches={min_touches}"
                )
                return None

            def _touch_matches(idx):
                if is_support:
                    touches_low = (abs(lows_c[idx] - lvl_wick) / norm_local) <= tolerance
                    # For support (below price), first valid touch must be a bearish (red) candle wick
                    return touches_low and is_bearish_c(idx)
                touches_high = (abs(highs_c[idx] - lvl_wick) / norm_local) <= tolerance
                # For resistance (above price), first valid touch must be a bullish (green) candle wick
                return touches_high and is_bullish_c(idx)

            first_valid_idx = None
            for idx in indices:
                if _touch_matches(idx):
                    first_valid_idx = idx
                    break

            if first_valid_idx is None:
                _log_rejection(
                    f"lvl={lvl:.6f} {'support' if is_support else 'resistance'} rejected: "
                    f"no valid {'bearish' if is_support else 'bullish'} touch found among {len(indices)} touches"
                )
                return None

            post_indices = [idx for idx in indices if idx >= first_valid_idx]
            if len(post_indices) < min_touches:
                _log_rejection(
                    f"lvl={lvl:.6f} {'support' if is_support else 'resistance'} rejected: "
                    f"only {len(post_indices)} touches at/after first valid (require {min_touches})"
                )
                return None

            start_i = first_valid_idx + 1
            broken = False
            for i in range(start_i, len(highs)):
                cur_h = highs[i]
                cur_l = lows[i]
                if is_support:
                    if cur_l < lower_bound:
                        broken = True
                        break
                else:
                    if cur_h > upper_bound:
                        broken = True
                        break
            if broken and not allow_broken:
                _log_rejection(
                    f"lvl={lvl:.6f} {'support' if is_support else 'resistance'} rejected: "
                    f"broken after first valid touch (allow_broken={allow_broken})"
                )
                return None

            try:
                first_touch_ts = float(klines[first_valid_idx][0]) / 1000.0
            except Exception:
                first_touch_ts = None

            # Snap level to the wick extreme (not body) across touches
            level_value = lvl_wick

            meta = {
                'support': is_support,
                'role': 'support' if is_support else 'resistance',
                'touch_indices': post_indices[:],
                'first_touch_index': first_valid_idx,
                'first_touch_ts': first_touch_ts,
                'broken': broken,
                'level_value': level_value
            }
            return meta

        level_entries = []
        for lvl, _ in clusters.items():
            norm = max(abs(lvl), 1e-12)

            low_touch_indices = [i for i in range(closed_count)
                                 if abs(lows_c[i] - lvl) / norm <= tolerance]
            low_touch_indices = _enforce_spacing(low_touch_indices)

            high_touch_indices = [i for i in range(closed_count)
                                  if abs(highs_c[i] - lvl) / norm <= tolerance]
            high_touch_indices = _enforce_spacing(high_touch_indices)

            support_meta = _build_entry(lvl, low_touch_indices, True) if low_touch_indices else None
            resistance_meta = _build_entry(lvl, high_touch_indices, False) if high_touch_indices else None

            if support_meta:
                lvl_s = support_meta.get('level_value', lvl)
                if return_details:
                    level_entries.append((lvl_s, 'support', support_meta))
                else:
                    level_entries.append((lvl_s, 'support'))
            if resistance_meta:
                lvl_r = resistance_meta.get('level_value', lvl)
                if return_details:
                    level_entries.append((lvl_r, 'resistance', resistance_meta))
                else:
                    level_entries.append((lvl_r, 'resistance'))

        if not level_entries:
            return [], None, None

        # Filter by dynamic distance to reference price (current price when live).
        max_level_distance = get_dynamic_max_level_distance(symbol, closes_c)
        price_ref = None
        ref_label = "останнє закриття"
        if klines_override is None:
            try:
                cached = symbol_prices.get(symbol)
                price_ref = cached['price'] if cached and (
                        time.time() - cached.get('ts', 0)) <= PRICE_STALE_SEC else None
            except Exception:
                price_ref = None
            if price_ref is None:
                try:
                    price_ref = get_last_price(symbol)
                except Exception:
                    price_ref = None
            if price_ref is not None:
                ref_label = "поточна ціна"
        if price_ref is None:
            try:
                price_ref = closes_c[-1]
            except Exception:
                price_ref = None
        try:
            price_ref = float(price_ref)
        except Exception:
            price_ref = closes_c[-1] if closes_c else None

        # Throttled debug logging
        try:
            _lvl_log_ts = getattr(find_horizontal_levels, '_lvl_log_ts', {})
            last_ts = _lvl_log_ts.get(symbol, 0)
            now_ts = time.time()
            if now_ts - last_ts >= 30.0:
                _lvl_log_ts[symbol] = now_ts
                setattr(find_horizontal_levels, '_lvl_log_ts', _lvl_log_ts)
                should_log = True
                try:
                    if globals().get('trading_paused_until') and now_ts < float(globals().get('trading_paused_until', 0)):
                        should_log = False
                    if not globals().get('bot_running', False):
                        should_log = False
                except Exception:
                    pass
                if should_log:
                    try:
                        sample_lvls = ','.join([f"{l[0]:.6f}" for l in level_entries[:6]])
                    except Exception:
                        sample_lvls = str(level_entries)
                    try:
                        log_message(
                            f"🖥️ Дані кандидата для [{symbol}]: Допустима дистанція ціни від рівня={max_level_distance:.4%}, {ref_label} ={price_ref:.8f}, кандидат ={sample_lvls}")
                    except Exception:
                        pass
        except Exception:
            pass

        if apply_distance_filter and price_ref is not None:
            filtered = [item for item in level_entries if percent_diff(item[0], price_ref) <= max_level_distance]
        else:
            filtered = list(level_entries)
        filtered.sort(key=lambda x: x[0], reverse=True)
        numeric_levels = [item[0] for item in filtered]
        local_high = min([lvl for lvl in numeric_levels if price_ref is not None and lvl > price_ref], default=None)
        local_low = max([lvl for lvl in numeric_levels if price_ref is not None and lvl < price_ref], default=None)

        return filtered, local_high, local_low
    except Exception as e:
        log_message(f"❌ Помилка horizontal_levels {symbol}: {e}")
        log_message(traceback.format_exc())
        return [], None, None


EXCHANGE_INFO_LOCK = threading.Lock()
EXCHANGE_INFO_CACHE = None
EXCHANGE_INFO_TS = 0.0
EXCHANGE_INFO_TTL = 1800.0
SYMBOL_PRECISION_CACHE = {}
SYMBOL_PRECISION_TTL = 1800.0


def get_exchange_info_cached(force=False):
    global EXCHANGE_INFO_CACHE, EXCHANGE_INFO_TS
    now = time.time()
    try:
        if not force and EXCHANGE_INFO_CACHE and (now - EXCHANGE_INFO_TS) <= EXCHANGE_INFO_TTL:
            return EXCHANGE_INFO_CACHE
    except Exception:
        pass
    with EXCHANGE_INFO_LOCK:
        try:
            if not force and EXCHANGE_INFO_CACHE and (now - EXCHANGE_INFO_TS) <= EXCHANGE_INFO_TTL:
                return EXCHANGE_INFO_CACHE
        except Exception:
            pass
        info = signed_request(client.futures_exchange_info)
        EXCHANGE_INFO_CACHE = info or {}
        EXCHANGE_INFO_TS = now
        return EXCHANGE_INFO_CACHE


def get_symbol_precision(symbol):
    sym = (symbol or "").upper()
    if not sym:
        return 0, 0
    try:
        entry = SYMBOL_PRECISION_CACHE.get(sym)
        if entry:
            ts = entry.get("ts", 0.0)
            if (time.time() - ts) <= SYMBOL_PRECISION_TTL:
                return entry.get("qty", 0), entry.get("price", 0)
    except Exception:
        pass
    info = get_exchange_info_cached()
    qty_precision = price_precision = 0
    try:
        for s in info.get("symbols", []):
            if s.get("symbol") == sym:
                for f in s.get("filters", []):
                    if f.get("filterType") == "LOT_SIZE":
                        step = float(f.get("stepSize"))
                        qty_precision = int(round(-math.log10(step), 0))
                    elif f.get("filterType") == "PRICE_FILTER":
                        tick = float(f.get("tickSize"))
                        price_precision = int(round(-math.log10(tick), 0))
                break
    except Exception:
        pass
    try:
        SYMBOL_PRECISION_CACHE[sym] = {"qty": qty_precision, "price": price_precision, "ts": time.time()}
    except Exception:
        pass
    return qty_precision, price_precision


# ------------------- WebSocket handlers & helpers -------------------


def _handle_price_message(msg):
    """Faster immediate handler for incoming tick messages."""
    try:
        global LAST_WS_MESSAGE_TS
        LAST_WS_MESSAGE_TS = time.time()
        symbol = msg.get('s') if isinstance(msg, dict) else None
        if not symbol:
            return
        price_str = None
        bid = None
        ask = None
        if isinstance(msg, dict):
            price_str = msg.get('c') or msg.get('p') or msg.get('price') or msg.get('l')
            # Futures ticker stream provides best bid/ask as "b" / "a" (strings)
            try:
                b_str = msg.get('b') or msg.get('bidPrice') or msg.get('bid')
                a_str = msg.get('a') or msg.get('askPrice') or msg.get('ask')
                if b_str not in (None, ""):
                    bid = float(b_str)
                if a_str not in (None, ""):
                    ask = float(a_str)
            except Exception:
                bid = None
                ask = None
        if price_str is None:
            return
        try:
            price = float(price_str)
        except Exception:
            price = price_str if isinstance(price_str, (int, float)) else None
            if price is None:
                return
        now_ts = time.time()
        try:
            price_source.update_ws_price(symbol, price=price, bid=bid, ask=ask)
        except Exception:
            try:
                symbol_prices[symbol] = {'price': price, 'ts': now_ts, 'bid': bid, 'ask': ask}
            except Exception:
                symbol_prices[symbol] = {'price': price, 'ts': now_ts, 'bid': bid, 'ask': ask}

        # --- IMMEDIATE: update open_positions peak/trough using this WS tick (minimal latency) ---
        with positions_lock:
            pos = open_positions.get(symbol)
            if pos:
                # safe numeric extraction without try/except
                cur_price = price if isinstance(price, (int, float)) else None
                if cur_price is None:
                    cur_price = symbol_prices.get(symbol, {}).get('price')
                    cur_price = cur_price if isinstance(cur_price, (int, float)) else None
                if cur_price is not None:
                    side = (pos.get('side') or '').upper()
                    if side in ('BUY', 'LONG'):
                        prev_max = pos.get('max_price') or pos.get('entry_price') or 0.0
                        if cur_price > prev_max:
                            pos['max_price'] = cur_price
                            open_positions[symbol] = pos
                    elif side in ('SELL', 'SHORT'):
                        prev_min = pos.get('min_price') or pos.get('entry_price') or float('inf')
                        if cur_price < prev_min:
                            pos['min_price'] = cur_price
                            open_positions[symbol] = pos

        try:
            dq = symbol_ticks.get(symbol)
            if dq is None:
                dq = deque(maxlen=600)
                symbol_ticks[symbol] = dq
            dq.append((now_ts, price))
        except Exception:
            pass

        try:
            with positions_lock:
                if open_positions.get(symbol):
                    if 'trailing_stop_check' in globals():
                        try:
                            _PRICE_EXECUTOR.submit(trailing_stop_check, symbol, price)
                            return
                        except Exception:
                            pass
        except Exception:
            pass

        try:
            with _price_pending_lock:
                if symbol in _price_pending:
                    return
                _price_pending.add(symbol)
            price_queue.put_nowait(symbol)
        except Exception:
            try:
                if 'trailing_stop_check' in globals():
                    trailing_stop_check(symbol, price)
            except Exception:
                pass
    except Exception as e:
        try:
            log_message('Помилка handle_price_message: %s' % (e,))
            log_message(traceback.format_exc())
        except Exception:
            pass


def get_exchange_position(symbol):
    try:
        pos_list = signed_request(client.futures_position_information)
        for p in pos_list:
            if p.get('symbol') == symbol:
                amt = float(p.get('positionAmt') or 0)
                entry = float(p.get('entryPrice') or 0)
                return amt, entry
    except Exception as e:
        log_message(f"❌ Помилка get_exchange_position({symbol}): {e}")
        log_message(traceback.format_exc())
    return 0.0, 0.0


# ------------------- Dynamic TP computation (RR-only) -------------------

def compute_trailing_pct_from_natr(natr, natr_factor=None, min_pct=None, max_pct=None):
    try:
        if not natr or natr <= 0:
            return None
        factor = TRAILING_NATR_FACTOR if natr_factor is None else natr_factor
        min_bound = TRAILING_MIN_PERCENT if min_pct is None else min_pct
        max_bound = TRAILING_MAX_PERCENT if max_pct is None else max_pct
        pct = natr * factor
        pct = max(min_bound, min(pct, max_bound))
        return pct
    except Exception:
        return None


def _rr_list(rr_min=None, rr_max=None, parts=None):
    if rr_min is None:
        rr_min = globals().get("RR_MIN", 0.6)
    if rr_max is None:
        rr_max = globals().get("RR_MAX", 4.0)
    if parts is None:
        parts = globals().get("TP_PARTS", 4)
    try:
        parts = int(parts)
    except Exception:
        parts = 1
    if parts <= 1:
        return [rr_max]
    step = (rr_max - rr_min) / (parts - 1)
    return [rr_min + i * step for i in range(parts)]


def compute_dynamic_tps(entry_price, trailing_percent, side, parts=None, rr_min=None, rr_max=None,
                        weight_power=None):
    """
    Compute TP prices and weights based on RR-only approach.
    - rr values are linearly spaced between rr_min and rr_max (inclusive)
    - weights are proportional to rr**weight_power to bias toward higher RR (bigger weight_power -> more weight to top TP)
    Returns list of tuples (tp_price, weight (0..1), rr)
    """
    try:
        # Normalize inputs defensively
        try:
            entry_price = float(entry_price)
        except Exception:
            return []
        try:
            trailing_percent = float(trailing_percent)
        except Exception:
            trailing_percent = None
        side = str(side).upper()
        if trailing_percent is None or trailing_percent <= 0:
            trailing_percent = FALLBACK_TRAILING_PERCENT
        if weight_power is None:
            weight_power = globals().get("TP_WEIGHT_POWER", -0.2)
        rrs = _rr_list(rr_min, rr_max, parts)
        # weights biased to larger RR
        raw_weights = [float(rr) ** float(weight_power) for rr in rrs]
        s = sum(raw_weights)
        if s == 0:
            return []
        weights = [w / s for w in raw_weights]
        tps = []
        for rr, w in zip(rrs, weights):
            if side == 'BUY':
                tp_price = round(entry_price * (1 + rr * trailing_percent / 100), 12)
            else:
                tp_price = round(entry_price * (1 - rr * trailing_percent / 100), 12)
            tps.append((tp_price, w, rr))
        return tps
    except Exception:
        log_message("❌ Помилка compute_dynamic_tps")
        log_message(traceback.format_exc())
        return []


# ----------------- Adaptive helpers -----------------
def _build_1m_bar_from_ticks(symbol):
    """Build a 1-minute bar from recent ticks stored in symbol_ticks.
    Returns dict with open/high/low/close and ts, or None if insufficient ticks."""
    try:
        dq = symbol_ticks.get(symbol)
        if not dq:
            return None
        now = time.time()
        start = now - 60.0
        open_p = None
        high = -1e18
        low = 1e18
        close = None
        for ts, price in dq:
            if ts < start:
                continue
            if open_p is None:
                open_p = price
            high = max(high, price)
            low = min(low, price)
            close = price
        if open_p is None:
            return None
        return {'open': open_p, 'high': high, 'low': low, 'close': close, 'ts': start}
    except Exception:
        return None


# ---- helper: check if level is already broken by current candle's open ----

def is_level_broken_by_current_open(symbol, level, tolerance):
    """
    Improved intrabar break check.
    Uses latest tick price when available and intrabar high/low from the latest 5m kline.
    Falls back to the kline open or tick price if necessary.
    Returns True if price crossed level beyond tolerance band.
    """
    try:
        lower = level * (1 - float(tolerance))
        upper = level * (1 + float(tolerance))

        # try to get latest tick price from cache or REST if needed
        cur_price = None
        try:
            cur_price = None
            if 'symbol_prices' in globals():
                cur_price = symbol_prices.get(symbol, {}).get('price')
            if cur_price is not None:
                cur_price = float(cur_price)
        except Exception:
            cur_price = None

        # try to get latest 5m klines to inspect intrabar high/low
        kl = None
        try:
            if 'signed_request' in globals() and 'client' in globals():
                # request last 2 klines - closed and current intrabar
                kl = signed_request(client.futures_klines, symbol=symbol, interval="1m", limit=2)
        except Exception:
            kl = None

        # if we have intrabar data, prefer intrabar high/low
        if kl and len(kl) >= 1:
            cur_k = kl[-1]
            # kline format: [openTime, open, high, low, close, ...]
            try:
                cur_high = float(cur_k[2])
                cur_low = float(cur_k[3])
            except Exception:
                cur_high = None
                cur_low = None

            # determine break direction using last closed close if available
            last_closed_close = None
            if len(kl) >= 2:
                try:
                    last_closed_close = float(kl[-2][4])
                except Exception:
                    last_closed_close = None

            # If last_closed_close is known, infer whether level acted as support (price above) or resistance (price below)
            if last_closed_close is not None:
                support = level < last_closed_close
            else:
                # if unknown, use level vs current price as heuristic
                support = (cur_price is not None and level < cur_price)

            if support:
                # break below support
                if (cur_low is not None and cur_low < lower):
                    return True
                if (cur_price is not None and cur_price < lower):
                    return True
                return False
            else:
                # break above resistance
                if (cur_high is not None and cur_high > upper):
                    return True
                if (cur_price is not None and cur_price > upper):
                    return True
                return False

        # fallback: rely on current tick price if available
        if cur_price is not None:
            return (cur_price < lower) or (cur_price > upper)

        # final fallback: try to read current 1m open via REST if available
        try:
            if 'signed_request' in globals() and 'client' in globals():
                kl_fallback = signed_request(client.futures_klines, symbol=symbol, interval="1m", limit=2)
                if kl_fallback and len(kl_fallback) >= 1:
                    try:
                        o = float(kl_fallback[-1][1])
                        return (o < lower) or (o > upper)
                    except Exception:
                        pass
        except Exception:
            pass

        return False
    except Exception:
        return False


def compute_last_retracement_pct_from_1m(symbol, side):
    """Compute retracement percent using the latest 1-minute bar and the recorded position peak/trough.

    For BUY: if we've seen a max_price while in position and the last 1m bar low is below that max,
    retracement_pct = (max_price - last_1m_low) / max_price * 100
    For SELL: symmetric using min_price and last_1m_high.
    Returns 0.0 if insufficient data.
    """
    try:
        with positions_lock:
            pos = open_positions.get(symbol)
            if not pos:
                return 0.0
            recorded_side = pos.get('side')
            side = side or recorded_side
            max_p = pos.get('max_price')
            min_p = pos.get('min_price')
        bar = _build_1m_bar_from_ticks(symbol)
        if not bar:
            return 0.0
        side_api = _side_to_api(side)
        if side_api == 'BUY':
            if not max_p:
                return 0.0
            last_low = bar.get('low')
            if last_low is None or last_low >= max_p:
                return 0.0
            retracement_pct = (max_p - last_low) / max_p * 100.0
            return retracement_pct
        else:
            if not min_p:
                return 0.0
            last_high = bar.get('high')
            if last_high is None or last_high <= min_p:
                return 0.0
            retracement_pct = (last_high - min_p) / min_p * 100.0
            return retracement_pct
    except Exception:
        return 0.0


def apply_retracement_tightening(symbol):
    now = time.time()
    if _last_retra_adjust_ts.get(symbol, 0) + MIN_TRAIL_ADJUST_INTERVAL > now:
        return
    with positions_lock:
        pos = open_positions.get(symbol)
        if not pos:
            return
        side = pos.get('side')
        base_trail = pos.get('base_trailing_percent', pos.get('trailing_percent', FALLBACK_TRAILING_PERCENT))
        current_trail = pos.get('trailing_percent', base_trail)
        if pos.get('fast_override', False):
            return
    retracement_pct = compute_last_retracement_pct_from_1m(symbol, side)  # using 1m bar for retracement detection
    if retracement_pct <= 0.0:
        return
    delta = RETRA_ALPHA * retracement_pct
    max_delta = base_trail * MAX_REDUCTION_RATIO
    if delta > max_delta:
        delta = max_delta
    new_trail = max(MIN_TRAIL_PCT, base_trail - delta)
    if new_trail < current_trail - 1e-12:
        with positions_lock:
            pos = open_positions.get(symbol)
            if not pos:
                return
            pos['trailing_percent'] = new_trail
            pos['last_retra_pct'] = retracement_pct
            open_positions[symbol] = pos
        _last_retra_adjust_ts[symbol] = now
        log_message(
            f"ℹ️ RETRA-TIGHTEN (1m) {symbol}: base {base_trail:.4f}% retr {retracement_pct:.4f}% => new trail {new_trail:.4f}%")


def _removed_is_fast_approach(symbol, *args, **kwargs):
    """
    Backwards-compatible fast-approach detector.
    Accepts multiple calling styles used in the codebase:
      - is_fast_approach(symbol)
      - is_fast_approach(symbol, lookback_minutes=3, threshold_pct=0.5)
      - is_fast_approach(symbol, level, lookback_minutes=3, threshold_pct=0.5)
      - is_fast_approach(symbol, lookback_s=6, price_pct_thresh=0.8)
    Behavior:
      - If a level_price is provided (positional 2nd arg or kwargs 'level'/'level_price'),
        it may be used by advanced detectors in future. Current implementation uses ticks to
        compute percent move over lookback window and ignores level_price (keeps previous semantics).
    Returns True if observed percent move over the lookback window >= threshold (in percent).
    """
    try:
        # Resolve flexible args/kwargs into canonical variables
        level_price = None
        lookback_s = None
        price_pct_thresh = None

        # positional second arg might be level_price or lookback (we only treat it as level if it is clearly numeric and others absent)
        if len(args) >= 1:
            # If caller passed a number and no lookback keywords, treat carefully
            try:
                # heuristics: if arg is numeric and kwargs include lookback_minutes/seconds, respect them;
                # otherwise, assume positional second arg is level_price
                level_price = args[0]
            except Exception:
                level_price = None

        # keywords mapping (support multiple names seen in code)
        if 'level' in kwargs:
            level_price = kwargs.get('level')
        if 'level_price' in kwargs:
            level_price = kwargs.get('level_price')
        if 'lookback_s' in kwargs:
            lookback_s = kwargs.get('lookback_s')
        if 'lookback_minutes' in kwargs:
            try:
                lookback_s = float(kwargs.get('lookback_minutes')) * 60.0
            except Exception:
                lookback_s = lookback_s or None
        if 'lookback_seconds' in kwargs:
            lookback_s = kwargs.get('lookback_seconds')
        if 'price_pct_thresh' in kwargs:
            price_pct_thresh = kwargs.get('price_pct_thresh')
        if 'threshold_pct' in kwargs:
            price_pct_thresh = kwargs.get('threshold_pct')

        # If not provided, fall back to module-level defaults
        if lookback_s is None:
            lookback_s = globals().get('FAST_LOOKBACK_S', 6)
        try:
            lookback_s = float(lookback_s)
        except Exception:
            lookback_s = globals().get('FAST_LOOKBACK_S', 6)

        if price_pct_thresh is None:
            price_pct_thresh = globals().get('FAST_PRICE_PCT_THRESH', 0.8)
        try:
            price_pct_thresh = float(price_pct_thresh)
        except Exception:
            price_pct_thresh = globals().get('FAST_PRICE_PCT_THRESH', 0.8)

        # Access recent ticks (deque of (ts, price))
        dq = globals().get('symbol_ticks', {}).get(symbol)
        if not dq or len(dq) < 2:
            return False

        now = time.time()
        start_ts = now - lookback_s

        # find first tick at or after start_ts
        start_price = None
        for ts, price in dq:
            try:
                if ts >= start_ts:
                    start_price = price
                    break
            except Exception:
                continue

        # fallback: if no tick inside window, use oldest available
        if start_price is None:
            start_price = dq[0][1]

        end_price = dq[-1][1] if dq else None
        if start_price is None or end_price is None:
            return False

        # percent change relative to start_price (in percent)
        try:
            pct = abs(end_price - start_price) / float(start_price) * 100.0
        except Exception:
            return False

        return pct >= float(price_pct_thresh)
    except Exception:
        # never raise from detector вЂ” callers expect boolean
        try:
            log_message(f"❌ Exception in is_fast_approach: {traceback.format_exc()}")
        except Exception:
            pass
        return False


def _to_bool(value):
    try:
        if isinstance(value, bool):
            return value
        if value is None:
            return False
        if isinstance(value, (int, float)):
            return bool(value)
        if isinstance(value, str):
            return value.strip().lower() in _TRUE_STRINGS or value.strip() == '1'
        return bool(value)
    except Exception:
        return False


# FIX: realized PnL logging
def send_profit_log(symbol: str, pnl_value: float, source: str) -> None:
    try:
        val = float(pnl_value or 0.0)
    except Exception:
        val = 0.0
    try:
        log_message(f"[PnL][{source}] {symbol}: {val:+.6f}")
    except Exception:
        try:
            print(f"[PnL][{source}] {symbol}: {val:+.6f}")
        except Exception:
            pass


def _get_futures_order_trade_breakdown(symbol, order_id, order_time_ms=None, max_wait_s=2.5):
    """
    Best-effort: fetch user trades for a specific futures order and compute:
      - realized_pnl (sum of realizedPnl)
      - fees (sum of commission grouped by commissionAsset)
      - avg_price (VWAP from trade price*qty)
    Returns dict or None if unavailable.
    """
    try:
        sym = (symbol or "").upper()
        oid = int(order_id) if order_id is not None else None
    except Exception:
        sym = (symbol or "").upper()
        oid = None
    if not sym or not oid:
        return None
    try:
        base_ms = int(order_time_ms) if order_time_ms is not None else None
    except Exception:
        base_ms = None
    if base_ms and base_ms > 0:
        start_ms = max(0, base_ms - 10 * 60 * 1000)
        end_ms = base_ms + 10 * 60 * 1000
    else:
        now_ms = int(time.time() * 1000)
        start_ms = max(0, now_ms - 15 * 60 * 1000)
        end_ms = now_ms

    deadline = time.time() + float(max_wait_s or 0)
    last_err = None
    while time.time() <= deadline:
        trades = None
        try:
            trades = signed_request(
                client.futures_account_trades,
                symbol=sym,
                startTime=int(start_ms),
                endTime=int(end_ms),
                limit=1000,
            )
        except Exception as e:
            last_err = e
            trades = None
        if not trades:
            try:
                trades = signed_request(client.futures_account_trades, symbol=sym, limit=50)
            except Exception as e:
                last_err = e
                trades = None
        matches = []
        try:
            if trades:
                oid_s = str(oid)
                matches = [t for t in trades if str(t.get('orderId')) == oid_s]
        except Exception:
            matches = []
        if matches:
            realized = 0.0
            fees = {}
            qty_total = 0.0
            notional = 0.0
            for t in matches:
                try:
                    realized += float(t.get('realizedPnl') or 0.0)
                except Exception:
                    pass
                try:
                    comm = abs(float(t.get('commission') or 0.0))
                    asset = (t.get('commissionAsset') or '').upper() or 'UNKNOWN'
                    fees[asset] = fees.get(asset, 0.0) + comm
                except Exception:
                    pass
                try:
                    q = abs(float(t.get('qty') or 0.0))
                    p = float(t.get('price') or 0.0)
                    if q > 0 and p > 0:
                        qty_total += q
                        notional += p * q
                except Exception:
                    pass
            avg_price = (notional / qty_total) if qty_total > 0 else None
            return {
                'order_id': oid,
                'realized_pnl': realized,
                'fees': fees,
                'avg_price': avg_price,
                'trades': matches,
            }
        time.sleep(0.25)
    try:
        if last_err:
            log_message(f"[PnL] userTrades lookup failed for {sym} oid={oid}: {last_err}")
    except Exception:
        pass


def _handle_depth_message(msg):
    try:
        global LAST_WS_MESSAGE_TS
        LAST_WS_MESSAGE_TS = time.time()
        payload = msg
        stream_name = None
        if isinstance(msg, dict):
            try:
                stream_name = msg.get('stream') or msg.get('streamName') or msg.get('topic')
            except Exception:
                stream_name = None
            if isinstance(msg.get('data'), dict):
                payload = msg.get('data')
        if isinstance(payload, (bytes, bytearray)):
            try:
                payload = json.loads(payload.decode("utf-8"))
            except Exception:
                return
        elif isinstance(payload, str):
            try:
                payload = json.loads(payload)
            except Exception:
                return
        if not isinstance(payload, dict):
            return
        symbol = payload.get('s') or payload.get('symbol')
        if not symbol:
            try:
                if stream_name:
                    symbol = stream_name.split("@", 1)[0]
            except Exception:
                symbol = None
        if not symbol:
            symbol = orderbook_socket_symbol
        if not symbol:
            return
        try:
            symbol = symbol.upper()
        except Exception:
            pass
        try:
            _emit_ws_status("book", f"LIVE {symbol}")
        except Exception:
            pass
        try:
            if _use_full_orderbook(symbol) and isinstance(payload, dict) and ('u' in payload or 'U' in payload or 'pu' in payload):
                state_ready = None
                need_seed = False
                with orderbook_full_lock:
                    state = orderbook_full_state.get(symbol)
                    if not state or not state.get('ready'):
                        buf = orderbook_diff_buffer.setdefault(symbol, [])
                        buf.append(payload)
                        need_seed = symbol not in orderbook_seed_inflight
                    else:
                        ok = _apply_depth_diff_locked(symbol, payload, state, allow_resync=True)
                        if not ok:
                            buf = orderbook_diff_buffer.setdefault(symbol, [])
                            buf.clear()
                            buf.append(payload)
                            need_seed = True
                        else:
                            state_ready = state
                if need_seed:
                    if _orderbook_rest_seeded(symbol):
                        _force_orderbook_partial(symbol, reason="diff out of sync")
                    else:
                        _seed_full_orderbook_async(symbol, force=True)
                if state_ready:
                    _publish_full_orderbook(symbol, state_ready)
                return
        except Exception:
            pass
        bids_raw = payload.get('b') or payload.get('bids') or []
        asks_raw = payload.get('a') or payload.get('asks') or []
        bids = []
        asks = []
        try:
            for item in bids_raw:
                try:
                    price = float(item[0])
                    qty = float(item[1])
                except Exception:
                    continue
                if qty <= 0:
                    continue
                bids.append((price, qty))
        except Exception:
            bids = []
        try:
            for item in asks_raw:
                try:
                    price = float(item[0])
                    qty = float(item[1])
                except Exception:
                    continue
                if qty <= 0:
                    continue
                asks.append((price, qty))
        except Exception:
            asks = []
        if not bids and not asks:
            return
        try:
            bids.sort(key=lambda x: x[0], reverse=True)
            asks.sort(key=lambda x: x[0])
        except Exception:
            pass
        bids = bids[:ORDERBOOK_LEVELS]
        asks = asks[:ORDERBOOK_LEVELS]
        now_ts = time.time()
        with orderbook_lock:
            orderbook_state[symbol] = {'symbol': symbol, 'bids': bids, 'asks': asks, 'ts': now_ts}
        try:
            last_emit = orderbook_emit_ts.get(symbol, 0.0)
            if (now_ts - last_emit) >= ORDERBOOK_EMIT_INTERVAL:
                orderbook_emit_ts[symbol] = now_ts
                _emit_orderbook(symbol)
        except Exception:
            pass
    except Exception:
        pass


def _handle_trade_print_message(msg):
    try:
        global LAST_WS_MESSAGE_TS
        LAST_WS_MESSAGE_TS = time.time()
        payload = msg
        stream_name = None
        if isinstance(msg, dict):
            try:
                stream_name = msg.get('stream') or msg.get('streamName') or msg.get('topic')
            except Exception:
                stream_name = None
            if isinstance(msg.get('data'), dict):
                payload = msg.get('data')
        if isinstance(payload, (bytes, bytearray)):
            try:
                payload = json.loads(payload.decode("utf-8"))
            except Exception:
                return
        elif isinstance(payload, str):
            try:
                payload = json.loads(payload)
            except Exception:
                return
        if not isinstance(payload, dict):
            return
        symbol = payload.get('s') or payload.get('symbol')
        if not symbol:
            try:
                if stream_name:
                    symbol = stream_name.split("@", 1)[0]
            except Exception:
                symbol = None
        if not symbol:
            symbol = trade_socket_symbol
        if not symbol:
            return
        try:
            symbol = symbol.upper()
        except Exception:
            pass
        try:
            _emit_ws_status("prints", f"LIVE {symbol}")
        except Exception:
            pass
        price = payload.get('p') or payload.get('price')
        qty = payload.get('q') or payload.get('qty') or payload.get('quantity')
        try:
            price = float(price)
        except Exception:
            return
        try:
            qty = float(qty)
        except Exception:
            qty = 0.0
        if qty <= 0:
            return
        ts_raw = payload.get('T') or payload.get('E') or payload.get('time')
        try:
            ts_val = float(ts_raw) / 1000.0 if ts_raw else time.time()
        except Exception:
            ts_val = time.time()
        side = None
        try:
            maker = payload.get('m')
            if maker is not None:
                side = 'SELL' if maker else 'BUY'
        except Exception:
            side = None
        trade_id = payload.get('t') or payload.get('a') or payload.get('id')
        try:
            notional = abs(float(price) * float(qty))
        except Exception:
            notional = 0.0
        # Global min notional filter (USD)
        try:
            mn = float(globals().get('PRINTS_MIN_NOTIONAL_USD', 0.0) or 0.0)
        except Exception:
            mn = 0.0
        if mn > 0 and notional < mn:
            return
        entry = {'ts': ts_val, 'price': price, 'qty': qty, 'side': side, 'id': trade_id, 'notional': float(notional)}
        # Deduplicate by trade id (or by (ts,price,qty,side) fallback)
        try:
            dupe_key = None
            if trade_id is not None:
                dupe_key = f'id:{trade_id}'
            else:
                dupe_key = f"{ts_val:.3f}|{price:.8f}|{qty:.8f}|{side or ''}"
            seen = globals().setdefault('trade_prints_seen', {})
            ss = seen.get(symbol)
            if ss is None:
                ss = deque(maxlen=4096)
                seen[symbol] = ss
            if dupe_key in ss:
                return
            ss.appendleft(dupe_key)
        except Exception:
            pass
        now_ts = time.time()
        with trade_prints_lock:
            dq = trade_prints.get(symbol)
            if dq is None:
                dq = deque(maxlen=PRINTS_LIMIT)
                trade_prints[symbol] = dq
            dq.appendleft(entry)
            trade_prints_state_ts[symbol] = now_ts
        try:
            if gui_bus is not None and bool(globals().get("PRINTS_EMIT_SINGLE", False)):
                try:
                    min_interval = float(globals().get("PRINTS_SINGLE_EMIT_INTERVAL", 0.0) or 0.0)
                except Exception:
                    min_interval = 0.0
                allow_emit = True
                if min_interval > 0:
                    try:
                        last_single = trade_prints_emit_ts.get(f"{symbol}__single", 0.0)
                        if (now_ts - last_single) < min_interval:
                            allow_emit = False
                        else:
                            trade_prints_emit_ts[f"{symbol}__single"] = now_ts
                    except Exception:
                        allow_emit = True
                if allow_emit:
                    gui_bus.prints_signal.emit({'symbol': symbol, 'print': entry})
        except Exception:
            pass
        try:
            # Bulk emit is disabled when single-emit mode is enabled
            # (otherwise the same trades are re-sent as a list and the UI may show duplicates / bursts).
            if not bool(globals().get("PRINTS_EMIT_SINGLE", False)):
                last_emit = trade_prints_emit_ts.get(symbol, 0.0)
                if (now_ts - last_emit) >= PRINTS_EMIT_INTERVAL:
                    trade_prints_emit_ts[symbol] = now_ts
                    _emit_prints(symbol)
        except Exception:
            pass
    except Exception:
        pass
    return None


def _fetch_orderbook_rest(symbol, limit_override=None, with_update_id=False):
    symbol = (symbol or "").upper()
    if not symbol:
        return None
    try:
        if 'client' not in globals() or client is None:
            return None
    except Exception:
        return None
    func = None
    try:
        for name in ("futures_order_book", "futures_depth", "futures_orderbook"):
            if hasattr(client, name):
                func = getattr(client, name)
                break
    except Exception:
        func = None
    if func is None:
        return None
    resp = None
    try:
        limit_val = limit_override if limit_override is not None else ORDERBOOK_LEVELS
        limit_val = _normalize_orderbook_rest_limit(limit_val)
        resp = signed_request(func, symbol=symbol, limit=limit_val)
    except Exception:
        try:
            resp = signed_request(func, symbol=symbol)
        except Exception:
            resp = None
    if not isinstance(resp, dict):
        return None
    bids_raw = resp.get('bids') or resp.get('b') or []
    asks_raw = resp.get('asks') or resp.get('a') or []
    bids = []
    asks = []
    try:
        for item in bids_raw:
            try:
                price = float(item[0])
                qty = float(item[1])
            except Exception:
                continue
            if qty <= 0:
                continue
            bids.append((price, qty))
    except Exception:
        bids = []
    try:
        for item in asks_raw:
            try:
                price = float(item[0])
                qty = float(item[1])
            except Exception:
                continue
            if qty <= 0:
                continue
            asks.append((price, qty))
    except Exception:
        asks = []
    if not bids and not asks:
        return None
    try:
        bids.sort(key=lambda x: x[0], reverse=True)
        asks.sort(key=lambda x: x[0])
    except Exception:
        pass
    try:
        slice_limit = int(limit_override) if limit_override is not None else int(ORDERBOOK_LEVELS or 0)
    except Exception:
        slice_limit = int(ORDERBOOK_LEVELS or 0)
    if slice_limit and slice_limit > 0:
        bids = bids[:slice_limit]
        asks = asks[:slice_limit]
    if with_update_id:
        upd = resp.get('lastUpdateId') or resp.get('last_update_id') or resp.get('u')
        return bids, asks, upd
    return bids, asks


def _fetch_prints_rest(symbol):
    symbol = (symbol or "").upper()
    if not symbol:
        return None
    try:
        if 'client' not in globals() or client is None:
            return None
    except Exception:
        return None
    func = None
    try:
        for name in ("futures_agg_trades", "futures_aggregate_trades", "futures_recent_trades"):
            if hasattr(client, name):
                func = getattr(client, name)
                break
    except Exception:
        func = None
    if func is None:
        return None
    resp = None
    try:
        resp = signed_request(func, symbol=symbol, limit=PRINTS_LIMIT)
    except Exception:
        try:
            resp = signed_request(func, symbol=symbol)
        except Exception:
            resp = None
    if not isinstance(resp, list):
        return None
    prints = []
    for item in resp:
        if not isinstance(item, dict):
            continue
        price = item.get('p') or item.get('price')
        qty = item.get('q') or item.get('qty') or item.get('quantity')
        try:
            price = float(price)
        except Exception:
            continue
        try:
            qty = float(qty)
        except Exception:
            qty = 0.0
        if qty <= 0:
            continue
        ts_raw = item.get('T') or item.get('time') or item.get('E') or item.get('timestamp')
        try:
            ts_val = float(ts_raw) / 1000.0 if ts_raw else time.time()
        except Exception:
            ts_val = time.time()
        side = None
        try:
            maker = item.get('m')
            if maker is None:
                maker = item.get('isBuyerMaker')
            if maker is not None:
                side = 'SELL' if maker else 'BUY'
        except Exception:
            side = None
        trade_id = item.get('a') or item.get('id') or item.get('tradeId') or item.get('t')
        prints.append({'ts': ts_val, 'price': price, 'qty': qty, 'side': side, 'id': trade_id})
    if not prints:
        return None
    try:
        prints.sort(key=lambda x: x['ts'], reverse=True)
    except Exception:
        pass
    return prints[:PRINTS_LIMIT]


def _get_futures_trade_window_breakdown(symbol, start_time_s, end_time_s=None, required_order_id=None, max_wait_s=2.5):
    """
    Best-effort: fetch futures user trades for a symbol within a time window and compute totals:
      - realized_pnl: sum of realizedPnl across the window (captures partial TPs too)
      - fees: sum of commission grouped by commissionAsset
      - net_pnl: realized_pnl minus USDT fees if available
    If required_order_id is provided, waits until at least one trade for that orderId is present.
    Returns dict or None if unavailable.
    """
    try:
        sym = (symbol or "").upper()
    except Exception:
        sym = symbol
    if not sym:
        return None
    try:
        start_s = float(start_time_s or 0.0)
    except Exception:
        start_s = 0.0
    if start_s <= 0:
        return None
    try:
        end_s = float(end_time_s) if end_time_s is not None else time.time()
    except Exception:
        end_s = time.time()

    # add small slack around the window to avoid off-by-a-few-seconds issues
    start_ms = max(0, int((start_s - 60.0) * 1000))
    end_ms = max(start_ms, int((end_s + 60.0) * 1000))

    oid_s = None
    if required_order_id not in (None, ''):
        try:
            oid_s = str(int(required_order_id))
        except Exception:
            try:
                oid_s = str(required_order_id)
            except Exception:
                oid_s = None

    deadline = time.time() + float(max_wait_s or 0)
    last_err = None
    while time.time() <= deadline:
        trades = None
        try:
            trades = signed_request(
                client.futures_account_trades,
                symbol=sym,
                startTime=int(start_ms),
                endTime=int(end_ms),
                limit=1000,
            )
        except Exception as e:
            last_err = e
            trades = None
        if not trades:
            try:
                trades = signed_request(client.futures_account_trades, symbol=sym, limit=200)
            except Exception as e:
                last_err = e
                trades = None

        selected = []
        try:
            for t in (trades or []):
                try:
                    t_ms = int(t.get('time') or t.get('T') or 0)
                except Exception:
                    t_ms = 0
                if t_ms and t_ms < start_ms:
                    continue
                if t_ms and t_ms > end_ms:
                    continue
                selected.append(t)
        except Exception:
            selected = []

        required_found = False
        if oid_s:
            try:
                required_found = any(str(t.get('orderId')) == oid_s for t in selected)
            except Exception:
                required_found = False
            if not required_found:
                time.sleep(0.25)
                continue

        if selected:
            realized = 0.0
            fees = {}
            for t in selected:
                try:
                    realized += float(t.get('realizedPnl') or 0.0)
                except Exception:
                    pass
                try:
                    comm = abs(float(t.get('commission') or 0.0))
                    asset = (t.get('commissionAsset') or '').upper() or 'UNKNOWN'
                    fees[asset] = fees.get(asset, 0.0) + comm
                except Exception:
                    pass
            fee_usdt = None
            try:
                if 'USDT' in fees:
                    fee_usdt = float(fees.get('USDT') or 0.0)
            except Exception:
                fee_usdt = None
            net = (realized - fee_usdt) if fee_usdt is not None else realized
            return {
                'symbol': sym,
                'start_ms': start_ms,
                'end_ms': end_ms,
                'required_order_id': oid_s,
                'required_order_found': bool(required_found) if oid_s else None,
                'realized_pnl': realized,
                'fees': fees,
                'fee_usdt': fee_usdt,
                'net_pnl': net,
                'trades': selected,
            }
        time.sleep(0.25)

    try:
        if last_err:
            log_message(f"[PnL] userTrades window lookup failed for {sym}: {last_err}")
    except Exception:
        pass
    return None


def _get_futures_income_window_breakdown(symbol, start_time_s, end_time_s=None, max_wait_s=2.5):
    """
    Best-effort: fetch futures income history for a symbol within a time window and compute:
      - realized_pnl: sum of REALIZED_PNL incomes
      - commission: sum of COMMISSION incomes (usually negative)
      - funding: sum of FUNDING_FEE incomes
      - net_pnl: realized_pnl + commission + funding
    Returns dict or None.
    """
    try:
        sym = (symbol or "").upper()
    except Exception:
        sym = symbol
    if not sym:
        return None
    try:
        start_s = float(start_time_s or 0.0)
    except Exception:
        start_s = 0.0
    if start_s <= 0:
        return None
    try:
        end_s = float(end_time_s) if end_time_s is not None else time.time()
    except Exception:
        end_s = time.time()

    # small slack to avoid off-by-a-few-seconds issues
    start_ms = max(0, int((start_s - 60.0) * 1000))
    end_ms = max(start_ms, int((end_s + 60.0) * 1000))

    wanted_types = {"REALIZED_PNL", "COMMISSION", "FUNDING_FEE"}
    deadline = time.time() + float(max_wait_s or 0)
    last_err = None
    while time.time() <= deadline:
        incomes = None
        try:
            incomes = signed_request(
                client.futures_income_history,
                symbol=sym,
                startTime=int(start_ms),
                endTime=int(end_ms),
                limit=1000,
            )
        except Exception as e:
            last_err = e
            incomes = None
        if incomes is None:
            time.sleep(0.25)
            continue

        selected = []
        try:
            for it in (incomes or []):
                try:
                    t_ms = int(it.get('time') or it.get('T') or 0)
                except Exception:
                    t_ms = 0
                if t_ms and t_ms < start_ms:
                    continue
                if t_ms and t_ms > end_ms:
                    continue
                try:
                    if (it.get('asset') or it.get('incomeAsset') or '').upper() not in ('', 'USDT'):
                        continue
                except Exception:
                    pass
                try:
                    typ = str(it.get('incomeType') or it.get('type') or '').upper()
                except Exception:
                    typ = ''
                if typ not in wanted_types:
                    continue
                selected.append(it)
        except Exception:
            selected = []

        if selected:
            realized = 0.0
            commission = 0.0
            funding = 0.0
            totals = {}
            for it in selected:
                try:
                    typ = str(it.get('incomeType') or it.get('type') or '').upper()
                except Exception:
                    typ = ''
                try:
                    val = float(it.get('income') or 0.0)
                except Exception:
                    val = 0.0
                totals[typ] = totals.get(typ, 0.0) + val
            try:
                realized = float(totals.get('REALIZED_PNL') or 0.0)
            except Exception:
                realized = 0.0
            try:
                commission = float(totals.get('COMMISSION') or 0.0)
            except Exception:
                commission = 0.0
            try:
                funding = float(totals.get('FUNDING_FEE') or 0.0)
            except Exception:
                funding = 0.0
            net = realized + commission + funding
            fee_usdt = None
            try:
                fee_usdt = abs(float(commission or 0.0))
            except Exception:
                fee_usdt = None
            fees = {}
            try:
                if fee_usdt is not None:
                    fees['USDT'] = fee_usdt
            except Exception:
                fees = {}
            return {
                'symbol': sym,
                'start_ms': start_ms,
                'end_ms': end_ms,
                'realized_pnl': realized,
                'commission': commission,
                'funding': funding,
                'net_pnl': net,
                'fee_usdt': fee_usdt,
                'fees': fees,
                'income_totals': totals,
                'income_items': selected,
            }

        time.sleep(0.25)

    try:
        if last_err:
            log_message(f"[PnL] income window lookup failed for {sym}: {last_err}")
    except Exception:
        pass
    return None


def _get_futures_pnl_window_breakdown(symbol, start_time_s, end_time_s=None, required_order_id=None, max_wait_s=2.5):
    """
    Prefer userTrades breakdown (reliable for realized PnL + commissions, supports required_order_id),
    then add funding from income history when available.
    Returns dict with 'net_pnl' or None.
    """
    income_bd = None
    try:
        income_bd = _get_futures_income_window_breakdown(symbol, start_time_s, end_time_s=end_time_s, max_wait_s=max_wait_s)
    except Exception:
        income_bd = None

    trade_bd = None
    try:
        trade_bd = _get_futures_trade_window_breakdown(
            symbol,
            start_time_s,
            end_time_s=end_time_s,
            required_order_id=required_order_id,
            max_wait_s=max_wait_s,
        )
    except Exception:
        trade_bd = None

    if trade_bd and trade_bd.get('net_pnl') is not None:
        try:
            trade_bd['method'] = 'trades'
            # Funding is not part of userTrades realizedPnl; add it when income history provides it.
            if income_bd and income_bd.get('funding') is not None:
                try:
                    funding_val = float(income_bd.get('funding') or 0.0)
                except Exception:
                    funding_val = 0.0
                try:
                    net_val = float(trade_bd.get('net_pnl') or 0.0)
                    trade_bd['net_pnl'] = net_val + funding_val
                    trade_bd['funding'] = funding_val
                    trade_bd['method'] = 'trades+funding'
                except Exception:
                    pass
            try:
                if income_bd:
                    trade_bd['income_totals'] = income_bd.get('income_totals')
                    trade_bd['commission_income'] = income_bd.get('commission')
            except Exception:
                pass
        except Exception:
            pass
        return trade_bd

    if income_bd and income_bd.get('net_pnl') is not None:
        try:
            income_bd['method'] = 'income'
        except Exception:
            pass
        return income_bd

    return income_bd or trade_bd


# FIX: TP chain & state
def send_info_log(text: str) -> None:
    try:
        log_message(str(text))
    except Exception:
        try:
            print(str(text))
        except Exception:
            pass


# FIX: TP chain & state
def futures_place_limit_reduce_only(symbol, price, quantity, side, tag="TP"):
    try:
        try:
            qty_prec, price_prec = get_symbol_precision(symbol)
        except Exception:
            qty_prec, price_prec = 0, 8
        qty_val = round(float(quantity or 0.0), qty_prec)
        price_val = round(float(price or 0.0), price_prec)
        if qty_val <= eps or price_val <= 0:
            return None
        resp = signed_request(
            client.futures_create_order,
            symbol=symbol,
            side=side,
            type='LIMIT',
            timeInForce='GTC',
            quantity=qty_val,
            price=price_val,
            reduceOnly=True
        )
        order_id = None
        if isinstance(resp, dict):
            try:
                _update_open_orders_cache_from_ws(resp)
            except Exception:
                pass
            order_id = resp.get('orderId') or resp.get('order_id')
        if order_id:
            send_info_log(f"[{tag}] reduceOnly LIMIT placed for {symbol}: orderId={order_id} qty={qty_val} price={price_val}")
            return int(order_id)
        send_info_log(f"[{tag}] failed to place reduceOnly LIMIT for {symbol}: resp={resp}")
    except Exception as e:
        log_message(f"WARN futures_place_limit_reduce_only error for {symbol}: {e}")
        log_message(traceback.format_exc())
    return None


def _handle_user_message(msg):
    def _safe_sound(symbol, side, qty):
        try:
            if not SOUND_ENABLED:
                log_message("[SOUND] disabled")
                return
            if TRADE_OPEN_SOUND_FILE and not os.path.exists(TRADE_OPEN_SOUND_FILE):
                log_message(f"[SOUND] file-missing {TRADE_OPEN_SOUND_FILE}")
            if play_trade_open_alert_once(symbol, side, qty):
                log_message("[SOUND] open played")
        except Exception as se:
            try:
                log_message(f"[SOUND] error: {se}")
            except Exception:
                pass
    try:
        auto_place_running = bool(globals().get("bot_running", False))
    except Exception:
        auto_place_running = False

    def handle_filled_event(evt):
        """
        Unified post-fill handler. Returns True if processed, False otherwise.
        """
        try:
            o = evt.get('o', {}) if isinstance(evt, dict) else {}
            status = str(o.get('X') or o.get('x') or evt.get('X') or evt.get('status') or "").upper()
            exec_type = str(o.get('x') or o.get('executionType') or "").upper()
            order_type = str(o.get('o') or o.get('type') or "").upper()
            reduce_only_flag = _to_bool(o.get('R') or o.get('reduceOnly'))
            close_position_flag = _to_bool(o.get('cp') or o.get('closePosition'))
            if exec_type != 'TRADE' or status != 'FILLED':
                return False
            if reduce_only_flag or close_position_flag:
                return False  # skip TP/SL fills
            symbol = o.get('s') or o.get('symbol')
            if not symbol:
                return False
            order_id = o.get('i') or o.get('orderId')
            side_api = (o.get('S') or o.get('side') or "").upper()
            side_state = _norm_side(side_api)
            position_side = o.get('ps') or o.get('positionSide') or 'BOTH'
            try:
                qty = abs(float(o.get('q') or o.get('origQty') or o.get('l') or o.get('lastFilledQty') or 0))
            except Exception:
                qty = 0.0
            if qty <= 0:
                try:
                    exch_amt, exch_entry = get_exchange_position(symbol)
                    qty = abs(float(exch_amt or 0))
                    if exch_entry and not o.get('ap'):
                        o['ap'] = exch_entry
                except Exception:
                    qty = 0.0
            entry_price, entry_source = price_source.get_entry_price(evt, symbol=symbol, order_id=order_id)
            if not entry_price:
                try:
                    entry_price = float(o.get('ap') or o.get('avgPrice') or 0)
                except Exception:
                    entry_price = None
            # SL/TP algo orders below are placed with CONTRACT_PRICE; use contract/last price here to avoid mark-price false triggers.
            current_price, current_source = price_source.get_current_price(symbol, prefer_ws=True, ws_wait_s=0.25, price_kind="mid")
            try:
                auto_place = bool(globals().get("bot_running", False))
            except Exception:
                auto_place = False
            if qty <= eps:
                try:
                    log_message(f"[FILLED] skip placement for {symbol}: qty={qty}")
                except Exception:
                    pass
                return False

            with orders_lock:
                meta = copy.deepcopy(pending_meta.get(symbol) or {})

            # Determine whether this fill belongs to a tracked pending entry (active_orders)
            tracked_oid = None
            try:
                with orders_lock:
                    tracked_oid = active_orders.get(symbol)
            except Exception:
                tracked_oid = None
            is_tracked_pending_fill = False
            try:
                if tracked_oid is not None and order_id is not None and str(tracked_oid) == str(order_id):
                    is_tracked_pending_fill = True
            except Exception:
                is_tracked_pending_fill = False

            # Dual-entry: ENTRY1 fill should not arm TP or clear pending tracking.
            dual_entry_waiting = False
            try:
                dual_entry_active_meta = bool(meta.get('dual_entry')) if isinstance(meta, dict) else False
            except Exception:
                dual_entry_active_meta = False
            try:
                if not bool(globals().get("DUAL_ENTRY_ENABLED", False)):
                    dual_entry_active_meta = False
            except Exception:
                dual_entry_active_meta = False
            try:
                dual_entry_waiting = bool(dual_entry_active_meta and tracked_oid is not None and not is_tracked_pending_fill)
            except Exception:
                dual_entry_waiting = False

            # Detect scale-in (2nd entry adds to an existing position).
            # IMPORTANT: do not treat duplicate WS/REST FILLED events as a scale-in.
            prev_state = pos_get(symbol) or {}
            try:
                prev_qty = abs(float(prev_state.get('qty', 0.0) or 0.0))
            except Exception:
                prev_qty = 0.0
            prev_side_api = _side_to_api(prev_state.get('side'))
            has_sl_already = bool(prev_state.get('sl_order_id'))
            try:
                dual_entry_active_state = bool(dual_entry_active_meta or (prev_state or {}).get('dual_entry', False))
            except Exception:
                dual_entry_active_state = bool(dual_entry_active_meta)
            try:
                if not bool(globals().get("DUAL_ENTRY_ENABLED", False)):
                    dual_entry_active_state = False
            except Exception:
                dual_entry_active_state = False

            # Some WS FILLED events can miss avg price; recover from exchange position or ENTRY1 anchor.
            try:
                if (not entry_price) or float(entry_price) <= 0:
                    _exch_amt, _exch_entry = get_exchange_position(symbol)
                    if _exch_entry and float(_exch_entry) > 0:
                        entry_price = float(_exch_entry)
                        entry_source = entry_source or "exchange"
            except Exception:
                pass
            try:
                is_entry1_leg = bool(dual_entry_active_meta and tracked_oid is not None and not is_tracked_pending_fill)
            except Exception:
                is_entry1_leg = False
            try:
                if (is_entry1_leg and ((not entry_price) or float(entry_price) <= 0)) and isinstance(meta, dict):
                    anchor = float(meta.get("entry1_anchor_price") or 0.0)
                    if anchor > 0:
                        entry_price = anchor
                        entry_source = "pm:entry1_anchor"
            except Exception:
                pass

            try:
                leg_label = "ENTRY2" if is_tracked_pending_fill else ("ENTRY1" if is_entry1_leg else "ENTRY")
            except Exception:
                leg_label = "ENTRY"
            entry_disp = f"{entry_price:.8f}" if entry_price else "?"
            cur_disp = f"{current_price:.8f}" if current_price else "?"
            log_message(
                f"[FILLED] {symbol} leg={leg_label} side={side_state} entry={entry_disp} cur={cur_disp} qty={qty} "
                f"entry_src={entry_source} cur_src={current_source}"
            )
            if not entry_price:
                log_message(f"[FILLED] skip placement for {symbol}: missing entry price (leg={leg_label})")
                return False

            # Dual-entry: mark ENTRY1 as open so trailing/TP stays gated until ENTRY2 confirms.
            try:
                if dual_entry_active_meta and is_entry1_leg and (not is_tracked_pending_fill):
                    pos_set(symbol, entry2_pending=True)
            except Exception:
                pass

            placed_any = False
            service = order_placement_service
            algo_id = None
            try:
                filt = service._filters(symbol)
                tick = filt.get("tick", 0.0) or 0.0
                step = filt.get("step", 0.0) or 0.0
                qty_prec = int(filt.get("qty_prec", 0) or 0)
                price_prec = int(filt.get("price_prec", 8) or 8)
            except Exception:
                tick = 0.0
                step = 0.0
                qty_prec, price_prec = 0, 8

            qty_step = 0.0
            try:
                qty_step = float(step) if (step and float(step) > 0) else (10 ** (-int(qty_prec or 0)))
            except Exception:
                qty_step = 0.0
            qty_delta_tol = 0.0
            try:
                qty_delta_tol = float(qty_step) / 2.0 if (qty_step and float(qty_step) > 0) else 0.0
            except Exception:
                qty_delta_tol = 0.0
            if qty_delta_tol <= 0:
                qty_delta_tol = max(eps * 10.0, 1e-8)

            is_scale_in = False
            qty_after = None
            entry_after = None
            try:
                same_side_existing = bool(prev_qty > eps and prev_side_api and prev_side_api == side_api)
            except Exception:
                same_side_existing = False
            try:
                if same_side_existing:
                    try:
                        exch_amt, _exch_entry = get_exchange_position(symbol)
                        qty_after = abs(float(exch_amt or 0.0))
                        try:
                            entry_after = float(_exch_entry) if _exch_entry not in (None, "", 0) else None
                        except Exception:
                            entry_after = None
                    except Exception:
                        qty_after = None
                        entry_after = None
                    if is_tracked_pending_fill:
                        is_scale_in = True
                    elif qty_after is not None:
                        is_scale_in = bool(float(qty_after) > (float(prev_qty) + float(qty_delta_tol)))
            except Exception:
                is_scale_in = False

            # Duplicate fill guard: same-side FILLED event but position size unchanged.
            # This prevents accidental SL re-anchor/TP replan from synthetic WS/REST duplicates.
            try:
                if (
                    same_side_existing
                    and (not is_scale_in)
                    and has_sl_already
                    and qty_after is not None
                    and abs(float(qty_after) - float(prev_qty)) <= float(qty_delta_tol)
                ):
                    # Dual-entry nuance:
                    # It is possible the position reaches full size via REST sync BEFORE the ENTRY2 FILLED event arrives.
                    # In that case qty may already be "unchanged" and we'd incorrectly skip the one-time ENTRY2 SL re-anchor.
                    allow_processing = False
                    try:
                        sl_anchor_prev = str((prev_state or {}).get('sl_anchor') or '').lower()
                    except Exception:
                        sl_anchor_prev = ''
                    try:
                        if dual_entry_active_state and sl_anchor_prev != 'entry2':
                            de_wait, de_plan, _de_cur, _de_tol = _dual_entry_wait_state(
                                symbol, meta=meta, qty_current=qty_after
                            )
                            if (de_plan is not None) and (not de_wait):
                                allow_processing = True
                    except Exception:
                        allow_processing = False
                    if allow_processing:
                        # Force the scale-in path so we still re-anchor SL to ENTRY2 exactly once.
                        is_scale_in = True
                        try:
                            log_message(
                                f"[FILLED] {symbol}: late/duplicate fill but dual-entry complete -> re-anchor SL (ENTRY2)"
                            )
                        except Exception:
                            pass
                    else:
                        # IMPORTANT: Dual-entry can defer TP on ENTRY1, then later the position reaches full size
                        # via REST sync before the ENTRY2 FILLED event arrives (orderId may be missing/None).
                        # If dual-entry is complete AND no TP exists, attempt to create/release TP here.
                        try:
                            de_wait, de_plan, _de_cur, _de_tol = _dual_entry_wait_state(
                                symbol, meta=meta, qty_current=qty_after
                            )
                        except Exception:
                            de_wait, de_plan = False, None
                        if (de_plan is not None) and (not de_wait):
                            tp_present = False
                            try:
                                with tp_lock:
                                    tp_present = bool(tp_orders.get(symbol)) or bool(pending_tps.get(symbol))
                            except Exception:
                                tp_present = False
                            if not tp_present:
                                try:
                                    pos_set(symbol, dual_entry_complete=True)
                                except Exception:
                                    pass
                                if auto_place:
                                    try:
                                        ensure_trailing_stop(symbol)
                                    except Exception:
                                        pass
                                    try:
                                        qty_actual = float(qty_after or 0.0)
                                        entry_actual = entry_after or entry_price
                                        if qty_actual <= eps or not entry_actual or float(entry_actual) <= 0:
                                            exch_amt2, exch_entry2 = get_exchange_position(symbol)
                                            qty_actual = abs(float(exch_amt2 or 0.0))
                                            entry_actual = float(exch_entry2 or entry_actual or 0.0)
                                        if qty_actual > eps and entry_actual and float(entry_actual) > 0:
                                            maybe_create_post_fill_tps(symbol, side_api, qty_actual, float(entry_actual))
                                    except Exception:
                                        pass
                        log_message(f"[FILLED] {symbol}: duplicate fill event (qty unchanged) -> skip SL/TP init")
                        return True
            except Exception:
                pass

            # Record entry marker for chart screenshots (buy/sell triangles)
            try:
                is_new_trade = bool(prev_qty <= eps and not is_scale_in)
                if is_new_trade:
                    trade_id = _chart_trade_new_id(symbol)
                else:
                    trade_id = _chart_trade_current_id(symbol)
                    if not trade_id:
                        trade_id = _chart_trade_new_id(symbol)
                trade_kind = "ENTRY" if is_new_trade else ("ADD" if is_scale_in else "ENTRY")
                ev_ts = None
                try:
                    ev_raw_ts = o.get('T') or o.get('E') or o.get('transactTime')
                    if ev_raw_ts:
                        ev_ts = float(ev_raw_ts) / 1000.0
                except Exception:
                    ev_ts = None
                chart_trade_record_event(symbol, side_api, entry_price, ts=ev_ts, kind=trade_kind, trade_id=trade_id, qty=qty)
            except Exception:
                pass

            # --- Telegram: dual-entry lifecycle (ENTRY1/ENTRY2 + SL) ---
            tg_emit_entry2 = False
            tg_entry2_is_first = False
            level_val = None
            try:
                if isinstance(meta, dict):
                    level_val = meta.get('level')
            except Exception:
                level_val = None
            try:
                tg_emit_entry2 = bool(dual_entry_active_meta and is_tracked_pending_fill)
                tg_entry2_is_first = bool(tg_emit_entry2 and prev_qty <= eps)
            except Exception:
                tg_emit_entry2 = False
                tg_entry2_is_first = False
            try:
                if dual_entry_active_meta and tracked_oid is not None and (not is_tracked_pending_fill) and (not is_scale_in):
                    level_part = ""
                    try:
                        if level_val is not None:
                            level_part = f" level={float(level_val):.{price_prec}f}"
                    except Exception:
                        level_part = f" level={level_val}"
                    _telegram_notify_once(
                        symbol,
                        "tg_entry1_cycle",
                        f"⚡ Вхід 1 відкрито {symbol} {side_state} qty={qty:.{qty_prec}f} entry={entry_price:.{price_prec}f}{level_part}",
                        with_ts=True,
                    )
            except Exception:
                pass
            # ---- SL placement (adaptive: swing high/low) ----
            sl_trigger = None
            sl_src = None
            sl_attempted = False
            sl_anchor = None
            if not auto_place:
                try:
                    log_message("[FILLED] bot not running -> skip SL/TP auto placement")
                except Exception:
                    pass
            if auto_place:
                if auto_place and is_scale_in and has_sl_already:
                    # Dual-entry: after ENTRY2 fill (scale-in), re-anchor SL relative to ENTRY2.
                    moved = False
                    should_reanchor = False
                    try:
                        should_reanchor = bool(dual_entry_active_meta)
                    except Exception:
                        should_reanchor = False
                    if not should_reanchor:
                        try:
                            should_reanchor = bool((prev_state or {}).get('dual_entry', False))
                        except Exception:
                            should_reanchor = False
                    try:
                        if str((prev_state or {}).get('sl_anchor') or '').lower() == 'entry2':
                            should_reanchor = False
                    except Exception:
                        pass
                    try:
                        if not bool(globals().get("DUAL_ENTRY_REANCHOR_SL_AFTER_ENTRY2", True)):
                            should_reanchor = False
                    except Exception:
                        should_reanchor = False
                    if should_reanchor:
                        entry2_ref = None
                        try:
                            if entry_after and float(entry_after) > 0:
                                entry2_ref = float(entry_after)
                            else:
                                entry2_ref = float(entry_price)
                        except Exception:
                            entry2_ref = entry_price
                        try:
                            # Anchor SL to the main entry after scale-in when possible.
                            # Fall back to fill/plan only if the entry is missing/invalid.
                            if (not entry2_ref) or float(entry2_ref) <= 0:
                                if isinstance(meta, dict):
                                    if meta.get('stop_price') not in (None, "", 0):
                                        entry2_ref = float(meta.get('stop_price'))
                                    elif meta.get('level') not in (None, "", 0):
                                        entry2_ref = float(meta.get('level'))
                        except Exception:
                            pass
                        try:
                            if (
                                (not entry2_ref or float(entry2_ref) <= 0)
                                and (prev_state or {}).get('planned_entry2_price') not in (None, "", 0)
                            ):
                                entry2_ref = float((prev_state or {}).get('planned_entry2_price'))
                        except Exception:
                            pass
    
                        old_sl_oid = None
                        old_sl_trigger = None
                        old_sl_src = None
                        try:
                            old_sl_oid = (prev_state or {}).get('sl_order_id')
                            old_sl_trigger = (prev_state or {}).get('hard_sl_trigger')
                            old_sl_src = (prev_state or {}).get('hard_sl_source')
                        except Exception:
                            old_sl_oid = None
                            old_sl_trigger = None
                            old_sl_src = None
                        # If local state lacks the previous trigger, try fetching it from the exchange
                        # BEFORE we cancel it (helps restore protection if re-anchor fails).
                        try:
                            if old_sl_oid and (old_sl_trigger in (None, "", 0, False)):
                                _old = get_conditional_order(symbol, old_sl_oid)
                                if isinstance(_old, dict):
                                    _tr = _old.get("triggerPrice") or _old.get("stopPrice") or _old.get("trigger_price")
                                    if _tr not in (None, "", 0, False):
                                        old_sl_trigger = float(_tr)
                        except Exception:
                            pass
    
                        # Compute new SL using swing logic relative to the main entry reference price.
                        try:
                            sl_trigger, sl_src = compute_hard_sl_trigger(
                                symbol,
                                side_api,
                                float(entry2_ref),
                                current_price=current_price,
                                tick=tick,
                                price_prec=price_prec,
                                meta=None
                            )
                        except Exception:
                            sl_trigger, sl_src = None, None
                        if not sl_trigger:
                            try:
                                hard_offset = float(globals().get('HARD_SL_OFFSET_PCT', 0.0055) or 0.0055)
                            except Exception:
                                hard_offset = 0.0055
                            raw_sl = float(entry2_ref) * (1 - hard_offset) if side_api == 'BUY' else float(entry2_ref) * (1 + hard_offset)
                            sl_trigger = _round_to_tick(raw_sl, tick, price_prec) or (round(raw_sl, price_prec))
                            sl_src = sl_src or "fallback_offset:none"
    
                        # Dual-entry: tighten SL distance after ENTRY2 (e.g., divisor=2 -> half the distance).
                        try:
                            e2_div = float(globals().get('DUAL_ENTRY_ENTRY2_SL_DIVISOR', 2.0) or 2.0)
                        except Exception:
                            e2_div = 2.0
                        try:
                            if e2_div and float(e2_div) > 1.0 and sl_trigger and entry2_ref:
                                ep2 = float(entry2_ref)
                                st = float(sl_trigger)
                                dist = abs(ep2 - st)
                                if dist > 0:
                                    new_dist = dist / float(e2_div)
                                    try:
                                        tick_f = float(tick or 0.0)
                                    except Exception:
                                        tick_f = 0.0
                                    if side_api == 'BUY':
                                        cand = ep2 - new_dist
                                        if tick_f and tick_f > 0:
                                            cand = min(cand, ep2 - tick_f)
                                            sl_trigger = _ceil_to_tick(cand, tick_f, price_prec) or round(cand, price_prec)
                                        else:
                                            sl_trigger = round(cand, price_prec)
                                    else:
                                        cand = ep2 + new_dist
                                        if tick_f and tick_f > 0:
                                            cand = max(cand, ep2 + tick_f)
                                            sl_trigger = _floor_to_tick(cand, tick_f, price_prec) or round(cand, price_prec)
                                        else:
                                            sl_trigger = round(cand, price_prec)
                                    try:
                                        tag = f"e2div{float(e2_div):g}"
                                    except Exception:
                                        tag = "e2div"
                                    sl_src = f"{sl_src}:{tag}" if sl_src else tag
                        except Exception:
                            pass
    
                        # Use full current position qty for SL operations (important for MARKET-close fallbacks).
                        qty_for_sl_move = qty
                        try:
                            if qty_after is not None and float(qty_after) > eps:
                                qty_for_sl_move = abs(float(qty_after))
                        except Exception:
                            qty_for_sl_move = qty
                        try:
                            if (qty_for_sl_move is None) or (float(qty_for_sl_move) <= eps):
                                exch_amt_tmp, _exch_entry_tmp = get_exchange_position(symbol)
                                qty_for_sl_move = abs(float(exch_amt_tmp or 0.0))
                        except Exception:
                            pass
    
                        # Replace the existing SL (avoid -4130 duplicates): cancel ALL closePosition SLs first.
                        canceled_sl_ids = []
                        try:
                            close_side = "SELL" if side_api == 'BUY' else "BUY"
                        except Exception:
                            close_side = None
                        try:
                            canceled_sl_ids = cancel_open_closeposition_sl_orders(
                                symbol,
                                side=close_side,
                                position_side=position_side,
                            ) or []
                        except Exception:
                            canceled_sl_ids = []
                        if not canceled_sl_ids:
                            try:
                                if old_sl_oid:
                                    cancel_conditional_order(symbol, old_sl_oid)
                                    canceled_sl_ids = [old_sl_oid]
                            except Exception:
                                pass
                        if canceled_sl_ids:
                            try:
                                pos_set(symbol, sl_order_id=None)
                            except Exception:
                                pass
                            try:
                                log_message(f"[SL MOVE] {symbol} canceled existing SLs: {canceled_sl_ids}")
                            except Exception:
                                pass
    
                        sl_err = None
                        sl_resp = None
                        try:
                            sl_attempted = True
                            sl_resp = service.place_conditional({
                                "kind": "SL",
                                "symbol": symbol,
                                "side": "SELL" if side_api == 'BUY' else "BUY",
                                "position_side": position_side,
                                "trigger": sl_trigger,
                                "quantity": qty_for_sl_move,
                                "close_position": True,
                                "entry_price": float(entry2_ref),
                                "current_price": current_price,
                                "working_type": "CONTRACT_PRICE",
                            })
                        except Exception as _sl_e2:
                            sl_err = _sl_e2
                        new_algo_id = None
                        if isinstance(sl_resp, dict):
                            new_algo_id = sl_resp.get('algoId') or sl_resp.get('orderId')
                        placed_any = placed_any or bool(sl_resp)
                        if new_algo_id:
                            algo_id = new_algo_id
    
                        # If we couldn't place a new SL, try to restore the previous one to avoid being unprotected.
                        restore_algo_id = None
                        if not new_algo_id:
                            closing_now = False
                            try:
                                with positions_lock:
                                    closing_now = bool((open_positions.get(symbol) or {}).get('closing'))
                            except Exception:
                                closing_now = False
                            if (not closing_now) and old_sl_trigger:
                                try:
                                    restore_entry = (prev_state or {}).get('entry_price') or entry_price
                                    restore_resp = service.place_conditional({
                                        "kind": "SL",
                                        "symbol": symbol,
                                        "side": "SELL" if side_api == 'BUY' else "BUY",
                                        "position_side": position_side,
                                        "trigger": float(old_sl_trigger),
                                        "quantity": qty_for_sl_move,
                                        "close_position": True,
                                        "entry_price": float(restore_entry),
                                        "current_price": current_price,
                                        "working_type": "CONTRACT_PRICE",
                                    })
                                    if isinstance(restore_resp, dict):
                                        restore_algo_id = restore_resp.get('algoId') or restore_resp.get('orderId')
                                    if restore_algo_id:
                                        algo_id = restore_algo_id
                                        sl_trigger = float(old_sl_trigger)
                                        sl_src = old_sl_src or sl_src
                                        sl_anchor = str((prev_state or {}).get('sl_anchor') or 'entry1')
                                        try:
                                            log_message(f"⚠️ [SL MOVE] restored previous SL for {symbol}: algoId={algo_id}")
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
    
                            # Safety: if we couldn't place/restore a new SL, ensure the position isn't left unprotected.
                            if (not restore_algo_id) and (not closing_now):
                                sl_on_book = False
                                try:
                                    for _o in get_open_conditional_orders(symbol) or []:
                                        o_type = (_o.get("orderType") or _o.get("type") or _o.get("o") or "").upper()
                                        if o_type not in ("STOP_MARKET", "STOP"):
                                            continue
                                        if not _to_bool(_o.get("closePosition")):
                                            continue
                                        o_side = (_o.get("side") or _o.get("S") or "").upper()
                                        if close_side and o_side and o_side != close_side:
                                            continue
                                        sl_on_book = True
                                        break
                                except Exception:
                                    sl_on_book = False
                                if not sl_on_book:
                                    try:
                                        log_message(f"❗ [SL MOVE] {symbol}: no SL after ENTRY2 reanchor -> forcing MARKET close for safety")
                                    except Exception:
                                        pass
                                    try:
                                        safe_close_position(symbol, side_state, qty=qty_for_sl_move)
                                    except Exception:
                                        pass
    
                        if new_algo_id:
                            moved = True
                            sl_anchor = "entry2"
                            try:
                                hs = f"{float(sl_trigger):.8f}" if sl_trigger else "?"
                            except Exception:
                                hs = str(sl_trigger)
                            try:
                                log_message(
                                    f"[SL MOVE] {symbol} reanchor=ENTRY2 entry_main={float(entry2_ref):.8f} hard={hs} src={sl_src} old={old_sl_oid} new={algo_id}"
                                )
                            except Exception:
                                pass
                            try:
                                if sl_trigger and algo_id:
                                    chart_trade_record_sl(symbol, float(sl_trigger), trade_id=_chart_trade_current_id(symbol))
                            except Exception:
                                pass
                            try:
                                _telegram_notify_once(
                                    symbol,
                                    "tg_sl_entry2_cycle",
                                    f"🧷 SL (ENTRY2) {symbol}: {hs}",
                                    with_ts=True,
                                )
                            except Exception:
                                pass
                        elif restore_algo_id:
                            moved = True
                        else:
                            if sl_err:
                                try:
                                    log_message(f"[ALGO ERR] SL move failed for {symbol}: {sl_err}")
                                except Exception:
                                    pass
    
                    if not moved:
                        # Keep existing SL as-is
                        try:
                            if isinstance(meta, dict):
                                sl_trigger = meta.get("hard_sl_trigger")
                                sl_src = meta.get("hard_sl_source")
                        except Exception:
                            sl_trigger = None
                            sl_src = None
                        try:
                            log_message(f"[SL SKIP] {symbol}: scale-in fill (existing SL {prev_state.get('sl_order_id')})")
                        except Exception:
                            pass
                else:
                    meta_for_sl = None
                    entry_for_sl = entry_price
                    try:
                        if entry_after and float(entry_after) > 0:
                            entry_for_sl = float(entry_after)
                        else:
                            exch_amt_tmp, exch_entry_tmp = get_exchange_position(symbol)
                            if exch_entry_tmp and float(exch_entry_tmp) > 0:
                                entry_for_sl = float(exch_entry_tmp)
                    except Exception:
                        entry_for_sl = entry_price
                    try:
                        sl_trigger, sl_src = compute_hard_sl_trigger(
                            symbol,
                            side_api,
                            entry_for_sl,
                            current_price=current_price,
                            tick=tick,
                            price_prec=price_prec,
                            meta=meta_for_sl
                        )
                    except Exception:
                        sl_trigger, sl_src = None, None
                    if not sl_trigger:
                        try:
                            hard_offset = float(globals().get('HARD_SL_OFFSET_PCT', 0.0055) or 0.0055)
                        except Exception:
                            hard_offset = 0.0055
                        raw_sl = entry_for_sl * (1 - hard_offset) if side_api == 'BUY' else entry_for_sl * (1 + hard_offset)
                        sl_trigger = _round_to_tick(raw_sl, tick, price_prec) or (round(raw_sl, price_prec))
                        sl_src = sl_src or "fallback_offset:none"
    
                    # Dual-entry: after ENTRY1 fill, adjust ENTRY2 qty using actual stop width vs entry.
                    # This fixes cases where the planned stop% (based on last_price) is much smaller than
                    # the real stop% (based on the actual fill), which otherwise oversizes the position.
                    try:
                        if (
                            dual_entry_active_meta
                            and isinstance(meta, dict)
                            and tracked_oid is not None
                            and (not is_tracked_pending_fill)
                            and (not is_scale_in)
                            and sl_trigger
                        ):
                            meta = _adjust_entry2_after_entry1_fill(
                                symbol=symbol,
                                meta=meta,
                                tracked_oid=tracked_oid,
                                entry_price=entry_price,
                                sl_trigger=sl_trigger,
                                qty_entry1=qty,
                                step=step,
                                qty_prec=qty_prec,
                            )
                    except Exception:
                        pass
    
                    # Dual-entry: once ENTRY1 is open, disable PendingRelocator for this symbol
                    # (relocator would otherwise mistake ENTRY1 open as "pending filled").
                    try:
                        if (
                            dual_entry_active_meta
                            and tracked_oid is not None
                            and (not is_tracked_pending_fill)
                            and (not is_scale_in)
                            and 'relocator' in globals()
                            and relocator is not None
                        ):
                            relocator.unregister_pending_order(symbol)
                            log_message(f"ℹ️ PendingRelocator: unregistered pending for {symbol} after ENTRY1 fill")
                    except Exception:
                        pass
                    # Ensure only one closePosition SL exists (avoid -4130 duplicates after restarts/desync).
                    try:
                        close_side = "SELL" if side_api == 'BUY' else "BUY"
                    except Exception:
                        close_side = None
                    try:
                        canceled_sl_ids = cancel_open_closeposition_sl_orders(
                            symbol,
                            side=close_side,
                            position_side=position_side,
                        ) or []
                    except Exception:
                        canceled_sl_ids = []
                    if canceled_sl_ids:
                        try:
                            pos_set(symbol, sl_order_id=None)
                        except Exception:
                            pass
                        try:
                            log_message(f"[SL INIT] {symbol} canceled existing SLs: {canceled_sl_ids}")
                        except Exception:
                            pass
                    try:
                        sl_attempted = True
                        sl_resp = service.place_conditional({
                            "kind": "SL",
                            "symbol": symbol,
                            "side": "SELL" if side_api == 'BUY' else "BUY",
                            "position_side": position_side,
                            "trigger": sl_trigger,
                            "quantity": qty,
                            "close_position": True,
                            "entry_price": entry_for_sl,
                            "current_price": current_price,
                            # Для SL використовуємо CONTRACT_PRICE, щоб тригерити максимально швидко по останній ціні контракту
                            "working_type": "CONTRACT_PRICE",
                        })
                        if isinstance(sl_resp, dict):
                            algo_id = sl_resp.get('algoId') or sl_resp.get('orderId')
                        placed_any = placed_any or bool(sl_resp)
                        try:
                            if dual_entry_active_meta and tracked_oid is not None and (not is_tracked_pending_fill) and (not is_scale_in):
                                sl_anchor = "entry1"
                        except Exception:
                            pass
                        try:
                            hs = f"{float(sl_trigger):.8f}" if sl_trigger else "?"
                        except Exception:
                            hs = str(sl_trigger)
                        log_message(f"[SL INIT] {symbol} side={side_state} entry={entry_for_sl:.8f} current={current_price or 0:.8f} hard={hs} src={sl_src} algoId={algo_id}")
                        try:
                            if sl_trigger and algo_id:
                                chart_trade_record_sl(symbol, float(sl_trigger), trade_id=_chart_trade_current_id(symbol))
                        except Exception:
                            pass
                        try:
                            sl_dist_pct = None
                            try:
                                sl_dist_pct = abs(float(sl_trigger) - float(entry_for_sl)) / float(entry_for_sl) * 100.0
                            except Exception:
                                sl_dist_pct = None
                            sl_dist_part = f" ({sl_dist_pct:.2f}%)" if sl_dist_pct is not None else ""
                            _telegram_notify_once(
                                symbol,
                                "tg_sl_cycle",
                                f"🧷 SL {symbol}: {hs}{sl_dist_part}",
                                with_ts=True,
                            )
                        except Exception:
                            pass
                    except Exception as sl_err:
                        log_message(f"[ALGO ERR] SL place failed for {symbol}: {sl_err}")
    
                # If SL placement triggered an immediate MARKET close, don't continue to TP placement or trailing init.
                try:
                    with positions_lock:
                        closing_now = bool((open_positions.get(symbol) or {}).get('closing'))
                    if sl_attempted and closing_now and not algo_id:
                        try:
                            log_message(f"[FILLED] {symbol}: close initiated during SL setup -> skip TP/track init")
                        except Exception:
                            pass
                        try:
                            with orders_lock:
                                if not dual_entry_waiting:
                                    active_orders.pop(symbol, None)
                                    pending_meta.pop(symbol, None)
                        except Exception:
                            pass
                        return True
                except Exception:
                    pass
    
            qty_for_tp = qty
            entry_for_tp = entry_price
            if is_scale_in:
                qty_total = qty
                entry_total = entry_price
                try:
                    exch_amt, exch_entry = get_exchange_position(symbol)
                    qty_total = abs(float(exch_amt or 0.0))
                    entry_total = float(exch_entry or entry_price)
                except Exception:
                    qty_total = qty
                    entry_total = entry_price
                try:
                    if dual_entry_active_state:
                        pos_set(symbol, entry2_filled=True, entry2_pending=False, dual_entry_complete=True)
                except Exception:
                    pass
                try:
                    pos_set(symbol, qty=qty_total, entry_price=entry_total)
                except Exception:
                    pass
                # Dual-entry: force-enable trailing after ENTRY2 (and keep it enabled even after partial TP closes).
                try:
                    if dual_entry_active_state:
                        st_now = pos_get(symbol) or {}
                        if not _to_bool(st_now.get('dual_entry_complete')):
                            pos_set(symbol, dual_entry_complete=True)
                        if auto_place:
                            try:
                                ensure_trailing_stop(symbol)
                            except Exception:
                                pass
                except Exception:
                    pass
                qty_for_tp = qty_total
                entry_for_tp = entry_total
                try:
                    if dual_entry_active_state:
                        entry2_ref = entry_price
                        try:
                            if (not entry2_ref) or float(entry2_ref) <= 0:
                                if isinstance(meta, dict):
                                    if meta.get('stop_price') not in (None, "", 0):
                                        entry2_ref = float(meta.get('stop_price'))
                                    elif meta.get('level') not in (None, "", 0):
                                        entry2_ref = float(meta.get('level'))
                        except Exception:
                            pass
                        try:
                            if (
                                (not entry2_ref or float(entry2_ref) <= 0)
                                and (prev_state or {}).get('planned_entry2_price') not in (None, "", 0)
                            ):
                                entry2_ref = float((prev_state or {}).get('planned_entry2_price'))
                        except Exception:
                            pass
                        try:
                            if entry2_ref and float(entry2_ref) > 0:
                                entry_for_tp = float(entry2_ref)
                                log_message(f"[TP BASE] {symbol} dual-entry -> entry2={entry_for_tp:.8f}")
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    st_local = pos_get(symbol) or {}
                    trailing_pct = st_local.get('trailing_percent') or FALLBACK_TRAILING_PERCENT
                except Exception:
                    trailing_pct = FALLBACK_TRAILING_PERCENT
            else:
                trailing_pct = _initialize_tracked_position(
                    symbol,
                    side_api,
                    qty,
                    entry_price,
                    meta=meta,
                    trigger_trailing=False,
                    reason="ORDER_FILL"
                )
                if trailing_pct is None:
                    trailing_pct = FALLBACK_TRAILING_PERCENT

            # If ENTRY2 filled via the tracked pending order, mark it explicitly.
            try:
                if dual_entry_active_state and is_tracked_pending_fill:
                    pos_set(symbol, entry2_filled=True, entry2_pending=False, dual_entry_complete=True)
            except Exception:
                pass

            # Telegram: ENTRY2 (level) fill (position is now full size or first fill if ENTRY1 skipped)
            try:
                if tg_emit_entry2:
                    level_part = ""
                    try:
                        if level_val is not None:
                            level_part = f" level={float(level_val):.{price_prec}f}"
                    except Exception:
                        level_part = f" level={level_val}"
                    title = "Вхід (рівень)" if tg_entry2_is_first else "Вхід 2 (рівень)"
                    _telegram_notify_once(
                        symbol,
                        "tg_entry2_cycle",
                        f"⚡ {title} {symbol} {side_state} qty={qty_for_tp:.{qty_prec}f} entry={entry_for_tp:.{price_prec}f}{level_part}",
                        with_ts=True,
                    )
            except Exception:
                pass

            # Persist planned hard SL for reference/debug (not used by trailing logic)
            try:
                if sl_trigger:
                    pos_set(symbol, hard_sl_trigger=sl_trigger, hard_sl_source=sl_src)
            except Exception:
                pass

            if algo_id:
                try:
                    if sl_anchor:
                        pos_set(symbol, sl_order_id=algo_id, sl_anchor=sl_anchor)
                    else:
                        pos_set(symbol, sl_order_id=algo_id)
                except Exception:
                    pass

            # Persist dual-entry plan into position state (survives pending_meta/active_orders cleanup).
            try:
                if isinstance(meta, dict):
                    dual_entry_plan = bool(meta.get('dual_entry'))
                else:
                    dual_entry_plan = False
            except Exception:
                dual_entry_plan = False
            if dual_entry_plan:
                try:
                    entry1_sent = None
                    try:
                        if isinstance(meta, dict) and 'entry1_sent' in meta:
                            entry1_sent = _to_bool(meta.get('entry1_sent'))
                    except Exception:
                        entry1_sent = None
                    try:
                        plan_entry1 = float((meta or {}).get('entry1_qty') or 0.0)
                    except Exception:
                        plan_entry1 = None
                    try:
                        plan_entry2 = float((meta or {}).get('entry2_qty') or (meta or {}).get('quantity') or 0.0)
                    except Exception:
                        plan_entry2 = None
                    try:
                        plan_total = float((meta or {}).get('quantity_total') or 0.0)
                    except Exception:
                        plan_total = None
                    plan_entry2_price = None
                    try:
                        if (meta or {}).get('stop_price') not in (None, "", 0):
                            plan_entry2_price = float((meta or {}).get('stop_price'))
                        elif (meta or {}).get('level') not in (None, "", 0):
                            plan_entry2_price = float((meta or {}).get('level'))
                    except Exception:
                        plan_entry2_price = None

                    # If ENTRY1 wasn't sent, treat ENTRY2 as the full position size.
                    if entry1_sent is False and plan_entry2 and float(plan_entry2) > 0:
                        plan_total = float(plan_entry2)
                    elif (not plan_total or float(plan_total) <= 0) and plan_entry1 is not None and plan_entry2 is not None:
                        try:
                            plan_total = float(plan_entry1) + float(plan_entry2)
                        except Exception:
                            pass

                    if plan_total and float(plan_total) > 0:
                        pos_set(
                            symbol,
                            dual_entry=True,
                            planned_qty_total=float(plan_total),
                            planned_entry1_qty=plan_entry1,
                            planned_entry2_qty=plan_entry2,
                            planned_entry2_price=plan_entry2_price,
                            entry1_sent=entry1_sent,
                        )
                        try:
                            if entry1_sent is True and (not is_tracked_pending_fill) and (not is_scale_in):
                                pos_set(symbol, entry2_pending=True)
                        except Exception:
                            pass
                except Exception:
                    pass

            # ---- TP placement (queue & release) ----
            do_tp = bool(auto_place)
            # Dual-entry: place TP only when the position is fully opened (ENTRY1+ENTRY2).
            try:
                de_wait, de_plan, de_cur, de_tol = _dual_entry_wait_state(symbol, meta=meta)
            except Exception:
                de_wait, de_plan, de_cur, de_tol = False, None, None, None
            entry2_ready = True
            try:
                entry2_ready, _p2, _c2 = _dual_entry_entry2_ready(symbol, meta=meta, qty_current=de_cur)
            except Exception:
                entry2_ready = True
            # Dual-entry: once full size is observed, mark completion so trailing isn't gated later.
            try:
                if (
                    dual_entry_active_state
                    and (de_plan is not None and float(de_plan) > 0)
                    and entry2_ready
                ):
                    st_now = pos_get(symbol) or {}
                    if not _to_bool(st_now.get('dual_entry_complete')):
                        pos_set(symbol, dual_entry_complete=True)
                        if auto_place:
                            try:
                                ensure_trailing_stop(symbol)
                            except Exception:
                                pass
            except Exception:
                pass
            if de_wait:
                do_tp = False
                try:
                    log_message(
                        f"[TP] deferred {symbol}: waiting full position qty "
                        f"(cur={de_cur:.8f} < plan={de_plan:.8f}, tol={de_tol})"
                    )
                except Exception:
                    pass
            elif not entry2_ready:
                do_tp = False
                try:
                    log_message(f"[TP] deferred {symbol}: waiting ENTRY2 fill confirmation")
                except Exception:
                    pass
            if is_scale_in:
                try:
                    st_tp = pos_get(symbol) or {}
                    tp_filled_cnt = int(st_tp.get('tp_filled', 0) or 0)
                except Exception:
                    tp_filled_cnt = 0
                # If TP chain already started, don't disrupt it on scale-in.
                if tp_filled_cnt > 0:
                    do_tp = False
                    try:
                        log_message(f"[TP] skip replan on scale-in {symbol}: tp_filled={tp_filled_cnt}")
                    except Exception:
                        pass
                else:
                    # Rebuild TP plan for the new total position size.
                    try:
                        cancel_all_tps(symbol)
                    except Exception:
                        pass
                    try:
                        with tp_lock:
                            pending_tps.pop(symbol, None)
                            tp_orders.pop(symbol, None)
                    except Exception:
                        pass

            tp_levels = []
            if do_tp:
                tp_levels = compute_dynamic_tps(
                    entry_for_tp,
                    trailing_pct,
                    side_api or _side_to_api(side_state),
                    parts=TP_PARTS,
                    rr_min=RR_MIN,
                    rr_max=RR_MAX,
                    weight_power=TP_WEIGHT_POWER
                )
            if do_tp:
                try:
                    preview = [f"TP{idx+1}={round(t[0], price_prec)}(rr={t[2]:.2f})" for idx, t in enumerate(tp_levels)]
                    log_message(f"✔️✔️✔️[TP PLAN] {symbol} parts={len(tp_levels)} | " + ", ".join(preview))
                except Exception:
                    pass
            if tp_levels:
                try:
                    weights = [w for (_, w, _) in tp_levels]
                    total_qty = round(qty_for_tp, qty_prec)
                    parts_qty = []
                    for w in weights[:-1]:
                        parts_qty.append(round(total_qty * float(w), qty_prec))
                    remainder = round(max(total_qty - sum(parts_qty), 0), qty_prec)
                    parts_qty.append(remainder)
                except Exception:
                    parts_qty = [qty_for_tp] + [0] * (len(tp_levels) - 1)

                tp_queue = []
                for idx, ((tp_price, _w, rr), part_qty) in enumerate(zip(tp_levels, parts_qty), start=1):
                    if part_qty <= 0:
                        continue
                    tp_queue.append((tp_price, part_qty, rr, meta))
                    try:
                        log_message(f"[TP{idx}] {symbol}: price={round(tp_price, price_prec)} qty={part_qty} RR={rr}")
                    except Exception:
                        pass
                with tp_lock:
                    pending_tps[symbol] = tp_queue
                placed_any = True

                # Place TP1 immediately (sync) right after open to minimize delay.
                # Keep the rest of TP levels in pending_tps for the normal chain.
                tp1_placed = False
                try:
                    with tp_lock:
                        tp1_placed = bool(tp_orders.get(symbol))
                except Exception:
                    tp1_placed = False

                if not tp1_placed and tp_queue:
                    try:
                        first_tp_price, first_qty, first_rr, _m = tp_queue[0]
                        tp_side = 'SELL' if (side_api or '').upper() == 'BUY' else 'BUY'
                        first_qty_round = round(first_qty, qty_prec)
                        first_price_round = round(first_tp_price, price_prec)
                        try:
                            passed, cp_val, cp_src = _tp_is_passed(symbol, first_price_round, tp_side)
                        except Exception:
                            passed, cp_val, cp_src = False, None, None
                        if passed:
                            try:
                                if _tp_place_market_close(symbol, tp_side, first_qty_round,
                                                          tp_price=first_price_round, current_price=cp_val, current_src=cp_src):
                                    with tp_lock:
                                        q = pending_tps.get(symbol) or []
                                        try:
                                            q = list(q)
                                        except Exception:
                                            q = q
                                        if q:
                                            q.pop(0)
                                        if q:
                                            pending_tps[symbol] = q
                                        else:
                                            pending_tps.pop(symbol, None)
                                    _tp_mark_filled(symbol, source="MARKET")
                                    tp1_placed = True
                            except Exception:
                                pass
                        if not tp1_placed:
                            oid = futures_place_limit_reduce_only(symbol, first_price_round, first_qty_round, tp_side, tag="TP")
                            if oid:
                                with tp_lock:
                                    tp_orders.setdefault(symbol, set()).add(int(oid))
                                    q = pending_tps.get(symbol) or []
                                    try:
                                        q = list(q)
                                    except Exception:
                                        q = q
                                    if q:
                                        q.pop(0)
                                    if q:
                                        pending_tps[symbol] = q
                                    else:
                                        pending_tps.pop(symbol, None)
                                st = pos_get(symbol) or {}
                                idx = int(st.get('tp_filled') or 0) + 1
                                log_message(f"[TP] PLACED{idx} {symbol}: price={first_price_round} qty={first_qty_round} rr={first_rr} oid={oid}")
                                add_order_row(symbol, 'TP', first_qty_round, first_price_round, '-')
                                tp1_placed = True
                    except Exception as __tp1_err:
                        try:
                            log_message(f"[TP ERR] immediate TP1 placement failed for {symbol}: {__tp1_err}")
                        except Exception:
                            pass

                if not tp1_placed:
                    try:
                        threading.Thread(target=release_next_tp, args=(symbol,), daemon=True).start()
                    except Exception:
                        release_next_tp(symbol)

            # Clear pending tracking only if this FILLED corresponds to the tracked pending order.
            # (For dual-entry: keep active_orders/pending_meta after ENTRY1 market fill.)
            try:
                if tracked_oid is None or is_tracked_pending_fill:
                    with orders_lock:
                        active_orders.pop(symbol, None)
                        pending_meta.pop(symbol, None)
            except Exception:
                pass

            if placed_any and not is_scale_in:
                _safe_sound(symbol, side_state, qty)
            if auto_place:
                try:
                    trailing_stop_check(symbol, current_price=current_price)
                except Exception:
                    pass
            try:
                global last_balance_snapshot
                last_balance_snapshot = get_balance()
                log_message(f"ℹ️ Balance snapshot at open: {last_balance_snapshot:.6f}")
            except Exception as e:
                log_message(f"❌ Не вдалось зняти snapshot балансу на відкритті: {e}")
            return True
        except Exception as e:
            log_message(f"[FILLED ERR] {e}")
            log_message(traceback.format_exc())
            return False

    # Deduplicate ORDER_TRADE_UPDATE events to avoid double-processing from WS reconnects
    try:
        global LAST_WS_MESSAGE_TS, LAST_USER_WS_MESSAGE_TS
        now_ts = time.time()
        LAST_WS_MESSAGE_TS = now_ts
        LAST_USER_WS_MESSAGE_TS = now_ts
        try:
            _set_connection_state(True)
        except Exception:
            pass
        order_id = None
        status = None
        symbol_in_msg = None
        if isinstance(msg, dict):
            # order id can be in different places depending on WS message shape
            order_id = msg.get('orderId') or msg.get('order_id') or (msg.get('o') or {}).get('i') or (
                    msg.get('o') or {}).get('orderId')
            status = msg.get('status') or msg.get('X') or msg.get('x') or (msg.get('o') or {}).get('X') or (msg.get('o') or {}).get('x')
            # symbol can be at top-level 's' or 'symbol' or inside 'o'
            symbol_in_msg = msg.get('s') or msg.get('symbol') or (msg.get('o') or {}).get('s')
        dedup_symbol = symbol_in_msg if symbol_in_msg else 'unknown'
        if order_id is not None and status is not None:
            dedup_key = f"{dedup_symbol}:{order_id}:{status}"
            if dedup_key in processed_order_events:
                return
            processed_order_events.add(dedup_key)
            # keep set size bounded
            if len(processed_order_events) > 20000:
                processed_order_events.clear()
    except Exception:
        pass

    global consecutive_losses, trading_paused_until
    try:
        e = msg.get('e')
        try:
            global first_user_event_logged
            if not first_user_event_logged and e:
                first_user_event_logged = True
        except Exception:
            pass

        # --- Futures ACCOUNT_UPDATE: keep UI position marker in sync even when bot is NOT running ---
        if e == 'ACCOUNT_UPDATE':
            try:
                a = msg.get('a', {}) or {}
                plist = a.get('P') or a.get('positions') or []
                updated_any = False
                # Update open_positions (used for orderbook marker) with minimal fields (UI-only)
                with positions_lock:
                    # We update only symbols present in this message; remove if size becomes 0
                    for p in plist or []:
                        try:
                            sym = str(p.get('s') or p.get('symbol') or '').upper()
                            if not sym:
                                continue
                            amt = float(p.get('pa') or p.get('positionAmt') or 0.0)
                            ep = float(p.get('ep') or p.get('entryPrice') or 0.0)
                            if abs(amt) <= 1e-12:
                                if sym in open_positions:
                                    # mark as closed for UI
                                    open_positions.pop(sym, None)
                                    updated_any = True
                                continue
                            side = 'LONG' if amt > 0 else 'SHORT'
                            open_positions[sym] = {
                                'symbol': sym,
                                'side': side,
                                'qty': abs(float(amt)),
                                'entry_price': float(ep or 0.0),
                                'ui_only': True,
                                'manual': True,
                                'ts': time.time(),
                            }
                            updated_any = True
                        except Exception:
                            continue
                if updated_any:
                    try:
                        log_message("📌 ACCOUNT_UPDATE позиція оновлена (prestart OK)")
                    except Exception:
                        pass
            except Exception:
                pass
        if e == 'ORDER_TRADE_UPDATE':
            o = msg.get('o', {})
            symbol = o.get('s') or o.get('symbol')
            status = o.get('X') or o.get('x') or o.get('X')
            side = o.get('S') or o.get('side')
            order_type = o.get('o') or o.get('type')
            avg_price = float(o.get('ap') or o.get('avgPrice') or 0)
            qty = float(o.get('origQty') or o.get('q') or 0)
            orderId = o.get('i') or o.get('orderId')
            try:
                _update_open_orders_cache_from_ws(o, status=status)
            except Exception:
                pass
            # Parse reduceOnly robustly: strings like 'false'/'0' must be False
            reduce_only = o.get('R') or o.get('reduceOnly')
            exec_type = str(o.get('x') or o.get('executionType') or '').upper()
            try:
                fill_qty = abs(float(o.get('l') or o.get('lastFilledQty') or 0))
            except Exception:
                fill_qty = 0.0
            try:
                fill_price = float(o.get('L') or o.get('lastFilledPrice') or avg_price or 0)
            except Exception:
                fill_price = avg_price
            realized_event = None
            try:
                if o.get('rp') not in (None, ''):
                    realized_event = o.get('rp')
                elif o.get('realizedPnL') not in (None, ''):
                    realized_event = o.get('realizedPnL')
            except Exception:
                realized_event = None
            try:
                reduce_only = _to_bool(reduce_only)
            except Exception:
                # fallback to safe False on error
                reduce_only = False
            try:
                close_position_flag = _to_bool(o.get('cp') or o.get('closePosition'))
            except Exception:
                close_position_flag = False
            try:
                if exec_type == 'TRADE' and str(status or '').upper() == 'FILLED' and (reduce_only or close_position_flag):
                    is_tp_tracked = False
                    try:
                        with tp_lock:
                            tracked_tp = tp_orders.get(symbol, set())
                            if not isinstance(tracked_tp, set):
                                tracked_tp = set(tracked_tp)
                        if orderId and tracked_tp and int(orderId) in {int(x) for x in tracked_tp}:
                            is_tp_tracked = True
                    except Exception:
                        is_tp_tracked = False
                    if not is_tp_tracked:
                        close_price = fill_price or avg_price
                        close_ts = None
                        try:
                            close_raw_ts = o.get('T') or o.get('E') or o.get('transactTime')
                            if close_raw_ts:
                                close_ts = float(close_raw_ts) / 1000.0
                        except Exception:
                            close_ts = None
                        try:
                            with last_close_fill_lock:
                                last_close_fill_cache[symbol] = (float(close_price or 0.0), close_ts or time.time())
                        except Exception:
                            pass
                        chart_trade_record_event(
                            symbol, side, close_price, ts=close_ts, kind="CLOSE", qty=(fill_qty or qty)
                        )
            except Exception:
                pass
            # Unified post-fill pipeline
            try:
                if exec_type == 'TRADE' and str(status or '').upper() == 'FILLED':
                    # Offload post-fill processing out of WS callback thread to avoid freezes / dropped events
                    try:
                        _PRICE_EXECUTOR.submit(handle_filled_event, msg)
                        return
                    except Exception:
                        try:
                            if handle_filled_event(msg):
                                return
                        except Exception:
                            pass
            except Exception:
                pass
            # Suppress manual order placement/cancel logs (requested).

            # EARLY TP handler: if this update corresponds to a tracked TP order, handle here and skip generic handling.
            tp_filled_now = False
            try:
                tracked = set()
                with tp_lock:
                    existing_tp = tp_orders.get(symbol, set())
                    if not isinstance(existing_tp, set):
                        existing_tp = set(existing_tp)
                        tp_orders[symbol] = existing_tp
                    tracked = set(existing_tp)
                if orderId and tracked and int(orderId) in {int(x) for x in tracked}:
                    log_message(f"ℹ️ TP order update detected for {symbol}: orderId={orderId}, status={status}")
                    if status == 'FILLED':
                        try:
                            with tp_lock:
                                if symbol in tp_orders:
                                    tp_orders[symbol].discard(int(orderId))
                                    if not tp_orders[symbol]:
                                        tp_orders.pop(symbol, None)
                        except Exception:
                            log_message(f"❌ Error removing TP orderId from tp_orders for {symbol}: {orderId}")
                        try:
                            pos = pos_get(symbol) or {}
                            tp_idx = int(pos.get('tp_filled', 0)) + 1
                            pos_set(symbol, tp_filled=tp_idx)
                        except Exception:
                            tp_idx = 1
                        log_message(f"✅ TP{tp_idx} FILLED {symbol}")
                        try:
                            tp_ts = None
                            try:
                                tp_raw_ts = o.get('T') or o.get('E') or o.get('transactTime')
                                if tp_raw_ts:
                                    tp_ts = float(tp_raw_ts) / 1000.0
                            except Exception:
                                tp_ts = None
                            chart_trade_record_event(
                                symbol, side, fill_price or avg_price, ts=tp_ts, kind="TP", qty=(fill_qty or qty)
                            )
                        except Exception:
                            pass
                        tp_filled_now = True
                        try:
                            threading.Thread(target=release_next_tp, args=(symbol,), daemon=True).start()
                        except Exception as __e_rel:
                            log_message(f"❌ Failed to start release_next_tp thread for {symbol}: {__e_rel}")
                        # reduce base trailing_percent by 0.05% on TP filled
                        try:
                            pos = pos_get(symbol) or {}
                            base = pos.get('base_trailing_percent', pos.get('trailing_percent', FALLBACK_TRAILING_PERCENT))
                            new_base = max(MIN_TRAIL_PCT, base - 0.05)
                            pos_set(symbol, base_trailing_percent=new_base, trailing_percent=min(pos.get('trailing_percent', new_base), new_base))
                            log_message(
                                f"ℹ️ TP FILLED adjust trailing for {symbol}: base {base:.4f}% -> {new_base:.4f}%")
                        except Exception:
                            pass
                    else:
                        if status in ('CANCELED', 'EXPIRED'):
                            try:
                                with tp_lock:
                                    if symbol in tp_orders:
                                        tp_orders[symbol].discard(int(orderId))
                                        if not tp_orders[symbol]:
                                            tp_orders.pop(symbol, None)
                            except Exception:
                                pass
            except Exception:
                pass

            # Manage active_orders: remove only on explicit CANCELED/EXPIRED
            if orderId:

                removed_pending_symbols = []
                try:
                    with orders_lock:
                        for sym, oid in list(active_orders.items()):
                            if str(oid) == str(orderId):
                                if status in ('CANCELED', 'EXPIRED'):
                                    try:
                                        del active_orders[sym]
                                        try:
                                            removed_pending_symbols.append(sym)
                                        except Exception:
                                            pass
                                    except KeyError:
                                        pass
                                    # unregister relocator for this symbol if present
                                    try:
                                        if relocator is not None:
                                            try:
                                                relocator.unregister_pending_order(sym)
                                            except Exception as __e:
                                                log_message(f"Relocator unregister error for {sym}: {__e}")
                                    except Exception:
                                        pass
                                    remove_order_rows(lambda row, s=sym: row.get('symbol') == s)
                                else:
                                    # If FILLED, keep active_orders/pending_meta until post-fill TP logic runs
                                    pass
                except Exception as ex:
                    log_message(f"❌ Помилка при обробці active_orders у _handle_user_message: {ex}")
                    log_message(traceback.format_exc())

            # If any pending orders were removed due to CANCELED/EXPIRED, ban those symbols briefly
            try:
                for _sym in removed_pending_symbols:
                    try:
                        ban_symbol(_sym)
                    except Exception:
                        pass
            except Exception:
                pass

            # handle tp_orders cleanup for canceled/executed TPs
            if orderId:
                try:
                    with tp_lock:
                        for sym in list(tp_orders.keys()):
                            tp_set_raw = tp_orders.get(sym, set())
                            tp_set = tp_set_raw if isinstance(tp_set_raw, set) else set(tp_set_raw)
                            tp_orders[sym] = tp_set
                            if str(orderId) in {str(x) for x in tp_set}:
                                tp_set.discard(int(orderId))
                                if status == 'FILLED' and not tp_filled_now:
                                    try:
                                        threading.Thread(target=release_next_tp, args=(sym,), daemon=True).start()
                                    except Exception:
                                        pass
                                if not tp_set:
                                    tp_orders.pop(sym, None)
                                    remove_order_rows(lambda row, s=sym: row.get('symbol') == s and str(row.get('tp_sl', '')).startswith('TP'))
                                else:
                                    tp_orders[sym] = tp_set
                except Exception as ex:
                    log_message(f"❌ Помилка в обробці tp_orders у _handle_user_message: {ex}")
                    log_message(traceback.format_exc())

            # handle fills / account updates for positions
            # Do not gate on qty>0 because some WS payloads may omit/zero it for STOP/TP market fills
            if status in ('FILLED', 'PARTIALLY_FILLED'):
                # Synchronize with exchange to determine actual resulting position
                try:
                    exch_amt, exch_entry = get_exchange_position(symbol)
                except Exception:
                    exch_amt, exch_entry = 0, 0
                qty_actual = abs(exch_amt) if isinstance(exch_amt, (int, float)) else 0
                entry_actual = exch_entry
                side_actual = 'BUY' if (isinstance(exch_amt, (int, float)) and exch_amt > 0) else ('SELL' if (isinstance(exch_amt, (int, float)) and exch_amt < 0) else None)
                side_actual_state = _norm_side(side_actual)
                try:
                    prev_state = pos_get(symbol) or {}
                    prev_qty = prev_state.get('qty', 0.0)
                    prev_side_state = prev_state.get('side')
                    prev_entry = prev_state.get('entry_price') or 0.0
                except Exception:
                    prev_qty = 0.0
                    prev_side_state = None
                    prev_entry = 0.0
                prev_api_side = _side_to_api(prev_side_state)
                order_api_side = _side_to_api(side)
                realized_delta = 0.0
                if realized_event not in (None, ''):
                    try:
                        realized_delta = float(realized_event)
                    except Exception:
                        realized_delta = 0.0
                else:
                    closing = False
                    try:
                        if reduce_only:
                            closing = True
                        elif prev_api_side and order_api_side and prev_api_side != order_api_side:
                            closing = True
                    except Exception:
                        closing = False
                    if closing and fill_qty and prev_entry:
                        try:
                            close_qty = min(prev_qty, fill_qty if fill_qty > 0 else prev_qty)
                        except Exception:
                            close_qty = fill_qty or prev_qty
                        if prev_api_side == 'BUY':
                            realized_delta = close_qty * (fill_price - prev_entry)
                        elif prev_api_side == 'SELL':
                            realized_delta = close_qty * (prev_entry - fill_price)
                try:
                    if realized_delta:
                        pos = pos_get(symbol) or {}
                        new_realized = float(pos.get('realized_pnl', 0.0)) + float(realized_delta or 0.0)
                        pos_set(symbol, realized_pnl=new_realized)
                except Exception:
                    pass

                fallback_entry = False
                if qty_actual <= 0:
                    try:
                        price_hint = avg_price
                        if not price_hint:
                            price_hint = float(o.get('L') or o.get('lastFilledPrice') or 0)
                    except Exception:
                        price_hint = 0.0
                    if not price_hint:
                        try:
                            price_hint = float(o.get('sp') or o.get('stopPrice') or 0)
                        except Exception:
                            price_hint = 0.0
                    side_hint = (side or '').upper()
                    if not side_hint:
                        side_hint = 'BUY' if qty > 0 else 'SELL'
                    if qty > 0 and price_hint and not reduce_only:
                        qty_actual = qty
                        entry_actual = price_hint
                        side_actual = 'BUY' if side_hint == 'BUY' else 'SELL'
                        fallback_entry = True
                    else:
                        try:
                            log_message(
                                f"Fallback entry not used for {symbol}: qty={qty}, price_hint={price_hint}, reduce_only={reduce_only}")
                        except Exception:
                            pass

                side_actual_state = _norm_side(side_actual)
                # If exch_amt == 0 -> nothing; otherwise we have a position on the exchange
                if qty_actual > 0:
                    if prev_qty <= eps or (prev_side_state and side_actual_state and prev_side_state != side_actual_state):
                        side_actual = side_actual or ('BUY' if exch_amt > 0 else 'SELL')
                        side_actual_state = _norm_side(side_actual)
                        if prev_side_state and side_actual_state and prev_side_state != side_actual_state and prev_qty > eps:
                            try:
                                st_prev = pos_get(symbol) or {}
                                realized_total = st_prev.get('realized_pnl', 0.0)
                                log_message(f"📕 POSITION CLOSED {symbol} | realizedPnL={realized_total:+.6f} (flip)")
                                cleanup_position(symbol, reason="SIDE_FLIP")
                            except Exception:
                                pass
                        with orders_lock:
                            meta = pending_meta.get(symbol)
                        trailing_pct = _initialize_tracked_position(
                            symbol,
                            side_actual,
                            qty_actual,
                            entry_actual,
                            meta=meta,
                            trigger_trailing=True,
                            reason="ORDER_FILL"
                        )
                        pos_set(
                            symbol,
                            qty=qty_actual,
                            entry_price=entry_actual,
                            side=side_actual_state,
                            tp_filled=0,
                            max_price=entry_actual if side_actual_state == 'LONG' else None,
                            min_price=entry_actual if side_actual_state == 'SHORT' else None,
                        )
                        if fallback_entry:
                            try:
                                log_message(
                                    f"ℹ️ Fallback trailing init для {symbol}: side={side_actual} qty={qty_actual} entry={entry_actual} (позиція ще не повернулась через REST)")
                            except Exception:
                                pass
                        log_message(
                            f"✅ Синхронізовано позицію {symbol} після FILLED: side={side_actual} qty={qty_actual} entry={entry_actual}")
                        try:
                            if play_trade_open_alert_once(symbol, side_actual, qty_actual):
                                log_message("🔊 Звук: відкриття позиції відтворено")
                        except Exception:
                            pass
                        try:
                            if relocator is not None:
                                try:
                                    relocator.unregister_pending_order(symbol)
                                except Exception as __e:
                                    log_message(f"Relocator unregister error for {symbol}: {__e}")
                        except Exception:
                            pass
                        try:
                            dual_entry_waiting = False
                            tracked_oid_local = None
                            with orders_lock:
                                meta = pending_meta.get(symbol)
                                tracked_oid_local = active_orders.get(symbol)
                            try:
                                dual_entry_active = bool(meta.get('dual_entry')) if isinstance(meta, dict) else False
                            except Exception:
                                dual_entry_active = False
                            try:
                                is_tracked_pending_fill = bool(
                                    tracked_oid_local is not None and orderId is not None and str(tracked_oid_local) == str(orderId)
                                )
                            except Exception:
                                is_tracked_pending_fill = False
                            try:
                                dual_entry_waiting, _, _, _ = _dual_entry_wait_state(symbol, meta=meta, qty_current=qty_actual)
                            except Exception:
                                dual_entry_waiting = False
                            if auto_place_running and (not maybe_create_post_fill_tps(symbol, side_actual, qty_actual, entry_actual)):
                                # якщо fallback не створив, почистимо pending_meta вручну
                                if not dual_entry_waiting:
                                    with orders_lock:
                                        # pending_meta preserved (not cleared on FILLED)
                                        active_orders.pop(symbol, None)
                                # Fallback: якщо не було pending_meta, але позиція відкрита і TP ще немає — створимо прості TP
                                try:
                                    tp_present = bool(dual_entry_waiting)
                                    with tp_lock:
                                        tp_present = bool(tp_present) or bool(tp_orders.get(symbol)) or bool(pending_tps.get(symbol))
                                    if not tp_present:
                                        try:
                                            qty_precision, price_precision = get_symbol_precision(symbol)
                                        except Exception:
                                            qty_precision, price_precision = 0, 8
                                        pos_state = pos_get(symbol) or {}
                                        trailing_pct_local = pos_state.get('trailing_percent', FALLBACK_TRAILING_PERCENT)
                                        tps = compute_dynamic_tps(
                                            entry_actual,
                                            trailing_pct_local,
                                            side_actual,
                                            parts=TP_PARTS,
                                            rr_min=RR_MIN,
                                            rr_max=RR_MAX,
                                            weight_power=TP_WEIGHT_POWER
                                        )
                                        weights = [w for (_, w, _) in tps] or [1.0]
                                        total_qty = round(qty_actual, qty_precision)
                                        parts_qty = []
                                        for w in weights[:-1]:
                                            parts_qty.append(round(total_qty * float(w), qty_precision))
                                        remainder = round(max(total_qty - sum(parts_qty), 0), qty_precision)
                                        parts_qty.append(remainder)
                                        with tp_lock:
                                            pending_tps[symbol] = []
                                        for idx, ((tp_price, _, rr), part_qty) in enumerate(zip(tps, parts_qty), start=1):
                                            if part_qty <= 0:
                                                continue
                                            with tp_lock:
                                                pending_tps.setdefault(symbol, []).append((tp_price, part_qty, rr, {}))
                                            log_message(f"✔️TP{idx} ✔️ {symbol}: price={round(tp_price, price_precision)} qty={part_qty} RR={rr}")
                                        try:
                                            threading.Thread(target=release_next_tp, args=(symbol,), daemon=True).start()
                                        except Exception:
                                            release_next_tp(symbol)
                                except Exception as _tp_fallback_err:
                                    log_message(f"⚠️ Fallback TP створення не вдалося для {symbol}: {_tp_fallback_err}")
                            elif not auto_place_running:
                                if not dual_entry_waiting:
                                    with orders_lock:
                                        active_orders.pop(symbol, None)
                        except Exception as ex:
                            log_message(f"❌ Помилка при створенні post-fill TP для {symbol}: {ex}")
                            log_message(traceback.format_exc())
                        with orders_lock:
                            active_orders.pop(symbol, None)
                    else:
                        pos_set(
                            symbol,
                            qty=qty_actual,
                            entry_price=entry_actual,
                            side=side_actual_state,
                        )
                        if auto_place_running:
                            try:
                                ensure_trailing_stop(symbol)
                            except Exception:
                                pass
                        try:
                            log_message(f"ℹ️ Оновлено позицію {symbol}: qty={qty_actual} entry={entry_actual} side={side_actual}")
                        except Exception:
                            pass

                else:
                    # Після FILLED на біржі позиції немає — це було закриття/зниження позиції, TP не створюємо.
                    try:
                        st = pos_get(symbol) or {}
                        try:
                            entry_price = float(st.get('entry_price') or 0.0)
                        except Exception:
                            entry_price = 0.0
                        try:
                            side_state = _norm_side(st.get('side'))
                        except Exception:
                            side_state = None
                        trade_id = None
                        try:
                            trade_id = _chart_trade_current_id(symbol)
                        except Exception:
                            trade_id = None
                        entry_event = None
                        try:
                            entry_event = _chart_trade_find_entry_event(symbol, trade_id)
                        except Exception:
                            entry_event = None
                        if (not entry_price) and entry_event:
                            try:
                                entry_price = float(entry_event.get('price') or 0.0)
                            except Exception:
                                entry_price = 0.0
                        if not side_state and entry_event:
                            ev_side = str(entry_event.get('side') or '').upper()
                            if ev_side == 'BUY':
                                side_state = 'LONG'
                            elif ev_side == 'SELL':
                                side_state = 'SHORT'
                        entry_ts = None
                        if entry_event:
                            try:
                                entry_ts = float(entry_event.get('ts') or 0.0) or None
                            except Exception:
                                entry_ts = None
                        try:
                            with last_close_entry_lock:
                                last_close_entry_cache[symbol] = {
                                    'entry_price': entry_price,
                                    'side': side_state,
                                    'trade_id': trade_id,
                                    'entry_ts': entry_ts,
                                }
                        except Exception:
                            pass
                        realized_total = st.get('realized_pnl', 0.0)
                        log_message(f"📕 POSITION CLOSED {symbol} | realizedPnL={realized_total:+.6f}")
                        cleanup_position(symbol, reason="ORDER_TRADE_UPDATE")
                    except Exception:
                        pass
                    pnl_percent_total = None
                    new_balance = None
                    try:
                        new_balance = get_balance()
                    except Exception:
                        new_balance = None
                    try:
                        pnl_percent_total = get_pnl_percent_from_gui(retry_delay=5)
                        if pnl_percent_total is None:
                            log_message("⚠️ Не вдалося прочитати PnL з GUI — використовую fallback обчислення від initial_balance")
                        else:
                            log_message(f"📝 PnL з початку запуску бота {pnl_percent_total:+.2f}%")
                    except Exception as e:
                        log_message(f"❌ Помилка при читанні PnL з GUI: {e}")
                        pnl_percent_total = None

                    try:
                        pnl_trade_delta = None
                        try:
                            start_ts = None
                            try:
                                start_ts = float((st or {}).get('trail_start_ts') or 0.0)
                            except Exception:
                                start_ts = None
                            if start_ts and start_ts > 0:
                                bd = _get_futures_pnl_window_breakdown(
                                    symbol,
                                    start_ts,
                                    required_order_id=orderId,
                                    max_wait_s=2.5,
                                )
                                if bd and bd.get('net_pnl') is not None:
                                    pnl_trade_delta = float(bd.get('net_pnl') or 0.0)
                        except Exception:
                            pnl_trade_delta = None
                        if pnl_trade_delta is not None:
                            safe_on_position_closed_balance_log(symbol, pnl_delta=pnl_trade_delta)
                        else:
                            safe_on_position_closed_balance_log(symbol)
                    except Exception:
                        pass

                    try:
                        if pnl_percent_total is None and initial_balance and new_balance is not None:
                            try:
                                pnl_percent_total = ((new_balance - initial_balance) / initial_balance) * 100
                                log_message(
                                    f"ℹ️ Fallback computed PnL total = {pnl_percent_total:+.2f}% (from initial_balance)")
                            except Exception:
                                pnl_percent_total = None

                        if pnl_percent_total is not None:
                            if PROFIT_STOP_ENABLED and pnl_percent_total >= PROFIT_STOP_THRESHOLD_PERCENT:
                                now = _kyiv_now()
                                next_mid = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0,
                                                                             microsecond=0)
                                trading_paused_until = max(trading_paused_until, next_mid.timestamp())
                                log_message(
                                    f"🏁 PROFIT_STOP activated! PnL total = {pnl_percent_total:.2f}%. Trading paused until next Kyiv midnight.")
                            elif LOSS_STOP_ENABLED and pnl_percent_total <= -LOSS_STOP_THRESHOLD_PERCENT:
                                now = _kyiv_now()
                                next_mid = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0,
                                                                             microsecond=0)
                                trading_paused_until = max(trading_paused_until, next_mid.timestamp())
                                log_message(
                                    f"⛔ LOSS_STOP activated! PnL total = {pnl_percent_total:.2f}%. Trading paused until next Kyiv midnight.")
                    except Exception as e:
                        log_message(f"❌ Помилка при перевірці PROFIT/LOSS STOP: {e}")

                    try:
                        pass
                    except Exception:
                        pass
                    time.sleep(0.5)
            else:
                # Закриваючий ордер або інші оновлення — синхронізація з біржею
                try:
                    exch_amt, exch_entry = get_exchange_position(symbol)
                    exch_qty = abs(exch_amt)
                    if exch_qty <= 1e-8:
                        time.sleep(0.5)
                        had_open = False
                        if pos_get(symbol):
                            had_open = True
                            cleanup_position(symbol, reason="REST_ZERO")
                        # cancel TP if position closed
                        try:
                            cancel_all_tps(symbol)
                        except Exception:
                            pass
                        try:
                            if had_open:
                                ban_symbol(symbol)
                        except Exception:
                            pass

                            pass
                    else:
                        pos_set(
                            symbol,
                            qty=exch_qty,
                            side=_norm_side('BUY' if exch_amt > 0 else 'SELL'),
                            entry_price=exch_entry,
                            # Do NOT reset max/min here: this code runs as a REST fallback and may execute
                            # repeatedly; resetting breaks trailing-stop peak tracking.
                        )
                        try:
                            subscribe_price(symbol)
                        except Exception:
                            pass
                        log_message(f"ℹ️ Позиція {symbol} синхронізована з біржею: qty={exch_qty}, entry={exch_entry}")
                except Exception as e:
                    log_message(f"❌ Помилка синхронізації позиції після ORDER_TRADE_UPDATE для {symbol}: {e}")
                    log_message(traceback.format_exc())
            try:
                rest_sync_position(symbol, reason="ORDER_TRADE_UPDATE")
            except Exception:
                pass

    except Exception as e:
        log_message(f"❌ Помилка handle_user: {e}")
        log_message(traceback.format_exc())


def subscribe_price(symbol):
    """Subscribe to ticker websocket and prime caches for GUI/logic."""
    global twm
    symbol = symbol.upper()
    if symbol in subscribed_symbols:
        return
    try:
        if not ENABLE_PRICE_WS:
            # WS price disabled: rely on REST polling
            subscribed_symbols.add(symbol)
            log_message(f"[WS] Price WS disabled, skipping subscribe for {symbol}")
            return
        if twm is None:
            ensure_twm_started()
        if twm is None:
            log_message(f"[WS] Unable to start TWM for {symbol}")
            return
        key = twm.start_symbol_ticker_socket(callback=_handle_price_message, symbol=symbol)
        ws_symbol_sockets[symbol] = key
        subscribed_symbols.add(symbol)
        log_message(f"[WS] Subscribed to {symbol}")
    except Exception as e:
        log_message(f"[WS] Failed to subscribe {symbol}: {e}")
        log_message(traceback.format_exc())


# Допоміжні функції

def unsubscribe_price(symbol):
    """Stop websocket ticker for symbol and remove local subscription info (best-effort)."""
    try:
        key = ws_symbol_sockets.get(symbol)
        if key and twm:
            try:
                twm.stop_socket(key)
            except Exception:
                try:
                    # fallback name for symbol-ticker sockets
                    twm.stop_symbol_ticker_socket(symbol)
                except Exception:
                    pass
        try:
            ws_symbol_sockets.pop(symbol, None)
        except Exception:
            pass
        try:
            subscribed_symbols.discard(symbol)
        except Exception:
            pass
    except Exception:
        pass


def _stop_orderbook_twm_socket():
    global orderbook_socket_key
    try:
        if orderbook_socket_key and twm:
            try:
                twm.stop_socket(orderbook_socket_key)
            except Exception:
                pass
    except Exception:
        pass
    orderbook_socket_key = None


def _stop_trade_twm_socket():
    global trade_socket_key
    try:
        if trade_socket_key and twm:
            try:
                twm.stop_socket(trade_socket_key)
            except Exception:
                pass
    except Exception:
        pass
    trade_socket_key = None


def _manual_book_ws_url(symbol, depth_level=None, full_depth=False):
    if full_depth:
        return f"wss://fstream.binance.com/ws/{symbol.lower()}@depth@100ms"
    return f"wss://fstream.binance.com/ws/{symbol.lower()}@depth{depth_level}@100ms"


def _manual_prints_ws_url(symbol):
    # Use per-trade stream (NOT aggTrade) so every market fill appears instantly
    return f"wss://fstream.binance.com/ws/{symbol.lower()}@trade"


def _manual_kline_ws_url(symbol, interval):
    iv = str(interval or "5m").strip()
    if not iv:
        iv = "5m"
    return f"wss://fstream.binance.com/ws/{symbol.lower()}@kline_{iv}"


def _manual_book_ws_run(symbol, depth_level, stop_event, full_depth=False):
    global _manual_book_ws_connected, _manual_book_ws_app
    try:
        try:
            import websocket
        except Exception:
            log_message("[WS] websocket-client not installed; manual book WS disabled")
            return

        def on_open(ws):
            _manual_book_ws_connected = True
            try:
                _emit_ws_status("book", f"ON {symbol}", force=True)
            except Exception:
                pass

        def on_message(ws, message):
            try:
                obj = json.loads(message)
            except Exception:
                return
            try:
                if isinstance(obj, dict):
                    _handle_depth_message(obj)
            except Exception:
                pass

        def on_error(ws, err):
            try:
                log_message(f"[WS] manual book error: {err}")
            except Exception:
                pass

        def on_close(ws, code, reason):
            _manual_book_ws_connected = False
            try:
                log_message(f"[WS] manual book closed code={code} reason={reason}")
            except Exception:
                pass

        ws_app = websocket.WebSocketApp(
            _manual_book_ws_url(symbol, depth_level, full_depth=full_depth),
            on_open=on_open,
            on_message=on_message,
            on_error=on_error,
            on_close=on_close,
        )
        _manual_book_ws_app = ws_app
        while not stop_event.is_set():
            try:
                ws_app.run_forever(ping_interval=20, ping_timeout=10)
            except Exception as e:
                try:
                    log_message(f"[WS] manual book run_forever error: {e}")
                except Exception:
                    pass
            if stop_event.wait(2.0):
                break
    except Exception:
        try:
            log_message("[WS] manual book thread error\n" + traceback.format_exc())
        except Exception:
            pass


def _manual_prints_ws_run(symbol, stop_event):
    global _manual_prints_ws_connected, _manual_prints_ws_app
    try:
        try:
            import websocket
        except Exception:
            log_message("[WS] websocket-client not installed; manual prints WS disabled")
            return

        def on_open(ws):
            _manual_prints_ws_connected = True
            try:
                _emit_ws_status("prints", f"ON {symbol}", force=True)
            except Exception:
                pass

        def on_message(ws, message):
            try:
                obj = json.loads(message)
            except Exception:
                return
            try:
                if isinstance(obj, dict):
                    _handle_trade_print_message(obj)
            except Exception:
                pass

        def on_error(ws, err):
            try:
                log_message(f"[WS] manual prints error: {err}")
            except Exception:
                pass

        def on_close(ws, code, reason):
            _manual_prints_ws_connected = False
            try:
                log_message(f"[WS] manual prints closed code={code} reason={reason}")
            except Exception:
                pass

        ws_app = websocket.WebSocketApp(
            _manual_prints_ws_url(symbol),
            on_open=on_open,
            on_message=on_message,
            on_error=on_error,
            on_close=on_close,
        )
        _manual_prints_ws_app = ws_app
        while not stop_event.is_set():
            try:
                ws_app.run_forever(ping_interval=20, ping_timeout=10)
            except Exception as e:
                try:
                    log_message(f"[WS] manual prints run_forever error: {e}")
                except Exception:
                    pass
            if stop_event.wait(2.0):
                break
    except Exception:
        try:
            log_message("[WS] manual prints thread error\n" + traceback.format_exc())
        except Exception:
            pass


def _manual_kline_ws_run(symbol, interval, stop_event):
    global _manual_kline_ws_connected, _manual_kline_ws_app
    try:
        try:
            import websocket
        except Exception:
            log_message("[WS] websocket-client not installed; manual kline WS disabled")
            return

        def on_open(ws):
            _manual_kline_ws_connected = True
            try:
                _emit_ws_status("chart", f"ON {symbol} {interval}", force=True)
            except Exception:
                pass

        def on_message(ws, message):
            try:
                obj = json.loads(message)
            except Exception:
                return
            try:
                if isinstance(obj, dict):
                    _handle_kline_stream_message(obj)
            except Exception:
                pass

        def on_error(ws, err):
            try:
                log_message(f"[WS] manual kline error: {err}")
            except Exception:
                pass

        def on_close(ws, code, reason):
            _manual_kline_ws_connected = False
            try:
                log_message(f"[WS] manual kline closed code={code} reason={reason}")
            except Exception:
                pass

        ws_app = websocket.WebSocketApp(
            _manual_kline_ws_url(symbol, interval),
            on_open=on_open,
            on_message=on_message,
            on_error=on_error,
            on_close=on_close,
        )
        _manual_kline_ws_app = ws_app
        while not stop_event.is_set():
            try:
                ws_app.run_forever(ping_interval=20, ping_timeout=10)
            except Exception as e:
                try:
                    log_message(f"[WS] manual kline run_forever error: {e}")
                except Exception:
                    pass
            if stop_event.wait(2.0):
                break
    except Exception:
        try:
            log_message("[WS] manual kline thread error\n" + traceback.format_exc())
        except Exception:
            pass


def _manual_book_ws_start(symbol):
    global _manual_book_ws_stop, _manual_book_ws_thread, _manual_book_ws_symbol, _manual_book_ws_mode
    if not USE_MANUAL_BOOK_WS_FALLBACK:
        return False
    symbol = (symbol or "").upper()
    if not symbol:
        return False
    mode = "full" if _use_full_orderbook(symbol) else "partial"
    with _manual_book_ws_lock:
        if _manual_book_ws_thread and _manual_book_ws_thread.is_alive():
            if _manual_book_ws_symbol == symbol and _manual_book_ws_mode == mode:
                return True
        try:
            if _manual_book_ws_stop:
                _manual_book_ws_stop.set()
        except Exception:
            pass
        try:
            if _manual_book_ws_app:
                _manual_book_ws_app.close()
        except Exception:
            pass
        stop_event = threading.Event()
        _manual_book_ws_stop = stop_event
        _manual_book_ws_symbol = symbol
        _manual_book_ws_mode = mode
        depth_level = _ws_depth_level()
        full_depth = mode == "full"
        t = threading.Thread(target=_manual_book_ws_run, args=(symbol, depth_level, stop_event, full_depth), daemon=True)
        _manual_book_ws_thread = t
        t.start()
        return True


def _manual_prints_ws_start(symbol):
    global _manual_prints_ws_stop, _manual_prints_ws_thread, _manual_prints_ws_symbol
    if not USE_MANUAL_PRINTS_WS_FALLBACK:
        return False
    symbol = (symbol or "").upper()
    if not symbol:
        return False
    with _manual_prints_ws_lock:
        if _manual_prints_ws_thread and _manual_prints_ws_thread.is_alive():
            if _manual_prints_ws_symbol == symbol:
                return True
        try:
            if _manual_prints_ws_stop:
                _manual_prints_ws_stop.set()
        except Exception:
            pass
        try:
            if _manual_prints_ws_app:
                _manual_prints_ws_app.close()
        except Exception:
            pass
        stop_event = threading.Event()
        _manual_prints_ws_stop = stop_event
        _manual_prints_ws_symbol = symbol
        t = threading.Thread(target=_manual_prints_ws_run, args=(symbol, stop_event), daemon=True)
        _manual_prints_ws_thread = t
        t.start()
        return True


def _manual_kline_ws_start(symbol, interval):
    global _manual_kline_ws_stop, _manual_kline_ws_thread, _manual_kline_ws_symbol, _manual_kline_ws_interval
    if not USE_MANUAL_KLINE_WS_FALLBACK:
        return False
    symbol = (symbol or "").upper()
    if not symbol:
        return False
    interval = str(interval or globals().get("CANDLE_WS_INTERVAL", "5m") or "5m").strip()
    if not interval:
        interval = "5m"
    with _manual_kline_ws_lock:
        if _manual_kline_ws_thread and _manual_kline_ws_thread.is_alive():
            if _manual_kline_ws_symbol == symbol and _manual_kline_ws_interval == interval:
                return True
        try:
            if _manual_kline_ws_stop:
                _manual_kline_ws_stop.set()
        except Exception:
            pass
        try:
            if _manual_kline_ws_app:
                _manual_kline_ws_app.close()
        except Exception:
            pass
        stop_event = threading.Event()
        _manual_kline_ws_stop = stop_event
        _manual_kline_ws_symbol = symbol
        _manual_kline_ws_interval = interval
        t = threading.Thread(target=_manual_kline_ws_run, args=(symbol, interval, stop_event), daemon=True)
        _manual_kline_ws_thread = t
        t.start()
        return True


def _manual_book_ws_stop_all():
    global _manual_book_ws_symbol, _manual_book_ws_connected, _manual_book_ws_mode
    with _manual_book_ws_lock:
        try:
            if _manual_book_ws_stop:
                _manual_book_ws_stop.set()
        except Exception:
            pass
        try:
            if _manual_book_ws_app:
                _manual_book_ws_app.close()
        except Exception:
            pass
        _manual_book_ws_symbol = None
        _manual_book_ws_connected = False
        _manual_book_ws_mode = None


def _manual_prints_ws_stop_all():
    global _manual_prints_ws_symbol, _manual_prints_ws_connected
    with _manual_prints_ws_lock:
        try:
            if _manual_prints_ws_stop:
                _manual_prints_ws_stop.set()
        except Exception:
            pass
        try:
            if _manual_prints_ws_app:
                _manual_prints_ws_app.close()
        except Exception:
            pass
        _manual_prints_ws_symbol = None
        _manual_prints_ws_connected = False


def _manual_kline_ws_stop_all():
    global _manual_kline_ws_symbol, _manual_kline_ws_interval, _manual_kline_ws_connected
    with _manual_kline_ws_lock:
        try:
            if _manual_kline_ws_stop:
                _manual_kline_ws_stop.set()
        except Exception:
            pass
        try:
            if _manual_kline_ws_app:
                _manual_kline_ws_app.close()
        except Exception:
            pass
        _manual_kline_ws_symbol = None
        _manual_kline_ws_interval = None
        _manual_kline_ws_connected = False


def _schedule_manual_book_ws_fallback(symbol):
    if not USE_MANUAL_BOOK_WS_FALLBACK:
        return
    symbol = (symbol or "").upper()
    if not symbol:
        return

    def _worker():
        try:
            time.sleep(float(MANUAL_BOOK_WS_FALLBACK_SEC))
        except Exception:
            time.sleep(2.0)
        if symbol != (orderbook_socket_symbol or "").upper():
            return
        if _manual_book_ws_symbol == symbol and _manual_book_ws_thread and _manual_book_ws_thread.is_alive():
            return
        try:
            with orderbook_lock:
                state = orderbook_state.get(symbol)
                state_ts = state.get('ts') if isinstance(state, dict) else 0.0
        except Exception:
            state_ts = 0.0
        if state_ts and (time.time() - state_ts) < float(MANUAL_BOOK_WS_FALLBACK_SEC):
            return
        try:
            log_message(f"[WS] No depth data from TWM; switching to manual WS for {symbol}")
        except Exception:
            pass
        _stop_orderbook_twm_socket()
        _manual_book_ws_start(symbol)

    threading.Thread(target=_worker, daemon=True).start()


def _schedule_manual_prints_ws_fallback(symbol):
    if not USE_MANUAL_PRINTS_WS_FALLBACK:
        return
    symbol = (symbol or "").upper()
    if not symbol:
        return

    def _worker():
        try:
            time.sleep(float(MANUAL_PRINTS_WS_FALLBACK_SEC))
        except Exception:
            time.sleep(2.0)
        if symbol != (trade_socket_symbol or "").upper():
            return
        if _manual_prints_ws_symbol == symbol and _manual_prints_ws_thread and _manual_prints_ws_thread.is_alive():
            return
        try:
            last_ts = trade_prints_state_ts.get(symbol, 0.0)
        except Exception:
            last_ts = 0.0
        if last_ts and (time.time() - last_ts) < float(MANUAL_PRINTS_WS_FALLBACK_SEC):
            return
        try:
            log_message(f"[WS] No trade data from TWM; switching to manual WS for {symbol}")
        except Exception:
            pass
        _stop_trade_twm_socket()
        _manual_prints_ws_start(symbol)

    threading.Thread(target=_worker, daemon=True).start()


def _schedule_manual_kline_ws_fallback(symbol, interval):
    if not USE_MANUAL_KLINE_WS_FALLBACK:
        return
    symbol = (symbol or "").upper()
    if not symbol:
        return
    interval = str(interval or globals().get("CANDLE_WS_INTERVAL", "5m") or "5m").strip()
    if not interval:
        interval = "5m"

    def _worker():
        try:
            time.sleep(float(MANUAL_KLINE_WS_FALLBACK_SEC))
        except Exception:
            time.sleep(2.0)
        entry = kline_socket_keys.get(symbol)
        if entry and isinstance(entry, dict):
            try:
                if entry.get("interval") and entry.get("interval") != interval:
                    return
            except Exception:
                pass
        if _manual_kline_ws_symbol == symbol and _manual_kline_ws_interval == interval and _manual_kline_ws_thread and _manual_kline_ws_thread.is_alive():
            return
        try:
            last_ts = kline_last_update_ts.get(_kline_key(symbol, interval), 0.0)
        except Exception:
            last_ts = 0.0
        if last_ts and (time.time() - last_ts) < float(MANUAL_KLINE_WS_FALLBACK_SEC):
            return
        try:
            log_message(f"[WS] No kline data from TWM; switching to manual WS for {symbol} {interval}")
        except Exception:
            pass
        try:
            stop_kline_subscription(symbol)
        except Exception:
            pass
        _manual_kline_ws_start(symbol, interval)

    threading.Thread(target=_worker, daemon=True).start()


def subscribe_orderbook(symbol):
    """Subscribe to depth websocket for order book updates (best-effort)."""
    global orderbook_socket_key, orderbook_socket_symbol, orderbook_socket_mode
    symbol = (symbol or "").upper()
    if not symbol:
        return
    mode = "full" if _use_full_orderbook(symbol) else "partial"
    if orderbook_socket_symbol == symbol and orderbook_socket_key and orderbook_socket_mode == mode:
        return
    try:
        unsubscribe_orderbook()
    except Exception:
        pass
    orderbook_socket_symbol = symbol
    orderbook_socket_mode = mode
    try:
        if not USE_WS:
            _emit_ws_status("book", "OFF")
            return
        if twm is None:
            ensure_twm_started()
        if twm is None:
            _emit_ws_status("book", "OFF")
            return
        key = None
        if mode == "full":
            try:
                if hasattr(twm, "start_socket"):
                    stream = f"{symbol.lower()}@depth@100ms"
                    key = twm.start_socket(_handle_depth_message, stream)
            except Exception:
                key = None
        else:
            depth_level = _ws_depth_level()
            try:
                if hasattr(twm, "start_futures_depth_socket"):
                    key = twm.start_futures_depth_socket(callback=_handle_depth_message, symbol=symbol, depth=depth_level)
            except Exception:
                key = None
            if key is None:
                try:
                    if hasattr(twm, "start_depth_socket"):
                        key = twm.start_depth_socket(callback=_handle_depth_message, symbol=symbol, depth=depth_level)
                except Exception:
                    key = None
            if key is None:
                try:
                    if hasattr(twm, "start_socket"):
                        stream = f"{symbol.lower()}@depth{depth_level}@100ms"
                        key = twm.start_socket(_handle_depth_message, stream)
                except Exception:
                    key = None
        if key is not None:
            orderbook_socket_key = key
            log_message(f"[WS] Depth subscribed for {symbol}")
            _emit_ws_status("book", f"ON {symbol}", force=True)
            try:
                _schedule_manual_book_ws_fallback(symbol)
            except Exception:
                pass
            if mode == "full":
                # FAST: publish a small REST snapshot immediately so UI is not empty
                try:
                    if bool(globals().get('ORDERBOOK_FAST_START_ENABLED', ORDERBOOK_FAST_START_ENABLED)):
                        _rest_fill_orderbook_state_async(symbol, reason='subscribe-fast', limit_override=int(globals().get('ORDERBOOK_FAST_START_LIMIT', ORDERBOOK_FAST_START_LIMIT) or ORDERBOOK_FAST_START_LIMIT))
                    else:
                        _rest_fill_orderbook_state_async(symbol, reason='subscribe')
                except Exception:
                    pass

                # FAST: seed local book with small snapshot first (enables WS diffs quickly)
                try:
                    if bool(globals().get('ORDERBOOK_FAST_START_ENABLED', ORDERBOOK_FAST_START_ENABLED)):
                        fast_lim = int(globals().get('ORDERBOOK_FAST_START_LIMIT', ORDERBOOK_FAST_START_LIMIT) or ORDERBOOK_FAST_START_LIMIT)
                        if symbol not in orderbook_fast_seed_done:
                            orderbook_fast_seed_done.add(symbol)
                            _seed_full_orderbook_async(symbol, force=True, seed_limit_override=fast_lim)
                            try:
                                _expand_orderbook_depth_async(symbol, target_limit=int(globals().get('ORDERBOOK_EXPAND_DEPTH_LIMIT', ORDERBOOK_EXPAND_DEPTH_LIMIT) or ORDERBOOK_EXPAND_DEPTH_LIMIT))
                            except Exception:
                                pass
                        else:
                            _seed_full_orderbook_async(symbol, force=True)
                    else:
                        _seed_full_orderbook_async(symbol, force=True)
                except Exception:
                    pass
                try:
                    _ensure_orderbook_reconcile_thread()
                except Exception:
                    pass
        else:
            log_message(f"[WS] Depth subscribe failed for {symbol}")
            _emit_ws_status("book", "OFF", force=True)
            try:
                _manual_book_ws_start(symbol)
            except Exception:
                pass
            if mode == "full":
                try:
                    _seed_full_orderbook_async(symbol, force=True)
                except Exception:
                    pass
                try:
                    _rest_fill_orderbook_state_async(symbol, reason='subscribe')
                except Exception:
                    pass
                try:
                    _ensure_orderbook_reconcile_thread()
                except Exception:
                    pass
    except Exception:
        try:
            _emit_ws_status("book", "OFF", force=True)
        except Exception:
            pass


def unsubscribe_orderbook():
    """Stop depth websocket (best-effort)."""
    global orderbook_socket_key, orderbook_socket_symbol, orderbook_socket_mode
    try:
        _stop_orderbook_twm_socket()
    except Exception:
        pass
    orderbook_socket_symbol = None
    orderbook_socket_mode = None
    try:
        _manual_book_ws_stop_all()
    except Exception:
        pass
    try:
        with orderbook_full_lock:
            orderbook_full_state.clear()
            orderbook_diff_buffer.clear()
            orderbook_seed_inflight.clear()
            try:
                orderbook_fast_seed_done.clear()
                orderbook_expand_inflight.clear()
                orderbook_rest_fill_last_ts.clear()
            except Exception:
                pass
    except Exception:
        pass
    try:
        _emit_ws_status("book", "OFF", force=True)
    except Exception:
        pass


def subscribe_trade_prints(symbol):
    """Subscribe to trade prints websocket (best-effort)."""
    global trade_socket_key, trade_socket_symbol
    symbol = (symbol or "").upper()
    if not symbol:
        return
    if trade_socket_symbol == symbol and trade_socket_key:
        return
    try:
        unsubscribe_trade_prints()
    except Exception:
        pass
    trade_socket_symbol = symbol
    try:
        if not USE_WS:
            _emit_ws_status("prints", "OFF")
            return
        if twm is None:
            ensure_twm_started()
        if twm is None:
            _emit_ws_status("prints", "OFF")
            return
        key = None
        try:
            if hasattr(twm, "start_futures_trade_socket"):
                key = twm.start_futures_trade_socket(callback=_handle_trade_print_message, symbol=symbol)
        except Exception:
            key = None
        if key is None:
            try:
                if hasattr(twm, "start_trade_socket"):
                    key = twm.start_trade_socket(callback=_handle_trade_print_message, symbol=symbol)
            except Exception:
                key = None
        if key is None:
            try:
                if hasattr(twm, "start_socket"):
                    stream = f"{symbol.lower()}@trade"
                    key = twm.start_socket(_handle_trade_print_message, stream)
            except Exception:
                key = None
        if key is not None:
            trade_socket_key = key
            log_message(f"[WS] Trades subscribed for {symbol}")
            _emit_ws_status("prints", f"ON {symbol}", force=True)
            try:
                _schedule_manual_prints_ws_fallback(symbol)
            except Exception:
                pass
        else:
            log_message(f"[WS] Trades subscribe failed for {symbol}")
            _emit_ws_status("prints", "OFF", force=True)
            try:
                _manual_prints_ws_start(symbol)
            except Exception:
                pass
    except Exception:
        try:
            _emit_ws_status("prints", "OFF", force=True)
        except Exception:
            pass


def unsubscribe_trade_prints():
    """Stop trade prints websocket (best-effort)."""
    global trade_socket_key, trade_socket_symbol
    try:
        _stop_trade_twm_socket()
    except Exception:
        pass
    trade_socket_symbol = None
    try:
        _manual_prints_ws_stop_all()
    except Exception:
        pass
    try:
        _emit_ws_status("prints", "OFF", force=True)
    except Exception:
        pass


def _ensure_event_loop_in_thread():
    """No-op to match old TWM usage (TWM manages its own loop)."""
    return



def _ensure_asyncio_event_loop():
    """Ensure this thread has an asyncio event loop (needed on Windows/Py3.12 for python-binance TWM)."""
    try:
        import asyncio
        try:
            asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
    except Exception:
        pass


def ensure_twm_started():
    """
    Ensure the ThreadedWebsocketManager (twm) is started.
    Thread-safe and safe to call multiple times.
    """
    global twm
    try:
        _ensure_asyncio_event_loop()
        if not USE_WS:
            return
        with twm_lock:
            if twm is None:
                try:
                    twm_local = ThreadedWebsocketManager(api_key=API_KEY, api_secret=API_SECRET)
                    twm_local.start()
                    twm = twm_local
                    log_message("🔔 twm started by ensure_twm_started()")
                except Exception as e:
                    log_message(f"❌ ensure_twm_started: failed to start twm: {e}")
                    log_message(traceback.format_exc())
    except Exception:
        log_message("❌ Unexpected error in ensure_twm_started()\n" + traceback.format_exc())


def _start_user_socket_safe(max_attempts: int = 5, delay_s: float = 1.0) -> bool:
    """Start Futures user stream.
    If USE_MANUAL_USER_STREAM=True, uses raw user-data WS (websocket-client) which is stable in prestart.
    Otherwise falls back to ThreadedWebsocketManager.
    """
    global twm, user_socket_key
    # Prefer manual user stream (raw ws) to avoid TWM/asyncio issues on Windows
    try:
        if globals().get('USE_MANUAL_USER_STREAM', False):
            ok = _manual_user_stream_start()
            return bool(ok)
    except Exception:
        pass
    _ensure_asyncio_event_loop()
    if (not USE_WS) or (not twm):
        return False
    last_err = None
    for attempt in range(max_attempts):
        # small incremental backoff to give SocketManager time to init
        try:
            time.sleep(max(0.0, delay_s * attempt))
        except Exception:
            pass
        try:
            if user_socket_key is None:
                        if not globals().get('USE_MANUAL_USER_STREAM', False):
                                user_socket_key = twm.start_futures_user_socket(callback=_handle_user_message)
            try:
                # mark user-stream as fresh
                globals()['LAST_USER_WS_MESSAGE_TS'] = time.time()
            except Exception:
                pass
            return True
        except Exception as e:
            last_err = e
            _set_connection_state(False)
            try:
                time.sleep(delay_s)
            except Exception:
                pass
    if last_err:
        _set_connection_state(False)
        try:
            log_message(f"❌ USER WS start failed: {last_err}")
        except Exception:
            pass
    return False


def _resubscribe_price_sockets_after_restart():
    """Re-subscribe all price sockets for symbols in subscribed_symbols after TWM restart."""
    global twm, ws_symbol_sockets
    if not twm:
        return
    if not ENABLE_PRICE_WS:
        # Price WS disabled; nothing to do
        return
    try:
        symbols = list(subscribed_symbols)
    except Exception:
        symbols = []
    for s in symbols:
        try:
            key = twm.start_symbol_ticker_socket(callback=_handle_price_message, symbol=s)
            ws_symbol_sockets[s] = key
            log_message(f"[WS] Re-subscribed to {s}")
        except Exception as e:
            log_message(f"[WS] Failed to re-subscribe {s}: {e}")


def _resubscribe_depth_trade_sockets_after_restart():
    """Re-subscribe depth/trade sockets after TWM restart."""
    global orderbook_socket_key, trade_socket_key
    orderbook_socket_key = None
    trade_socket_key = None
    try:
        if orderbook_socket_symbol:
            subscribe_orderbook(orderbook_socket_symbol)
    except Exception:
        pass
    try:
        if trade_socket_symbol:
            subscribe_trade_prints(trade_socket_symbol)
    except Exception:
        pass
    try:
        _resubscribe_kline_sockets_after_restart()
    except Exception:
        pass


def _resubscribe_kline_sockets_after_restart():
    """Re-subscribe kline sockets after TWM restart."""
    try:
        entries = list(kline_socket_keys.items())
    except Exception:
        entries = []
    try:
        kline_socket_keys.clear()
    except Exception:
        pass
    for sym, entry in entries:
        try:
            interval = entry.get("interval") if isinstance(entry, dict) else None
        except Exception:
            interval = None
        try:
            ensure_kline_subscription(sym, interval=interval or globals().get("CANDLE_WS_INTERVAL", "5m"))
        except Exception:
            pass


def _ws_activity_expected() -> bool:
    """Return True if we reasonably expect WS traffic now (positions, active orders or price subs)."""
    try:
        with positions_lock:
            has_positions = bool(open_positions)
    except Exception:
        has_positions = False
    try:
        has_active = bool(active_orders)
    except Exception:
        has_active = False
    try:
        has_subs = bool(subscribed_symbols)
    except Exception:
        has_subs = False
    return bool(has_positions or has_active or has_subs)


def _user_stream_required() -> bool:
    """Return True if account/user stream is required (positions or any tracked orders)."""
    try:
        with positions_lock:
            pos_req = bool(open_positions)
    except Exception:
        pos_req = False
    try:
        ord_req = bool(active_orders) or any(bool(v) for v in getattr(sys.modules[__name__], 'tp_orders', {}).values())
    except Exception:
        ord_req = False
    return bool(pos_req or ord_req)


def _restart_user_socket_quietly(max_attempts: int = 5) -> bool:
    """Restart only the futures user socket without touching TWM."""
    global twm, user_socket_key
    if not twm:
        return False
    try:
        if user_socket_key:
            try:
                twm.stop_socket(user_socket_key)
            except Exception:
                try:
                    twm.stop_futures_user_socket(user_socket_key)
                except Exception:
                    pass
        user_socket_key = None
    except Exception:
        pass
    return _start_user_socket_safe(max_attempts=max_attempts, delay_s=1.0)


def get_last_price(symbol, prefer_ws=True, ws_wait_s=0.15):
    """
    Return latest price for symbol using unified PriceSource (WS first, REST fallback).
    """
    try:
        price, _src = price_source.get_current_price(symbol, prefer_ws=prefer_ws, ws_wait_s=ws_wait_s)
        return price
    except Exception as e:
        log_message(f"[PRICE] get_last_price wrapper error: {e}")
        log_message(traceback.format_exc())
        return None


def cancel_trailing_order(symbol, order_id):
    try:
        signed_request(client.futures_cancel_order, symbol=symbol, orderId=order_id)
        log_message(f"❌  Скасовано trailing-order {order_id} для {symbol}")
    except Exception as e:
        log_message(f"? Не вдалося скасувати trailing-order {order_id} для {symbol}: {e}")
        log_message(traceback.format_exc())


# ---------------- Функції для трейлінг стопу (локально) ----------------

def cancel_all_tps(symbol):
    """Скасовує всі збережені take-profit ордери для symbol (якщо є) та очищує tp_orders."""
    try:
        with tp_lock:
            tps = list(tp_orders.get(symbol, []))
        for tid in tps:
            try:
                signed_request(client.futures_cancel_order, symbol=symbol, orderId=tid)
                log_message(f"🗃️ Скасовано TP {tid} для {symbol}")
            except Exception as e:
                log_message(f"❌ Не вдалося скасувати TP {tid} для {symbol}: {e}")
        with tp_lock:
            tp_orders.pop(symbol, None)
    except Exception as e:
        log_message(f"❌ Помилка cancel_all_tps для {symbol}: {e}")
        log_message(traceback.format_exc())


def _tp_is_passed(symbol, tp_price, tp_side):
    try:
        tp_price_f = float(tp_price)
    except Exception:
        return False, None, None
    if tp_price_f <= 0:
        return False, None, None
    cp = None
    cp_src = None
    try:
        cp, cp_src = price_source.get_current_price(symbol, price_kind="last")
    except Exception:
        cp = None
        cp_src = None
    if cp is None:
        try:
            cp, cp_src = price_source.get_current_price(symbol, price_kind="mark")
        except Exception:
            cp = None
            cp_src = None
    if cp is None:
        return False, None, None
    try:
        cp_f = float(cp)
    except Exception:
        return False, None, None
    side_up = (tp_side or "").upper()
    if side_up == "BUY":
        return (cp_f <= tp_price_f), cp_f, cp_src
    if side_up == "SELL":
        return (cp_f >= tp_price_f), cp_f, cp_src
    return False, cp_f, cp_src


def _tp_place_market_close(symbol, tp_side, qty, tp_price=None, current_price=None, current_src=None):
    try:
        qty_prec, _ = get_symbol_precision(symbol)
    except Exception:
        qty_prec = 0
    try:
        qty_round = round(float(qty or 0.0), qty_prec)
    except Exception:
        qty_round = 0
    if qty_round <= 0:
        return False
    try:
        resp = signed_request(
            client.futures_create_order,
            symbol=symbol,
            side=str(tp_side or "").upper(),
            type='MARKET',
            quantity=qty_round,
            reduceOnly=True
        )
        log_message(
            f"[TP IMMEDIATE] MARKET close {symbol} side={tp_side} qty={qty_round} "
            f"tp={tp_price} cur={current_price} src={current_src} resp={resp}"
        )
        try:
            chart_trade_record_event(symbol, tp_side, tp_price or current_price, kind="TP_MKT", qty=qty_round)
        except Exception:
            pass
        return True
    except Exception as e:
        log_message(f"[TP IMMEDIATE ERR] market close failed for {symbol}: {e}")
        log_message(traceback.format_exc())
        return False


def _tp_mark_filled(symbol, source="MARKET"):
    tp_idx = 1
    try:
        pos = pos_get(symbol) or {}
        tp_idx = int(pos.get('tp_filled', 0)) + 1
        pos_set(symbol, tp_filled=tp_idx)
    except Exception:
        tp_idx = 1
    try:
        log_message(f"[TP{tp_idx}] FILLED {symbol} ({source})")
    except Exception:
        pass
    try:
        pos = pos_get(symbol) or {}
        base = pos.get('base_trailing_percent', pos.get('trailing_percent', FALLBACK_TRAILING_PERCENT))
        new_base = max(MIN_TRAIL_PCT, base - 0.05)
        pos_set(symbol, base_trailing_percent=new_base,
                trailing_percent=min(pos.get('trailing_percent', new_base), new_base))
        log_message(
            f"[TP FILLED] adjust trailing for {symbol}: base {base:.4f}% -> {new_base:.4f}% ({source})"
        )
    except Exception:
        pass
    try:
        threading.Thread(target=release_next_tp, args=(symbol,), daemon=True).start()
    except Exception:
        try:
            release_next_tp(symbol)
        except Exception:
            pass
    return True


def release_next_tp(symbol):
    # Ensure there's an actual exchange position before releasing queued TP
    try:
        exch_amt = 0
        try:
            exch_amt, _ = get_exchange_position(symbol)
        except Exception:
            exch_amt = 0
        if abs(exch_amt) < 1e-8:
            log_message(f"[TP] release_next_tp: exchange shows no open position for {symbol} -> skip")
            return False
    except Exception:
        pass

    # Dual-entry: wait for ENTRY2 confirmation before releasing TP.
    try:
        with orders_lock:
            meta = pending_meta.get(symbol)
        entry2_ready, _p2, _c2 = _dual_entry_entry2_ready(symbol, meta=meta)
        if not entry2_ready:
            log_message(f"[TP] release_next_tp: waiting ENTRY2 fill confirmation for {symbol} -> skip")
            return False
    except Exception:
        pass

    # Avoid stacking multiple TP orders if exchange already has one
    try:
        existing_tp = False
        open_tp_orders = signed_request(client.futures_get_open_orders, symbol=symbol)
        for _o in open_tp_orders or []:
            otype = (_o.get('type') or '').upper()
            is_close = bool(_o.get('closePosition'))
            # Вважаємо існуючим TP лише справжні TP-ордера:
            # - TAKE_PROFIT / TAKE_PROFIT_MARKET
            # - LIMIT reduceOnly (часткові тейки), але НЕ SL (STOP/STOP_MARKET з closePosition=True)
            if otype in {'TAKE_PROFIT', 'TAKE_PROFIT_MARKET'}:
                existing_tp = True
            elif otype == 'LIMIT' and bool(_o.get('reduceOnly')) and not is_close:
                existing_tp = True
            if existing_tp:
                log_message(f"[TP] release_next_tp: existing TP/close on book for {symbol}, skip new TP")
                break
        if existing_tp:
            return False
    except Exception:
        pass

    # Place the next TP from queue
    try:
        with tp_lock:
            queue = pending_tps.get(symbol) or []
            if not queue:
                return False
            item = queue.pop(0)
            if isinstance(item, (list, tuple)) and len(item) >= 3:
                next_tp_price = item[0]
                next_qty = item[1]
                next_rr = item[2]
                next_meta = item[3] if len(item) > 3 else None
            else:
                log_message(f"[TP] invalid queued item for {symbol}: {item}")
                return False
            if queue:
                pending_tps[symbol] = queue
            else:
                pending_tps.pop(symbol, None)

        try:
            qty_prec, price_prec = get_symbol_precision(symbol)
        except Exception:
            qty_prec, price_prec = 0, 8
        next_qty_round = round(next_qty, qty_prec)
        next_price_round = round(next_tp_price, price_prec)

        with positions_lock:
            pos = open_positions.get(symbol)
        if pos and pos.get('qty', 0) > 0:
            tp_side = 'SELL' if _side_to_api(pos.get('side')) == 'BUY' else 'BUY'
        else:
            if next_meta and isinstance(next_meta, dict):
                sp = next_meta.get('stop_side')
                if sp and str(sp).upper().startswith('B'):
                    tp_side = 'SELL'
                else:
                    tp_side = 'BUY'
            else:
                tp_side = 'SELL'
        current_price, _src = price_source.get_current_price(symbol)
        try:
            passed, cp_val, cp_src = _tp_is_passed(symbol, next_price_round, tp_side)
        except Exception:
            passed, cp_val, cp_src = False, None, None
        if passed:
            try:
                if _tp_place_market_close(symbol, tp_side, next_qty_round,
                                          tp_price=next_price_round, current_price=cp_val, current_src=cp_src):
                    _tp_mark_filled(symbol, source="MARKET")
                    return True
            except Exception:
                pass
        # Основний шлях для TP: ставимо звичайний reduce-only LIMIT-ордер,
        # щоб тейк профіт виконувався без затримок як звичайний лімітний ордер на біржі.
        oid = futures_place_limit_reduce_only(symbol, next_price_round, next_qty_round, tp_side, tag="TP")
        if not oid:
            log_message(f"[TP ERR] release_next_tp: failed to place LIMIT TP for {symbol} at {next_price_round} qty={next_qty_round}")
            # Put the TP back to the queue so it isn't lost (may succeed on the next attempt).
            try:
                with tp_lock:
                    pending_tps.setdefault(symbol, []).insert(0, item)
            except Exception:
                pass
            return False
        with tp_lock:
            tp_orders.setdefault(symbol, set()).add(int(oid))
        st = pos_get(symbol) or {}
        idx = int(st.get('tp_filled') or 0) + 1
        log_message(f"[TP] PLACED{idx} {symbol}: price={next_price_round} qty={next_qty_round} rr={next_rr} oid={oid}")
        add_order_row(symbol, 'TP', next_qty_round, next_price_round, '-')
        return True
    except Exception as e:
        log_message(f"[TP ERR] release_next_tp error for {symbol}: {e}")
        log_message(traceback.format_exc())
        return False


def _handle_tp_filled_rest(symbol, order_id):
    """
    REST-based fallback: handle FILLED TP order when WS ORDER_TRADE_UPDATE was missed.
    Removes orderId from tp_orders, updates tp_filled and releases the next TP from queue.
    """
    try:
        oid_int = int(order_id)
    except Exception:
        return False

    try:
        with tp_lock:
            raw = tp_orders.get(symbol)
            if not raw:
                return False
            tp_set = raw if isinstance(raw, set) else set(raw)
            if oid_int not in {int(x) for x in tp_set}:
                return False
            tp_set.discard(oid_int)
            if tp_set:
                tp_orders[symbol] = tp_set
            else:
                tp_orders.pop(symbol, None)
    except Exception:
        return False

    tp_idx = 1
    try:
        pos = pos_get(symbol) or {}
        tp_idx = int(pos.get('tp_filled', 0)) + 1
        pos_set(symbol, tp_filled=tp_idx)
    except Exception:
        tp_idx = 1
    try:
        log_message(f"[TP{tp_idx}] FILLED {symbol} (REST)")
    except Exception:
        pass
    try:
        pos = pos_get(symbol) or {}
        tp_side = 'SELL' if _side_to_api(pos.get('side')) == 'BUY' else 'BUY'
    except Exception:
        tp_side = None
    try:
        cp_val, _src = price_source.get_current_price(symbol, price_kind="last")
    except Exception:
        cp_val = None
    try:
        chart_trade_record_event(symbol, tp_side, cp_val, kind="TP")
    except Exception:
        pass

    # Корекція трейлінгу після TP, аналогічно WS-гілці
    try:
        pos = pos_get(symbol) or {}
        base = pos.get('base_trailing_percent', pos.get('trailing_percent', FALLBACK_TRAILING_PERCENT))
        new_base = max(MIN_TRAIL_PCT, base - 0.05)
        pos_set(symbol, base_trailing_percent=new_base,
                trailing_percent=min(pos.get('trailing_percent', new_base), new_base))
        log_message(f"ℹ️ TP FILLED adjust trailing for {symbol}: base {base:.4f}% -> {new_base:.4f}% (REST)")
    except Exception:
        pass

    try:
        threading.Thread(target=release_next_tp, args=(symbol,), daemon=True).start()
    except Exception:
        try:
            release_next_tp(symbol)
        except Exception:
            pass
    return True


def maybe_create_post_fill_tps(symbol, side_actual, qty_actual, entry_actual):
    """
    Fallback TP creator: when a position is detected on the exchange but we missed the FILLED event,
    use pending_meta (if available) to queue and place TP orders. pending_meta ?? ???????? ???.
    """
    try:
        tracked_oid = None
        with orders_lock:
            meta = pending_meta.get(symbol)
            tracked_oid = active_orders.get(symbol)
        if not meta:
            return False
        stop_side = meta.get('stop_side') if isinstance(meta, dict) else None
        if not stop_side or not side_actual:
            return False
        if not ((stop_side == 'BUY' and side_actual == 'BUY') or (stop_side == 'SELL' and side_actual == 'SELL')):
            return False
        if isinstance(meta, dict) and meta.get("tp_created"):
            return True
        # Dual-entry: don't create TP until the position is fully opened (ENTRY1+ENTRY2).
        try:
            de_wait, de_plan, de_cur, de_tol = _dual_entry_wait_state(symbol, meta=meta, qty_current=qty_actual)
        except Exception:
            de_wait, de_plan, de_cur, de_tol = False, None, None, None
        entry2_ready = True
        try:
            entry2_ready, _p2, _c2 = _dual_entry_entry2_ready(symbol, meta=meta, qty_current=qty_actual)
        except Exception:
            entry2_ready = True
        if de_wait:
            try:
                log_message(
                    f"[TP] deferred {symbol} (REST): waiting full position qty "
                    f"(cur={de_cur:.8f} < plan={de_plan:.8f}, tol={de_tol})"
                )
            except Exception:
                pass
            return False
        if not entry2_ready:
            try:
                log_message(f"[TP] deferred {symbol} (REST): waiting ENTRY2 fill confirmation")
            except Exception:
                pass
            return False
        try:
            qty_precision, price_precision = get_symbol_precision(symbol)
        except Exception:
            qty_precision, price_precision = 0, 8
        with positions_lock:
            pos_state = open_positions.get(symbol, {})
        tp_entry = entry_actual
        try:
            if isinstance(meta, dict) and bool(meta.get('dual_entry')):
                entry2_ref = entry_actual
                try:
                    if (not entry2_ref) or float(entry2_ref) <= 0:
                        if meta.get('stop_price') not in (None, "", 0):
                            entry2_ref = float(meta.get('stop_price'))
                        elif meta.get('level') not in (None, "", 0):
                            entry2_ref = float(meta.get('level'))
                except Exception:
                    pass
                try:
                    if (
                        (not entry2_ref or float(entry2_ref) <= 0)
                        and (pos_state or {}).get('planned_entry2_price') not in (None, "", 0)
                    ):
                        entry2_ref = float((pos_state or {}).get('planned_entry2_price'))
                except Exception:
                    pass
                try:
                    if entry2_ref and float(entry2_ref) > 0:
                        tp_entry = float(entry2_ref)
                        log_message(f"[TP BASE] {symbol} dual-entry (REST) -> entry2={tp_entry:.8f}")
                except Exception:
                    pass
        except Exception:
            pass
        try:
            chart_trade_record_event(symbol, side_actual, tp_entry, kind="ENTRY_REST", qty=qty_actual)
        except Exception:
            pass
        trailing_fallback_local = pos_state.get('fallback_trailing_percent', FALLBACK_TRAILING_PERCENT)
        trailing_pct_local = pos_state.get('trailing_percent', trailing_fallback_local)
        rr_min_local = RR_MIN
        rr_max_local = RR_MAX
        tps = compute_dynamic_tps(
            tp_entry,
            trailing_pct_local,
            side_actual,
            parts=TP_PARTS,
            rr_min=rr_min_local,
            rr_max=rr_max_local,
            weight_power=TP_WEIGHT_POWER
        )
        weights = [w for (_, w, _) in tps]
        if not weights:
            log_message(f"[maybe_create_post_fill_tps] empty TP weights for {symbol} ? using single full-size TP")
            weights = [1.0]
        total_qty = round(abs(qty_actual or 0), qty_precision)
        if total_qty <= 0:
            log_message(f"[maybe_create_post_fill_tps] no qty for TP {symbol}: total_qty={total_qty}")
            with orders_lock:
                try:
                    active_orders.pop(symbol, None)
                except Exception:
                    pass
            return False
        parts_qty = []
        for w in weights[:-1]:
            q = round(total_qty * float(w), qty_precision)
            parts_qty.append(q)
        remainder = round(max(total_qty - sum(parts_qty), 0), qty_precision)
        parts_qty.append(remainder)
        with tp_lock:
            pending_tps[symbol] = []
        for idx, ((tp_price, _, rr), part_qty) in enumerate(zip(tps, parts_qty), start=1):
            if part_qty <= 0:
                continue
            with tp_lock:
                pending_tps.setdefault(symbol, [])
                pending_tps[symbol].append((tp_price, part_qty, rr, copy.deepcopy(meta) if isinstance(meta, dict) else meta))
            log_message(f"[TP{idx}] {symbol}: price={round(tp_price, price_precision)} qty={part_qty} RR={rr}")
        # emit synthetic ORDER_TRADE_UPDATE if WS missed
        try:
            _emit_rest_fill_event(symbol, {
                'orderId': meta.get('order_id') if isinstance(meta, dict) else None,
                'side': side_actual,
                'type': 'MARKET',
                'avgPrice': entry_actual,
                'origQty': qty_actual
            }, status_hint='FILLED')
        except Exception:
            pass
        try:
            threading.Thread(target=release_next_tp, args=(symbol,), daemon=True).start()
        except Exception as rel_err:
            log_message(f"?? release_next_tp thread error for {symbol}: {rel_err}")
            try:
                release_next_tp(symbol)
            except Exception:
                log_message(f"? Inline release_next_tp failed for {symbol}")
                log_message(traceback.format_exc())
        with orders_lock:
            try:
                active_orders.pop(symbol, None)
            except Exception:
                pass
            try:
                if isinstance(meta, dict):
                    meta["tp_created"] = True
                    pending_meta[symbol] = meta
            except Exception:
                pass
        return True
    except Exception as e:
        try:
            log_message(f"? maybe_create_post_fill_tps error for {symbol}: {e}")
            log_message(traceback.format_exc())
        except Exception:
            pass
        return False

def safe_close_position(symbol, side, qty=None):
    """
    Synchronous wrapper kept for compatibility (returns True/False).
    But the actual closing will be attempted in a background thread via _close_worker.
    This function simply spawns the worker and returns True if spawned.
    """
    try:
        with positions_lock:
            pos = open_positions.get(symbol)
            if pos and pos.get('closing'):
                log_message(f"?? safe_close_position: Закриття для {symbol} вже в процесі — пропускаємо spawn.")
                return False
            # mark closing to avoid race
            if pos:
                pos['closing'] = True
            else:
                # if no pos locally, still mark to avoid duplicate attempts
                open_positions.setdefault(symbol, {})['closing'] = True
    except Exception as e:
        log_message(f"? Помилка при маркуванні closing для {symbol}: {e}")
        log_message(traceback.format_exc())
        return False

    # spawn background worker to actually perform closing (safe to run async)
    try:
        t = threading.Thread(target=_close_worker, args=(symbol, side, qty), daemon=True)
        t.start()
        log_message(f"?? spawn close worker для {symbol}")
        return True
    except Exception as e:
        log_message(f"? Не вдалось запустити close worker для {symbol}: {e}")
        log_message(traceback.format_exc())
        # clear closing flag on failure
        with positions_lock:
            if symbol in open_positions:
                open_positions[symbol].pop('closing', None)
        return False


def _close_worker(symbol, side, qty=None):
    """
    Background worker that attempts to close market with retries and detailed logging.
    This will also cancel TPs on successful full close.
    """
    try:
        attempts = 0
        while attempts < MAX_CLOSE_RETRIES:
            attempts += 1
            try:
                # get current exchange position as truth
                exch_amt, exch_entry = get_exchange_position(symbol)
                exch_qty = abs(exch_amt)
                if exch_qty <= 1e-8:
                    log_message(
                        f"🤖✔️ біржі немає позиції для {symbol} (exch_qty=0). Очистимо локальні дані.")
                    with positions_lock:
                        # Suppress trailing logs briefly and unsubscribe price updates to avoid noisy callbacks after position removal

                        pos_local = None
                        try:
                            pos_local = open_positions.get(symbol, {})
                            if isinstance(pos_local, dict):
                                pos_local = dict(pos_local)
                        except Exception:
                            pos_local = None

                        try:

                            trailing_suppressed_until[symbol] = time.time() + TRAIL_SUPPRESS_AFTER_CLOSE

                            try:

                                unsubscribe_price(symbol)

                            except Exception:

                                pass

                        except Exception:

                            pass

                        open_positions.pop(symbol, None)
                        try:
                            _pos_event_mark_closed(symbol)
                        except Exception:
                            pass
                    # ensure no leftover TPs
                    try:
                        cancel_all_tps(symbol)
                    except Exception:
                        pass
                    try:
                        ban_symbol(symbol)
                    except Exception:
                        pass
                    try:
                        pnl_trade_delta = None
                        try:
                            start_ts = None
                            try:
                                start_ts = float((pos_local or {}).get('trail_start_ts') or 0.0)
                            except Exception:
                                start_ts = None
                            if start_ts and start_ts > 0:
                                bd = _get_futures_pnl_window_breakdown(symbol, start_ts, max_wait_s=2.5)
                                if bd and bd.get('net_pnl') is not None:
                                    pnl_trade_delta = float(bd.get('net_pnl') or 0.0)
                        except Exception:
                            pnl_trade_delta = None
                        if pnl_trade_delta is not None:
                            safe_on_position_closed_balance_log(symbol, pnl_delta=pnl_trade_delta)
                        else:
                            safe_on_position_closed_balance_log(symbol)
                    except Exception:
                        pass
                    return True

                # Визначаємо сторону закриття за фактичною позицією на біржі,
                # щоб не залежати від того, що нам передали в параметрі side (LONG/SHORT/BUY/SELL).
                try:
                    close_side = 'SELL' if exch_amt > 0 else 'BUY'
                except Exception:
                    close_side = 'SELL' if str(side).upper() == 'BUY' else 'BUY'

                qty_precision, _ = get_symbol_precision(symbol)
                close_qty = round((qty if qty is not None else exch_qty), qty_precision)

                if close_qty <= 0:
                    log_message(
                        f"❌ _close_worker: округлена кількість close_qty=0 для {symbol} (exch_qty={exch_qty}) — не надсилаю MARKET.")
                    # clear closing flag so future attempts possible
                    with positions_lock:
                        if symbol in open_positions:
                            open_positions[symbol].pop('closing', None)
                    return False

                log_message(
                    f"✅[_close_worker] Спроба MARKET close {symbol} attempt {attempts}/{MAX_CLOSE_RETRIES} qty={close_qty} side={close_side}")
                resp = signed_request(
                    client.futures_create_order,
                    symbol=symbol,
                    side=close_side,
                    type='MARKET',
                    quantity=close_qty,
                    reduceOnly=True
                )
                log_message(f"✅ [_close_worker] MARKET close response for {symbol}: {resp}")
                close_order_id = None
                close_order_time_ms = None
                try:
                    if isinstance(resp, dict):
                        close_order_id = resp.get('orderId') or resp.get('order_id')
                        close_order_time_ms = resp.get('updateTime') or resp.get('transactTime')
                except Exception:
                    close_order_id = None
                    close_order_time_ms = None
                # wait short time for exchange to update
                time.sleep(0.6)

                exch_amt_after, _ = get_exchange_position(symbol)
                if abs(exch_amt_after) < 1e-8:
                    # Record closed trade snapshot for stats (best-effort)
                    with positions_lock:
                        pos_local = open_positions.get(symbol, {})
                        try:
                            entry = float(pos_local.get('entry_price'))
                        except Exception:
                            try:
                                entry = float(exch_entry)
                            except Exception:
                                entry = None
                        try:
                            trade_breakdown = None
                            trade_total_breakdown = None
                            try:
                                if close_order_id:
                                    trade_breakdown = _get_futures_order_trade_breakdown(
                                        symbol,
                                        close_order_id,
                                        order_time_ms=close_order_time_ms,
                                        max_wait_s=2.5,
                                    )
                            except Exception:
                                trade_breakdown = None
                            try:
                                start_ts = None
                                try:
                                    start_ts = float(pos_local.get('trail_start_ts') or 0.0)
                                except Exception:
                                    start_ts = None
                                if start_ts and start_ts > 0:
                                    trade_total_breakdown = _get_futures_pnl_window_breakdown(
                                        symbol,
                                        start_ts,
                                        required_order_id=close_order_id,
                                        max_wait_s=2.5,
                                    )
                            except Exception:
                                trade_total_breakdown = None
                            if trade_breakdown and trade_breakdown.get('avg_price'):
                                exit_px = float(trade_breakdown.get('avg_price') or 0.0)
                            else:
                                exit_px = float(get_last_price(symbol) or 0.0)
                        except Exception:
                            exit_px = entry or 0.0
                        side_local = (pos_local.get('side') if isinstance(pos_local, dict) else side) or side
                        qty_used = float(exch_qty or 0.0)
                        if entry and qty_used > 0:
                            side_api = None
                            try:
                                side_api = _side_to_api(side_local) or str(side_local).upper()
                            except Exception:
                                side_api = str(side_local).upper() if side_local is not None else None
                            if side_api == 'BUY':
                                pnl_abs = (exit_px - entry) * qty_used
                                pnl_pct = ((exit_px - entry) / entry * 100.0)
                            elif side_api == 'SELL':
                                pnl_abs = (entry - exit_px) * qty_used
                                pnl_pct = ((entry - exit_px) / entry * 100.0)
                            else:
                                pnl_abs = (exit_px - entry) * qty_used
                                pnl_pct = ((exit_px - entry) / entry * 100.0)
                        else:
                            pnl_abs = 0.0
                            pnl_pct = None
                        hold_min = None
                        try:
                            start_ts = pos_local.get('trail_start_ts') or 0
                            if start_ts:
                                hold_min = max(0.0, (time.time() - float(start_ts)) / 60.0)
                        except Exception:
                            hold_min = None
                        trade_entry = record_trade_journal_entry({
                            'ts': time.time(),
                            'symbol': symbol,
                            'side': side_local,
                            'qty': qty_used,
                            'entry': entry,
                            'exit': exit_px,
                            'pnl_abs': pnl_abs,
                            'pnl_pct': pnl_pct,
                            'hold_min': hold_min,
                            'reason': 'close_market'
                        })
                        try:
                            advisor_trigger_event.set()
                        except Exception:
                            pass
                        # FIX: realized PnL logging - single consolidated log (prefer balance delta if snapshot exists)
                        try:
                            pnl_delta = pnl_abs
                            realized_pnl = None
                            fees_by_asset = None
                            pnl_scope = "ESTIMATE"
                            try:
                                # Prefer full-trade window (captures partial TPs) when possible
                                if trade_total_breakdown and trade_total_breakdown.get('net_pnl') is not None:
                                    pnl_delta = float(trade_total_breakdown.get('net_pnl') or 0.0)
                                    realized_pnl = float(trade_total_breakdown.get('realized_pnl') or 0.0)
                                    fees_by_asset = trade_total_breakdown.get('fees') or {}
                                    pnl_scope = "TRADES_WINDOW"
                                elif trade_breakdown and trade_breakdown.get('realized_pnl') is not None:
                                    # Fallback: only this close order
                                    realized_pnl = float(trade_breakdown.get('realized_pnl') or 0.0)
                                    fees_by_asset = trade_breakdown.get('fees') or {}
                                    fee_usdt = None
                                    try:
                                        if isinstance(fees_by_asset, dict) and 'USDT' in fees_by_asset:
                                            fee_usdt = float(fees_by_asset.get('USDT') or 0.0)
                                    except Exception:
                                        fee_usdt = None
                                    pnl_delta = (realized_pnl - fee_usdt) if fee_usdt is not None else realized_pnl
                                    pnl_scope = "CLOSE_ORDER"
                            except Exception:
                                realized_pnl = None
                            if 'last_balance_snapshot' in globals():
                                pnl_snapshot = globals().get('last_balance_snapshot')
                            else:
                                pnl_snapshot = None
                            if realized_pnl is None and pnl_snapshot is not None:
                                try:
                                    new_balance = get_balance()
                                    pnl_delta = new_balance - pnl_snapshot
                                    pnl_scope = "BALANCE_DELTA"
                                except Exception:
                                    pnl_delta = pnl_abs
                            try:
                                if 'last_balance_snapshot' in globals():
                                    globals()['last_balance_snapshot'] = None
                            except Exception:
                                pass
                            try:
                                if realized_pnl is not None:
                                    fee_parts = []
                                    try:
                                        if isinstance(fees_by_asset, dict):
                                            for _k, _v in fees_by_asset.items():
                                                try:
                                                    fee_parts.append(f"{str(_k)}={float(_v):.6f}")
                                                except Exception:
                                                    fee_parts.append(f"{str(_k)}={_v}")
                                    except Exception:
                                        fee_parts = []
                                    fees_txt = ", ".join(fee_parts) if fee_parts else "-"
                                    log_message(
                                        f"[PnL][CLOSE_MARKET] {symbol}: scope={pnl_scope} realized={realized_pnl:+.6f} fees=({fees_txt}) net={pnl_delta:+.6f}")
                                else:
                                    log_message(f"[PnL][CLOSE_MARKET] {symbol}: scope={pnl_scope} pnl={pnl_delta:+.6f}")
                            except Exception:
                                pass
                            try:
                                if realized_pnl is not None:
                                    fee_usdt_txt = "-"
                                    try:
                                        if isinstance(fees_by_asset, dict) and 'USDT' in fees_by_asset:
                                            fee_usdt_txt = f"{float(fees_by_asset.get('USDT') or 0.0):.6f}"
                                    except Exception:
                                        fee_usdt_txt = "-"
                                    send_info_log(
                                        f"[POSITION-CLOSE] {symbol} side={side_local} qty={qty_used} entry={entry} exit={exit_px} "
                                        f"scope={pnl_scope} realized={realized_pnl:+.6f} feeUSDT={fee_usdt_txt} pnl={pnl_delta:+.6f}")
                                else:
                                    send_info_log(
                                        f"[POSITION-CLOSE] {symbol} side={side_local} qty={qty_used} entry={entry} exit={exit_px} scope={pnl_scope} pnl={pnl_delta:+.6f}")
                            except Exception:
                                pass
                            try:
                                try:
                                    trade_entry_ref = trade_entry
                                    if trade_entry_ref is None and closed_trades:
                                        trade_entry_ref = closed_trades[-1]
                                    if trade_entry_ref:
                                        trade_entry_ref['close_order_id'] = close_order_id
                                        trade_entry_ref['pnl_scope'] = pnl_scope
                                        if realized_pnl is not None:
                                            trade_entry_ref['pnl_realized'] = realized_pnl
                                        if fees_by_asset is not None:
                                            trade_entry_ref['fees'] = fees_by_asset
                                        trade_entry_ref['pnl_net'] = pnl_delta
                                except Exception:
                                    pass
                                safe_on_position_closed_balance_log(symbol, pnl_delta=pnl_delta)
                            except Exception:
                                pass
                            try:
                                _emit_trade_journal()
                            except Exception:
                                pass
                        except Exception:
                            pass
                    log_message(f"✅ Позиція {symbol} підтверджено закрита на біржі.")
                    try:
                        play_trade_close_alert_once(symbol, side_local, qty_used)
                    except Exception:
                        pass
                    # cancel any TPs
                    try:
                        cancel_all_tps(symbol)
                    except Exception as e:
                        log_message(f"❌ Помилка cancel_all_tps після close для {symbol}: {e}")
                    # clean local
                    with positions_lock:
                        # Suppress trailing logs briefly and unsubscribe price updates to avoid noisy callbacks after position removal

                        try:

                            trailing_suppressed_until[symbol] = time.time() + TRAIL_SUPPRESS_AFTER_CLOSE

                            try:

                                unsubscribe_price(symbol)

                            except Exception:

                                pass

                        except Exception:

                            pass

                        open_positions.pop(symbol, None)
                        try:
                            _pos_event_mark_closed(symbol)
                        except Exception:
                            pass
                    return True
                else:
                    log_message(
                        f"ℹ️ Після MARKET close залишилось на біржі {abs(exch_amt_after)} контрактів для {symbol}. (attempt {attempts})")
                    # update local to reflect leftover
                    pos_set(
                        symbol,
                        qty=abs(exch_amt_after),
                        side=_norm_side('BUY' if exch_amt_after > 0 else 'SELL'),
                        entry_price=open_positions.get(symbol, {}).get('entry_price', exch_entry),
                    )
                    # retry loop will try again after backoff
            except Exception as e:
                log_message(f"❌ _close_worker помилка при спробі MARKET close для {symbol} (attempt {attempts}): {e}")
                log_message(traceback.format_exc())
            # exponential/backoff-ish wait
            time.sleep(0.6 * attempts)
        # exhausted retries
        log_message(f"❌ _close_worker: вичерпані спроби закрити {symbol} після {MAX_CLOSE_RETRIES} спроб.")
        # clear closing flag so other workflows can attempt later
        with positions_lock:
            if symbol in open_positions:
                open_positions[symbol].pop('closing', None)
        return False
    except Exception as e:
        log_message(f"❌Критична помилка _close_worker для {symbol}: {e}")
        log_message(traceback.format_exc())
        with positions_lock:
            if symbol in open_positions:
                open_positions[symbol].pop('closing', None)
        return False


def get_current_price(symbol):
    price, _src = price_source.get_current_price(symbol, prefer_ws=True, ws_wait_s=0.15)
    return price


def trailing_stop_check(symbol, current_price=None, trailing_percent=None):
    """
    ????????-???? ????????? (?????? 1-?-1 ?? ? Tetra BanV2).
    """
    # Dual-entry: trailing should start only after ENTRY2 is confirmed.
    try:
        with orders_lock:
            _m = pending_meta.get(symbol)
        entry2_ready, _plan, _cur = _dual_entry_entry2_ready(symbol, meta=_m)
        if not entry2_ready:
            return
    except Exception:
        pass
    if current_price is None:
        current_price = get_current_price(symbol)
    if current_price is None:
        return

    try:
        with positions_lock:
            pos = open_positions.get(symbol)
            if not pos:
                return
            side = pos.get('side')
            side_api = _side_to_api(side)
            entry = pos.get('entry_price')
            already_closing = pos.get('closing', False)
            trailing_percent = pos.get('trailing_percent', None)
    except Exception:
        return

    try:
        last_trail_check_ts[symbol] = time.time()
    except Exception:
        pass

    if already_closing:
        return

    if not trailing_percent:
        return
    try:
        with positions_lock:
            pos = open_positions.get(symbol)

            try:
                if pos.get('temp_widen_active'):
                    until = pos.get('temp_widen_until', 0)
                    if time.time() > float(until):
                        prev = pos.get('pre_temp_trail')
                        if prev is not None:
                            pos['trailing_percent'] = prev
                        else:
                            base = pos.get('base_trailing_percent')
                            if base is not None:
                                pos['trailing_percent'] = base
                        pos.pop('temp_widen_active', None)
                        pos.pop('temp_widen_until', None)
                        pos.pop('pre_temp_trail', None)
                        open_positions[symbol] = pos
                        log_message(
                            f"?? TEMP-WIDEN expired for {symbol}: restored trailing% to {pos.get('trailing_percent')}")
            except Exception as e:
                log_message(f"?? TEMP-WIDEN restore error for {symbol}: {e}")
            if not pos:
                return
            side = pos.get('side')
            side_api = _side_to_api(side)
            entry = pos.get('entry_price')
            already_closing = pos.get('closing', False)
            trailing_percent = pos.get('trailing_percent', None)
    except Exception:
        return

    if already_closing:
        try:
            log_message(f"?? trailing_stop_check: {symbol} already closing -> skip.")
        except Exception:
            pass
        return

    if not trailing_percent:
        try:
            log_message(f"?? ????? ??? {symbol} ????????? ? trailing_percent ?????????")
        except Exception:
            pass
        return

    try:
        exch_amt_check, _ = get_exchange_position(symbol)
        if abs(exch_amt_check) < 1e-8:
            try:
                log_message(f"DEBUG TRAIL: exch_qty=0 for {symbol}, clearing local position to stop trailing.")
            except Exception:
                pass
            # Делегуємо фінальне закриття на REST-синхронізацію,
            # щоб коректно відпрацювали PnL/баланс/звук через on_position_closed_balance_log.
            try:
                rest_sync_position(symbol, reason="TRAIL_ZERO")
            except Exception:
                pass
            return
    except Exception:
        pass

    try:
        sup_until = trailing_suppressed_until.get(symbol, 0)
        if sup_until and time.time() < sup_until:
            return
    except Exception:
        pass

    try:
        if current_price is None:
            cached = symbol_prices.get(symbol)
            if cached and (time.time() - cached.get('ts', 0)) <= PRICE_STALE_SEC:
                current_price = cached.get('price')
            else:
                return
    except Exception:
        return
    if current_price is None:
        return

    def should_emit_trail_log(sym, diff_value):
        try:
            if not TRAIL_LOG_INTERVAL or TRAIL_LOG_INTERVAL <= 0:
                return True
            last_t = last_trail_log_ts.get(sym, 0)
            last_v = last_trail_log_value.get(sym)
            if (time.time() - last_t) >= TRAIL_LOG_INTERVAL:
                return True
            if last_v is None:
                return True
            if TRAIL_LOG_DELTA_PCT and abs(diff_value - last_v) >= TRAIL_LOG_DELTA_PCT:
                return True
            return False
        except Exception:
            return True

    if side_api == 'BUY':
        try:
            with positions_lock:
                pos = open_positions.get(symbol)
                if pos is None:
                    return
                if 'max_price' not in pos:
                    pos['max_price'] = entry or current_price
                pos['max_price'] = max(pos['max_price'], current_price)
                max_price = pos['max_price']
                open_positions[symbol] = pos
        except Exception:
            max_price = current_price

        try:
            curr_profit_pct = (max_price - entry) / entry * 100.0 if entry else None
            tw_active = pos.get('temp_widen_active', False)
            if (curr_profit_pct is not None) and (curr_profit_pct >= TEMP_WIDEN_THRESHOLD_PCT) and (not tw_active):
                pos['pre_temp_trail'] = pos.get('trailing_percent', pos.get('base_trailing_percent', 0.0))
                pos['trailing_percent'] = pos['pre_temp_trail'] + TEMP_WIDEN_AMOUNT_PCT
                pos['temp_widen_active'] = True
                pos['temp_widen_until'] = time.time() + TEMP_WIDEN_SECONDS
                open_positions[symbol] = pos
                log_message(
                    f"?? TEMP-WIDEN {symbol} (LONG): profit={curr_profit_pct:.3f}% -> trailing% {pos['pre_temp_trail']:.3f}% -> {pos['trailing_percent']:.3f}% for {TEMP_WIDEN_SECONDS}s")
        except Exception as e:
            log_message(f"?? TEMP-WIDEN trigger error (LONG) for {symbol}: {e}")

        stop_price = max_price * (1 - trailing_percent / 100.0)
        diff_pct = compute_diff_from_stop_pct(entry, stop_price, current_price)
        diff = diff_pct if diff_pct is not None else percent_diff(current_price, stop_price) * 100.0

        if should_emit_trail_log(symbol, diff):
            try:
                last_trail_log_ts[symbol] = time.time()
                last_trail_log_value[symbol] = diff
            except Exception:
                pass
            log_message(
                f"⚠️ TRAIL CHECK {symbol} LONG | max={max_price} | stop={stop_price} | current={current_price} | trailing%={trailing_percent} | diff_from_stop={diff:.2f}%")

        if current_price <= stop_price:
            try:
                log_message(
                    f" TRAILING STOP LONG ⚠️⚠️⚠️ {symbol}: current {current_price} <= stop {stop_price}")
            except Exception:
                pass
            spawned = safe_close_position(symbol, side, qty=None)
            try:
                trailing_suppressed_until[symbol] = time.time() + TRAIL_SUPPRESS_AFTER_CLOSE
            except Exception:
                pass
            if not spawned:
                pass
    else:
        try:
            with positions_lock:
                pos = open_positions.get(symbol)
                if pos is None:
                    return
                if 'min_price' not in pos:
                    pos['min_price'] = entry or current_price
                pos['min_price'] = min(pos['min_price'], current_price)
                min_price = pos['min_price']
                open_positions[symbol] = pos
        except Exception:
            min_price = current_price

        try:
            curr_profit_pct = (entry - min_price) / entry * 100.0 if entry else None
            tw_active = pos.get('temp_widen_active', False)
            if (curr_profit_pct is not None) and (curr_profit_pct >= TEMP_WIDEN_THRESHOLD_PCT) and (not tw_active):
                pos['pre_temp_trail'] = pos.get('trailing_percent', pos.get('base_trailing_percent', 0.0))
                pos['trailing_percent'] = pos['pre_temp_trail'] + TEMP_WIDEN_AMOUNT_PCT
                pos['temp_widen_active'] = True
                pos['temp_widen_until'] = time.time() + TEMP_WIDEN_SECONDS
                open_positions[symbol] = pos
                log_message(
                    f"?? TEMP-WIDEN {symbol} (SHORT): profit={curr_profit_pct:.3f}% -> trailing% {pos['pre_temp_trail']:.3f}% -> {pos['trailing_percent']:.3f}% for {TEMP_WIDEN_SECONDS}s")
        except Exception as e:
            log_message(f"?? TEMP-WIDEN trigger error (SHORT) for {symbol}: {e}")

        stop_price = min_price * (1 + trailing_percent / 100.0)
        diff_pct = compute_diff_from_stop_pct(entry, stop_price, current_price)
        diff = diff_pct if diff_pct is not None else percent_diff(current_price, stop_price) * 100.0

        if should_emit_trail_log(symbol, diff):
            try:
                last_trail_log_ts[symbol] = time.time()
                last_trail_log_value[symbol] = diff
            except Exception:
                pass
            log_message(
                f"⚠️ TRAIL CHECK {symbol} SHORT | min={min_price} | stop={stop_price} | current={current_price} | trailing%={trailing_percent} | diff_from_stop={diff:.2f}%")

        if current_price >= stop_price:
            try:
                log_message(
                    f" TRAILING STOP SHORT ⚠️⚠️⚠️ {symbol}: current {current_price} >= stop {stop_price}")
            except Exception:
                pass
            spawned = safe_close_position(symbol, side, qty=None)
            try:
                trailing_suppressed_until[symbol] = time.time() + TRAIL_SUPPRESS_AFTER_CLOSE
            except Exception:
                pass
            if not spawned:
                pass


# ---------- helper: detect fast approach ----------


def ensure_trailing_stop(symbol):
    """
    Ensure trailing stop is applied immediately for a given symbol.
    Used right after position open/update (e.g. from ORDER_TRADE_UPDATE handler).
    Fetches current price (WS cache or REST) and runs trailing_stop_check once.
    """
    try:
        sym = (symbol or "").upper()
        if not sym:
            return
        current_price = None
        # 1) Try cached price from symbol_prices
        try:
            sp = symbol_prices.get(sym)
            if isinstance(sp, dict):
                current_price = sp.get("price")
        except Exception:
            current_price = None
        # 2) Fallback to REST if no cached price
        if current_price is None:
            try:
                t = signed_request(client.futures_symbol_ticker, symbol=sym)
                current_price = float(t["price"])
                symbol_prices[sym] = {"price": current_price, "ts": time.time()}
            except Exception as e:
                log_message(f"⚠️ensure_trailing_stop: cannot fetch price for {sym}: {e}")
                try:
                    log_message(traceback.format_exc())
                except Exception:
                    pass
                return
        trailing_stop_check(sym, current_price=current_price)
    except Exception as e:
        try:
            log_message(f"⚠️ensure_trailing_stop error for {symbol}: {e}")
            log_message(traceback.format_exc())
        except Exception:
            pass


def _removed_is_fast_approach_level(symbol, level, lookback_minutes=1, threshold_pct=0.004):
    """Повертає True якщо ціна швидко підбігла до level за last lookback_minutes.
       threshold_pct — мінімальний відносний рух (наприклад 0.005 == 0.2%)."""
    try:
        kl = signed_request(client.futures_klines, symbol=symbol, interval='1m', limit=lookback_minutes + 1)
        closes = [float(k[4]) for k in kl]
        if len(closes) < 2:
            return False
        first = closes[0]
        last = closes[-1]
        if first == 0:
            return False
        velocity = abs(last - first) / first
        # Переконаємось, що напрямок руху був в сторону level
        moving_toward = abs(level - last) < abs(level - first)
        return moving_toward and (velocity >= threshold_pct)
    except Exception:
        return False


# ---------- adaptive buffer (used to replace fixed 0.05% buffer) ----------
# local defaults (can be tuned globally if you prefer)
MIN_STOP_BUFFER_PCT = 0.002 # мінімум 0.25% для пробоїв
MIN_STOP_BUFFER_FAKE_PCT = 0.003  # мінімум 0.275% для заколів
STOP_NATR_BUFFER_FACTOR = 0  # множник NATR -> buffer
FAST_APPROACH_MIN_BUFFER = 0.0035  # якщо швидкий підхід — мінімум 0.1%


# ---------- unified helper: compute_stop_price ----------
def compute_stop_price(symbol, level, last_price, price_precision,
                       min_stop_buffer_pct=None,
                       stop_natr_buffer_factor=None,
                       fast_approach_min_buffer=None):
    """Compute stop_price and buffer_pct using the same adaptive logic as place_pending_order.
       Returns (stop_price, buffer_pct)."""
    try:
        if min_stop_buffer_pct is None:
            min_stop_buffer_pct = globals().get("MIN_STOP_BUFFER_PCT", 0.002)
        if stop_natr_buffer_factor is None:
            stop_natr_buffer_factor = globals().get("STOP_NATR_BUFFER_FACTOR", 0)
        if fast_approach_min_buffer is None:
            fast_approach_min_buffer = globals().get("FAST_APPROACH_MIN_BUFFER", 0.0035)
        try:
            symbol_natr = calculate_natr(symbol) or 0.0
        except Exception:
            symbol_natr = 0.0
        buffer_pct = max(min_stop_buffer_pct, (symbol_natr / 100.0) * stop_natr_buffer_factor)
        # fast-approach buffer adjustment removed

        if level > last_price:
            stop_price = round(level * (1.0 + buffer_pct), price_precision)
        else:
            stop_price = round(level * (1.0 - buffer_pct), price_precision)
        return stop_price, buffer_pct
    except Exception:
        return None, None


# ---------- end compute_stop_price ----------

# ---------- hard SL (swing-based) helpers ----------
def _round_to_tick(value, tick, price_prec=8):
    try:
        v = float(value)
    except Exception:
        return None
    try:
        t = float(tick or 0.0)
    except Exception:
        t = 0.0
    try:
        p = int(price_prec if price_prec is not None else 8)
    except Exception:
        p = 8
    if t and t > 0:
        try:
            return round(round(v / t) * t, p)
        except Exception:
            return round(v, p)
    return round(v, p)


def _floor_to_tick(value, tick, price_prec=8):
    try:
        v = float(value)
    except Exception:
        return None
    try:
        t = float(tick or 0.0)
    except Exception:
        t = 0.0
    try:
        p = int(price_prec if price_prec is not None else 8)
    except Exception:
        p = 8
    if t and t > 0:
        try:
            return round(math.floor(v / t) * t, p)
        except Exception:
            return round(v, p)
    return round(v, p)


def _ceil_to_tick(value, tick, price_prec=8):
    try:
        v = float(value)
    except Exception:
        return None
    try:
        t = float(tick or 0.0)
    except Exception:
        t = 0.0
    try:
        p = int(price_prec if price_prec is not None else 8)
    except Exception:
        p = 8
    if t and t > 0:
        try:
            return round(math.ceil(v / t) * t, p)
        except Exception:
            return round(v, p)
    return round(v, p)


def _clamp_sl_distance_bounds(side_up, entry_price, sl_raw, min_pct, max_pct, tick=None, price_prec=8):
    """Clamp SL so that stop distance from entry is within [min_pct, max_pct] (fractions of entry).
    Returns (sl_final, clamp_tag) where clamp_tag is '', 'min', 'max', or 'tick'.
    """
    side = (side_up or "").upper()
    try:
        ep = float(entry_price or 0.0)
        sl = float(sl_raw or 0.0)
    except Exception:
        return None, "invalid"
    if ep <= 0 or sl <= 0:
        return None, "invalid"
    try:
        lo = float(min_pct or 0.0)
    except Exception:
        lo = 0.0
    try:
        hi = float(max_pct or 0.0)
    except Exception:
        hi = 0.0
    lo = max(lo, 0.0)
    hi = max(hi, lo)

    # Bounds in price space
    if side == "BUY":
        lower = ep * (1.0 - hi)  # farthest allowed (max distance)
        upper = ep * (1.0 - lo)  # closest allowed (min distance)
    else:
        lower = ep * (1.0 + lo)  # closest allowed (min distance)
        upper = ep * (1.0 + hi)  # farthest allowed (max distance)

    clamp_tag = ""
    if sl < lower:
        # BUY: too far (distance > max) | SELL: too tight (distance < min)
        clamp_tag = "max" if side == "BUY" else "min"
        sl = lower
    elif sl > upper:
        # BUY: too tight (distance < min) | SELL: too far (distance > max)
        clamp_tag = "min" if side == "BUY" else "max"
        sl = upper

    sl = _round_to_tick(sl, tick, price_prec)

    # Post-round bound enforcement on tick grid.
    try:
        t = float(tick or 0.0)
    except Exception:
        t = 0.0
    if t and t > 0:
        lower_t = _ceil_to_tick(lower, t, price_prec)
        upper_t = _floor_to_tick(upper, t, price_prec)
        if lower_t is not None and upper_t is not None:
            if lower_t <= upper_t:
                if sl < lower_t:
                    sl = lower_t
                    clamp_tag = clamp_tag or "tick"
                elif sl > upper_t:
                    sl = upper_t
                    clamp_tag = clamp_tag or "tick"
            else:
                # No tick value can satisfy both bounds; prioritize respecting max distance.
                sl = lower_t if side == "BUY" else upper_t
                clamp_tag = clamp_tag or "tick"
    return sl, clamp_tag


def _find_last_pivot_low(lows, left=2, right=2):
    try:
        left = max(int(left or 2), 0)
    except Exception:
        left = 2
    try:
        right = max(int(right or 2), 0)
    except Exception:
        right = 2
    if not lows:
        return None, None
    n = len(lows)
    end = n - 1 - right
    start = left
    if end < start:
        return None, None
    for i in range(end, start - 1, -1):
        w = lows[i - left:i + right + 1]
        if len(w) != (left + right + 1):
            continue
        try:
            if lows[i] == min(w):
                return lows[i], i
        except Exception:
            continue
    return None, None


def _find_last_pivot_high(highs, left=2, right=2):
    try:
        left = max(int(left or 2), 0)
    except Exception:
        left = 2
    try:
        right = max(int(right or 2), 0)
    except Exception:
        right = 2
    if not highs:
        return None, None
    n = len(highs)
    end = n - 1 - right
    start = left
    if end < start:
        return None, None
    for i in range(end, start - 1, -1):
        w = highs[i - left:i + right + 1]
        if len(w) != (left + right + 1):
            continue
        try:
            if highs[i] == max(w):
                return highs[i], i
        except Exception:
            continue
    return None, None


def compute_hard_sl_trigger(symbol, side_api, entry_price, current_price=None,
                            tick=None, price_prec=8, meta=None):
    """
    Returns (sl_trigger, source_str).
    - side_api: entry side ("BUY" for LONG, "SELL" for SHORT)
    - If meta contains hard_sl_trigger -> use it (validated), else compute.
    """
    sym = (symbol or "").upper()
    side_up = (side_api or "").upper()
    try:
        ep = float(entry_price or 0.0)
    except Exception:
        ep = 0.0
    if ep <= 0:
        return None, "no_entry"

    try:
        sl_min_pct = float(globals().get("STOP_LOSS_MIN_PCT", 0.002) or 0.002)
    except Exception:
        sl_min_pct = 0.002
    try:
        sl_max_pct = float(globals().get("STOP_LOSS_MAX_PCT", 0.04) or 0.04)
    except Exception:
        sl_max_pct = 0.04

    # 0) Prefer precomputed stop in meta (planned stop for the setup)
    if isinstance(meta, dict):
        cand = meta.get("hard_sl_trigger")
        if cand not in (None, "", 0):
            try:
                cand_f = float(cand)
            except Exception:
                cand_f = None
            if cand_f and (
                (side_up == "BUY" and cand_f < ep) or
                (side_up == "SELL" and cand_f > ep)
            ):
                sl_final, clamp_tag = _clamp_sl_distance_bounds(
                    side_up, ep, cand_f, sl_min_pct, sl_max_pct, tick=tick, price_prec=price_prec
                )
                if sl_final:
                    src = "meta"
                    if clamp_tag and clamp_tag != "invalid":
                        src = f"{src}:{clamp_tag}"
                    return sl_final, src

    mode = str(globals().get("HARD_SL_MODE", "swing") or "swing").lower().strip()

    # 1) Legacy offset mode
    if mode == "offset":
        try:
            offset = float(globals().get("HARD_SL_OFFSET_PCT", 0.0055) or 0.0055)
        except Exception:
            offset = 0.0055
        raw_sl = ep * (1 - offset) if side_up == "BUY" else ep * (1 + offset)
        sl_final, clamp_tag = _clamp_sl_distance_bounds(
            side_up, ep, raw_sl, sl_min_pct, sl_max_pct, tick=tick, price_prec=price_prec
        )
        src = "offset"
        if clamp_tag and clamp_tag != "invalid":
            src = f"{src}:{clamp_tag}"
        return sl_final, src

    # 2) Swing mode
    interval = globals().get("HARD_SL_SWING_INTERVAL", "5m") or "5m"
    try:
        lookback = int(globals().get("HARD_SL_SWING_LOOKBACK", 60) or 60)
    except Exception:
        lookback = 60
    lookback = max(20, min(lookback, 500))
    try:
        left = int(globals().get("HARD_SL_SWING_PIVOT_LEFT", 2) or 2)
    except Exception:
        left = 2
    try:
        right = int(globals().get("HARD_SL_SWING_PIVOT_RIGHT", 2) or 2)
    except Exception:
        right = 2
    try:
        buffer_ticks = float(globals().get("HARD_SL_SWING_BUFFER_TICKS", 2) or 0.0)
    except Exception:
        buffer_ticks = 0.0
    try:
        buffer_pct = float(globals().get("HARD_SL_SWING_BUFFER_PCT", 0.0005) or 0.0)
    except Exception:
        buffer_pct = 0.0
    try:
        min_dist_pct = float(globals().get("HARD_SL_MIN_DIST_PCT", 0.001) or 0.0)
    except Exception:
        min_dist_pct = 0.0

    candles = []
    try:
        candles = get_chart_candles(sym, interval=interval, limit=lookback, force_refresh=False) or []
    except Exception:
        candles = []
    lows, highs = [], []
    for c in candles:
        try:
            lows.append(float(c[3]))
            highs.append(float(c[4]))
        except Exception:
            continue
    if not lows or not highs:
        # fallback to legacy offset if we cannot get candles
        try:
            offset = float(globals().get("HARD_SL_OFFSET_PCT", 0.0055) or 0.0055)
        except Exception:
            offset = 0.0055
        raw_sl = ep * (1 - offset) if side_up == "BUY" else ep * (1 + offset)
        sl_final, clamp_tag = _clamp_sl_distance_bounds(
            side_up, ep, raw_sl, sl_min_pct, sl_max_pct, tick=tick, price_prec=price_prec
        )
        src = "fallback_offset:no_candles"
        if clamp_tag and clamp_tag != "invalid":
            src = f"{src}:{clamp_tag}"
        return sl_final, src

    sl_raw = None
    src = None

    if side_up == "BUY":
        extreme, _idx = _find_last_pivot_low(lows, left=left, right=right)
        if extreme is not None:
            src = "swing:pivot_low"
        else:
            try:
                extreme = min(lows)
                src = "swing:min_low"
            except Exception:
                extreme = None
        if extreme is None:
            return None, "swing:no_extreme"
        buffer_abs = 0.0
        try:
            t = float(tick or 0.0)
            if t > 0 and buffer_ticks > 0:
                buffer_abs = max(buffer_abs, t * buffer_ticks)
        except Exception:
            pass
        try:
            if buffer_pct and buffer_pct > 0:
                buffer_abs = max(buffer_abs, float(extreme) * buffer_pct)
        except Exception:
            pass
        sl_raw = float(extreme) - float(buffer_abs or 0.0)
        # ensure minimum distance from entry (avoid ultra-tight SL)
        if min_dist_pct and (ep - sl_raw) < (ep * min_dist_pct):
            sl_raw = min(sl_raw, ep * (1 - min_dist_pct))
        if sl_raw >= ep:
            sl_raw = None
    else:
        extreme, _idx = _find_last_pivot_high(highs, left=left, right=right)
        if extreme is not None:
            src = "swing:pivot_high"
        else:
            try:
                extreme = max(highs)
                src = "swing:max_high"
            except Exception:
                extreme = None
        if extreme is None:
            return None, "swing:no_extreme"
        buffer_abs = 0.0
        try:
            t = float(tick or 0.0)
            if t > 0 and buffer_ticks > 0:
                buffer_abs = max(buffer_abs, t * buffer_ticks)
        except Exception:
            pass
        try:
            if buffer_pct and buffer_pct > 0:
                buffer_abs = max(buffer_abs, float(extreme) * buffer_pct)
        except Exception:
            pass
        sl_raw = float(extreme) + float(buffer_abs or 0.0)
        # ensure minimum distance from entry (avoid ultra-tight SL)
        if min_dist_pct and (sl_raw - ep) < (ep * min_dist_pct):
            sl_raw = max(sl_raw, ep * (1 + min_dist_pct))
        if sl_raw <= ep:
            sl_raw = None

    if sl_raw is None or not (isinstance(sl_raw, (int, float)) and sl_raw > 0):
        try:
            offset = float(globals().get("HARD_SL_OFFSET_PCT", 0.0055) or 0.0055)
        except Exception:
            offset = 0.0055
        raw_sl = ep * (1 - offset) if side_up == "BUY" else ep * (1 + offset)
        sl_final, clamp_tag = _clamp_sl_distance_bounds(
            side_up, ep, raw_sl, sl_min_pct, sl_max_pct, tick=tick, price_prec=price_prec
        )
        src2 = "fallback_offset:invalid_swing"
        if clamp_tag and clamp_tag != "invalid":
            src2 = f"{src2}:{clamp_tag}"
        return sl_final, src2

    sl_final, clamp_tag = _clamp_sl_distance_bounds(
        side_up, ep, sl_raw, sl_min_pct, sl_max_pct, tick=tick, price_prec=price_prec
    )
    src2 = (src or "swing")
    if clamp_tag and clamp_tag != "invalid":
        src2 = f"{src2}:{clamp_tag}"
    return sl_final, src2


def compute_risk_sized_qty(balance, base_multi, risk_anchor_pct, entry_price, sl_trigger, qty_precision):
    """
    Returns (qty, risk_budget_usdt, stop_dist_abs). Risk budget is derived from
    balance * base_multi * risk_anchor_pct (keeps legacy behavior when hard SL was fixed-offset).
    """
    try:
        bal = float(balance or 0.0)
        multi = float(base_multi or 0.0)
        anchor = float(risk_anchor_pct or 0.0)
        ep = float(entry_price or 0.0)
        sl = float(sl_trigger or 0.0)
    except Exception:
        return None, None, None
    if bal <= 0 or multi <= 0 or anchor <= 0 or ep <= 0 or sl <= 0:
        return None, None, None
    stop_dist = abs(ep - sl)
    if stop_dist <= 0:
        return None, None, None
    risk_budget = bal * multi * anchor
    try:
        qty = risk_budget / stop_dist
    except Exception:
        return None, risk_budget, stop_dist
    try:
        qp = int(qty_precision or 0)
    except Exception:
        qp = 0
    try:
        qty = round(float(qty), qp)
    except Exception:
        return None, risk_budget, stop_dist
    if qty <= 0:
        return None, risk_budget, stop_dist
    return qty, risk_budget, stop_dist


# compute adaptive buffer and set stop_side/stop_price accordingly

def place_pending_order(symbol, level, closes_c=None):
    global relocator
    order = None
    try:
        if not bool(globals().get("bot_running", False)) or shutdown_event.is_set():
            return

        if symbol in rejected_symbols:
            log_message(f"⏩ Пропускаю {symbol}, бо відхилена у цьому циклі")
            return

        # ---- capacity/duplicate guards based on live exchange state ----
        try:
            # 1) per-symbol: якщо вже є відкриті стопові ордери по символу — не ставимо ще
            existing_sym_orders = signed_request(client.futures_get_open_orders, symbol=symbol)
            stop_like_types = {'STOP', 'STOP_MARKET', 'TAKE_PROFIT', 'TAKE_PROFIT_MARKET'}
            exists_stop_sym = any((o.get('type') in stop_like_types) for o in existing_sym_orders or [])
            if exists_stop_sym:
                log_message(f"⚠️ Пропускаю {symbol}: на біржі вже є відкритий STOP/TP ордер для цього символу.")
                return
        except Exception:
            pass

        try:
            # 2) глобальний ліміт pending по біржовим ордерам
            if MAX_CONCURRENT_PENDING is not None:
                all_open_orders = signed_request(client.futures_get_open_orders)
                stop_syms = {
                    o.get('symbol') for o in (all_open_orders or [])
                    if o.get('type') in {'STOP', 'STOP_MARKET', 'TAKE_PROFIT', 'TAKE_PROFIT_MARKET'}
                }
                if len(stop_syms) >= MAX_CONCURRENT_PENDING and symbol not in stop_syms:
                    log_message(f"⚠️ Ліміт pending досягнуто (биржові STOP/TP по {len(stop_syms)}/{MAX_CONCURRENT_PENDING}). Пропускаю {symbol}.")
                    return
        except Exception:
            pass

        try:
            # 3) ліміт позицій: якщо вже відкрито позицій на біржі >= MAX_CONCURRENT_POSITIONS — скіпаємо
            if MAX_CONCURRENT_POSITIONS is not None:
                pos_info = signed_request(client.futures_position_information)
                pos_cnt = 0
                if pos_info:
                    for p in pos_info:
                        try:
                            if abs(float(p.get('positionAmt', 0) or 0.0)) > 0:
                                pos_cnt += 1
                        except Exception:
                            continue
                if pos_cnt >= MAX_CONCURRENT_POSITIONS:
                    log_message(f"⚠️ Ліміт відкритих позицій досягнуто {pos_cnt}/{MAX_CONCURRENT_POSITIONS}. Пропускаю {symbol}.")
                    return
        except Exception:
            pass

        # compute dynamic max_level_distance using volatility from closes (preferred)
        try:
            # if caller provided closed closes list, use it; otherwise attempt to fetch recent 5m closed closes
            if closes_c and isinstance(closes_c, (list, tuple)) and len(closes_c) >= 2:
                _closes_for_distance = closes_c
            else:
                try:
                    kl = signed_request(client.futures_klines, symbol=symbol, interval="5m", limit=DYN_VOL_WINDOW + 2)
                    if kl and len(kl) >= 2:
                        # use only closed candles (exclude last open)
                        closed_cnt = max(1, len(kl) - 1)
                        _closes_for_distance = [float(k[4]) for k in kl][:closed_cnt]
                    else:
                        _closes_for_distance = None
                except Exception:
                    _closes_for_distance = None
            max_level_distance = get_dynamic_max_level_distance(symbol, _closes_for_distance)
        except Exception:
            max_level_distance = DYN_MAX_LEVEL_DISTANCE

        cached = symbol_prices.get(symbol)
        last_price = cached['price'] if cached and (time.time() - cached.get('ts', 0)) <= PRICE_STALE_SEC else None
        if last_price is None:
            ticker = signed_request(client.futures_symbol_ticker, symbol=symbol)
            last_price = float(ticker['price'])
            symbol_prices[symbol] = {'price': last_price, 'ts': time.time()}
        qty_precision, price_precision = get_symbol_precision(symbol)
        balance = get_balance()
        rounded_balance = round(balance)
        if level == 0:
            log_message(f"❌ Некоректний рівень (0) для {symbol}")
            return
        try:
            symbol_natr = None
            try:
                # prefer a cached or fast calculation when available
                symbol_natr = calculate_natr(symbol)
            except Exception:
                try:
                    # fallback: if meta exists in pending_meta or elsewhere, try to read it
                    meta_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                    if meta_local and isinstance(meta_local, dict):
                        symbol_natr = meta_local.get('natr')
                except Exception:
                    symbol_natr = None
            # if symbol_natr is falsy, set to None so the function will fallback to closes-based estimation
            if symbol_natr is not None:
                try:
                    symbol_natr = float(symbol_natr)
                except Exception:
                    symbol_natr = None
        except Exception:
            symbol_natr = None
        # Use NATR-only approach for dynamic position sizing.
        try:
            # Prefer direct NATR calculation and use it as the sole volatility input.
            symbol_natr = None
            try:
                symbol_natr = calculate_natr(symbol)
            except Exception as e_calc:
                log_message(f"⚠️ calculate_natr failed for {symbol}: {e_calc}")
                symbol_natr = None
            # If calculate_natr returns a falsy 0 value, keep it (means volatile estimate ~0)
            log_message(f"🔎 Using NATR for position sizing [{symbol}]: natr={symbol_natr}")
        except Exception:
            symbol_natr = None
        # Pass closes as None to ensure function uses only natr (if provided)
        dynamic_multi = get_dynamic_position_multiplier(symbol, None, natr=symbol_natr)
        legacy_quantity = round((rounded_balance * dynamic_multi) / level, qty_precision)
        if legacy_quantity <= 0:
            log_message(f"❌ Розрахована кількість <=0 для {symbol} — баланс/рівень нереальні")
            return

        symbol_natr = calculate_natr(symbol) or 0.0  # твоя функція вже повертає ATR для 5m
        # fast-approach buffer adjustment removed
        min_buffer = abs(MIN_STOP_BUFFER_PCT)
        dyn_buffer = (symbol_natr / 100.0) * STOP_NATR_BUFFER_FACTOR
        buffer_pct = max(min_buffer, dyn_buffer)

        # Base direction (breakout side)
        if level > last_price:
            base_side = 'BUY'
        else:
            base_side = 'SELL'

        # Prefer to anchor STOP_MARKET behind the largest wall within ±0.5% of the detected level:
        # - BUY: scan asks in [level*(1-0.5%), level*(1+0.5%)] and place stopPrice 1 tick ABOVE the wall
        # - SELL: scan bids in [level*(1-0.5%), level*(1+0.5%)] and place stopPrice 1 tick BELOW the wall
        # If no wall is available (or book not ready), fallback to volatility-based buffer.
        tick_size = None
        try:
            filt_tmp = order_placement_service._filters(symbol)
            tick_size = float(filt_tmp.get("tick", 0.0) or 0.0)
        except Exception:
            tick_size = None
        if not tick_size or tick_size <= 0:
            try:
                tick_size = 10 ** (-int(price_precision or 8))
            except Exception:
                tick_size = 0.0

        wall_range_pct = float(globals().get("PENDING_WALL_RANGE_PCT", 0.01) or 0.01)
        wall_offset_ticks = int(globals().get("PENDING_WALL_OFFSET_TICKS", 1) or 1)
        lo_p = float(level) * (1.0 - wall_range_pct)
        hi_p = float(level) * (1.0 + wall_range_pct)

        best_wall_price = None
        best_wall_notional = None
        try:
            side_list = None
            try:
                with orderbook_lock:
                    ob = orderbook_state.get(symbol) or {}
                    if base_side == 'BUY':
                        side_list = list(ob.get('asks') or [])
                    else:
                        side_list = list(ob.get('bids') or [])
            except Exception:
                side_list = None

            if side_list:
                for p, q in side_list:
                    try:
                        fp = float(p)
                        fq = float(q)
                    except Exception:
                        continue
                    if fp < lo_p or fp > hi_p:
                        continue
                    # Prefer notional (quote) size as "largest wall"
                    notional = fp * fq
                    if best_wall_notional is None or notional > best_wall_notional:
                        best_wall_notional = notional
                        best_wall_price = fp
        except Exception:
            best_wall_price = None
            best_wall_notional = None

        stop_price = None
        if best_wall_price is not None and tick_size and tick_size > 0:
            try:
                if base_side == 'BUY':
                    raw = float(best_wall_price) + float(tick_size) * float(max(1, wall_offset_ticks))
                    stop_price = _ceil_to_tick(raw, tick_size, price_precision)
                else:
                    raw = float(best_wall_price) - float(tick_size) * float(max(1, wall_offset_ticks))
                    stop_price = _floor_to_tick(raw, tick_size, price_precision)
                try:
                    log_message(f"🧱 Pending anchor wall {symbol}: side={base_side} wall={best_wall_price} notional≈{float(best_wall_notional or 0.0):.0f}$ stop={stop_price}")
                except Exception:
                    pass
            except Exception:
                stop_price = None

        if stop_price is None:
            # Fallback: volatility-based buffer
            if base_side == 'BUY':
                stop_price = round(level * (1.0 + buffer_pct), price_precision)
            else:
                stop_price = round(level * (1.0 - buffer_pct), price_precision)

        # Ensure stop price is valid relative to current price for STOP_MARKET acceptance
        try:
            if base_side == 'BUY' and stop_price <= last_price and tick_size and tick_size > 0:
                stop_price = _ceil_to_tick(float(last_price) + float(tick_size), tick_size, price_precision)
            if base_side == 'SELL' and stop_price >= last_price and tick_size and tick_size > 0:
                stop_price = _floor_to_tick(float(last_price) - float(tick_size), tick_size, price_precision)
        except Exception:
            pass

        try:
            update_chart_target(symbol, level)
        except Exception:
            pass

        order_type = 'STOP_MARKET'
        stop_side = base_side
        # --- adaptive buffer replacement end ---

        with orders_lock:
            if symbol in active_orders:
                existing_order_id = active_orders[symbol]
                current_price = symbol_prices.get(symbol, {}).get('price') if symbol_prices.get(symbol) else None
                if current_price is None:
                    current_price = get_last_price(symbol)
                if current_price is None:
                    log_message(f"❌ Не вдалося отримати поточну ціну при перевірці активного ордера для {symbol}")
                else:
                    diff = percent_diff(current_price, level)
                    log_message(
                        f"🔎 Перевірка активного ордера {symbol}: price={current_price}, level={level}, diff={diff * 100:.2f}%, threshold={max_level_distance * 100:.2f}%")
                    broken_by_open = False
                    try:
                        broken_by_open = is_level_broken_by_current_open(symbol, level, max_level_distance)
                    except Exception:
                        broken_by_open = False
                    if diff >= max_level_distance or broken_by_open:
                        try:
                            signed_request(client.futures_cancel_order, symbol=symbol, orderId=existing_order_id)
                            log_message(
                                f"❌ Ордер {symbol} знято через віддалення ціни ({diff * 100:.2f}%) > {max_level_distance * 100:.2f}%")
                            del active_orders[symbol]
                            rejected_symbols.add(symbol)
                        except Exception as e:
                            log_message(f"❌ Не вдалося зняти ордер {symbol}: {e}")
                            log_message(traceback.format_exc())
                    else:
                        return False

        # --- Adaptive hard SL (swing) + stop-width sizing ---
        hard_sl_trigger = None
        hard_sl_source = None
        risk_budget_usdt = None
        stop_dist_abs = None
        stop_pct = None
        stopmap_target_mult = None
        stopmap_sl_min_pct = None
        stopmap_sl_max_pct = None
        quantity = None
        try:
            filt_tmp = order_placement_service._filters(symbol)
            tick_tmp = float(filt_tmp.get("tick", 0.0) or 0.0)
            step_tmp = float(filt_tmp.get("step", 0.0) or 0.0)
            price_prec_tmp = int(filt_tmp.get("price_prec", price_precision) or price_precision or 8)
        except Exception:
            tick_tmp = 0.0
            step_tmp = 0.0
            try:
                price_prec_tmp = int(price_precision or 8)
            except Exception:
                price_prec_tmp = 8
        try:
            entry_est = float(stop_price or level or 0.0)
        except Exception:
            entry_est = float(level or 0.0) if level else 0.0
        try:
            hard_sl_trigger, hard_sl_source = compute_hard_sl_trigger(
                symbol,
                stop_side,
                entry_est,
                current_price=last_price,
                tick=tick_tmp,
                price_prec=price_prec_tmp,
                meta=None
            )
        except Exception:
            hard_sl_trigger, hard_sl_source = None, None
        try:
            if hard_sl_trigger and entry_est:
                stop_dist_abs = abs(float(entry_est) - float(hard_sl_trigger))
                stop_pct = float(stop_dist_abs) / float(entry_est)
        except Exception:
            stop_dist_abs = None
            stop_pct = None
        try:
            risk_anchor = float(globals().get('HARD_SL_OFFSET_PCT', 0.0055) or 0.0055)
        except Exception:
            risk_anchor = 0.0055
        try:
            if hard_sl_trigger:
                sizing_src = "risk"
                quantity, risk_budget_usdt, stop_dist_abs = compute_risk_sized_qty(
                    rounded_balance,
                    dynamic_multi,
                    risk_anchor,
                    entry_est,
                    hard_sl_trigger,
                    qty_precision
                )
        except Exception:
            quantity = None
        if not quantity or quantity <= 0:
            sizing_src = "legacy"
            quantity = legacy_quantity

        # --- Notional clamps (balance * x) ---
        min_notional_mult = 0.0
        max_notional_mult = 0.0
        min_notional_usdt = None
        max_notional_usdt = None
        notional_est_usdt = None
        try:
            min_notional_mult = float(globals().get("MIN_POS_NOTIONAL_MULT", 0.0) or 0.0)
        except Exception:
            min_notional_mult = 0.0
        try:
            max_notional_mult = float(globals().get("MAX_POS_NOTIONAL_MULT", 0.0) or 0.0)
        except Exception:
            max_notional_mult = 0.0
        try:
            bal_for_limits = float(balance if balance is not None else rounded_balance)
        except Exception:
            bal_for_limits = float(rounded_balance or 0.0)

        # Normalize invalid config: if MIN > MAX swap them (keeps meaning: MIN=smaller, MAX=larger).
        try:
            if min_notional_mult and max_notional_mult and float(min_notional_mult) > float(max_notional_mult):
                try:
                    log_message(
                        f"⚠️ Invalid notional mults: MIN_POS_NOTIONAL_MULT={float(min_notional_mult):.4f} > "
                        f"MAX_POS_NOTIONAL_MULT={float(max_notional_mult):.4f}. Swapping."
                    )
                except Exception:
                    pass
                min_notional_mult, max_notional_mult = float(max_notional_mult), float(min_notional_mult)
        except Exception:
            pass

        # Stop-width -> notional mapping:
        # - tight stop (STOP_LOSS_MIN_PCT) -> MAX_POS_NOTIONAL_MULT (bigger size)
        # - wide stop  (STOP_LOSS_MAX_PCT) -> MIN_POS_NOTIONAL_MULT (smaller size)
        try:
            if (
                hard_sl_trigger
                and stop_pct is not None
                and entry_est
                and min_notional_mult and float(min_notional_mult) > 0
                and max_notional_mult and float(max_notional_mult) > 0
            ):
                try:
                    sl_min_pct = float(globals().get("STOP_LOSS_MIN_PCT", 0.002) or 0.002)
                except Exception:
                    sl_min_pct = 0.002
                try:
                    sl_max_pct = float(globals().get("STOP_LOSS_MAX_PCT", 0.04) or 0.04)
                except Exception:
                    sl_max_pct = 0.04
                try:
                    if sl_min_pct <= 0:
                        sl_min_pct = 0.002
                    if sl_max_pct < sl_min_pct:
                        sl_max_pct = sl_min_pct
                except Exception:
                    sl_min_pct, sl_max_pct = 0.002, 0.04

                stopmap_sl_min_pct = sl_min_pct
                stopmap_sl_max_pct = sl_max_pct
                sp = float(stop_pct)
                if sp < sl_min_pct:
                    sp = sl_min_pct
                if sp > sl_max_pct:
                    sp = sl_max_pct
                denom = float(sl_max_pct) - float(sl_min_pct)
                t = 1.0 if denom <= 1e-12 else (sp - float(sl_min_pct)) / denom
                if t < 0.0:
                    t = 0.0
                elif t > 1.0:
                    t = 1.0

                stopmap_target_mult = float(max_notional_mult) + float(t) * (
                    float(min_notional_mult) - float(max_notional_mult)
                )
                lo_m = min(float(min_notional_mult), float(max_notional_mult))
                hi_m = max(float(min_notional_mult), float(max_notional_mult))
                if stopmap_target_mult < lo_m:
                    stopmap_target_mult = lo_m
                elif stopmap_target_mult > hi_m:
                    stopmap_target_mult = hi_m

                target_notional = float(bal_for_limits) * float(stopmap_target_mult)
                q_map = round(float(target_notional) / float(entry_est), qty_precision)
                if q_map and q_map > 0:
                    quantity = q_map
                    sizing_src = "stopmap"
                    risk_budget_usdt = None
        except Exception:
            pass
        if min_notional_mult and min_notional_mult > 0:
            try:
                min_notional_usdt = bal_for_limits * float(min_notional_mult)
            except Exception:
                min_notional_usdt = None
        if max_notional_mult and max_notional_mult > 0:
            try:
                max_notional_usdt = bal_for_limits * float(max_notional_mult)
            except Exception:
                max_notional_usdt = None
        try:
            if entry_est and quantity:
                notional_est_usdt = float(quantity) * float(entry_est)
        except Exception:
            notional_est_usdt = None
        notional_raw_usdt = notional_est_usdt

        # Normalize invalid config: if min > max, treat min as max.
        if min_notional_usdt and max_notional_usdt:
            try:
                if float(min_notional_usdt) > float(max_notional_usdt):
                    log_message(
                        f"⚠️ Invalid notional limits: min {float(min_notional_usdt):.2f} > max {float(max_notional_usdt):.2f}. "
                        f"Using max as min for {symbol}."
                    )
                    min_notional_usdt = float(max_notional_usdt)
            except Exception:
                pass

        # If position is too small -> raise up to min_notional (increases risk vs anchor sizing).
        if min_notional_usdt and notional_est_usdt is not None and notional_est_usdt < float(min_notional_usdt):
            try:
                raw_q = float(min_notional_usdt) / float(entry_est)
                step_q = float(step_tmp or 0.0)
                if not step_q or step_q <= 0:
                    step_q = 10 ** (-int(qty_precision or 0))
                raised_qty = raw_q
                if step_q and step_q > 0:
                    raised_qty = math.ceil((raw_q / step_q) - 1e-12) * step_q
                raised_qty = round(float(raised_qty), qty_precision)
            except Exception:
                raised_qty = None
            if not raised_qty or raised_qty <= 0:
                try:
                    log_message(
                        f"⚠️ Skip {symbol}: notional {notional_est_usdt:.2f} < min {float(min_notional_usdt):.2f} "
                        f"(MIN_POS_NOTIONAL_MULT={min_notional_mult}) and min-raise produced qty<=0"
                    )
                except Exception:
                    pass
                return
            try:
                log_message(
                    f"⬆️ Raise {symbol}: notional {notional_est_usdt:.2f} -> min {float(min_notional_usdt):.2f} "
                    f"qty {quantity} -> {raised_qty} (MIN_POS_NOTIONAL_MULT={min_notional_mult})"
                )
            except Exception:
                pass
            quantity = raised_qty
            try:
                notional_est_usdt = float(quantity) * float(entry_est)
            except Exception:
                pass

        # If position is too large -> cap down to max_notional.
        if max_notional_usdt and notional_est_usdt is not None and notional_est_usdt > float(max_notional_usdt):
            try:
                raw_q = float(max_notional_usdt) / float(entry_est)
                step_q = float(step_tmp or 0.0)
                if not step_q or step_q <= 0:
                    step_q = 10 ** (-int(qty_precision or 0))
                capped_qty = raw_q
                if step_q and step_q > 0:
                    capped_qty = math.floor((raw_q / step_q) + 1e-12) * step_q
                capped_qty = round(float(capped_qty), qty_precision)
            except Exception:
                capped_qty = None
            if not capped_qty or capped_qty <= 0:
                try:
                    log_message(
                        f"⚠️ Skip {symbol}: notional cap produced qty<=0 (max={max_notional_usdt}, entry={entry_est})"
                    )
                except Exception:
                    pass
                return
            try:
                log_message(
                    f"🧢 Cap {symbol}: notional {notional_est_usdt:.2f} -> max {float(max_notional_usdt):.2f} "
                    f"qty {quantity} -> {capped_qty} (MAX_POS_NOTIONAL_MULT={max_notional_mult})"
                )
            except Exception:
                pass
            quantity = capped_qty
            try:
                notional_est_usdt = float(quantity) * float(entry_est)
            except Exception:
                pass

        # Sizing summary (helps debug why max/min did or didn't apply)
        try:
            if (min_notional_usdt or max_notional_usdt):
                stop_pct = None
                try:
                    if stop_dist_abs and entry_est:
                        stop_pct = float(stop_dist_abs) / float(entry_est)
                except Exception:
                    stop_pct = None
                raw_mult = None
                fin_mult = None
                try:
                    if bal_for_limits and notional_raw_usdt is not None:
                        raw_mult = float(notional_raw_usdt) / float(bal_for_limits)
                except Exception:
                    raw_mult = None
                try:
                    if bal_for_limits and notional_est_usdt is not None:
                        fin_mult = float(notional_est_usdt) / float(bal_for_limits)
                except Exception:
                    fin_mult = None
                min_disp = f"{float(min_notional_usdt):.2f}" if min_notional_usdt else "off"
                max_disp = f"{float(max_notional_usdt):.2f}" if max_notional_usdt else "off"
                stop_disp = f"{float(stop_pct):.3%}" if stop_pct is not None else "?"
                raw_n_disp = f"{float(notional_raw_usdt):.2f}" if notional_raw_usdt is not None else "?"
                fin_n_disp = f"{float(notional_est_usdt):.2f}" if notional_est_usdt is not None else "?"
                raw_m_disp = f"{float(raw_mult):.2f}" if raw_mult is not None else "?"
                fin_m_disp = f"{float(fin_mult):.2f}" if fin_mult is not None else "?"
                dyn_disp = f"{float(dynamic_multi):.4f}" if dynamic_multi is not None else "?"
                anc_disp = f"{float(risk_anchor):.6f}" if risk_anchor is not None else "?"
                rb_disp = f"{float(risk_budget_usdt):.2f}" if risk_budget_usdt is not None else "?"
                map_disp = ""
                try:
                    if (
                        sizing_src == "stopmap"
                        and stopmap_target_mult is not None
                        and stopmap_sl_min_pct
                        and stopmap_sl_max_pct
                    ):
                        map_disp = (
                            f" map=[{float(stopmap_sl_min_pct):.3%}..{float(stopmap_sl_max_pct):.3%}]"
                            f" tgt={float(stopmap_target_mult):.2f}"
                        )
                except Exception:
                    map_disp = ""
                log_message(
                    f"[SIZE] {symbol} src={sizing_src} stop={stop_disp} "
                    f"notional {raw_n_disp}->{fin_n_disp} mult {raw_m_disp}->{fin_m_disp} "
                    f"min={min_disp} max={max_disp} dyn={dyn_disp} anchor={anc_disp} risk={rb_disp}{map_disp}"
                )
        except Exception:
            pass

        # --- Single-entry sizing (only ENTRY2) ---
        qty_total = quantity

        # Ensure conditional algo order satisfies Binance min-notional rule.
        try:
            algo_min_notional = float(globals().get("ALGO_MIN_NOTIONAL_USDT", 5.0) or 5.0)
        except Exception:
            algo_min_notional = 5.0
        try:
            trigger_px = float(stop_price or entry_est or 0.0)
        except Exception:
            trigger_px = 0.0
        try:
            step_q = float(step_tmp or 0.0)
            if not step_q or step_q <= 0:
                step_q = 10 ** (-int(qty_precision or 0))
        except Exception:
            step_q = 10 ** (-int(qty_precision or 0))

        if trigger_px and algo_min_notional and algo_min_notional > 0:
            try:
                qty_for_cond = float(qty_total)
                notional_cond = qty_for_cond * float(trigger_px)
                if notional_cond < float(algo_min_notional) - 1e-9:
                    log_message(
                        f"⚠️ Skip {symbol}: conditional notional {notional_cond:.2f} < Algo min {float(algo_min_notional):.2f} "
                        f"(qty={qty_for_cond}, trigger={trigger_px})"
                    )
                    return
            except Exception:
                pass

        # For pending order bookkeeping: quantity == full size.
        quantity_total = qty_total
        quantity = qty_total
        try:
            if hard_sl_trigger and stop_dist_abs and entry_est:
                log_message(
                    f"🧷 Hard SL план {symbol}: sl={hard_sl_trigger:.8f} ({hard_sl_source}) dist={(stop_dist_abs / entry_est):.3%} qty_total={quantity_total}"
                )
        except Exception:
            pass

        # compute NATR now and save into pending_meta for later use

        # prefer pending_meta's max_level_distance if present (avoid recomputing inconsistenly)
        try:
            pm_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
            if pm_local and isinstance(pm_local, dict) and 'max_level_distance' in pm_local:
                max_level_distance = pm_local.get('max_level_distance')
        except Exception:
            pass

        try:
            symbol_natr = calculate_natr(symbol)
        except Exception:
            symbol_natr = 0
        try:
            client_oid = _unique_client_order_id("stp")
            stop_order = create_conditional_order(
                symbol=symbol,
                side=stop_side,
                order_type=order_type,
                quantity=quantity,
                stop_price=stop_price,
                client_oid=client_oid,
                reduce_only=False,
                position_side='BOTH'
            )
        except Exception as be:
            log_message(f"❌ Помилка створення STOP/TP (algo) для {symbol}: {be}")
            raise
        # --- ONE-TIME post-place check: immediately verify level not already broken ---
        post_place_cancelled = False
        try:
            oid = None
            try:
                if isinstance(stop_order, dict):
                    oid = stop_order.get('orderId') or stop_order.get('algoId') or stop_order.get('order_id')
            except Exception:
                oid = None
            # fetch latest price once
            try:
                cur_price = symbol_prices.get(symbol, {}).get('price') if symbol_prices.get(symbol) else None
                if cur_price is None:
                    cur_price = float(signed_request(client.futures_symbol_ticker, symbol=symbol)['price'])
                    symbol_prices[symbol] = {'price': cur_price, 'ts': time.time()}
            except Exception:
                cur_price = None
            # if price is available and level is now broken -> cancel order
            if cur_price is not None:
                try:
                    dist_now = percent_diff(cur_price, level)
                    broken_by_open = False
                    try:
                        broken_by_open = is_level_broken_by_current_open(symbol, level, max_level_distance)
                    except Exception:
                        broken_by_open = False
                    if dist_now >= max_level_distance or broken_by_open:
                        # cancel the freshly created pending order
                        try:
                            if oid:
                                try:
                                    signed_request(client.futures_cancel_order, symbol=symbol, orderId=oid)
                                except Exception:
                                    try:
                                        cancel_conditional_order(symbol, oid)
                                    except Exception:
                                        pass
                                log_message(
                                    f"❌ Post-place check: cancelled pending order {symbol} ({oid}) because level appears broken: price={cur_price:.8f}, level={level:.8f}, dist={dist_now:.4%}")
                            else:
                                log_message(
                                    f"❌ Post-place check: level appears broken for {symbol} (price={cur_price:.8f}, level={level:.8f}) but order id unknown — manual cleanup may be needed")
                        except Exception as e_cancel:
                            log_message(f"❌Failed to cancel post-placed order for {symbol}: {e_cancel}")
                        # cleanup bookkeeping regardless
                        try:
                            with orders_lock:
                                active_orders.pop(symbol, None)
                                pending_meta.pop(symbol, None)
                        except Exception:
                            pass
                        post_place_cancelled = True
                except Exception:
                    pass
        except Exception:
            pass
        # --- end post-place check ---
        if post_place_cancelled:
            return

        if isinstance(stop_order, dict) and 'orderId' in stop_order:
            with orders_lock:
                active_orders[symbol] = stop_order['orderId']
                pending_meta[symbol] = {
                    'stop_side': stop_side,
                    'stop_price': stop_price,
                    'level': level,
                    'level_price': level,
                    'quantity': quantity,
                    'quantity_total': quantity_total,
                    'entry2_order_id': stop_order.get('orderId'),
                    'min_pos_notional_mult': min_notional_mult,
                    'max_pos_notional_mult': max_notional_mult,
                    'min_pos_notional_usdt': min_notional_usdt,
                    'max_pos_notional_usdt': max_notional_usdt,
                    'notional_est_usdt': notional_est_usdt,
                    'natr': symbol_natr,
                    'max_level_distance': max_level_distance,
                    'hard_sl_trigger': hard_sl_trigger,
                    'hard_sl_source': hard_sl_source,
                    'risk_budget_usdt': risk_budget_usdt,
                    'hard_sl_stop_dist': stop_dist_abs,
                    'base_multi': dynamic_multi,
                    'legacy_quantity': legacy_quantity,
                }
            log_message(
                f"🌟 Відкладений ордер({stop_side}) на {symbol}: {stop_price} | qty={quantity_total}  NATR={symbol_natr:.2f}% 🌟")

            add_order_row(symbol, stop_side, quantity, stop_price, "-")

            # --- PendingRelocator registration (auto-added) ---
            try:
                # lazy-create a module adapter and relocator if not present
                if relocator is None and 'PendingRelocator' in globals():
                    class _ModuleBotAdapter:
                        def __init__(self):
                            self.client = client

                        def find_horizontal_levels(self, symbol, *args, **kwargs):
                            # Always use the global standard parameters to ensure consistency
                            try:
                                return find_horizontal_levels(
                                    symbol,
                                    window=globals().get('LEVEL_WINDOW', 100),
                                    precision=globals().get('LEVEL_PRECISION', 5),
                                    tolerance=globals().get('TOLERANCE', 0.002),
                                    min_touches=globals().get('MIN_TOUCHES', 2),
                                    min_interval=globals().get('MIN_INTERVAL', 4)
                                )
                            except TypeError:
                                # fallback to positional signature (symbol, window, precision)
                                return find_horizontal_levels(symbol, globals().get('LEVEL_WINDOW', 100),
                                                              globals().get('LEVEL_PRECISION', 5))
                            except Exception as e:
                                try:
                                    log_message('_ModuleBotAdapter.find_horizontal_levels error for ' + str(
                                        symbol) + ': ' + str(e))
                                except Exception:
                                    print('_ModuleBotAdapter.find_horizontal_levels error for ' + str(
                                        symbol) + ': ' + str(e))
                                return []

                        def place_pending_order(self, symbol, side, qty, stop_price, meta=None, **kwargs):
                            # low-level direct placement to avoid re-registering via module place_pending_order
                            try:
                                mod_fn = globals().get('place_pending_order')
                                if callable(mod_fn):
                                    try:
                                        return mod_fn(symbol, level=stop_price)
                                    except TypeError:
                                        try:
                                            return mod_fn(symbol=symbol, level=stop_price)
                                        except Exception:
                                            pass

                            except Exception:
                                pass
                            # fallback to raw API create
                            return signed_request(client.futures_create_order, symbol=symbol, side=side,
                                                  type='STOP_MARKET', quantity=qty, stopPrice=stop_price)

                        def log_message(self, msg):
                            try:
                                log_message(msg)
                            except Exception:
                                print(msg)

                        def get_price_from_cache(self, symbol):
                            return symbol_prices.get(symbol, {}).get('price', 0)

                    relocator = PendingRelocator(_ModuleBotAdapter())

                register_with_relocator = relocator is not None
                if register_with_relocator:
                    created_order = stop_order
                    pending_info = {
                        'orderId': created_order.get('orderId'),
                        'stopPrice': float(stop_price),
                        'side': stop_side,
                        'qty': quantity,
                        'meta': pending_meta.get(symbol, {}),
                        'last_relocate_ts': time.time(),
                    }
                    try:
                        relocator.register_pending_order(symbol, pending_info)
                    except Exception as _e:
                        log_message(f"Relocator register error for {symbol}: {_e}")
            except Exception as e:
                log_message(f"Relocator setup error for {symbol}: {e}")
            # --- End relocator registration ---

            except Exception:
                pass
            # ensure we subscribe to price updates so trailing and monitoring will have fresh prices
            try:
                subscribe_price(symbol)
            except Exception:
                pass
        else:
            log_message(f"❌ Неочікувана відповідь при створенні stop_order для {symbol}: {stop_order}")
    except Exception as e:
        log_message(f"❌ Помилка place_pending_order для {symbol}: {e}")
        log_message(traceback.format_exc())


# глобальна утиліта split_qty

def split_qty(q, parts, precision):
    parts_list = []
    for i in range(parts - 1):
        parts_list.append(round(q / parts, precision))
    last = round(q - sum(parts_list), precision)
    parts_list.append(last)
    return parts_list


def _emit_rest_fill_event(symbol, order_obj=None, status_hint=None):
    """
    Синтезує ORDER_TRADE_UPDATE(FILLED) з REST-відповіді, якщо WS пропустив подію.
    Повертає True, якщо подія була відправлена у _handle_user_message.
    """
    try:
        try:
            amt, _ = get_exchange_position(symbol)
            if abs(amt) <= eps:
                return False
        except Exception:
            pass
        status_raw = status_hint or ((order_obj or {}).get('status'))
        if not status_raw:
            return False
        status = str(status_raw).upper()
        if status not in ('FILLED', 'PARTIALLY_FILLED', 'TRADE'):
            return False
        oid = (order_obj or {}).get('orderId') or (order_obj or {}).get('order_id')
        side = (order_obj or {}).get('side') or (order_obj or {}).get('S')
        otype = (order_obj or {}).get('type') or (order_obj or {}).get('origType') or (order_obj or {}).get('o')
        avg = (order_obj or {}).get('avgPrice') or (order_obj or {}).get('price') or (order_obj or {}).get('stopPrice') or '0'
        qty = (order_obj or {}).get('origQty') or (order_obj or {}).get('origQuantity') or (order_obj or {}).get('quantity') or (order_obj or {}).get('qty')
        synthetic = {
            'e': 'ORDER_TRADE_UPDATE',
            'o': {
                's': symbol,
                'X': status,
                'S': side,
                'o': otype,
                'ap': avg,
                'origQty': qty,
                'i': oid
            }
        }
        _handle_user_message(synthetic)
        return True
    except Exception as e:
        try:
            log_message(f"❌ REST fill dispatch failed for {symbol}: {e}")
        except Exception:
            pass
        return False


# ------------------- Фоновий моніторинг віддалення ціни -------------------
def monitor_order_distance():
    while bot_running:
        orders_snapshot = list(active_orders.items())
        for symbol, stop_order_id in orders_snapshot:
            try:
                cached = symbol_prices.get(symbol)
                last_price = cached['price'] if cached and (
                        time.time() - cached.get('ts', 0)) <= PRICE_STALE_SEC else None
                if last_price is None:
                    last_price = get_last_price(symbol)
                if last_price is None:
                    continue

                try:
                    stop_order = signed_request(client.futures_get_order, symbol=symbol, orderId=stop_order_id)
                except Exception as e:
                    log_message(f"❌ Помилка отримання ордеру (futures_get_order) {symbol}: {e}")
                    log_message(traceback.format_exc())
                    continue

                stop_status = str(stop_order.get('status') or '').upper() if stop_order else ''
                if stop_status in ('FILLED', 'PARTIALLY_FILLED'):
                    try:
                        exch_amt_check, _ = get_exchange_position(symbol)
                        if abs(exch_amt_check) <= eps:
                            log_message(f"ℹ️ Монітор: {symbol} ордер {stop_order_id} FILLED, але позиції немає — очищаю pending.")
                            # Also cancel any pre-placed ENTRY1 order to avoid a late unexpected entry.
                            try:
                                e1_oid = None
                                with orders_lock:
                                    pm_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                                    if isinstance(pm_local, dict):
                                        e1_oid = pm_local.get("entry1_order_id")
                                if e1_oid not in (None, "", 0, False):
                                    try:
                                        signed_request(client.futures_cancel_order, symbol=symbol, orderId=e1_oid)
                                    except Exception:
                                        try:
                                            cancel_conditional_order(symbol, e1_oid)
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                            with orders_lock:
                                active_orders.pop(symbol, None)
                                pending_meta.pop(symbol, None)
                            continue
                    except Exception:
                        pass
                    log_message(
                        f"ℹ️ Монітор: ордер {symbol} ({stop_order_id}) має статус {stop_status} (REST) — запускаємо post-fill обробку")
                    try:
                        _emit_rest_fill_event(symbol, stop_order, status_hint=stop_status)
                    except Exception:
                        try:
                            log_message(f"⚠️ Не вдалося синхронізувати FILLED для {symbol} через monitor_order_distance")
                        except Exception:
                            pass
                    continue

                # ENTRY1 (micro): if enabled, trigger starter only after micro-confirmation (compression/sweep)
                # If a position is already open, disable distance-based cancellation for this symbol.
                try:
                    pos_qty = 0.0
                    try:
                        with positions_lock:
                            pos_qty = abs(float((open_positions.get(symbol) or {}).get('qty') or 0.0))
                    except Exception:
                        pos_qty = 0.0
                    if pos_qty > eps:
                        continue
                    try:
                        exch_amt_de, _ = get_exchange_position(symbol)
                        exch_qty_de = abs(float(exch_amt_de or 0.0))
                    except Exception:
                        exch_qty_de = 0.0
                    if exch_qty_de > eps:
                        continue
                except Exception:
                    pass

                stop_price = 0.0
                if stop_order:
                    if 'stopPrice' in stop_order and stop_order.get('stopPrice') not in (None, '', 0):
                        try:
                            stop_price = float(stop_order['stopPrice'])
                        except Exception:
                            stop_price = 0.0
                    else:
                        try:
                            stop_price = float(stop_order.get('price') or 0)
                        except Exception:
                            stop_price = 0.0

                if stop_price == 0.0:
                    log_message(f"⚠️ Монітор: для {symbol} stop_price невідомий/0 — пропускаємо перевірку віддалення")
                    continue

                # Prefer the original level from pending_meta for distance checks.
                # For breakout STOP orders, stop_price includes an extra buffer and can make every setup look "too far".
                lvl_for_check = stop_price
                try:
                    pm_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                    if isinstance(pm_local, dict):
                        lvl_candidate = pm_local.get('level') or pm_local.get('level_price') or pm_local.get('monitor_level')
                        if lvl_candidate not in (None, '', 0, 0.0):
                            lvl_for_check = float(lvl_candidate)
                except Exception:
                    lvl_for_check = stop_price

                diff = percent_diff(last_price, lvl_for_check)
                # compute dynamic max_level_distance for this symbol (prefer meta.natr if available)
                try:
                    # prefer stored value in pending_meta if available (avoid recompute mismatch)
                    pm_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                    symbol_natr_local = None
                    if pm_local and isinstance(pm_local, dict):
                        try:
                            symbol_natr_local = pm_local.get('natr')
                        except Exception:
                            symbol_natr_local = None
                        # if max_level_distance already saved with pending_meta, use it
                        try:
                            if 'max_level_distance' in pm_local:
                                max_level_distance = pm_local.get('max_level_distance')
                                # we have it, skip recompute
                                closes_for_distance = None
                            else:
                                closes_for_distance = None
                        except Exception:
                            closes_for_distance = None
                    else:
                        symbol_natr_local = None
                        closes_for_distance = None
                    # If we don't have stored max distance, attempt to compute from closes
                    if 'max_level_distance' not in (pm_local or {}):
                        # try to use closes cached in pm (if any)
                        try:
                            if pm_local and isinstance(pm_local, dict):
                                if pm_local.get('closes'):
                                    closes_for_distance = pm_local.get('closes')
                                elif pm_local.get('closes_c'):
                                    closes_for_distance = pm_local.get('closes_c')
                        except Exception:
                            closes_for_distance = None
                        # if still none, fetch recent 5m klines and use closed candles only
                        if closes_for_distance is None:
                            try:
                                kl = signed_request(client.futures_klines, symbol=symbol, interval='5m',
                                                    limit=DYN_VOL_WINDOW + 2)
                                if kl and len(kl) >= 2:
                                    closed_cnt = max(1, len(kl) - 1)
                                    closes_for_distance = [float(k[4]) for k in kl][:closed_cnt]
                                else:
                                    closes_for_distance = None
                            except Exception:
                                closes_for_distance = None
                        # If we still don't have closes but have a natr estimate, allow get_dynamic_max_level_distance to use natr
                        if (closes_for_distance is None):
                            try:
                                if symbol_natr_local is None:
                                    symbol_natr_local = calculate_natr(symbol)
                            except Exception:
                                symbol_natr_local = None
                        max_level_distance = get_dynamic_max_level_distance(symbol, closes_for_distance,
                                                                            natr=symbol_natr_local)

                except Exception:
                    max_level_distance = DYN_MAX_LEVEL_DISTANCE

                now_log = time.time()
                should_log = True
                try:
                    last_ts = last_monitor_log_ts.get(symbol, 0.0)
                    last_val = last_monitor_log_value.get(symbol, None)
                    if last_ts and (now_log - last_ts) < ORDER_MONITOR_LOG_INTERVAL:
                        if last_val is not None and abs((diff * 100) - last_val) < ORDER_MONITOR_LOG_DELTA_PCT:
                            should_log = False
                except Exception:
                    should_log = True
                if should_log:
                    try:
                        _lvl_note = f" (trigger={stop_price})" if float(lvl_for_check) != float(stop_price) else ""
                    except Exception:
                        _lvl_note = ""
                    log_message(
                        f"🔦 Монітор дистанції {symbol}: Остання ціна ={last_price}, Рівень ={lvl_for_check}{_lvl_note}, відстань до рівня ={diff * 100:.2f}%, допустима дистанція ={max_level_distance * 100:.2f}%")
                    try:
                        last_monitor_log_ts[symbol] = now_log
                        last_monitor_log_value[symbol] = diff * 100
                    except Exception:
                        pass
                broken_by_open = False
                try:
                    broken_by_open = is_level_broken_by_current_open(symbol, float(lvl_for_check), max_level_distance)
                except Exception:
                    broken_by_open = False

                if diff >= max_level_distance or broken_by_open:
                    log_message(
                        f"⚠️  Ціна {symbol} відійшла від рівня на {diff * 100:.2f}% , знімаємо ордер та перезапускаємо цикл 🔁 ")
                    try:
                        ban_symbol(symbol)  # тимчасово банимо, щоб не перевиставляти відразу
                        rejected_symbols.add(symbol)
                    except Exception:
                        pass
                    try:
                        canceled = False
                        # Cancel only specific order
                        try:
                            signed_request(client.futures_cancel_order, symbol=symbol, orderId=stop_order_id)
                            time.sleep(0.25)
                            log_message(f"❌ Ордер {symbol} ({stop_order_id}) скасовано через віддалення ціни")
                            canceled = True
                        except Exception as e:
                            code = getattr(e, 'code', None)
                            msg = str(e).lower()
                            if code == -2011 or "unknown order" in msg:
                                log_message(
                                    f"ℹ️ Binance повернув -2011/Unknown order для {symbol} ({stop_order_id}) — вважаю скасованим.")
                                canceled = True
                            else:
                                log_message(f"❌ Не вдалося скасувати ордер {symbol} ({stop_order_id}): {e}")
                                log_message(traceback.format_exc())
                        # Verify order status after cancel attempt (skip if already treated as canceled)
                        o_status = None
                        if not canceled:
                            try:
                                o = signed_request(client.futures_get_order, symbol=symbol, orderId=stop_order_id)
                                o_status = o.get('status') or None
                            except Exception:
                                o_status = None
                        else:
                            o_status = 'CANCELED'

                        if o_status in ('CANCELED', 'EXPIRED'):
                            # Also cancel any pre-placed ENTRY1 order to avoid a late unexpected entry.
                            try:
                                e1_oid = None
                                with orders_lock:
                                    pm_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                                    if isinstance(pm_local, dict):
                                        e1_oid = pm_local.get("entry1_order_id")
                                if e1_oid not in (None, "", 0, False):
                                    try:
                                        signed_request(client.futures_cancel_order, symbol=symbol, orderId=e1_oid)
                                    except Exception:
                                        try:
                                            cancel_conditional_order(symbol, e1_oid)
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                            with orders_lock:
                                try:
                                    if symbol in active_orders:
                                        del active_orders[symbol]
                                except KeyError:
                                    pass
                                pending_meta.pop(symbol, None)
                            # GUI cleanup
                            remove_order_rows(lambda row, s=symbol: row.get('symbol') == s)
                            try:
                                if relocator is not None:
                                    relocator.unregister_pending_order(symbol)
                            except Exception:
                                pass
                            log_message(f"ℹ️ pending_meta для {symbol} видалено після підтвердженого/припущеного скасування")
                        else:
                            log_message(
                                f"ℹ️ Після спроби скасування статус ордеру {symbol} = {o_status} — pending_meta збережено для обробки WS")

                            # === Нова частина: REST-перевірка відкритої позиції і синхронізація open_positions ===
                            try:
                                # Перевіряємо лише якщо у нас є pending_meta (бо інакше це неактуально)
                                pm_check = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                                if pm_check is not None:
                                    try:
                                        exch_amt, exch_entry = get_exchange_position(symbol)
                                    except Exception as _e:
                                        exch_amt, exch_entry = 0.0, None
                                    log_message(f"⚠️Помилка при отриманні позиції з біржі для {symbol}: {_e}")

                                    if abs(exch_amt) > 1e-8:
                                        side_actual = 'BUY' if exch_amt > 0 else 'SELL'
                                        qty_actual = abs(exch_amt)
                                        log_message(
                                             f"✅ Позиція на біржі для {symbol} підтверджена: side={side_actual} qty={qty_actual} entry={exch_entry}")
                                        try:
                                            with positions_lock:
                                                cur = open_positions.get(symbol, {}) or {}
                                                cur.update({
                                                    'qty': qty_actual,
                                                    'side': side_actual,
                                                    'entry_price': exch_entry,
                                                })
                                                open_positions[symbol] = cur
                                            try:
                                                subscribe_price(symbol)
                                            except Exception:
                                                pass
                                        except Exception as __e:
                                            log_message(f"⚠️ Помилка синхронізації open_positions для {symbol}: {__e}")
                                    else:
                                        log_message(
                                            f"ℹ️ Позиція для {symbol} на біржі відсутня після cancel-attempt (o_status={o_status}).")
                            except Exception as _ex:
                                log_message(
                                    f"❌ Невідома помилка перевірки позиції після cancel-attempt для {symbol}: {_ex}")
                            # === Кінець нової частини ===
                    except Exception as e:
                        log_message(f"❌ Помилка при моніторингу/скасуванні ордеру {symbol}: {e}")
                        log_message(traceback.format_exc())
                        continue
            except Exception as e:
                log_message(f"❌ Помилка моніторингу ордера {symbol}: {e}")
                log_message(traceback.format_exc())
                continue
        try:
            sleep_for = MONITOR_INTERVAL
            if orders_snapshot:
                sleep_for = max(1.0, min(MONITOR_INTERVAL, 3.0))
        except Exception:
            sleep_for = MONITOR_INTERVAL
        time.sleep(sleep_for)


# ------------------- Polling fallback (REST) для відкритих позицій -------------------

def price_polling_loop():
    while not shutdown_event.is_set():
        try:
            symbols = []
            with positions_lock:
                symbols = list(open_positions.keys())
            for s in symbols:
                try:
                    t = signed_request(client.futures_symbol_ticker, symbol=s)
                    price = float(t['price'])
                    symbol_prices[s] = {'price': price, 'ts': time.time()}
                    trailing_stop_check(s, price)
                except Exception as e:
                    log_message(f"❌ Poll fallback error for {s}: {e}")
                    log_message(traceback.format_exc())
            time.sleep(PRICE_POLL_INTERVAL)
        except Exception as e:
            log_message(f"❌ Poll loop error: {e}")
            log_message(traceback.format_exc())
            time.sleep(1)


def orderbook_prints_rest_loop():
    while not shutdown_event.is_set():
        try:
            if not bool(globals().get("USE_ORDERBOOK_REST_FALLBACK", False)):
                time.sleep(0.5)
                continue
            symbol = (orderbook_socket_symbol or "").upper()
            if symbol:
                now = time.time()
                try:
                    with orderbook_lock:
                        state = orderbook_state.get(symbol)
                        state_ts = state.get('ts') if isinstance(state, dict) else 0.0
                except Exception:
                    state_ts = 0.0
                try:
                    last_poll = orderbook_rest_poll_ts.get(symbol, 0.0)
                except Exception:
                    last_poll = 0.0
                if (not state_ts or (now - state_ts) >= ORDERBOOK_REST_FALLBACK_SEC) and (now - last_poll) >= ORDERBOOK_REST_FALLBACK_SEC:
                    orderbook_rest_poll_ts[symbol] = now
                    allow_rest = True
                    try:
                        with orderbook_rest_seed_lock:
                            if symbol in orderbook_rest_seeded:
                                allow_rest = False
                    except Exception:
                        allow_rest = True
                    ob = _fetch_orderbook_rest(symbol) if allow_rest else None
                    if ob:
                        bids, asks = ob
                        now_ts = time.time()
                        with orderbook_lock:
                            orderbook_state[symbol] = {'symbol': symbol, 'bids': bids, 'asks': asks, 'ts': now_ts}
                        try:
                            with orderbook_rest_seed_lock:
                                orderbook_rest_seeded.add(symbol)
                        except Exception:
                            pass
                        try:
                            last_emit = orderbook_emit_ts.get(symbol, 0.0)
                            if (now_ts - last_emit) >= ORDERBOOK_EMIT_INTERVAL:
                                orderbook_emit_ts[symbol] = now_ts
                                _emit_orderbook(symbol)
                        except Exception:
                            pass
            symbol = (trade_socket_symbol or "").upper()
            if symbol:
                now = time.time()
                try:
                    last_ts = trade_prints_state_ts.get(symbol, 0.0)
                except Exception:
                    last_ts = 0.0
                try:
                    last_poll = trade_prints_rest_poll_ts.get(symbol, 0.0)
                except Exception:
                    last_poll = 0.0
                if (not last_ts or (now - last_ts) >= PRINTS_REST_FALLBACK_SEC) and (now - last_poll) >= PRINTS_REST_FALLBACK_SEC:
                    trade_prints_rest_poll_ts[symbol] = now
                    prints = _fetch_prints_rest(symbol)
                    if prints:
                        now_ts = time.time()
                        with trade_prints_lock:
                            trade_prints[symbol] = deque(prints, maxlen=PRINTS_LIMIT)
                            trade_prints_state_ts[symbol] = now_ts
                        try:
                            last_emit = trade_prints_emit_ts.get(symbol, 0.0)
                            if (now_ts - last_emit) >= PRINTS_EMIT_INTERVAL:
                                trade_prints_emit_ts[symbol] = now_ts
                                _emit_prints(symbol)
                        except Exception:
                            pass
            time.sleep(0.05)
        except Exception as e:
            try:
                log_message(f"[REST] orderbook/prints loop error: {e}")
                log_message(traceback.format_exc())
            except Exception:
                pass
            time.sleep(0.05)


def rest_watchdog_loop(interval_sec=3):
    """Періодично звіряє позиції з REST, щоб не пропускати закриття."""
    global bot_running
    while True:
        try:
            if not bot_running:
                time.sleep(interval_sec)
                continue
            symbols = []
            with positions_lock:
                symbols = list(open_positions.keys())
            for sym in symbols:
                try:
                    rest_sync_position(sym, reason="REST_WATCHDOG")
                except Exception:
                    try:
                        log_message(f"⚠️ REST watchdog помилка для {sym}")
                    except Exception:
                        pass
                    continue
            time.sleep(interval_sec)
        except Exception as e:
            try:
                log_message(f"⚠️ REST watchdog loop error: {e}")
                log_message(traceback.format_exc())
            except Exception:
                pass
            time.sleep(interval_sec)


def rest_position_refresher(interval_sec=5):
    """Підтягує позиції з REST періодично, щоб підхопити відкриття, навіть якщо WS пропустив."""
    global bot_running
    while True:
        try:
            if not bot_running:
                time.sleep(interval_sec)
                continue
            try:
                sync_open_positions_from_exchange(trigger_trailing=True)
            except Exception as e:
                try:
                    log_message(f"⚠️ REST refresher error: {e}")
                except Exception:
                    pass
            time.sleep(interval_sec)
        except Exception as e:
            try:
                log_message(f"⚠️ REST refresher loop error: {e}")
                log_message(traceback.format_exc())
            except Exception:
                pass
            time.sleep(interval_sec)


def tp_rest_watchdog_loop(interval_sec=3):
    """
    Poll TP orders via REST and trigger next TP when FILLED, in case WS ORDER_TRADE_UPDATE was missed.
    """
    global bot_running
    while True:
        try:
            if not bot_running:
                time.sleep(interval_sec)
                continue
            try:
                with tp_lock:
                    snapshot = {sym: set(ids) for sym, ids in tp_orders.items()}
            except Exception:
                snapshot = {}
            for sym, ids in snapshot.items():
                for oid in list(ids):
                    try:
                        info = signed_request(client.futures_get_order, symbol=sym, orderId=oid)
                    except Exception:
                        continue
                    try:
                        status = (info.get('status') or "").upper()
                    except Exception:
                        status = ""
                    if status == "FILLED":
                        try:
                            _handle_tp_filled_rest(sym, oid)
                        except Exception:
                            pass
            time.sleep(interval_sec)
        except Exception as e:
            try:
                log_message(f"⚠️ tp_rest_watchdog_loop error: {e}")
                log_message(traceback.format_exc())
            except Exception:
                pass
            time.sleep(interval_sec)


def trailing_keepalive_loop():
    """
    Резервний цикл, який гарантує регулярні перевірки trailing_stop_check навіть
    якщо WS або REST-оновлення тимчасово не приходять.
    """
    while not shutdown_event.is_set():
        try:
            if not bot_running:
                time.sleep(TRAIL_KEEPALIVE_INTERVAL)
                continue
            now = time.time()
            with positions_lock:
                symbols = list(open_positions.keys())
            min_gap = TRAIL_CHECK_MIN_INTERVAL if (TRAIL_CHECK_MIN_INTERVAL and TRAIL_CHECK_MIN_INTERVAL > 0) else 0.0
            required_gap = max(min_gap, TRAIL_KEEPALIVE_INTERVAL)
            for sym in symbols:
                last_ts = last_trail_check_ts.get(sym, 0.0)
                if last_ts and (now - last_ts) < required_gap:
                    continue
                price = get_current_price(sym)
                if price is None:
                    try:
                        ticker = signed_request(client.futures_symbol_ticker, symbol=sym)
                        price = float(ticker['price'])
                        symbol_prices[sym] = {'price': price, 'ts': time.time()}
                    except Exception as price_err:
                        log_message(f"⚠️ trailing_keepalive: не вдалося отримати ціну для {sym}: {price_err}")
                        log_message(traceback.format_exc())
                        continue
                trailing_stop_check(sym, price)
            time.sleep(TRAIL_KEEPALIVE_INTERVAL)
        except Exception as e:
            log_message(f"⚠️ trailing_keepalive_loop error: {e}")
            log_message(traceback.format_exc())
            time.sleep(TRAIL_KEEPALIVE_INTERVAL)


def ws_watchdog_loop():
    """
    Слідкує за активністю WS: якщо довго немає повідомлень, перезапускає TWM/юзерський сокет.
    Це допомагає ловити ситуації типу "Read loop has been closed".
    """
    global twm, user_socket_key, LAST_WS_MESSAGE_TS, LAST_POSITION_SYNC_TS, _ws_restart_in_progress
    while True:
        try:
            if not bot_running:
                return
            now = time.time()
            last = LAST_WS_MESSAGE_TS or 0.0
            if last and (now - last) > WS_STALE_TIMEOUT:
                _set_connection_state(False)
                try:
                    if twm:
                        try:
                            if user_socket_key:
                                try:
                                    twm.stop_socket(user_socket_key)
                                except Exception:
                                    try:
                                        twm.stop_futures_user_socket(user_socket_key)
                                    except Exception:
                                        pass
                                user_socket_key = None
                        except Exception as e:
                            log_message(f"⚠️ WS watchdog: error stopping user socket: {e}")
                        try:
                            twm.stop()
                        except Exception as e:
                            log_message(f"⚠️ WS watchdog: error stopping twm: {e}")
                        twm = None
                except Exception as e:
                    log_message(f"⚠️ WS watchdog: error while stopping WS: {e}")
                try:
                    ensure_twm_started()
                    if twm and not user_socket_key:
                        try:
                            if not globals().get('USE_MANUAL_USER_STREAM', False):
                                user_socket_key = twm.start_futures_user_socket(callback=_handle_user_message)
                        except Exception as e:
                            log_message(f"⚠️ WS watchdog: error restarting user socket: {e}")
                except Exception as e:
                    log_message(f"⚠️ WS watchdog: error restarting WS manager: {e}")
                    try:
                        # Periodically resync positions from REST if WS is flaky so trailing still works
                        if (LAST_POSITION_SYNC_TS or 0.0) <= 0.0 or (time.time() - (LAST_POSITION_SYNC_TS or 0.0)) > 30.0:
                            try:
                                sync_open_positions_from_exchange(trigger_trailing=True)
                            except Exception as e2:
                                log_message(f"⚠️ WS watchdog: position resync failed after WS error: {e2}")
                    except Exception:
                        pass
                time.sleep(5.0)
        except Exception:
            log_message("⚠️ WS watchdog error:\n" + traceback.format_exc())
            time.sleep(5.0)


# ------------------- Старт бота -------------------

# Improved, guarded WS watchdog with safe restart and resubscribe
def ws_watchdog_loop2():
    """
    Моніторить активність WS: якщо довго немає повідомлень, перезапускає TWM і юзерський сокет,
    та повторно підписується на всі price sockets. Захищено від конкурентних перезапусків.
    """
    global twm, user_socket_key, LAST_WS_MESSAGE_TS, LAST_POSITION_SYNC_TS, _ws_restart_in_progress
    while True:
        try:
            if not USE_WS:
                time.sleep(5.0)
                continue
            if not bot_running:
                return
            now = time.time()
            last = LAST_WS_MESSAGE_TS or 0.0
            # Skip restart when no WS activity is expected (idle scanning mode)
            if not _ws_activity_expected():
                LAST_WS_MESSAGE_TS = now
                time.sleep(5.0)
                continue
            # If timeout is <= 0, treat as "disabled"
            if (WS_STALE_TIMEOUT and WS_STALE_TIMEOUT > 0) and last and (now - last) > WS_STALE_TIMEOUT:
                _set_connection_state(False)
                if _ws_restart_in_progress:
                    time.sleep(2.0)
                    continue
                try:
                    with twm_lock:
                        _ws_restart_in_progress = True
                        # Stop existing sockets/manager
                        try:
                            if twm:
                                try:
                                    if user_socket_key:
                                        try:
                                            twm.stop_socket(user_socket_key)
                                        except Exception:
                                            try:
                                                twm.stop_futures_user_socket(user_socket_key)
                                            except Exception:
                                                pass
                                        user_socket_key = None
                                except Exception as e:
                                    log_message(f"⚠️ WS watchdog2: error stopping user socket: {e}")
                                try:
                                    twm.stop()
                                except Exception as e:
                                    log_message(f"⚠️ WS watchdog2: error stopping twm: {e}")
                                twm = None
                        except Exception as e:
                            log_message(f"⚠️ WS watchdog2: error while stopping WS: {e}")

                        # Start fresh TWM and user socket with retries
                        ensure_twm_started()
                        if twm and _user_stream_required():
                            _start_user_socket_safe(max_attempts=5, delay_s=1.0)
                            _resubscribe_price_sockets_after_restart()
                            _resubscribe_depth_trade_sockets_after_restart()
                            LAST_WS_MESSAGE_TS = time.time()
                except Exception as e:
                    log_message(f"⚠️ WS watchdog2: error restarting WS manager: {e}")
                    try:
                        if (LAST_POSITION_SYNC_TS or 0.0) <= 0.0 or (time.time() - (LAST_POSITION_SYNC_TS or 0.0)) > 30.0:
                            try:
                                sync_open_positions_from_exchange(trigger_trailing=True)
                            except Exception as e2:
                                log_message(f"⚠️ WS watchdog2: position resync failed after WS error: {e2}")
                    except Exception:
                        pass
                finally:
                    _ws_restart_in_progress = False
                time.sleep(5.0)
        except Exception:
            log_message("⚠️ WS watchdog2 error:\n" + traceback.format_exc())
            time.sleep(5.0)


def user_stream_supervisor_loop():
    """Keep futures user stream up. If missing or stale, (re)start the user socket; does not restart TWM."""
    global bot_running, twm, user_socket_key, LAST_USER_WS_MESSAGE_TS
    while True:
        try:
            if not USE_WS:
                time.sleep(30.0)
                continue
            if not bot_running:
                return
            ensure_twm_started()
            if twm:
                now = time.time()
                stale = False
                try:
                    if USER_STREAM_REFRESH_SECS and USER_STREAM_REFRESH_SECS > 0:
                        last = LAST_USER_WS_MESSAGE_TS or 0.0
                        if last <= 0.0:
                            # never seen user event — treat as stale
                            stale = True
                        else:
                            stale = (now - last) > float(USER_STREAM_REFRESH_SECS)
                except Exception:
                    stale = False

                if user_socket_key is None or stale:
                    try:
                        _set_connection_state(False)
                    except Exception:
                        pass
                    _restart_user_socket_quietly(max_attempts=8)
            time.sleep(30.0)
        except Exception as e:
            try:
                _set_connection_state(False)
            except Exception:
                pass
            time.sleep(30.0)


# Lightweight connection monitor: logs only on transition and triggers resync on reconnect.
def connection_watchdog_loop():
    while True:
        try:
            if shutdown_event.is_set():
                return
            if not bot_running or not (USE_WS or USE_MANUAL_USER_STREAM):
                time.sleep(1.0)
                continue
            if not _ws_activity_expected():
                time.sleep(1.0)
                continue
            last = LAST_WS_MESSAGE_TS or 0.0
            if last <= 0.0:
                time.sleep(1.0)
                continue
            timeout = WS_STALE_TIMEOUT if (WS_STALE_TIMEOUT and WS_STALE_TIMEOUT > 0) else None
            if not timeout:
                time.sleep(1.0)
                continue
            now = time.time()
            if (now - last) > timeout:
                _set_connection_state(False)
            else:
                _set_connection_state(True)
        except Exception:
            pass
        time.sleep(1.0)


# Poll order status via REST to backfill when WS is down
_order_status_cache = {}

def orders_poll_supervisor_loop():
    global bot_running, _order_status_cache
    while True:
        try:
            if not bot_running:
                return
            # Gather tracked order ids
            symbols = set()
            try:
                with orders_lock:
                    symbols.update(list(active_orders.keys()))
                    symbols.update(list(tp_orders.keys()))
            except Exception:
                pass
            for s in list(symbols):
                try:
                    # Active pending order id (if any)
                    oid = None
                    try:
                        with orders_lock:
                            oid = active_orders.get(s)
                    except Exception:
                        oid = None
                    ids = []
                    if oid:
                        ids.append(oid)
                    try:
                        ids.extend(list(tp_orders.get(s, [])))
                    except Exception:
                        pass
                    for order_id in list(set(ids)):
                        try:
                            o = signed_request(client.futures_get_order, symbol=s, orderId=order_id)
                            status = o.get('status')
                            key = f"{s}:{order_id}"
                            if _order_status_cache.get(key) != status:
                                _order_status_cache[key] = status
                                syn = {
                                    'e': 'ORDER_TRADE_UPDATE',
                                    'o': {
                                        's': s,
                                        'i': int(order_id) if order_id is not None else None,
                                        'X': status,
                                        'S': o.get('side'),
                                        'o': o.get('type') or o.get('origType'),
                                        'ap': o.get('avgPrice') or o.get('price') or '0',
                                        'origQty': o.get('origQty') or o.get('origQuantity') or o.get('quantity'),
                                    }
                                }
                                try:
                                    _handle_user_message(syn)
                                except Exception:
                                    pass
                        except Exception:
                            pass
                except Exception:
                    pass
            time.sleep(3.0)
        except Exception:
            try:
                log_message("⚠️ orders_poll_supervisor_loop error\n" + traceback.format_exc())
            except Exception:
                pass
            time.sleep(5.0)


# --- Live REST sync for open orders cache (prevents stale UI markers if WS misses events) ---
_live_open_orders_sync_started = False

def _live_open_orders_sync_loop():
    while not shutdown_event.is_set():
        try:
            if not bool(globals().get("OPEN_ORDERS_REST_LIVE_SYNC", True)):
                time.sleep(2.0)
                continue
        except Exception:
            pass
        try:
            interval = float(globals().get("LIVE_OPEN_ORDERS_REFRESH_SEC", 7.0) or 7.0)
        except Exception:
            interval = 7.0
        try:
            time.sleep(max(1.5, interval))
        except Exception:
            time.sleep(7.0)
        if shutdown_event.is_set():
            break
        try:
            try:
                poll_ts = time.time()
            except Exception:
                poll_ts = 0.0
            # Only useful when UI is running
            syms = set()
            try:
                if 'window' in globals() and globals().get('window') is not None:
                    cur = (globals()['window'].current_symbol or '').upper()
                    if cur:
                        syms.add(cur)
            except Exception:
                pass
            try:
                with orders_lock:
                    syms.update([s.upper() for s in (active_orders.keys() or [])])
                    syms.update([s.upper() for s in (tp_orders.keys() or [])])
            except Exception:
                pass
            # limit symbols to avoid REST spam
            try:
                max_syms = int(globals().get("LIVE_OPEN_ORDERS_SYNC_MAX_SYMS", 4) or 4)
            except Exception:
                max_syms = 4
            if not syms:
                continue
            syms = list(syms)[:max(1, max_syms)]
            # refresh each symbol
            for sym in syms:
                rest_ok = True
                try:
                    open_orders = signed_request(client.futures_get_open_orders, symbol=sym) or []
                except Exception:
                    open_orders = []
                    rest_ok = False
                book_list = []
                try:
                    for _o in open_orders or []:
                        norm = _normalize_open_order_for_book(_o)
                        if not norm:
                            continue
                        try:
                            if _should_suppress_order_after_cancel_all(sym, norm.get("ts")):
                                continue
                        except Exception:
                            pass
                        try:
                            if _should_suppress_order_id(
                                norm.get("order_id") or norm.get("orderId") or norm.get("id"),
                                norm.get("algo_id") or norm.get("algoId"),
                            ):
                                continue
                        except Exception:
                            pass
                        book_list.append(norm)
                except Exception:
                    pass
                # include conditional/algo orders if enabled
                algo_ok = True
                algo = []
                try:
                    if bool(globals().get("SNAPSHOT_INCLUDE_ALGO_ORDERS", True)):
                        algo = get_open_conditional_orders() or []
                        algo = [o for o in (algo or []) if ((o.get('symbol') or o.get('s') or '').upper() == sym)]
                        for _o in algo:
                            norm = _normalize_open_order_for_book(_o)
                            if not norm:
                                continue
                            try:
                                if _should_suppress_order_after_cancel_all(sym, norm.get("ts")):
                                    continue
                            except Exception:
                                pass
                            try:
                                if _should_suppress_order_id(
                                    norm.get("order_id") or norm.get("orderId") or norm.get("id"),
                                    norm.get("algo_id") or norm.get("algoId"),
                                ):
                                    continue
                            except Exception:
                                pass
                            book_list.append(norm)
                except Exception:
                    algo_ok = False
                    algo = []
                if (not rest_ok) or (not algo_ok):
                    try:
                        with open_orders_cache_lock:
                            prev_items = list(open_orders_cache.get(sym) or [])
                    except Exception:
                        prev_items = []
                    if prev_items:
                        if not rest_ok:
                            for it in prev_items:
                                try:
                                    if it.get("algo_id") or it.get("algoId"):
                                        continue
                                except Exception:
                                    pass
                                book_list.append(it)
                        if not algo_ok:
                            for it in prev_items:
                                try:
                                    if not (it.get("algo_id") or it.get("algoId")):
                                        continue
                                except Exception:
                                    pass
                                book_list.append(it)
                        merged = []
                        seen = set()
                        for it in book_list:
                            try:
                                oid = str(it.get("order_id") or it.get("orderId") or it.get("id") or "")
                            except Exception:
                                oid = ""
                            try:
                                aid = str(it.get("algo_id") or it.get("algoId") or "")
                            except Exception:
                                aid = ""
                            if aid:
                                key = f"algo:{aid}"
                            elif oid:
                                key = f"oid:{oid}"
                            else:
                                try:
                                    key = f"p:{float(it.get('price') or 0.0)}:{it.get('side')}:{it.get('type')}"
                                except Exception:
                                    key = None
                            if key and key in seen:
                                continue
                            if key:
                                seen.add(key)
                            merged.append(it)
                        book_list = merged
                try:
                    book_list = _merge_recent_cached_orders(sym, book_list)
                except Exception:
                    pass
                try:
                    book_list = _merge_local_orders_for_symbol(sym, book_list)
                except Exception:
                    pass
                try:
                    with open_orders_cache_lock:
                        existing = list(open_orders_cache.get(sym) or [])
                        if bool(globals().get("OPEN_ORDERS_REST_PRUNE", False)):
                            merged = _merge_cached_orders_after_ts(existing, book_list, poll_ts)
                        else:
                            merged = _merge_cached_orders_keep(existing, book_list)
                        try:
                            merged = _filter_suppressed_order_list(merged)
                        except Exception:
                            pass
                        open_orders_cache[sym] = merged
                        globals()["open_orders_cache_ts"] = time.time()
                        book_list = merged
                except Exception:
                    pass
            # trigger repaint for current symbol
            try:
                if gui_bus is not None and 'window' in globals() and globals().get('window') is not None:
                    cur_sym = (globals()['window'].current_symbol or '').upper()
                    if cur_sym:
                        with orderbook_lock:
                            ob_snapshot = orderbook_state.get(cur_sym)
                        if ob_snapshot is not None:
                            gui_bus.orderbook_signal.emit(ob_snapshot)
            except Exception:
                pass
        except Exception:
            pass

def start_live_open_orders_sync():
    global _live_open_orders_sync_started
    try:
        if not bool(globals().get("OPEN_ORDERS_REST_LIVE_SYNC", True)):
            return
    except Exception:
        return
    if _live_open_orders_sync_started:
        return
    try:
        threading.Thread(target=_live_open_orders_sync_loop, daemon=True).start()
        _live_open_orders_sync_started = True
    except Exception:
        pass

def start_bot():
    global bot_running, twm, user_socket_key, _trailing_keepalive_started
    try:
        shutdown_event.clear()
    except Exception:
        pass
    if not bot_running:
        bot_running = True
        try:
            load_settings_history_from_file()
            start_daily_pnl_reset()
            # Гарантуємо наявність asyncio event loop у цьому потоці для ThreadedWebsocketManager
            try:
                asyncio.get_event_loop()
            except RuntimeError:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
            if USE_WS:
                ensure_twm_started()
                # Старий підхід: одразу запускаємо user socket після старту TWM (без повторних ретраїв)
                if twm:
                    try:
                        global user_socket_key
                        if not globals().get('USE_MANUAL_USER_STREAM', False):
                                user_socket_key = twm.start_futures_user_socket(callback=_handle_user_message)
                    except Exception as e:
                        log_message(f"⚠️ Не вдалося запустити user socket: {e}")
                        log_message(traceback.format_exc())
                log_message("💫 WebSocket менеджер запущено.")
            if USE_MANUAL_USER_STREAM:
                _manual_user_stream_start()
        except Exception as e:
            log_message(f"❌ Помилка запуску WebSocket менеджера: {e}")
            log_message(traceback.format_exc())
            twm = None
        threading.Thread(target=run_bot, daemon=True).start()
        threading.Thread(target=monitor_order_distance, daemon=True).start()
        global _connection_watchdog_started
        if not _connection_watchdog_started:
            threading.Thread(target=connection_watchdog_loop, daemon=True).start()
            _connection_watchdog_started = True
        if PRICE_POLL_INTERVAL and PRICE_POLL_INTERVAL > 0:
            threading.Thread(target=price_polling_loop, daemon=True).start()
        if USE_WS and ENABLE_WS_WATCHDOG:
            threading.Thread(target=ws_watchdog_loop2, daemon=True).start()
        global _user_supervisor_started
        if USE_WS and ENABLE_USER_STREAM_SUPERVISOR and not _user_supervisor_started:
            try:
                threading.Thread(target=user_stream_supervisor_loop, daemon=True).start()
                _user_supervisor_started = True
            except Exception:
                pass
        global _orders_supervisor_started
        if ENABLE_ORDERS_POLL_SUPERVISOR and not _orders_supervisor_started:
            try:
                threading.Thread(target=orders_poll_supervisor_loop, daemon=True).start()
                _orders_supervisor_started = True
            except Exception:
                pass
        try:
            start_live_open_orders_sync()
        except Exception:
            pass
        if not _trailing_keepalive_started:
            threading.Thread(target=trailing_keepalive_loop, daemon=True).start()
            _trailing_keepalive_started = True
        global _rest_watchdog_started
        if not _rest_watchdog_started:
            try:
                threading.Thread(target=rest_watchdog_loop, daemon=True).start()
                threading.Thread(target=rest_position_refresher, daemon=True).start()
                threading.Thread(target=tp_rest_watchdog_loop, daemon=True).start()
                _rest_watchdog_started = True
            except Exception:
                pass
        try:
            sync_open_positions_from_exchange(trigger_trailing=True)
        except Exception as e:
            log_message(f"⚠️ Не вдалося синхронізувати позиції після старту: {e}")
        log_message("Бот запущено , ⏳ очікуємо ТОП монет ")


# ------------------- Основний цикл -------------------

def stop_bot(blocking=False, max_wait_s=8.0):
    '''
    Коректно зупинити бота:
    - встановити bot_running = False (щоб фон. цикли завершились),
    - відписати price sockets,
    - зупинити user socket / twm (ThreadedWebsocketManager) якщо є,
    - залишити повідомлення у лог,
    - скасувати всі відкриті ордери та закрити всі позиції (best-effort).
    '''

    global bot_running, twm, user_socket_key, subscribed_symbols, ws_symbol_sockets

    try:
        log_message("⏹️ Зупинка бота: ініціюю завершення...")

        # signal to loops to stop creating new work
        bot_running = False
        try:
            keep_streams = bool(globals().get("STOP_BOT_KEEP_STREAMS", True))
        except Exception:
            keep_streams = True

        # --- Масове скасування відкритих ордерів та закриття позицій ---
        try:
            open_orders = signed_request(client.futures_get_open_orders)
        except Exception as e:
            open_orders = []
            log_message(f"⚠️ Не вдалося отримати відкриті ордери перед зупинкою: {e}")
        # cancel all open orders per symbol (stronger than per-order cancel)
        try:
            sym_set = set()
            try:
                for o in open_orders or []:
                    s = (o.get('symbol') or '').upper()
                    if s:
                        sym_set.add(s)
            except Exception:
                sym_set = set()
            for sym in list(sym_set):
                try:
                    signed_request(client.futures_cancel_all_open_orders, symbol=sym)
                    log_message(f"❌ Скасовано ВСІ відкриті ордери для {sym} при зупинці бота")
                except Exception as ce_all:
                    log_message(f"⚠️ Не вдалося скасувати всі ордери для {sym}: {ce_all}")
            # Fallback: try individual cancel (in case of partial failures)
            for o in open_orders or []:
                sym = o.get('symbol')
                oid = o.get('orderId')
                if sym and oid:
                    try:
                        signed_request(client.futures_cancel_order, symbol=sym, orderId=oid)
                    except Exception:
                        pass
        except Exception:
            pass
        # close all positions
        try:
            positions = signed_request(client.futures_position_information)
        except Exception as e:
            positions = []
            log_message(f"⚠️ Не вдалося отримати позиції перед зупинкою: {e}")
        try:
            for p in positions or []:
                try:
                    amt = float(p.get('positionAmt') or 0)
                except Exception:
                    amt = 0.0
                if abs(amt) <= 0:
                    continue
                sym = p.get('symbol')
                entry = p.get('entryPrice') or 0
                side = 'BUY' if amt > 0 else 'SELL'
                qty = abs(amt)
                log_message(f"⚠️ Закриваю позицію {sym} qty={qty} side={side} перед зупинкою (entry={entry})")
                try:
                    if blocking:
                        _close_worker(sym, side, qty=qty)
                    else:
                        safe_close_position(sym, side, qty=qty)
                except Exception as ce:
                    log_message(f"⚠️ Не вдалося запустити закриття для {sym}: {ce}")
            try:
                if not blocking:
                    time.sleep(1.0)
            except Exception:
                pass
        except Exception:
            pass

        if blocking:
            try:
                end_ts = time.time() + float(max_wait_s or 0.0)
            except Exception:
                end_ts = time.time() + 8.0
            while time.time() < end_ts:
                open_orders = []
                positions_left = []
                try:
                    open_orders = signed_request(client.futures_get_open_orders) or []
                except Exception:
                    open_orders = []
                try:
                    positions_left = signed_request(client.futures_position_information) or []
                except Exception:
                    positions_left = []
                has_pos = False
                try:
                    for p in positions_left:
                        try:
                            if abs(float(p.get('positionAmt', 0) or 0)) > 0.0:
                                has_pos = True
                                break
                        except Exception:
                            continue
                except Exception:
                    has_pos = True
                if not open_orders and not has_pos:
                    break
                if open_orders:
                    for o in open_orders:
                        try:
                            sym = o.get('symbol')
                            oid = o.get('orderId')
                            if sym and oid:
                                signed_request(client.futures_cancel_order, symbol=sym, orderId=oid)
                        except Exception:
                            pass
                try:
                    time.sleep(0.6)
                except Exception:
                    break

        if not keep_streams:
            # unsubscribe all per-symbol price sockets (best-effort)
            try:
                syms = list(subscribed_symbols) if isinstance(subscribed_symbols, (set, list)) else []
                for s in syms:
                    try:
                        unsubscribe_price(s)
                    except Exception as e:
                        log_message(f"⚠️ unsubscribe_price({s}) error during stop: {e}")
            except Exception as e:
                log_message(f"⚠️ Помилка при масовому відписуванні: {e}")

            try:
                unsubscribe_orderbook()
                unsubscribe_trade_prints()
            except Exception:
                pass

            # stop manual user stream first (if enabled)
            try:
                _manual_user_stream_stop()
            except Exception:
                pass

            # stop user socket and twm
            try:
                if twm:
                    # stop user socket if known
                    try:
                        if user_socket_key:
                            try:
                                # try stopping by key
                                twm.stop_socket(user_socket_key)
                            except Exception:
                                try:
                                    twm.stop_futures_user_socket(user_socket_key)
                                except Exception:
                                    pass
                            user_socket_key = None
                    except Exception as e:
                        log_message(f"⚠️ Помилка при зупинці user socket: {e}")

                    # finally stop twm itself
                    try:
                        twm.stop()
                    except Exception as e:
                        log_message(f"⚠️ Помилка при twm.stop(): {e}")

                    twm = None
            except Exception as e:
                log_message(f"⚠️ Помилка при зупинці WS менеджера: {e}")

        # small delay to allow background threads to notice bot_running=False and finish gracefully
        try:
            import time as _t
            _t.sleep(0.15)
        except Exception:
            pass

        if not keep_streams:
            try:
                global TELEGRAM_POLLING_ENABLED
                TELEGRAM_POLLING_ENABLED = False
                shutdown_event.set()
            except Exception:
                pass

        log_message("✅ Бот зупинено (bot_running=False). Якщо залишилися відкриті позиції/ордера — перевірте вручну.")
    except Exception as e:
        log_message(f"❌ stop_bot() критична помилка: {e}")


def run_bot():
    global bot_running, trading_paused_until, open_orders_cache_ts, open_cond_orders_cache_ts
    while bot_running and not shutdown_event.is_set():
        try:
            try:
                positions = signed_request(client.futures_position_information)
            except Exception as e:
                code = getattr(e, 'code', None)
                msg = str(e).lower()
                if code == -1007 or "timeout waiting for response from backend server" in msg:
                    log_message("⚠️ Binance timeout (-1007) при futures_position_information — пропускаю цикл, спробуємо знову.")
                    time.sleep(1.5)
                else:
                    log_message(f"? Помилка отримання positions: {e}")
                    log_message(traceback.format_exc())
                positions = []

            detected_positions = []
            open_position_symbols = set()
            if positions:
                try:
                    for p in positions:
                        amt = float(p.get('positionAmt', 0) or 0)
                        if abs(amt) <= 0.0:
                            continue
                        sym = p.get('symbol')
                        if not sym:
                            continue
                        entry_val = p.get('entryPrice') or 0
                        side_val = 'BUY' if amt > 0 else 'SELL'
                        qty_val = abs(amt)
                        detected_positions.append((sym, side_val, qty_val, entry_val))
                        open_position_symbols.add(sym)
                except Exception:
                    detected_positions = []
                    open_position_symbols.clear()
            open_position_count = len(open_position_symbols)

            # ensure locally tracked positions match exchange reality (covers manual opens)
            try:
                for sym, side_val, qty_val, entry_val in detected_positions:
                    needs_init = False
                    with positions_lock:
                        cur = open_positions.get(sym)
                        if not cur:
                            needs_init = True
                        else:
                            cur_qty = abs(cur.get('qty', 0) or 0)
                            cur_side = cur.get('side')
                            cur_entry = cur.get('entry_price')
                            if abs(cur_qty - qty_val) > 1e-9 or str(cur_side).upper() != side_val or (
                                    cur_entry is None and entry_val) or (
                                    cur_entry and abs(float(cur_entry) - float(entry_val or 0)) > 1e-9):
                                needs_init = True
                    if needs_init:
                        try:
                            synthetic = {
                                'e': 'ORDER_TRADE_UPDATE',
                                'o': {
                                    's': sym,
                                    'X': 'FILLED',
                                    'x': 'TRADE',
                                    'S': side_val,
                                    'o': 'MARKET',
                                    'ap': entry_val,
                                    'origQty': qty_val,
                                    'ps': 'BOTH',
                                    'i': None,
                                }
                            }
                            _handle_user_message(synthetic)
                        except Exception as e:
                            log_message(f"⚠️ Synthetic FILLED manual sync error for {sym}: {e}")
                    else:
                        # Позиція вже трекається — переконаймося, що TP-план добудовано
                        try:
                            maybe_create_post_fill_tps(sym, side_val, qty_val, entry_val)
                        except Exception:
                            pass
                with positions_lock:
                    stale_syms = [sym for sym in open_positions.keys() if sym not in open_position_symbols]
                    for sym in stale_syms:
                        open_positions.pop(sym, None)
                        try:
                            _pos_event_mark_closed(sym)
                        except Exception:
                            pass
            except Exception as sync_exc:
                log_message(f"⚠️ Manual position sync error: {sync_exc}")

            # --- Run trailing stop check for all open positions (REST/WS agnostic) ---
            if open_position_symbols:
                try:
                    for sym in list(open_position_symbols):
                        try:
                            trailing_stop_check(sym)
                        except Exception as e:
                            log_message(f"⚠️ trailing_stop_check error in run_bot for {sym}: {e}")
                except Exception as e:
                    log_message(f"⚠️ bulk trailing_stop_check error in run_bot: {e}")

            has_open_positions = open_position_count > 0

            try:
                open_orders = signed_request(client.futures_get_open_orders)
                try:
                    book_map = {}
                    for _o in open_orders or []:
                        norm = _normalize_open_order_for_book(_o)
                        if not norm:
                            continue
                        book_map.setdefault(norm["symbol"], []).append(norm)
                    algo_orders = []
                    try:
                        now_ts = time.time()
                        if (now_ts - open_cond_orders_cache_ts) >= float(OPEN_COND_ORDERS_POLL_SEC or 5.0):
                            algo_orders = get_open_conditional_orders() or []
                            open_cond_orders_cache_ts = now_ts
                    except Exception:
                        algo_orders = []
                    for _o in algo_orders or []:
                        norm = _normalize_open_order_for_book(_o)
                        if not norm:
                            continue
                        book_map.setdefault(norm["symbol"], []).append(norm)
                    try:
                        cached_syms = []
                        try:
                            with open_orders_cache_lock:
                                cached_syms = list(open_orders_cache.keys())
                        except Exception:
                            cached_syms = []
                        for _sym_k in cached_syms:
                            book_map.setdefault(_sym_k, [])
                        for _sym_k, _list in list(book_map.items()):
                            book_map[_sym_k] = _merge_recent_cached_orders(_sym_k, _list)
                    except Exception:
                        pass
                    try:
                        book_map = _merge_local_orders_into_book_map(book_map)
                    except Exception:
                        pass
                    with open_orders_cache_lock:
                        for _sym_k, _list in (book_map or {}).items():
                            open_orders_cache[_sym_k] = list(_list or [])
                        open_orders_cache_ts = time.time()
                except Exception:
                    pass
                open_ids = {str(o.get('orderId')) for o in open_orders if o.get('orderId') is not None} if open_orders else set()
                # Sync TP-like reduceOnly orders from the exchange into local tp_orders to avoid duplicate placements (e.g., after reconnects)
                try:
                    tp_like_map = {}
                    for _o in open_orders or []:
                        sym_tp = _o.get('symbol')
                        if not sym_tp:
                            continue
                        otype = (_o.get('type') or '').upper()
                        is_ro = bool(_o.get('reduceOnly'))
                        is_close = bool(_o.get('closePosition'))
                        if otype in {'TAKE_PROFIT', 'TAKE_PROFIT_MARKET'} or (otype == 'LIMIT' and is_ro) or (
                                is_close and otype in {'LIMIT', 'STOP', 'STOP_MARKET', 'TAKE_PROFIT', 'TAKE_PROFIT_MARKET'}):
                            oid_tp = _o.get('orderId')
                            if oid_tp is not None:
                                tp_like_map.setdefault(sym_tp, set()).add(int(oid_tp))
                    if tp_like_map:
                        with tp_lock:
                            for _sym, _ids in tp_like_map.items():
                                existing = tp_orders.get(_sym)
                                if isinstance(existing, set):
                                    current_ids = existing
                                else:
                                    current_ids = set(existing) if existing else set()
                                current_ids.update(_ids)
                                tp_orders[_sym] = current_ids
                except Exception:
                    pass
                # track live stop-like orders from the exchange (even if not in local bookkeeping)
                open_stop_symbols = set()
                exch_pending_map = {}
                try:
                    stop_like_types = {'STOP', 'STOP_MARKET', 'TAKE_PROFIT', 'TAKE_PROFIT_MARKET'}
                    for _o in open_orders or []:
                        if _o.get('type') in stop_like_types:
                            sym_o = _o.get('symbol')
                            if sym_o:
                                open_stop_symbols.add(sym_o)
                                exch_pending_map[sym_o] = _o
                except Exception:
                    open_stop_symbols = set()
                    exch_pending_map = {}

                # Sync missing local bookkeeping with exchange stop/TP orders (handles restarts)
                try:
                    with orders_lock:
                        for _sym, _o in exch_pending_map.items():
                            oid = _o.get('orderId')
                            if _sym not in active_orders and oid is not None:
                                active_orders[_sym] = oid
                            if _sym not in pending_meta:
                                try:
                                    qty_raw = _o.get('origQty') or _o.get('origQuantity') or _o.get('quantity') or 0
                                    qty_val = float(qty_raw)
                                except Exception:
                                    qty_val = 0.0
                                try:
                                    stop_px = _o.get('stopPrice') or _o.get('price')
                                except Exception:
                                    stop_px = None
                                pending_meta[_sym] = {
                                    'stop_side': _o.get('side'),
                                    'stop_price': stop_px,
                                    'quantity': qty_val,
                                    'level': stop_px,
                                    'restored': True
                                }
                                log_message(f"ℹ️ Синхронізував pending з біржі: { _sym } orderId={oid}")
                except Exception:
                    pass
                with orders_lock:
                    for symbol, order_id in list(active_orders.items()):
                        time.sleep(0.10)
                        if str(order_id) not in open_ids:
                            try:
                                o = signed_request(client.futures_get_order, symbol=symbol, orderId=order_id)
                                o_status = (o.get('status') or o.get('algoStatus') or "").upper() if o else None
                            except BinanceAPIException as be_chk:
                                code_chk = getattr(be_chk, "code", None)
                                if code_chk == -2013:
                                    o_status = "CANCELED"
                                else:
                                    o_status = None
                                    try:
                                        log_message(f"⚠️ get_order error for {symbol}/{order_id}: {be_chk}")
                                    except Exception:
                                        pass
                            except Exception as e_chk:
                                o_status = None
                                try:
                                    log_message(f"⚠️ get_order unexpected error for {symbol}/{order_id}: {e_chk}")
                                except Exception:
                                    pass

                            # Видаляємо лише якщо точно знаємо, що ордер скасований/прострочений
                            if o_status in ('CANCELED', 'EXPIRED'):
                                log_message(
                                    f"ℹ️ Ордер {symbol} має статус {o_status} — видаляю active_orders/pending_meta")
                                # Also cancel any pre-placed ENTRY1 order to avoid a late unexpected entry.
                                try:
                                    pm_local = pending_meta.get(symbol) if isinstance(pending_meta, dict) else None
                                    e1_oid = pm_local.get("entry1_order_id") if isinstance(pm_local, dict) else None
                                    if e1_oid not in (None, "", 0, False):
                                        try:
                                            signed_request(client.futures_cancel_order, symbol=symbol, orderId=e1_oid)
                                        except Exception:
                                            try:
                                                cancel_conditional_order(symbol, e1_oid)
                                            except Exception:
                                                pass
                                except Exception:
                                    pass
                                try:
                                    del active_orders[symbol]
                                except KeyError:
                                    pass
                                pending_meta.pop(symbol, None)

                                # --- СТОП РЕЛОКАТОРА: видалити pending з PendingRelocator, якщо він там залишився ---
                                try:
                                    if 'relocator' in globals() and relocator is not None:
                                        try:
                                            relocator.unregister_pending_order(symbol)
                                            log_message(
                                                f"ℹ️ PendingRelocator: unregistered pending for {symbol} (run_bot cleanup)")
                                        except Exception as e:
                                            log_message(
                                                f"⚠️ Failed to unregister pending in relocator for {symbol}: {e}")
                                except Exception:
                                    pass

                                remove_order_rows(lambda row, s=symbol: row.get('symbol') == s)
                            elif o_status == 'FILLED':
                                #  FILLED  pending_meta   TP;   active_orders.
                                try:
                                    del active_orders[symbol]
                                except Exception:
                                    pass
                                try:
                                    if 'relocator' in globals() and relocator is not None:
                                        relocator.unregister_pending_order(symbol)
                                except Exception:
                                    pass
                                remove_order_rows(lambda row, s=symbol: row.get('symbol') == s)

                            else:
                                log_message(
                                    f"ℹ️ Ордер {symbol} не в open_ids але статус={o_status} — зберігаємо pending_meta (можливий FILLED/обробляється)")
            except Exception as e:
                log_message(f"❌ Помилка синхронізації ордерів: {e}")
                log_message(traceback.format_exc())

            with orders_lock:
                pending_symbols = {
                    sym for sym in active_orders.keys()
                    if sym in pending_meta
                }
            pending_count = len(pending_symbols)
            try:
                pending_count = max(pending_count, len(open_stop_symbols))
            except Exception:
                pass

            tracked_symbols = pending_symbols.union(open_position_symbols)

            pending_limit_hit = _limit_reached(pending_count, MAX_CONCURRENT_PENDING)
            position_limit_hit = _limit_reached(open_position_count, MAX_CONCURRENT_POSITIONS)
            if pending_limit_hit or position_limit_hit:
                reasons = []
                if pending_limit_hit:
                    reasons.append(f"pending {pending_count}/{MAX_CONCURRENT_PENDING}")
                if position_limit_hit:
                    reasons.append(f"positions {open_position_count}/{MAX_CONCURRENT_POSITIONS}")
                reason_str = ", ".join(reasons) if reasons else "невідомо"
                log_message(f"⚠️ Досягнуто лімітів одночасних угод ({reason_str}) — очікуємо звільнення слотів")
                time.sleep(max(5, CAPACITY_COOLDOWN_SEC))
                continue

            balance = get_balance()
            pnl_percent = ((balance - initial_balance) / initial_balance) * 100 if initial_balance else 0
            update_balance_display(balance, pnl_percent)
            # Apply daily profit/loss stop even без нового FILLED, використовуючи актуальний баланс.
            try:
                if initial_balance:
                    now_dt = _kyiv_now()
                    next_mid = (now_dt + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
                    if PROFIT_STOP_ENABLED and pnl_percent >= PROFIT_STOP_THRESHOLD_PERCENT:
                        trading_paused_until = max(trading_paused_until, next_mid.timestamp())
                        log_message(
                            f"🏁 PROFIT_STOP (loop) activated! PnL total = {pnl_percent:.2f}%. Trading paused until next Kyiv midnight.")
                    elif LOSS_STOP_ENABLED and pnl_percent <= -LOSS_STOP_THRESHOLD_PERCENT:
                        trading_paused_until = max(trading_paused_until, next_mid.timestamp())
                        log_message(
                            f"⛔ LOSS_STOP (loop) activated! PnL total = {pnl_percent:.2f}%. Trading paused until next Kyiv midnight.")
            except Exception:
                pass

            # Check trading pause (from protections) after updating trading_paused_until above.
            if time.time() < trading_paused_until:
                resume_at = datetime.fromtimestamp(trading_paused_until).strftime('%Y-%m-%d %H:%M:%S')
                log_message(f"Торгівля тимчасово призупинена до {resume_at}. ")
                time.sleep(CONSECUTIVE_LOSS_H * 60)
                continue

            rejected_symbols.clear()
            if not bot_running:
                break
            active_symbols = get_active_futures_symbols()
            tickers = signed_request(client.futures_ticker)
            usdt_tickers = [t for t in tickers if t["symbol"] in active_symbols]
            usdt_tickers.sort(key=lambda x: float(x["priceChangePercent"]), reverse=True)
            # Build top winners and top losers (24h movers), combine and filter by recent volume and NATR.
            top_growth = usdt_tickers[:TOP_N_GROWTH]
            # top losers by 24h percent (ascending)
            top_fall = sorted(usdt_tickers, key=lambda x: float(x.get("priceChangePercent", 0.0)))[:TOP_N_FALL]

            # preserve order but deduplicate symbols: winners first then losers
            seen = set()
            combined_symbols = []
            for t in (top_growth + top_fall):
                s = t.get("symbol")
                if s and s not in seen:
                    seen.add(s)
                    combined_symbols.append(s)

            # prepare candidate list with 5h recent volume, 24h volume and NATR
            candidates = []
            # create quick lookup for ticker info
            ticker_map = {t["symbol"]: t for t in usdt_tickers}
            for symbol in combined_symbols:
                if not bot_running:
                    break
                try:
                    recent_vol = get_volume_last_hours(symbol, hours=5)
                except Exception:
                    recent_vol = 0.0
                # try to get 24h quoteVolume from ticker first
                vol24 = None
                tk = ticker_map.get(symbol)
                if tk:
                    try:
                        vol24_raw = tk.get('quoteVolume') or tk.get('quote_volume') or tk.get('quoteVolume') or tk.get(
                            'quote_volume')
                        if vol24_raw is not None:
                            vol24 = float(vol24_raw)
                    except Exception:
                        vol24 = None
                if vol24 is None:
                    try:
                        vol24 = get_volume_last_hours(symbol, hours=24)
                    except Exception:
                        vol24 = 0.0
                try:
                    natr = calculate_natr(symbol)
                    natr_1m = calculate_natr(symbol, period=14, interval='5m')  # тепер це саме 5m NATR за 14 періодів

                except Exception:
                    natr = 0.0
                try:
                    change24 = None
                    if tk:
                        # Try common ticker fields
                        for k in ('priceChangePercent', 'price_change_percent', 'priceChange', 'percentChange'):
                            try:
                                v = tk.get(k)
                                if v is not None:
                                    change24 = float(v)
                                    break
                            except Exception:
                                continue
                    if change24 is None:
                        # fallback: compute 24h % from 1h klines (close now vs 24h ago)
                        try:
                            klines24 = signed_request(client.futures_klines, symbol=symbol, interval="1h", limit=25)
                            if klines24 and len(klines24) >= 2:
                                closes = [float(k[4]) for k in klines24]
                                first = closes[0]
                                last = closes[-1]
                                if first and first != 0:
                                    change24 = (last - first) / first * 100.0
                                else:
                                    change24 = 0.0
                            else:
                                change24 = 0.0
                        except Exception:
                            change24 = 0.0
                except Exception:
                    change24 = 0.0
                candidates.append({"symbol": symbol, "volume": float(recent_vol or 0.0), "vol_24h": float(vol24 or 0.0),
                                   "natr": float(natr or 0.0), "natr_1m": float(natr_1m or 0.0),
                                   "change_24h": float(change24 or 0.0)})

            # select top by recent 5h volume
            top_volume = sorted(candidates, key=lambda x: x["volume"], reverse=True)[:TOP_N_VOLUME]

            # then select top by NATR from those
            top_natr = sorted(top_volume, key=lambda x: x["natr"], reverse=True)[:TOP_N_NATR]

            # --- Фільтрація по 24h проторгованому об'єму (в USDT) ---
            filtered = [c for c in top_natr if c.get('vol_24h', 0.0) >= VOLUME_24H_THRESHOLD]

            # additionally filter out coins with 1-minute NATR below threshold

            filtered = [c for c in filtered if c.get('natr_1m', 0.0) >= NATR_1M_MIN]

            try:
                filtered = [c for c in filtered if not is_banned(c.get('symbol'))]
            except Exception:
                pass

            try:
                filtered = [c for c in filtered if c.get('symbol') not in tracked_symbols]
            except Exception:
                filtered = [c for c in filtered if c.get('symbol') not in tracked_symbols]

            # Final ordering: primary by NATR descending, secondary by 24h volume descending
            final_list = sorted(filtered, key=lambda x: (-x.get('natr', 0.0), -x.get('vol_24h', 0.0)))  # 200 млн USDT
            log_message(f"💥 Топ монет (оновлено {time.strftime('%Y-%m-%d %H:%M:%S')}):")
            if not filtered:
                log_message(
                    f"⚠️ Після фільтрації по 24h >= {VOLUME_24H_THRESHOLD:.0f} USDT нічого не лишилось. Пропускаємо пошук рівнів в цьому циклі.")
            else:
                for coin in filtered:
                    if not bot_running:
                        break
                    symbol = coin["symbol"]
                    try:
                        raw_levels, _, _ = find_horizontal_levels(symbol, return_details=True)
                        # normalize possible return formats (tuple, dict, numeric) into numeric list
                        levels = []
                        level_meta_map = {}
                        if raw_levels:
                            for it in raw_levels:
                                val = None
                                meta = None
                                if isinstance(it, (list, tuple)) and len(it) > 0:
                                    val = it[0]
                                    if len(it) > 2 and isinstance(it[2], dict):
                                        meta = it[2]
                                elif isinstance(it, dict):
                                    for k in ('price', 'level', 'value'):
                                        if k in it:
                                            try:
                                                val = it[k]
                                                break
                                            except Exception:
                                                pass
                                    if val is None:
                                        for v in it.values():
                                            if isinstance(v, (int, float)):
                                                val = v
                                                break
                                else:
                                    val = it
                                try:
                                    if val is not None:
                                        val_f = float(val)
                                        levels.append(val_f)
                                        if meta:
                                            level_meta_map[val_f] = meta
                                except Exception:
                                    continue
                        msg = (f"🌠🌠🌠  {symbol} | Volume(5h): {coin['volume']:.0f} | "
                               f"Volume(24h): {coin['vol_24h']:.0f} | "
                               f"NATR: {coin['natr']:.2f}% | 24h%: {coin['change_24h']:+.2f}% | Levels: {levels}")
                        log_message(msg)
                        # time.sleep(5)  # removed: avoid delaying order placement
                        if levels:
                            # відправляємо повідомлення у Telegram

                            cached = symbol_prices.get(symbol)
                            last_price = cached['price'] if cached and (
                                    time.time() - cached.get('ts', 0)) <= PRICE_STALE_SEC else None
                            if last_price is None:
                                last_price = get_last_price(symbol)
                            if last_price is None:
                                continue
                            closest_level = min(levels, key=lambda x: abs(x - last_price)) if levels else None
                            if closest_level is not None:
                                if level_meta_map:
                                    try:
                                        meta_match = min(
                                            level_meta_map.items(),
                                            key=lambda item: abs(item[0] - closest_level)
                                        )[1]
                                    except Exception:
                                        meta_match = None
                                    if isinstance(meta_match, dict):
                                        cache_level_display(symbol, closest_level, meta_match.get('first_touch_ts'))
                                place_pending_order(symbol, closest_level)
                                try:
                                    if bool(globals().get("TELEGRAM_LEVEL_SCREENSHOT_ENABLED", True)):
                                        shot_path = request_chart_screenshot(
                                            symbol,
                                            closest_level,
                                            timeout=globals().get("TELEGRAM_LEVEL_SCREENSHOT_TIMEOUT", 4.0),
                                            clear_markers=True,
                                            priority='low',
                                            fast=True,
                                            fullscreen=False,
                                        )
                                        if shot_path:
                                            try:
                                                prec = int(globals().get("LEVEL_PRECISION", 5) or 5)
                                            except Exception:
                                                prec = 5
                                            caption = f"{msg}\nЗнайдений рівень: {float(closest_level):.{prec}f}"
                                            send_telegram_photo_async(shot_path, caption=caption)
                                        else:
                                            pass
                                except Exception:
                                    pass
                            break
                    except Exception as e_coin:
                        log_message(f"❌ Помилка обробки монети {symbol}: {e_coin}")
                        log_message(traceback.format_exc())
                        continue
            if not bot_running:
                break
            # sleep in smaller increments but allow early exit if capacity is available for new trades
            for _ in range(1800):

                if not bot_running:
                    break

                time.sleep(15)
                try:
                    positions = signed_request(client.futures_position_information)
                except Exception:
                    positions = []

                open_position_count = 0
                if positions:
                    try:
                        open_position_count = sum(
                            1 for p in positions if abs(float(p.get('positionAmt', 0) or 0)) > 0.0
                        )
                    except Exception:
                        open_position_count = 0
                has_open_positions = open_position_count > 0

                with orders_lock:
                    pending_symbols = {
                        sym for sym in active_orders.keys()
                        if sym in pending_meta
                    }
                    pending_count = len(pending_symbols)

                pending_limit_hit = _limit_reached(pending_count, MAX_CONCURRENT_PENDING)
                position_limit_hit = _limit_reached(open_position_count, MAX_CONCURRENT_POSITIONS)
                if not pending_limit_hit and not position_limit_hit:
                    if pending_count == 0 and not has_open_positions:
                        log_message("✅ Всі позиції/ордера закриті — цикл запускається достроково")
                    else:
                        log_message(
                            f"ℹ️ Доступний слот для нової угоди (pending={pending_count}, positions={open_position_count}) — цикл запускається достроково")
                    break

                time.sleep(0.5)

            time.sleep(30)

        except Exception as e:
            log_message(f"❌ Помилка run_bot: {e}")
            log_message(traceback.format_exc())
            time.sleep(ERROR_RETRY_INTERVAL)


# ------------------- GUI -------------------

def compute_diff_from_stop_pct(entry_price, stop_price, current_price):
    """Return percentage difference between current_price and stop_price relative to stop_price."""
    try:
        if stop_price in (None, 0):
            return None
        diff = abs(stop_price - current_price)
        pct = (diff / float(stop_price)) * 100.0
        return pct
    except Exception:
        return None


# Dedup set for processed order updates (prevents WS duplicate handling)
processed_order_events = set()


def get_pnl_percent_from_gui(retry_delay=5):
    """Return the latest GUI PnL percent if available, otherwise fallback to balance-based calc."""
    if current_pnl_percent_display is not None:
        return current_pnl_percent_display
    try:
        bal = get_balance()
        if initial_balance and initial_balance != 0:
            return ((bal - initial_balance) / initial_balance) * 100.0
    except Exception:
        pass
    return None


# ------------------- Modern GUI (PySide6 + PyQtGraph) -------------------


class CandlestickItem(pg.GraphicsObject):
    """Lightweight candlestick renderer for the PyQtGraph view."""

    def __init__(self):
        super().__init__()
        self._data = []
        self._bar_width = 120.0
        self.picture = QPicture()
        self._up_pen = pg.mkPen('#2ecc71')
        self._down_pen = pg.mkPen('#e74c3c')
        self._up_brush = pg.mkBrush('#2ecc71')
        self._down_brush = pg.mkBrush('#e74c3c')

    def setData(self, data):
        self._data = data or []
        if len(self._data) >= 2:
            spacing = max(self._data[1][0] - self._data[0][0], 1.0)
            self._bar_width = max(spacing * 0.7, 30.0)
        else:
            self._bar_width = 120.0
        self._generate_picture()
        self.update()

    def _generate_picture(self):
        pic = QPicture()
        painter = QPainter(pic)
        if not self._data:
            painter.end()
            self.picture = pic
            return
        half_w = self._bar_width / 2.0
        for ts, open_p, close_p, low_p, high_p in self._data:
            rising = close_p >= open_p
            pen = self._up_pen if rising else self._down_pen
            brush = self._up_brush if rising else self._down_brush
            painter.setPen(pen)
            painter.drawLine(QPointF(ts, low_p), QPointF(ts, high_p))
            painter.setBrush(brush)
            top = max(open_p, close_p)
            bottom = min(open_p, close_p)
            height = top - bottom
            if height == 0:
                height = 1e-6
            rect = QRectF(ts - half_w, bottom, self._bar_width, height)
            painter.drawRect(rect)
        painter.end()
        self.picture = pic

    def paint(self, painter, *args):
        painter.drawPicture(0, 0, self.picture)

    def boundingRect(self):
        return self.picture.boundingRect()


class PrintsTapeWidget(QWidget):
    """Animate print bubbles aligned to the current order book ladder."""

    def __init__(self, parent=None):
        super().__init__(parent)
        # OpenGL-backed widget for ultra-high FPS tape rendering
        try:
            fmt = self.format()
            try:
                fmt.setSwapInterval(0)
            except Exception:
                pass
            try:
                fmt.setSamples(0)
            except Exception:
                pass
            try:
                fmt.setDepthBufferSize(0)
            except Exception:
                pass
            try:
                fmt.setStencilBufferSize(0)
            except Exception:
                pass
            self.setFormat(fmt)
        except Exception:
            pass
        try:
            # Prefer full updates for smoother animation
            self.setUpdateBehavior(QOpenGLWidget.NoPartialUpdate)
        except Exception:
            pass
        try:
            self.setAutoFillBackground(False)
            self.setAttribute(Qt.WA_OpaquePaintEvent, True)
            self.setAttribute(Qt.WA_NoSystemBackground, True)
        except Exception:
            pass
        self._prints = []
        self._last_key = None
        self._max_qty = 1.0
        self._pending = deque()
        self._start_price = None
        self._start_key = None
        self._tick = 0.0
        self._rows = 0
        self._row_height = int(ORDERBOOK_ROW_HEIGHT)
        self._best_bid = None
        self._best_ask = None
        self._book_table = None
        # External scroll support for image-mode orderbook (when table is hidden)
        self._external_scroll_rows = None
        self._external_scroll_row_h = None
        self._external_scroll_callback = None
        self._base_speed = 120.0
        self._speed_range = 150.0
        try:
            self._last_ts = time.monotonic()
        except Exception:
            self._last_ts = time.time()
        self._smooth_dt = None
        self._smooth_density = None
        self._fps_smooth = None
        self._font_cache = {}
        # Track print arrival rate for adaptive speed (auto mode when speed=0)
        self._rate_marks = deque()
        self._text_color = QColor(0, 0, 0, 255)
        self._book_shift_last_ts = None
        self._book_shift_boost = 0.0
        self._ladder_center_last_price = None
        self._ladder_center_last_ts = None
        self._ladder_gap_anchor_price = None
        self._ladder_gap_anchor_ts = None
        self._order_markers = []
        self._order_marker_hits = []
        self._order_marker_cb = None
        self._order_marker_sig = None
        self._order_marker_font = None
        self._order_marker_font_pt = None
        self._order_marker_text_cache = {}
        self._top_overlay = None
        self._top_overlay_h = 0
        self.setMinimumWidth(120)
        try:
            self.setAttribute(Qt.WA_OpaquePaintEvent, True)
            self.setAutoFillBackground(False)
        except Exception:
            pass
        self._timer = QTimer(self)
        try:
            self._timer.setTimerType(Qt.PreciseTimer)
        except Exception:
            pass
        self._timer.timeout.connect(self._advance)
        try:
            v = globals().get("PRINTS_TAPE_FRAME_MS", 8)
            frame_ms = int(v) if v is not None else 8
        except Exception:
            frame_ms = 8
        if frame_ms < 0:
            frame_ms = 0
        # Force high FPS: never allow very large frame intervals from stale settings.
        # 8ms ~= 125 FPS target (best-effort).
        try:
            frame_ms = max(0, min(int(frame_ms), 8))
        except Exception:
            frame_ms = 8
        try:
            if frame_ms >= 12:
                self._timer.setTimerType(Qt.CoarseTimer)
            else:
                self._timer.setTimerType(Qt.PreciseTimer)
        except Exception:
            pass
        self._timer.start(frame_ms)

    def bind_book_table(self, table):
        self._book_table = table

    def set_external_scroll_rows(self, scroll_rows=None, row_height=None, scroll_callback=None):
        """Provide external scroll position (in ROWS) when orderbook is rendered as an image.
        This keeps prints tape aligned even if the QTableView is hidden / not scrolling.
        """
        try:
            self._external_scroll_rows = None if scroll_rows is None else float(scroll_rows)
        except Exception:
            self._external_scroll_rows = None
        try:
            if row_height is not None:
                self._external_scroll_row_h = float(row_height)
        except Exception:
            pass
        try:
            if scroll_callback is not None:
                self._external_scroll_callback = scroll_callback
        except Exception:
            pass
        try:
            self.update()
        except Exception:
            pass

    def set_order_click_callback(self, cb):
        self._order_marker_cb = cb

    def set_top_overlay(self, widget, height_px=0):
        try:
            if widget is None:
                self._top_overlay = None
                self._top_overlay_h = 0
                return
        except Exception:
            return
        try:
            self._top_overlay = widget
            self._top_overlay_h = int(height_px or 0)
        except Exception:
            self._top_overlay = widget
            self._top_overlay_h = 0
        try:
            widget.setParent(self)
        except Exception:
            pass
        try:
            widget.show()
        except Exception:
            pass
        try:
            widget.raise_()
        except Exception:
            pass
        try:
            h = int(self._top_overlay_h or 0)
            if h > 0:
                widget.setGeometry(0, 0, int(self.width() or 0), h)
        except Exception:
            pass

    def resizeEvent(self, event):
        try:
            if self._top_overlay is not None:
                h = int(self._top_overlay_h or 0)
                if h > 0:
                    self._top_overlay.setGeometry(0, 0, int(self.width() or 0), h)
        except Exception:
            pass
        try:
            super().resizeEvent(event)
        except Exception:
            pass

    def hit_test_order_marker(self, pos):
        try:
            p = QPointF(pos)
        except Exception:
            try:
                p = QPointF(float(pos.x()), float(pos.y()))
            except Exception:
                return None
        try:
            hits = list(getattr(self, "_order_marker_hits", None) or [])
        except Exception:
            hits = []
        for rect, payload in hits:
            try:
                if rect.contains(p):
                    return payload
            except Exception:
                continue
        return None

    def _format_order_notional(self, val):
        try:
            val_f = float(val)
        except Exception:
            return ""
        abs_val = abs(val_f)
        try:
            compact = bool(globals().get("ORDERBOOK_VOL_COMPACT", False))
        except Exception:
            compact = False

        def _trim_num(s: str) -> str:
            s = s.rstrip("0").rstrip(".")
            return s if s else "0"

        if compact:
            if abs_val >= 1_000_000:
                return f"{_trim_num(f'{abs_val / 1_000_000.0:.2f}')}M"
            if abs_val >= 1_000:
                return f"{_trim_num(f'{abs_val / 1_000.0:.2f}')}K"
        return _trim_num(f"{abs_val:.2f}")

    def set_order_markers(self, order_markers):
        if not order_markers:
            if self._order_markers:
                self._order_markers = []
                self._order_marker_hits = []
                self._order_marker_sig = None
                try:
                    self.update()
                except Exception:
                    pass
            return
        try:
            tick = float(self._tick or 0.0)
        except Exception:
            tick = 0.0
        merged = {}
        for item in order_markers:
            if not isinstance(item, dict):
                continue
            try:
                price = float(item.get("price"))
            except Exception:
                continue
            try:
                notional = float(item.get("notional") or 0.0)
            except Exception:
                notional = 0.0
            try:
                total = int(item.get("total") or 0)
            except Exception:
                total = 0
            try:
                order_ids = list(item.get("order_ids") or [])
            except Exception:
                order_ids = []
            try:
                algo_ids = list(item.get("algo_ids") or [])
            except Exception:
                algo_ids = []
            if notional <= 0.0 and total <= 0:
                continue
            key = None
            if tick > 0:
                try:
                    key = int(round(price / tick))
                    price = float(key) * float(tick)
                except Exception:
                    key = None
            if key is None:
                key = round(price, 8)
            info = merged.get(key)
            if info is None:
                info = {"price": price, "notional": 0.0, "total": 0, "order_ids": set(), "algo_ids": set()}
                merged[key] = info
            try:
                info["notional"] = float(info.get("notional") or 0.0) + max(0.0, float(notional))
            except Exception:
                pass
            try:
                info["total"] = int(info.get("total") or 0) + max(0, int(total))
            except Exception:
                pass
            try:
                for oid in order_ids or []:
                    if oid not in (None, ""):
                        info["order_ids"].add(str(oid))
            except Exception:
                pass
            try:
                for aid in algo_ids or []:
                    if aid not in (None, ""):
                        info["algo_ids"].add(str(aid))
            except Exception:
                pass
        markers = []
        sig_items = []
        for key, info in merged.items():
            try:
                notional = float(info.get("notional") or 0.0)
            except Exception:
                notional = 0.0
            try:
                order_ids = sorted(list(info.get("order_ids") or []))
            except Exception:
                order_ids = []
            try:
                algo_ids = sorted(list(info.get("algo_ids") or []))
            except Exception:
                algo_ids = []
            try:
                total = len(order_ids) + len(algo_ids)
            except Exception:
                total = 0
            if total <= 0:
                try:
                    total = int(info.get("total") or 0)
                except Exception:
                    total = 0
            text = "x"
            if notional > 0.0:
                text = f"x {self._format_order_notional(notional)}"
            elif total > 1:
                text = f"x{total}"
            try:
                price = float(info.get("price"))
            except Exception:
                price = None
            if price is None:
                continue
            markers.append({"price": price, "text": text, "notional": notional, "order_ids": order_ids, "algo_ids": algo_ids})
            sig_key = key if key is not None else round(price, 8)
            sig_items.append((sig_key, int(round(notional * 100.0)), text, len(order_ids), len(algo_ids)))
        sig_items.sort()
        sig = tuple(sig_items)
        if sig == self._order_marker_sig:
            return
        self._order_marker_sig = sig
        self._order_markers = markers
        self._order_marker_hits = []
        try:
            self.update()
        except Exception:
            pass

    def wheelEvent(self, event):
        """Forward mouse wheel to the orderbook table even when hovering prints."""
        try:
            # In image-mode, forward wheel to external scroll callback (no table scroll).
            try:
                cb = getattr(self, "_external_scroll_callback", None)
            except Exception:
                cb = None
            if cb is not None:
                try:
                    dy = event.angleDelta().y()
                except Exception:
                    dy = 0
                if dy:
                    try:
                        step_rows = int(globals().get("ORDERBOOK_IMAGE_SCROLL_STEP_ROWS", 6) or 6)
                    except Exception:
                        step_rows = 6
                    step_rows = max(1, min(step_rows, 50))
                    try:
                        notches = int(dy / 120)
                    except Exception:
                        notches = 1 if dy > 0 else -1
                    delta_rows = -notches * step_rows
                    try:
                        cb(int(delta_rows))
                    except Exception:
                        pass
                    try:
                        event.accept()
                    except Exception:
                        pass
                    return
            table = self._book_table

            if table is None:
                return super().wheelEvent(event)
            try:
                dy = event.angleDelta().y()
            except Exception:
                dy = 0
            if not dy:
                return super().wheelEvent(event)
            try:
                row_h = float(table.rowHeight(0) or ORDERBOOK_ROW_HEIGHT or 14)
            except Exception:
                row_h = float(ORDERBOOK_ROW_HEIGHT or 14)
            if row_h <= 0:
                row_h = 14.0
            steps = dy / 120.0
            delta_px = int(round(steps * row_h * 6.0))
            try:
                bar = table.verticalScrollBar()
                bar.setValue(int(bar.value() - delta_px))
                try:
                    self._book_img_user_scrolled = True
                except Exception:
                    pass
            except Exception:
                pass
            try:
                event.accept()
            except Exception:
                pass
            return
        except Exception:
            return super().wheelEvent(event)

    def mousePressEvent(self, event):
        try:
            btn = event.button()
        except Exception:
            btn = Qt.LeftButton
        if btn == Qt.LeftButton:
            try:
                pos = event.position()
            except Exception:
                pos = event.pos()
            try:
                pos = QPointF(pos)
            except Exception:
                pass
            try:
                hits = list(getattr(self, "_order_marker_hits", None) or [])
            except Exception:
                hits = []
            for rect, price in hits:
                try:
                    if rect.contains(pos):
                        cb = getattr(self, "_order_marker_cb", None)
                        if cb is not None:
                            try:
                                cb(float(price))
                            except Exception:
                                cb(price)
                        try:
                            event.accept()
                        except Exception:
                            pass
                        return
                except Exception:
                    continue
        try:
            event.ignore()
        except Exception:
            pass

    def prune_min_notional(self, min_notional_usd: float):
        """Drop queued/active prints below the given USD threshold (used when filter increases)."""
        try:
            mn = float(min_notional_usd)
        except Exception:
            return
        if mn <= 0:
            return
        try:
            self._prints = [p for p in (self._prints or []) if float(p.get('notional', 0.0) or 0.0) >= mn]
        except Exception:
            pass
        try:
            if self._pending:
                from collections import deque
                nd = deque()
                for it in list(self._pending):
                    try:
                        price = float(it.get('price') or 0.0)
                        qty = float(it.get('qty') or 0.0)
                        notional = abs(price * qty)
                    except Exception:
                        notional = 0.0
                    if notional >= mn:
                        nd.append(it)
                self._pending = nd
        except Exception:
            pass
        try:
            self.update()
        except Exception:
            pass


    def update_ladder(self, start_price, tick, rows, row_height=None, best_bid=None, best_ask=None):
        """Update ladder mapping for prints.

        IMPORTANT: when the ladder's start_price shifts due to image-mode scrolling/auto-centering,
        all existing bubbles must shift by the same row-delta immediately, otherwise they appear to
        "lag behind" and then slowly catch up.
        """
        # Capture previous mapping
        try:
            old_start = float(getattr(self, "_start_price", None)) if getattr(self, "_start_price", None) is not None else None
        except Exception:
            old_start = None
        try:
            old_tick = float(getattr(self, "_tick", None)) if getattr(self, "_tick", None) is not None else None
        except Exception:
            old_tick = None
        try:
            old_key = getattr(self, "_start_key", None)
        except Exception:
            old_key = None

        # Normalize new mapping
        try:
            new_start = float(start_price) if start_price is not None else None
        except Exception:
            new_start = None
        try:
            new_tick = float(tick) if tick is not None else None
        except Exception:
            new_tick = None
        tick_changed = False
        try:
            if (old_tick is not None) and (new_tick is not None):
                if abs(float(new_tick) - float(old_tick)) > max(abs(float(old_tick)) * 1e-6, 1e-12):
                    tick_changed = True
        except Exception:
            tick_changed = False
        new_key = None
        try:
            if (new_start is not None) and (new_tick is not None) and float(new_tick) > 0:
                new_key = int(round(float(new_start) / float(new_tick)))
        except Exception:
            new_key = None

        # Shift existing bubbles in-row immediately when start changes (prevents trailing).
        try:
            if self._prints and (old_start is not None) and (old_tick is not None) and old_tick > 0 and (new_start is not None) and (new_tick is not None) and new_tick > 0:
                # If tick changed, recompute from price. Otherwise shift by delta rows.
                if abs(float(new_tick) - float(old_tick)) > 1e-12:
                    for p in self._prints:
                        try:
                            pr = float(p.get("price"))
                            row_f = self._row_for_price(pr, start_key=new_key, tick=new_tick, start_price=new_start)
                            if row_f is not None:
                                p["row_f"] = float(row_f)
                        except Exception:
                            pass
                else:
                    if (new_key is not None) and (old_key is not None):
                        dr = float(new_key - old_key)
                    else:
                        dr = float(new_start - old_start) / float(new_tick)
                    if abs(dr) > 1e-12:
                        for p in self._prints:
                            try:
                                p["row_f"] = float(p.get("row_f", 0.0) or 0.0) + float(dr)
                            except Exception:
                                pass
        except Exception:
            pass

        # Track fast ladder shifts to adapt aggregated print stretch (cover gaps on sharp moves).
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            dist_ref = float(globals().get("PRINTS_AGG_OVAL_Y_DIST_REF", 20.0) or 20.0)
        except Exception:
            dist_ref = 20.0
        try:
            min_rows = float(globals().get("PRINTS_AGG_OVAL_Y_MIN_ROWS", 1.5) or 1.5)
        except Exception:
            min_rows = 1.5
        try:
            gap_rows = float(globals().get("PRINTS_AGG_OVAL_Y_GAP_ROWS", 6.0) or 6.0)
        except Exception:
            gap_rows = 6.0
        if gap_rows < 0:
            gap_rows = 0.0
        if dist_ref <= 0:
            dist_ref = 20.0
        try:
            if gap_rows < min_rows:
                gap_rows = float(min_rows)
        except Exception:
            pass
        try:
            gap_sec = float(globals().get("PRINTS_AGG_OVAL_Y_GAP_SEC", 0.35) or 0.35)
        except Exception:
            gap_sec = 0.35
        if gap_sec <= 0:
            gap_sec = 0.35

        row_target = None
        gap_detected = False
        try:
            if (new_tick is not None) and float(new_tick) > 0:
                ref_price = None
                try:
                    if best_bid is not None and best_ask is not None:
                        ref_price = (float(best_bid) + float(best_ask)) / 2.0
                    elif best_bid is not None:
                        ref_price = float(best_bid)
                    elif best_ask is not None:
                        ref_price = float(best_ask)
                except Exception:
                    ref_price = None
                if ref_price is not None:
                    if tick_changed:
                        try:
                            self._ladder_center_last_price = float(ref_price)
                            self._ladder_center_last_ts = float(now_m)
                        except Exception:
                            pass
                        try:
                            self._ladder_gap_anchor_price = float(ref_price)
                            self._ladder_gap_anchor_ts = float(now_m)
                        except Exception:
                            pass
                        try:
                            self._book_shift_boost = 0.0
                        except Exception:
                            pass
                        try:
                            self._book_shift_last_ts = 0.0
                        except Exception:
                            pass
                    else:
                        try:
                            anchor_price = getattr(self, "_ladder_gap_anchor_price", None)
                        except Exception:
                            anchor_price = None
                        try:
                            anchor_ts = getattr(self, "_ladder_gap_anchor_ts", None)
                        except Exception:
                            anchor_ts = None
                        abs_rows = None
                        if (anchor_price is not None):
                            try:
                                abs_rows = abs(float(ref_price) - float(anchor_price)) / float(new_tick)
                            except Exception:
                                abs_rows = None
                        if (abs_rows is not None) and (abs_rows >= gap_rows):
                            row_target = min(1.0, max(0.0, abs_rows - float(gap_rows)) / float(dist_ref))
                            gap_detected = True
                            try:
                                self._ladder_gap_anchor_price = float(ref_price)
                                self._ladder_gap_anchor_ts = float(now_m)
                            except Exception:
                                pass
                        else:
                            gap_detected = False
                            if (anchor_price is None) or (anchor_ts is None) or ((now_m - float(anchor_ts)) > float(gap_sec)):
                                try:
                                    self._ladder_gap_anchor_price = float(ref_price)
                                    self._ladder_gap_anchor_ts = float(now_m)
                                except Exception:
                                    pass
                        try:
                            self._ladder_center_last_price = float(ref_price)
                            self._ladder_center_last_ts = float(now_m)
                        except Exception:
                            pass
        except Exception:
            row_target = None
            gap_detected = False
        try:
            if not tick_changed:
                if gap_detected and (row_target is not None):
                    boost = float(row_target)
                    if boost < 0.0:
                        boost = 0.0
                    if boost > 1.0:
                        boost = 1.0
                    try:
                        self._book_shift_boost = float(boost)
                    except Exception:
                        pass
                    try:
                        self._book_shift_last_ts = float(now_m)
                    except Exception:
                        pass
                else:
                    try:
                        last_ts = float(getattr(self, "_book_shift_last_ts", 0.0) or 0.0)
                    except Exception:
                        last_ts = 0.0
                    if last_ts > 0 and (float(now_m) - float(last_ts)) > float(gap_sec):
                        try:
                            self._book_shift_boost = 0.0
                        except Exception:
                            pass
        except Exception:
            pass

        # Store new mapping
        self._start_price = start_price
        self._start_key = new_key
        self._tick = tick
        self._rows = rows
        self._best_bid = best_bid
        self._best_ask = best_ask
        if row_height:
            try:
                self._row_height = int(row_height)
            except Exception:
                pass

    def clear(self):
        self._prints = []
        self._last_key = None
        self._smooth_dt = None
        self._order_markers = []
        self._order_marker_hits = []
        self._order_marker_sig = None
        try:
            self._pending.clear()
        except Exception:
            self._pending = deque()
        self.update()

    def get_fps(self):
        """Return smoothed FPS of the prints animation loop."""
        try:
            return float(getattr(self, '_fps_smooth', 0.0) or 0.0)
        except Exception:
            return 0.0

    def get_rate_stats(self):
        """Return (count_in_window, window_seconds, current_auto_multiplier_or_None).

        Used by the main UI to show a real-time speedometer.
        """
        try:
            cnt = int(getattr(self, '_last_rate_count', 0) or 0)
        except Exception:
            cnt = 0
        try:
            win = float(getattr(self, '_last_rate_window_s', 5.0) or 5.0)
        except Exception:
            win = 5.0
        try:
            auto_flag = bool(globals().get('PRINTS_SPEED_AUTO', False))
        except Exception:
            auto_flag = False
        if auto_flag:
            try:
                mult = float(getattr(self, '_auto_speed_smooth', 0.0) or 0.0)
            except Exception:
                mult = None
            return cnt, win, mult
        return cnt, win, None

    def queue_prints(self, prints, max_new=20):
        if not prints:
            return False
        new_items = []
        for item in prints:
            key = self._print_key(item)
            if self._last_key and key == self._last_key:
                continue
            new_items.append(item)
            if len(new_items) >= max_new:
                break
        if not new_items:
            return False
        self._last_key = self._print_key(new_items[0])
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            for _ in range(len(new_items)):
                self._rate_marks.append(now_m)
        except Exception:
            pass
        if max_new <= 1 and len(new_items) == 1 and self._start_price and self._tick:
            try:
                before = len(self._prints)
                self._add_print(new_items[0])
                if len(self._prints) > before:
                        # Added directly; the animation timer will redraw.
                        return True
            except Exception:
                pass
        added_direct = False
        if self._start_price and self._tick and not self._prints:
            try:
                self._add_print(new_items[0])
                added_direct = True
            except Exception:
                added_direct = False
        items_to_queue = new_items[1:] if added_direct else new_items
        try:
            now_ms = int(time.time() * 1000.0)
        except Exception:
            now_ms = 0
        for item in reversed(items_to_queue):
            # Ensure each print has a timestamp so PRINTS_AGG_WINDOW_MS works reliably
            try:
                if now_ms and isinstance(item, dict):
                    if not any(k in item for k in ('ts', 'T', 'E', 'time', 'timestamp', 'transactTime')):
                        item['ts'] = now_ms
            except Exception:
                pass
            self._pending.append(item)
        try:
            _val = globals().get("PRINTS_MAX_PENDING", 500)
            max_pending = int(_val) if _val is not None else 500
        except Exception:
            max_pending = 500
        if max_pending > 0 and len(self._pending) > max_pending:
            drop = len(self._pending) - max_pending
            for _ in range(drop):
                try:
                    self._pending.popleft()
                except Exception:
                    break
        # Do not spam UI repaint here; the animation timer will repaint at a stable FPS
        return True

    def _print_key(self, item):
        tid = None
        try:
            tid = item.get('id') or item.get('trade_id') or item.get('tradeId') or item.get('a') or item.get('t')
        except Exception:
            tid = None
        if tid is not None:
            return f"id:{tid}"
        try:
            ts_val = float(item.get('ts') or 0.0)
        except Exception:
            ts_val = 0.0
        try:
            price_val = float(item.get('price') or 0.0)
        except Exception:
            price_val = 0.0
        try:
            qty_val = float(item.get('qty') or 0.0)
        except Exception:
            qty_val = 0.0
        side_val = str(item.get('side') or "")
        return f"{ts_val:.3f}|{price_val:.8f}|{qty_val:.8f}|{side_val}"

    def _ts_ms(self, item):
        """Best-effort timestamp (milliseconds) for print aggregation."""
        if not item:
            return 0.0
        ts = None
        try:
            # Common keys across exchanges / internal adapters
            for k in ('ts', 'T', 'E', 'time', 'timestamp', 'transactTime'):
                if k in item and item.get(k) is not None:
                    ts = item.get(k)
                    break
        except Exception:
            ts = None
        try:
            ts = float(ts)
        except Exception:
            ts = 0.0
        # Normalize to milliseconds
        if ts <= 0:
            return 0.0
        # If it's already in ms since epoch (1.7e12) or similar
        if ts > 1e11:
            # microseconds
            if ts > 1e15:
                return ts / 1000.0
            return ts
        # seconds since epoch or monotonic seconds
        return ts * 1000.0

    def _side_norm(self, item):
        try:
            return str(item.get('side') or '').upper()
        except Exception:
            return ''

    def _price_key(self, price, tick=None):
        try:
            t = float(tick if tick is not None else (self._tick or 0.0))
        except Exception:
            t = 0.0
        if t <= 0:
            return None
        try:
            return int(round(float(price) / t))
        except Exception:
            return None

    def _row_for_price(self, price, start_key=None, tick=None, start_price=None):
        try:
            t = float(tick if tick is not None else (self._tick or 0.0))
        except Exception:
            t = 0.0
        if t <= 0:
            return None
        if start_key is None:
            try:
                start_key = getattr(self, "_start_key", None)
            except Exception:
                start_key = None
        if start_key is None:
            if start_price is None:
                try:
                    start_price = float(self._start_price)
                except Exception:
                    start_price = None
            if start_price is not None:
                try:
                    start_key = int(round(float(start_price) / t))
                except Exception:
                    start_key = None
        try:
            key = self._price_key(price, tick=t)
        except Exception:
            key = None
        if start_key is not None and key is not None:
            try:
                return float(start_key - key)
            except Exception:
                return None
        if start_price is None:
            try:
                start_price = float(self._start_price)
            except Exception:
                start_price = None
        if start_price is None:
            return None
        try:
            return float((float(start_price) - float(price)) / t)
        except Exception:
            return None

    def _add_print(self, item):
        try:
            qty = float(item.get('qty') or 0.0)
        except Exception:
            return
        if qty <= 0:
            return
        if not self._start_price or not self._tick:
            return
        side = str(item.get('side') or '').upper()
        try:
            price = float(item.get('price') or 0.0)
        except Exception:
            price = None
        # Target price is the actual trade price.
        # Snap it to the ladder tick so prints always align to the compressed book price rows.
        if price is None or price <= 0:
            return
        try:
            t = float(self._tick or 0.0)
        except Exception:
            t = 0.0
        if t and t > 0:
            try:
                b = self._price_key(price, tick=t)
                if b is None:
                    b = int(round(float(price) / float(t)))
                price = float(b) * float(t)
                # Keep original price for optional tooltip/debug
                item = dict(item)
                item['price'] = price
                item['price_bucket'] = b
            except Exception:
                pass
        # Spawn prints from the spread (best bid/ask row) so bubbles always "fly out" from the spread,
        # and then drift toward their real (compressed) trade price row.
        # This prevents the visual bug where prints appear far away from the spread immediately.
        try:
            # Spawn on the trade row (so each print keeps its own trajectory),
            # then clamp into a narrow corridor around the spread.
            spawn_row = self._row_for_price(price)
            if spawn_row is None:
                return
        except Exception:
            return

        # Clamp prints to a narrow corridor around the spread (tape lane) ON SPAWN,
        # and keep that row fixed for the whole flight.
        try:
            corr = int(globals().get('PRINTS_TAPE_CORRIDOR_ROWS', 3) or 3)
        except Exception:
            corr = 3
        if corr > 0:
            try:
                if (self._best_bid is not None) or (self._best_ask is not None):
                    if (self._best_bid is not None) and (self._best_ask is not None):
                        spread_ref = (float(self._best_bid) + float(self._best_ask)) / 2.0
                    else:
                        spread_ref = float(self._best_bid) if self._best_bid is not None else float(self._best_ask)
                    spread_row = self._row_for_price(spread_ref)
                    if spread_row is None:
                        spread_row = float(spawn_row)
                    lo = spread_row - float(corr)
                    hi = spread_row + float(corr)
                    if spawn_row < lo:
                        spawn_row = lo
                    elif spawn_row > hi:
                        spawn_row = hi
            except Exception:
                pass
        # Clamp spawn row into visible area so prints always appear on screen.
        try:
            if self._rows and self._rows > 0:
                spawn_row = max(0.0, min(float(self._rows - 1), float(spawn_row)))
        except Exception:
            pass
        # Use USD notional for sizing (more intuitive vs raw qty).
        try:
            notional = abs(float(qty) * float(price))
        except Exception:
            notional = abs(float(qty))

        # Extra safety: never render bubbles below the global USD filter (even if upstream filtering missed it)
        try:
            _mn = float(globals().get('PRINTS_MIN_NOTIONAL_USD', 0.0) or 0.0)
        except Exception:
            _mn = 0.0
        if _mn > 0.0 and float(notional) < _mn:
            return

        # Timestamp for time-window aggregation (required for PRINTS_AGG_WINDOW_MS to work across frames)
        try:
            ts_ms = int(self._ts_ms(item) or 0)
        except Exception:
            ts_ms = 0
        if ts_ms <= 0:
            try:
                ts_ms = int(time.time() * 1000.0)
            except Exception:
                ts_ms = 0
        try:
            agg_count_in = int(item.get('agg_count', 1) or 1)
        except Exception:
            agg_count_in = 1
        if agg_count_in < 1:
            agg_count_in = 1

        # Track a decayed rolling max so 1k vs 5k stays visually different
        # even after a rare huge print.
        try:
            cur_max = float(getattr(self, "_max_notional", 1.0) or 1.0)
        except Exception:
            cur_max = 1.0
        cur_max = max(cur_max * 0.985, notional, 1e-6)
        self._max_notional = cur_max

        # Log scaling keeps separation across wide ranges.
        try:
            import math
            ratio_lin = notional / max(cur_max, 1e-9)
            ratio = math.sqrt(max(0.0, min(1.0, ratio_lin)))
        except Exception:
            ratio = min(max(notional / max(cur_max, 1e-9), 0.0), 1.0)
        ratio = min(max(ratio, 0.0), 1.0)

        try:
            r_min = float(globals().get("PRINTS_RADIUS_MIN", 3.0) or 3.0)
        except Exception:
            r_min = 3.0
        try:
            r_max = float(globals().get("PRINTS_RADIUS_MAX", 32.0) or 32.0)
        except Exception:
            r_max = 32.0
        try:
            r_exp = float(globals().get("PRINTS_RADIUS_EXP", 0.85) or 0.85)
        except Exception:
            r_exp = 0.85
        if r_max < r_min + 1.0:
            r_max = r_min + 1.0

        radius = r_min + (r_max - r_min) * (ratio ** r_exp)
        # Uniform speed independent of print size/volume
        speed = self._base_speed + (self._speed_range * 0.5)

        # Show USD when using a USD filter or when the orderbook itself is in USD.
        show_usd = False
        try:
            show_usd = bool(globals().get("ORDERBOOK_VOL_IN_USD", False))
        except Exception:
            show_usd = False
        try:
            min_f = float(globals().get("PRINTS_MIN_NOTIONAL_USD", 0.0) or 0.0)
        except Exception:
            min_f = 0.0
        if min_f > 0:
            show_usd = True

        qty_display = notional if show_usd else qty
        text = self._format_qty(qty_display, usd=show_usd)
        # Aggregated prints are displayed as a single print (no ×N label)
        font_size = max(6.0, min(16.0, radius * 0.95))
        # Lighter backgrounds for readability (black text).
        if side == 'BUY':
            color = QColor(170, 240, 195, 245)  # light green
        elif side == 'SELL':
            color = QColor(255, 205, 205, 245)  # light red
        else:
            color = QColor(235, 235, 235, 235)
        # Aggregate micro-prints (too small for readable text) into the nearest bubble
        try:
            agg_r = float(globals().get('PRINTS_AGG_SMALL_RADIUS', 9.0) or 9.0)
        except Exception:
            agg_r = 9.0
        try:
            if radius < agg_r and self._prints:
                best_i = None
                best_d = 1e9
                for i, pp in enumerate(self._prints):
                    try:
                        if str(pp.get('side','')).upper() != side:
                            continue
                        d = abs(float(pp.get('row_f', 0.0)) - float(spawn_row))
                        if d < best_d:
                            best_d = d
                            best_i = i
                    except Exception:
                        continue
                # Merge into a nearby bubble (DISABLED: show every print individually)
                if False and best_i is not None and best_d <= 1.5:
                    pp = self._prints[best_i]
                    try:
                        pp['notional'] = float(pp.get('notional', 0.0) or 0.0) + float(notional)
                    except Exception:
                        pp['notional'] = float(notional)
                    # Recompute size/text based on merged notional
                    try:
                        m_notional = float(pp.get('notional', 0.0) or 0.0)
                    except Exception:
                        m_notional = float(notional)
                    try:
                        import math
                        ratio_lin2 = m_notional / max(float(self._max_notional or 1.0), 1e-9)
                        ratio2 = math.sqrt(max(0.0, min(1.0, ratio_lin2)))
                    except Exception:
                        ratio2 = 0.0
                    nr = r_min + (r_max - r_min) * (min(max(ratio2,0.0),1.0) ** r_exp)
                    pp['r'] = max(float(pp.get('r', 0.0) or 0.0), float(nr))
                    # Keep uniform speed even after merging micro-prints
                    pp['speed'] = max(float(pp.get('speed', 0.0) or 0.0), float(self._base_speed + (self._speed_range * 0.5)))
                    pp['text'] = self._format_qty(m_notional, usd=True) if show_usd else self._format_qty(float(m_notional) / max(float(price), 1e-9), usd=False)
                    pp['fit_pt'] = None
                    pp['fit_text'] = None
                    return
        except Exception:
            pass


        # Capture current gap-based stretch for this print (keep size fixed per bubble).
        try:
            agg_boost = float(getattr(self, "_book_shift_boost", 0.0) or 0.0)
        except Exception:
            agg_boost = 0.0
        if agg_boost < 0.0:
            agg_boost = 0.0
        if agg_boost > 1.0:
            agg_boost = 1.0
        try:
            gap_sec = float(globals().get("PRINTS_AGG_OVAL_Y_GAP_SEC", 0.35) or 0.35)
        except Exception:
            gap_sec = 0.35
        try:
            last_shift_ts = float(getattr(self, "_book_shift_last_ts", 0.0) or 0.0)
        except Exception:
            last_shift_ts = 0.0
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        if gap_sec > 0 and last_shift_ts > 0 and (now_m - last_shift_ts) > gap_sec:
            agg_boost = 0.0

        # Time-window aggregation: merge prints into the most recent bubble of the same side
        # within PRINTS_AGG_WINDOW_MS, so the setting actually affects visuals even with high FPS flushes.
        try:
            _agg_en = bool(globals().get('PRINTS_AGG_ENABLED', True))
        except Exception:
            _agg_en = True
        try:
            _agg_win_ms = int(globals().get('PRINTS_AGG_WINDOW_MS', 250) or 250)
        except Exception:
            _agg_win_ms = 250
        if _agg_en and _agg_win_ms > 0 and self._prints:
            try:
                ts_ms = int(self._ts_ms(item) or 0)
            except Exception:
                ts_ms = 0
            if ts_ms <= 0:
                try:
                    ts_ms = int(time.time() * 1000.0)
                except Exception:
                    ts_ms = 0
            try:
                last = None
                # Search from newest to oldest; stop once we pass the window for this side.
                for pp in reversed(self._prints):
                    try:
                        if str(pp.get('side', '')).upper() != side:
                            continue
                        p_ts = int(pp.get('ts_ms') or 0)
                        if p_ts <= 0:
                            continue
                        dt = int(ts_ms) - int(p_ts)
                        if dt < 0:
                            dt = 0
                        if dt <= int(_agg_win_ms):
                            last = pp
                            break
                        # Older than window -> no need to search further for this side
                        if dt > int(_agg_win_ms):
                            break
                    except Exception:
                        continue
                if last is not None:
                    try:
                        last['notional'] = float(last.get('notional', 0.0) or 0.0) + float(notional)
                    except Exception:
                        last['notional'] = float(notional)
                    try:
                        last['qty_sum'] = float(last.get('qty_sum', 0.0) or 0.0) + float(qty)
                    except Exception:
                        last['qty_sum'] = float(qty)
                    try:
                        last['agg_count'] = int(last.get('agg_count', 1) or 1) + 1
                    except Exception:
                        last['agg_count'] = 2
                    last['ts_ms'] = int(ts_ms)

                    # Recompute size/text based on merged notional
                    try:
                        m_notional = float(last.get('notional', 0.0) or 0.0)
                    except Exception:
                        m_notional = float(notional)

                    try:
                        cur_max2 = float(getattr(self, "_max_notional", 1.0) or 1.0)
                    except Exception:
                        cur_max2 = 1.0
                    cur_max2 = max(cur_max2 * 0.985, m_notional, 1e-6)
                    self._max_notional = cur_max2

                    try:
                        import math
                        ratio_lin2 = m_notional / max(cur_max2, 1e-9)
                        ratio2 = math.sqrt(max(0.0, min(1.0, ratio_lin2)))
                    except Exception:
                        ratio2 = 0.0
                    nr = r_min + (r_max - r_min) * (min(max(ratio2, 0.0), 1.0) ** r_exp)
                    try:
                        last['r'] = max(float(last.get('r', 0.0) or 0.0), float(nr))
                    except Exception:
                        last['r'] = float(nr)
                    try:
                        last['font_size'] = max(6.0, min(16.0, float(last.get('r', 0.0) or 0.0) * 0.95))
                    except Exception:
                        pass

                    qty_display2 = m_notional if show_usd else float(last.get('qty_sum', 0.0) or 0.0)
                    last['text'] = self._format_qty(qty_display2, usd=show_usd)
                    last['fit_pt'] = None
                    last['fit_text'] = None
                    # Keep uniform speed even after merging
                    last['speed'] = float(self._base_speed + (self._speed_range * 0.5))
                    try:
                        prev_boost = float(last.get('agg_boost', 0.0) or 0.0)
                    except Exception:
                        prev_boost = 0.0
                    if agg_boost > prev_boost:
                        last['agg_boost'] = float(agg_boost)
                    return
            except Exception:
                pass
        self._prints.append({
            'price': price,
            'notional': float(notional),
            'side': side,
            'x': self.width() - radius - 2.0,
            'row_f': float(spawn_row),
            'r': radius,
            'color': color,
            'speed': speed,
            'text': text,
            'font_size': font_size,
            'ts_ms': int(ts_ms or 0),
            'agg_count': int(agg_count_in or 1),
            'qty_sum': float(qty_display) if qty_display is not None else float(qty),
            'agg_boost': float(agg_boost),
            # cache for text fitting inside the circle
            'fit_pt': None,
            'fit_text': None,
        })
        try:
            _val = globals().get("PRINTS_MAX_ACTIVE", 120)
            max_active = int(_val) if _val is not None else 120
        except Exception:
            max_active = 120
        if max_active > 0 and len(self._prints) > max_active:
            self._prints = self._prints[-max_active:]

    def _advance(self):
        # Monotonic clock avoids freezes if system time jumps backward.
        try:
            now = time.monotonic()
        except Exception:
            now = time.time()
        dt = now - self._last_ts
        if dt <= 0:
            self._last_ts = now
            return
        self._last_ts = now
        if dt > 0.050:
            dt = 0.035
        if self._smooth_dt is None:
            self._smooth_dt = dt
        else:
            self._smooth_dt = (self._smooth_dt * 0.70) + (dt * 0.30)
        dt = self._smooth_dt
        # FPS estimate for UI
        try:
            fps_now = 1.0 / max(float(dt), 1e-6)
        except Exception:
            fps_now = 0.0
        try:
            if self._fps_smooth is None:
                self._fps_smooth = float(fps_now)
            else:
                self._fps_smooth = (float(self._fps_smooth) * 0.85) + (float(fps_now) * 0.15)
        except Exception:
            pass
        if self._pending and self._start_price and self._tick:
            try:
                base_spawn = int(globals().get("PRINTS_SPAWN_PER_FRAME", 1) or 1)
            except Exception:
                base_spawn = 1
            if base_spawn < 1:
                base_spawn = 1
            try:
                backlog = len(self._pending)
            except Exception:
                backlog = 0
            try:
                overload_at = int(globals().get("PRINTS_OVERLOAD_AT", 140) or 140)
            except Exception:
                overload_at = 140
            # Dynamic spawning to reduce lag when prints burst.
            # We never want an ever-growing backlog (prints appearing 0.5% away from spread).
            if overload_at > 0 and len(self._prints) >= overload_at:
                # In ultra mode we still spawn prints (no freezing) to avoid backlog lag.
                try:
                    burst = int(backlog // 10) + 1
                except Exception:
                    burst = 1
                burst = max(base_spawn, min(24, burst))
                spawn_count = min(backlog, burst)
            else:
                try:
                    burst = int(backlog // 20) + 1
                except Exception:
                    burst = 1
                burst = max(base_spawn, min(8, burst))
                spawn_count = min(backlog, burst)
            # Prints aggregation (optional): compress prints by (side, price_bucket, time_slice).
            # This reduces duplicates and keeps bubbles aligned to the compressed ladder rows.
            try:
                agg_enabled = bool(globals().get('PRINTS_AGG_ENABLED', False))  # aggregation ON/OFF
            except Exception:
                agg_enabled = False
            try:
                agg_window_ms = float(globals().get('PRINTS_AGG_WINDOW_MS', 250) or 250)
            except Exception:
                agg_window_ms = 250.0
            if agg_window_ms <= 0:
                agg_window_ms = 250.0

            batch = []
            for _ in range(spawn_count):
                try:
                    batch.append(self._pending.pop())
                except Exception:
                    break

            if agg_enabled and batch:
                bins = {}
                # Aggregate regardless of arrival ordering
                for it in batch:
                    try:
                        side0 = self._side_norm(it)
                    except Exception:
                        side0 = ''
                    if side0 not in ('BUY', 'SELL'):
                        side0 = side0 or ''
                    try:
                        ts0 = self._ts_ms(it)
                    except Exception:
                        ts0 = 0.0
                    try:
                        slice_id = int(ts0 // agg_window_ms) if ts0 and agg_window_ms else 0
                    except Exception:
                        slice_id = 0
                    try:
                        price0 = float(it.get('price') or 0.0)
                    except Exception:
                        price0 = 0.0
                    try:
                        tick0 = float(self._tick or 0.0)
                    except Exception:
                        tick0 = 0.0
                    if tick0 > 0 and price0 > 0:
                        try:
                            b0 = int(math.floor((price0 / tick0) + 1e-12))
                        except Exception:
                            b0 = 0
                    else:
                        b0 = 0
                    key = (side0, b0, slice_id)
                    try:
                        q0 = float(it.get('qty') or 0.0)
                    except Exception:
                        q0 = 0.0
                    if q0 <= 0:
                        continue
                    if key not in bins:
                        bins[key] = {'qty': 0.0, 'notional': 0.0, 'count': 0, 'sample': it, 'bucket': b0, 'side': side0}
                    acc = bins[key]
                    acc['qty'] += float(q0)
                    if price0 > 0:
                        acc['notional'] += float(q0) * float(price0)
                    acc['count'] += 1

                # Emit one aggregated print per bin
                for (side0, b0, slice_id), acc in bins.items():
                    try:
                        qty_sum = float(acc.get('qty') or 0.0)
                    except Exception:
                        qty_sum = 0.0
                    if qty_sum <= 0:
                        continue
                    try:
                        tick0 = float(self._tick or 0.0)
                    except Exception:
                        tick0 = 0.0
                    try:
                        price_bucket = float(b0) * float(tick0) if tick0 > 0 else float((acc.get('sample') or {}).get('price') or 0.0)
                    except Exception:
                        price_bucket = float((acc.get('sample') or {}).get('price') or 0.0)
                    # If notional is available, use VWAP inside the bucket for better sizing
                    try:
                        notional_sum = float(acc.get('notional') or 0.0)
                    except Exception:
                        notional_sum = 0.0
                    if notional_sum > 0 and qty_sum > 0 and tick0 > 0:
                        try:
                            vwap = notional_sum / qty_sum
                            # Keep it inside the same bucket
                            price_use = price_bucket
                        except Exception:
                            price_use = price_bucket
                    else:
                        price_use = price_bucket

                    try:
                        base = dict(acc.get('sample') or {})
                    except Exception:
                        base = {}
                    base['side'] = side0
                    base['qty'] = float(qty_sum)
                    base['price'] = float(price_use)
                    base['agg_count'] = int(acc.get('count') or 1)
                    self._add_print(base)
            else:
                # No aggregation: spawn each print as-is
                for it in batch:
                    self._add_print(it)
        if not self._prints:
            return
        # Read speed settings
        try:
            speed_setting = (float(globals().get("PRINTS_SPEED_MULT")) if globals().get("PRINTS_SPEED_MULT") is not None else 1.0)
        except Exception:
            speed_setting = 1.0
        try:
            auto_flag = bool(globals().get("PRINTS_SPEED_AUTO", False))
        except Exception:
            auto_flag = False

        # Always compute real-time prints flow for UI (speedometer), regardless of AUTO/FIXED mode
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            window_s = float(globals().get("PRINTS_AUTO_RATE_WINDOW_S", 5.0) or 5.0)
        except Exception:
            window_s = 5.0
        if window_s <= 0:
            window_s = 5.0
        try:
            while self._rate_marks and (now_m - float(self._rate_marks[0])) > window_s:
                self._rate_marks.popleft()
            cnt = int(len(self._rate_marks))
        except Exception:
            cnt = 0
        try:
            rate = float(cnt) / float(window_s)
        except Exception:
            rate = 0.0

        # Save stats for the main UI label
        self._last_rate_count = int(cnt)
        self._last_rate_window_s = float(window_s)
        self._last_rate_per_s = float(rate)


        # AUTO speed: map prints flow to speed multiplier (0.65 == ~1 print/s baseline), clamped to [PRINTS_SPEED_MIN .. PRINTS_SPEED_MAX]
        auto_mult = None
        try:
            speed_max = float(globals().get('PRINTS_SPEED_MAX', 2.5) or 2.5)
        except Exception:
            speed_max = 2.5
        if speed_max <= 0:
            speed_max = 2.5
        try:
            speed_min = float(globals().get('PRINTS_SPEED_MIN', 0.35) or 0.35)
        except Exception:
            speed_min = 0.7
        if speed_min <= 0:
            speed_min = 0.7

        if auto_flag:
            # Linear mapping by prints count over the rate window (default 5s).
            # Requirement: minimal speed at 1 print / 5s, maximal speed at 200 prints / 5s.
            try:
                target_win = 5.0
            except Exception:
                target_win = 5.0
            try:
                count_5s = float(cnt) * (target_win / float(window_s))
            except Exception:
                count_5s = float(cnt)
            try:
                c_min = float(globals().get('PRINTS_AUTO_COUNT_MIN_5S', 1.0) or 1.0)
                c_max = float(globals().get('PRINTS_AUTO_COUNT_MAX_5S', 200.0) or 200.0)
            except Exception:
                c_min, c_max = 1.0, 200.0
            if c_max <= c_min:
                c_max = c_min + 1.0
            try:
                s_min = float(globals().get('PRINTS_AUTO_SPEED_MIN', 0.65) or 0.65)
            except Exception:
                s_min = 0.7
            try:
                s_max = float(globals().get('PRINTS_SPEED_MAX', 2.5) or 2.5)
            except Exception:
                s_max = 2.5
            if s_max <= s_min:
                s_max = s_min + 0.1

            try:
                if count_5s <= c_min:
                    auto_mult = float(s_min)
                else:
                    t_lin = (min(float(count_5s), float(c_max)) - float(c_min)) / (float(c_max) - float(c_min))
                    auto_mult = float(s_min) + float(t_lin) * (float(s_max) - float(s_min))
            except Exception:
                auto_mult = float(s_min)

            # Clamp and smooth AUTO speed to avoid jitter
            if auto_mult < speed_min:
                auto_mult = speed_min
            if auto_mult > speed_max:
                auto_mult = speed_max

            try:
                last_auto = float(getattr(self, '_auto_speed_smooth', auto_mult) or auto_mult)
            except Exception:
                last_auto = auto_mult
            last_auto = (last_auto * 0.80) + (auto_mult * 0.20)
            self._auto_speed_smooth = last_auto
            speed_mult = float(last_auto)
        else:
            # FIXED speed mode
            try:
                speed_mult = float(speed_setting)
            except Exception:
                speed_mult = 1.0
            if speed_mult < speed_min:
                speed_mult = speed_min
            if speed_mult > speed_max:
                speed_mult = speed_max

        # Keep a mild density boost only in AUTO mode (speed=0).
        if auto_flag:
            target_density = 1.0
            try:
                target_density += min(1.0, len(self._prints) / 120.0) * 0.25
            except Exception:
                pass
            if self._smooth_density is None:
                self._smooth_density = target_density
            else:
                self._smooth_density = (self._smooth_density * 0.85) + (target_density * 0.15)
            density_boost = self._smooth_density
        else:
            density_boost = 1.0
        # Grab row height once for diagonal motion in row-space.
        try:
            row_h = float(self._row_height or 1.0)
        except Exception:
            row_h = 1.0
        if self._book_table is not None:
            try:
                row_h = float(self._book_table.rowHeight(0) or row_h)
            except Exception:
                pass
        if row_h <= 0.1:
            row_h = 1.0

        keep = []
        try:
            ref_one = float(globals().get('PRINTS_SPEED_REF_ONE', 0.65) or 0.65)
        except Exception:
            ref_one = 0.65
        if ref_one <= 0:
            ref_one = 0.65
        try:
            eff_mult = float(speed_mult) / float(ref_one)
        except Exception:
            eff_mult = float(speed_mult)
        try:
            corr = int(globals().get('PRINTS_TAPE_CORRIDOR_ROWS', 3) or 3)
        except Exception:
            corr = 3
        try:
            start_price = float(self._start_price) if self._start_price is not None else None
        except Exception:
            start_price = None
        try:
            tick = float(self._tick) if self._tick is not None else None
        except Exception:
            tick = None
        best_bid = self._best_bid
        best_ask = self._best_ask
        lo = hi = None
        if corr > 0 and start_price is not None and tick and tick > 0 and (best_bid is not None or best_ask is not None):
            try:
                if (best_bid is not None) and (best_ask is not None):
                    spread_ref = (float(best_bid) + float(best_ask)) / 2.0
                else:
                    spread_ref = float(best_bid) if best_bid is not None else float(best_ask)
                spread_row = self._row_for_price(spread_ref, start_key=getattr(self, "_start_key", None), tick=tick, start_price=start_price)
                if spread_row is None:
                    spread_row = float((start_price - spread_ref) / tick)
                lo = spread_row - float(corr)
                hi = spread_row + float(corr)
            except Exception:
                lo = hi = None
        # Draw order: small prints first, big prints last (big always on top)
        _draw_list = self._prints
        try:
            if len(_draw_list) > 1:
                _draw_list = sorted(_draw_list, key=lambda _p: float(_p.get('r', 0.0) or 0.0))
        except Exception:
            _draw_list = self._prints
        for p in _draw_list:
            dx = float(p.get('speed', self._base_speed)) * eff_mult * dt * density_boost
            p['x'] -= dx

            # Diagonal movement: start at spread row and drift toward the real trade row.
            # We compute the target row from the current viewport mapping each frame.
            try:
                if start_price is not None and tick and tick > 0 and p.get('price') is not None:
                    target_row = self._row_for_price(p.get('price'), start_key=getattr(self, "_start_key", None), tick=tick, start_price=start_price)
                    if target_row is None:
                        target_row = float((start_price - float(p.get('price'))) / tick)
                    if lo is not None and hi is not None:
                        if target_row < lo:
                            target_row = lo
                        elif target_row > hi:
                            target_row = hi

                    # Keep prints locked to the row where they were spawned (no drift / re-targeting).
                    p['row_f'] = float(p.get('row_f', target_row))
            except Exception:
                pass

            if p['x'] + p['r'] >= 0:
                keep.append(p)
        self._prints = keep
        try:
            if bool(globals().get('PRINTS_FORCE_REPAINT', False)) and int(globals().get('PRINTS_TAPE_FRAME_MS', 0) or 0) == 0:
                self.repaint()
            else:
                self.update()
        except Exception:
            self.update()

    def _format_qty(self, qty, usd=False):
        """Short label inside a print bubble.

        Notes:
        - Dollar sign removed (user preference + better fit)
        - No thousand separators
        - Shorter formatting for large values to keep text inside the bubble
        - If usd=True: round to integers (no decimal point)
        """
        try:
            val = abs(float(qty))
        except Exception:
            return ""

        # USD values: integer-only output (no decimal point)
        if usd:
            try:
                if val >= 1_000_000:
                    return f"{int(round(val / 1_000_000.0))}m"
                if val >= 1_000:
                    return f"{int(round(val / 1_000.0))}k"
                return str(int(round(val)))
            except Exception:
                return ""

        def _trim_num(s: str) -> str:
            s = s.rstrip("0").rstrip(".")
            return s if s else "0"

        if val >= 1_000_000:
            return f"{_trim_num(f'{val / 1_000_000:.0f}')}m"
        if val >= 100_000:
            return f"{_trim_num(f'{val / 1_000:.0f}')}k"
        if val >= 10_000:
            return f"{_trim_num(f'{val / 1_000:.1f}')}k"
        if val >= 1_000:
            return f"{_trim_num(f'{val / 1_000:.1f}')}k"
        if val >= 100:
            return _trim_num(f"{val:.0f}")
        if val >= 10:
            return _trim_num(f"{val:.1f}")
        if val >= 1:
            return _trim_num(f"{val:.2f}")
        return _trim_num(f"{val:.3f}")

    def _paint_frame(self, painter):
        # Clear background every frame (prevents ghost trails and keeps theme-consistent)
        try:
            bg = None
            if self._book_table is not None:
                try:
                    bg = self._book_table.palette().color(QPalette.Base)
                except Exception:
                    bg = None
            if bg is None:
                try:
                    bg = self.palette().color(QPalette.Window)
                except Exception:
                    bg = QColor(0, 0, 0)
            painter.fillRect(self.rect(), bg)
        except Exception:
            pass

        try:
            overload_at = int(globals().get("PRINTS_OVERLOAD_AT", 140) or 140)
        except Exception:
            overload_at = 140
        overload = overload_at > 0 and len(self._prints) >= overload_at
        painter.setRenderHint(QPainter.Antialiasing, False)
        try:
            painter.setRenderHint(QPainter.TextAntialiasing, False)
        except Exception:
            pass
        try:
            painter.setRenderHint(QPainter.SmoothPixmapTransform, False)
        except Exception:
            pass
        outline_pen = getattr(self, '_outline_pen', None)
        if outline_pen is None:
            outline_pen = QPen(QColor(0, 0, 0, 230))
            try:
                outline_pen.setWidthF(1.0)
                outline_pen.setCosmetic(True)
            except Exception:
                pass
            self._outline_pen = outline_pen

        try:
            len_prints = int(len(self._prints))
        except Exception:
            len_prints = 0
        try:
            hide_at = int(globals().get("PRINTS_TEXT_HIDE_AT", 160) or 160)
        except Exception:
            hide_at = 160
        try:
            force_r = float(globals().get("PRINTS_TEXT_FORCE_RADIUS", 9.0) or 9.0)
        except Exception:
            force_r = 11.0
        try:
            sx_agg = float(globals().get('PRINTS_AGG_OVAL_X', 1.35) or 1.35)
        except Exception:
            sx_agg = 1.35
        try:
            sy_base_agg = float(globals().get('PRINTS_AGG_OVAL_Y', 0.95) or 0.95)
        except Exception:
            sy_base_agg = 0.95
        try:
            sy_max_global = float(globals().get('PRINTS_AGG_OVAL_Y_MAX', sy_base_agg) or sy_base_agg)
        except Exception:
            sy_max_global = sy_base_agg
        if sy_max_global < sy_base_agg:
            sy_max_global = sy_base_agg
        sy_max_all = max(1.0, sy_max_global)

        try:
            row_h = float(self._row_height or 1.0)
        except Exception:
            row_h = 1.0
        scroll_val = 0.0
        if self._book_table is not None:
            try:
                row_h = float(self._book_table.rowHeight(0) or row_h)
            except Exception:
                row_h = float(self._row_height or 1.0)
            try:
                scroll_val = float(self._book_table.verticalScrollBar().value())
            except Exception:
                scroll_val = 0.0
            try:
                if self._book_table.verticalScrollMode() == QAbstractItemView.ScrollPerItem:
                    scroll_val *= row_h
            except Exception:
                pass

        # Image-mode external scroll override (use row-based offset instead of QTableView scroll).
        try:
            ext_rows = getattr(self, "_external_scroll_rows", None)
        except Exception:
            ext_rows = None
        if ext_rows is not None:
            try:
                if getattr(self, "_external_scroll_row_h", None):
                    row_h = float(self._external_scroll_row_h)
            except Exception:
                pass
            try:
                scroll_val = float(ext_rows) * float(row_h)
            except Exception:
                scroll_val = 0.0
        try:
            viewport_h = float(self.height() or 0.0)
        except Exception:
            viewport_h = 0.0
        try:
            text_min_usd = float(globals().get("PRINTS_TEXT_MIN_NOTIONAL_USD", 0.0) or 0.0)
        except Exception:
            text_min_usd = 0.0
        if text_min_usd < 0:
            text_min_usd = 0.0

        visible = []
        for p in self._prints:
            if not self._start_price or not self._tick:
                continue
            # Use animated row position when available.
            try:
                row_f = float(p.get('row_f'))
            except Exception:
                row_f = None
            if row_f is None:
                # Fallback to direct row mapping.
                try:
                    price = float(p.get('price'))
                    row_f = self._row_for_price(price)
                    if row_f is None:
                        row_f = float((self._start_price - price) / self._tick)
                except Exception:
                    continue
            try:
                if self._rows and self._rows > 0:
                    if row_f < -1.0 or row_f > float(self._rows) + 1.0:
                        continue
            except Exception:
                pass
            try:
                y = ((row_f + 0.5) * row_h) - scroll_val
            except Exception:
                y = (row_f * (self._row_height or 1.0)) + ((self._row_height or 1.0) / 2.0)
            if y < -p['r'] or y > (viewport_h + p['r']):
                continue
            visible.append((p, y))

        if len(visible) > 1:
            try:
                line_pen = getattr(self, '_prints_link_pen', None)
                if line_pen is None:
                    line_pen = QPen(QColor(150, 150, 150, 90))
                    try:
                        line_pen.setWidthF(1.5)
                        line_pen.setCosmetic(True)
                    except Exception:
                        pass
                    self._prints_link_pen = line_pen
            except Exception:
                line_pen = None
            if line_pen is not None:
                try:
                    painter.setPen(line_pen)
                    painter.setBrush(Qt.NoBrush)
                    try:
                        points = sorted(visible, key=lambda it: float(it[0].get('x', 0.0) or 0.0))
                    except Exception:
                        points = visible
                    prev_pt = None
                    for p, y in points:
                        try:
                            x = float(p.get('x', 0.0) or 0.0)
                        except Exception:
                            x = 0.0
                        cur_pt = QPointF(x, float(y))
                        if prev_pt is not None:
                            painter.drawLine(prev_pt, cur_pt)
                        prev_pt = cur_pt
                except Exception:
                    pass

        for p, y in visible:
            painter.setBrush(p['color'])
            if overload:
                painter.setPen(Qt.NoPen)
            else:
                painter.setPen(outline_pen)
            # Aggregated prints are drawn as slightly stretched ovals (easier to spot)
            try:
                agg_n = int(p.get('agg_count', 1) or 1)
            except Exception:
                agg_n = 1
            try:
                boost = float(p.get("agg_boost", None))
            except Exception:
                boost = None
            if boost is None:
                try:
                    boost = float(getattr(self, "_book_shift_boost", 0.0) or 0.0)
                except Exception:
                    boost = 0.0
            if boost < 0.0:
                boost = 0.0
            if boost > 1.0:
                boost = 1.0
            if agg_n > 1:
                sx = sx_agg
                sy_base = sy_base_agg
                sy_max = sy_max_global
            else:
                sx = 1.0
                sy_base = 1.0
                sy_max = sy_max_all
            sy = sy_base + (sy_max - sy_base) * boost
            rx = float(p['r']) * float(sx)
            ry = float(p['r']) * float(sy)
            painter.drawEllipse(QPointF(p['x'], y), rx, ry)
            text = p.get('text') or ""
            # Hide text when overloaded to keep FPS high.
            show_text = bool(text) and not overload and (hide_at <= 0 or len_prints < hide_at or float(p.get('r', 0.0)) >= force_r)
            if show_text and text_min_usd > 0:
                try:
                    notional_val = float(p.get('notional', 0.0) or 0.0)
                except Exception:
                    notional_val = 0.0
                if notional_val < text_min_usd:
                    show_text = False
            if show_text:
                try:
                    # Fit the font size so text always stays inside the bubble.
                    fit_pt = p.get('fit_pt')
                    if (fit_pt is None) or (p.get('fit_text') != text):
                        # Fast font sizing: avoid per-bubble scanning with QFontMetrics (big FPS win).
                        try:
                            r0 = float(p.get('r', 0.0))
                        except Exception:
                            r0 = 0.0
                        try:
                            base_pt = int(max(5, min(18, r0 * 0.70)))
                        except Exception:
                            base_pt = 10
                        try:
                            ln = max(1, len(text))
                            if ln >= 5:
                                base_pt = max(5, int(base_pt * (4.0 / float(ln)) * 1.05))
                        except Exception:
                            pass
                        p['fit_pt'] = base_pt
                        p['fit_text'] = text
                        fit_pt = base_pt

                    if fit_pt is not None:
                        pt_i = int(fit_pt)
                        font = self._font_cache.get(pt_i)
                        if font is None:
                            font = QFont()
                            font.setBold(False)
                            font.setPointSizeF(float(pt_i))
                            if len(self._font_cache) >= 24:
                                self._font_cache.clear()
                            self._font_cache[pt_i] = font
                        painter.setFont(font)
                        painter.setPen(self._text_color)
                        # Static text cache (glyph caching)
                        try:
                            cache = getattr(self, '_static_text_cache', None)
                            if cache is None:
                                cache = {}
                                self._static_text_cache = cache
                            key = (text, pt_i)
                            st = cache.get(key)
                            if st is None:
                                st = QStaticText(text)
                                try:
                                    st.setPerformanceHint(QStaticText.AggressiveCaching)
                                except Exception:
                                    pass
                                # Prepare once per (text,font) for accurate size + faster draw
                                try:
                                    st.prepare(QTransform(), font)
                                except Exception:
                                    pass
                                if len(cache) >= 256:
                                    cache.clear()
                                cache[key] = st
                            try:
                                sz = st.size()
                                dx = float(sz.width()) * 0.5
                                dy = float(sz.height()) * 0.5
                            except Exception:
                                dx = dy = 0.0
                            painter.drawStaticText(QPointF(p['x'] - dx, y - dy), st)
                        except Exception:
                            rect = QRectF(p['x'] - p['r'], y - p['r'], p['r'] * 2.0, p['r'] * 2.0)
                            painter.drawText(rect, Qt.AlignCenter, text)
                except Exception:
                    pass
        try:
            markers = list(getattr(self, "_order_markers", None) or [])
        except Exception:
            markers = []
        if markers and self._start_price and self._tick:
            try:
                self._order_marker_hits = []
            except Exception:
                self._order_marker_hits = []
            try:
                start_key = getattr(self, "_start_key", None)
                if start_key is None:
                    start_key = int(round(float(self._start_price) / float(self._tick)))
            except Exception:
                start_key = None
            try:
                marker_font_pt = int(max(9, min(14, float(row_h) * 0.80)))
            except Exception:
                marker_font_pt = 10
            marker_font = getattr(self, "_order_marker_font", None)
            if marker_font is None or marker_font_pt != getattr(self, "_order_marker_font_pt", None):
                marker_font = QFont()
                marker_font.setBold(True)
                marker_font.setPointSizeF(float(marker_font_pt))
                self._order_marker_font = marker_font
                self._order_marker_font_pt = marker_font_pt
                try:
                    self._order_marker_text_cache.clear()
                except Exception:
                    self._order_marker_text_cache = {}
            try:
                painter.setFont(marker_font)
            except Exception:
                pass
            try:
                marker_color = self.palette().color(QPalette.Text)
                if marker_color is None:
                    marker_color = QColor(220, 220, 220, 220)
            except Exception:
                marker_color = QColor(220, 220, 220, 220)
            try:
                marker_pen = getattr(self, "_order_marker_pen", None)
                if marker_pen is None or marker_pen.color() != marker_color:
                    marker_pen = QPen(marker_color)
                    try:
                        marker_pen.setCosmetic(True)
                    except Exception:
                        pass
                    self._order_marker_pen = marker_pen
            except Exception:
                marker_pen = QPen(QColor(220, 220, 220, 220))
            try:
                painter.setPen(marker_pen)
            except Exception:
                pass
            try:
                painter.setBrush(Qt.NoBrush)
            except Exception:
                pass
            try:
                edge_pad = 12.0
            except Exception:
                edge_pad = 12.0
            try:
                x_right = float(self.width() or 0.0) - float(edge_pad)
            except Exception:
                x_right = 0.0
            try:
                cache = getattr(self, "_order_marker_text_cache", None)
                if cache is None:
                    cache = {}
                    self._order_marker_text_cache = cache
            except Exception:
                cache = {}
            for it in markers:
                try:
                    price = float(it.get("price"))
                except Exception:
                    continue
                text = str(it.get("text") or "x")
                try:
                    if start_key is not None:
                        key = int(round(float(price) / float(self._tick)))
                        row_f = float(start_key - key)
                    else:
                        row_f = self._row_for_price(price)
                        if row_f is None:
                            row_f = float((self._start_price - price) / self._tick)
                except Exception:
                    continue
                y = ((row_f + 0.5) * row_h) - scroll_val
                if y < -row_h or y > (viewport_h + row_h):
                    continue
                key = (text, marker_font_pt)
                st = cache.get(key)
                if st is None:
                    st = QStaticText(text)
                    try:
                        st.setPerformanceHint(QStaticText.AggressiveCaching)
                    except Exception:
                        pass
                    try:
                        st.prepare(QTransform(), marker_font)
                    except Exception:
                        pass
                    if len(cache) >= 128:
                        cache.clear()
                    cache[key] = st
                try:
                    sz = st.size()
                    tw = float(sz.width())
                    th = float(sz.height())
                except Exception:
                    tw = th = 0.0
                x_left = x_right - tw - 2.0
                try:
                    hit_h = max(float(th) + 4.0, float(row_h) * 0.90)
                except Exception:
                    hit_h = float(th) + 4.0
                try:
                    hit_w = max(float(tw) + 12.0, 52.0)
                except Exception:
                    hit_w = float(tw) + 12.0
                try:
                    x_left_hit = max(0.0, float(x_right) - float(hit_w) - 2.0)
                except Exception:
                    x_left_hit = x_left - 6.0
                rect = QRectF(x_left_hit, y - (hit_h / 2.0), max(4.0, float(x_right) - float(x_left_hit) + 2.0), hit_h)
                try:
                    payload = {"price": price, "order_ids": list(it.get("order_ids") or []), "algo_ids": list(it.get("algo_ids") or [])}
                    self._order_marker_hits.append((rect, payload))
                except Exception:
                    pass
                try:
                    painter.drawStaticText(QPointF(x_left, y - (th / 2.0)), st)
                except Exception:
                    pass
        else:
            try:
                self._order_marker_hits = []
            except Exception:
                pass
    def paintEvent(self, event):
        painter = QPainter(self)
        self._paint_frame(painter)
        painter.end()


class BookRulerOverlay(QWidget):
    """Single overlay that draws the book ruler line and optional text."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self._line = None  # (x0, x1, y, h)
        self._text = ""
        self._text_rect = None
        self._bg_color = QColor(30, 120, 255, 80)
        self._text_color = QColor(255, 255, 255, 240)
        try:
            self.setAttribute(Qt.WA_TransparentForMouseEvents, True)
            self.setAttribute(Qt.WA_TranslucentBackground, True)
            self.setAttribute(Qt.WA_NoSystemBackground, True)
            self.setAutoFillBackground(False)
        except Exception:
            pass
        self.hide()

    def update_ruler(self, x0, x1, y, h, text="", text_rect=None):
        try:
            self._line = (float(x0), float(x1), float(y), float(h))
        except Exception:
            self._line = None
        self._text = text or ""
        self._text_rect = text_rect
        try:
            if self._line:
                self.show()
                self.update()
            else:
                self.hide()
        except Exception:
            pass

    def clear(self):
        self._line = None
        self._text = ""
        self._text_rect = None
        try:
            self.hide()
        except Exception:
            pass

    def paintEvent(self, event):
        if not self._line:
            return
        try:
            x0, x1, y, h = self._line
        except Exception:
            return
        if x1 < x0:
            x0, x1 = x1, x0
        if (x1 - x0) <= 1 or h <= 0:
            return
        p = QPainter(self)
        try:
            p.fillRect(QRectF(x0, y, x1 - x0, h), self._bg_color)
            if self._text and self._text_rect:
                p.setPen(self._text_color)
                p.drawText(self._text_rect, Qt.AlignLeft | Qt.AlignVCenter, self._text)
        except Exception:
            pass
        p.end()


ORDERBOOK_COL_VOL = 0
ORDERBOOK_COL_PRICE = 1
OB_ROW_VOL_TEXT = 0
OB_ROW_PRICE_TEXT = 1
OB_ROW_VOL_FG = 2
OB_ROW_PRICE_FG = 3
OB_ROW_VOL_BG = 4
OB_ROW_PRICE_BG = 5
OB_ROW_BAR_FRAC = 6
OB_ROW_BAR_COLOR = 7
OB_ROW_VOL_BASE_BG = 8
OB_ROW_VOL_BRUSH = 9
OB_ROW_PRICE_VALUE = 10
OB_ROW_STYLE_FLAGS = 11
OB_ROW_SIG = 12  # cached signature for fast row diffing

OB_STYLE_BOLD_PRICE = 1   # bold the PRICE cell
OB_STYLE_BOLD_ALL   = 2   # bold BOTH cells (e.g., best bid/ask)


def _hex_to_rgb_tuple(value):
    try:
        s = str(value or "").strip().lstrip("#")
        if len(s) == 3:
            s = "".join([c * 2 for c in s])
        if len(s) != 6:
            return None
        return int(s[0:2], 16), int(s[2:4], 16), int(s[4:6], 16)
    except Exception:
        return None


def _color_is_light_hex(value):
    rgb = _hex_to_rgb_tuple(value)
    if not rgb:
        return False
    r, g, b = rgb
    return (0.299 * r + 0.587 * g + 0.114 * b) >= 160


def _ensure_rgba_tuple(value, default_alpha=255):
    if value is None:
        return None
    try:
        if isinstance(value, tuple) or isinstance(value, list):
            if len(value) == 4:
                return int(value[0]), int(value[1]), int(value[2]), int(value[3])
            if len(value) == 3:
                return int(value[0]), int(value[1]), int(value[2]), int(default_alpha)
    except Exception:
        pass
    try:
        if isinstance(value, QColor):
            return value.red(), value.green(), value.blue(), value.alpha()
    except Exception:
        pass
    return None


def _rgba_to_qcolor(value):
    rgba = _ensure_rgba_tuple(value)
    if not rgba:
        return None
    try:
        key = (int(rgba[0]), int(rgba[1]), int(rgba[2]), int(rgba[3]))
    except Exception:
        key = None
    cache = getattr(_rgba_to_qcolor, "_cache", None)
    if cache is None:
        cache = {}
        _rgba_to_qcolor._cache = cache
    if key is not None:
        cached = cache.get(key)
        if cached is not None:
            return cached
    r, g, b, a = rgba
    q = QColor(int(r), int(g), int(b))
    try:
        q.setAlpha(int(a))
    except Exception:
        pass
    if key is not None:
        if len(cache) >= 256:
            cache.clear()
        cache[key] = q
    return q


def _orderbook_render_raw(payload):
    def _infer_tick_from_levels(local_bids, local_asks, limit=80):
        prices = []
        try:
            for price, _ in (local_bids or [])[:limit]:
                prices.append(float(price))
        except Exception:
            pass
        try:
            for price, _ in (local_asks or [])[:limit]:
                prices.append(float(price))
        except Exception:
            pass
        if len(prices) < 2:
            return None
        try:
            prices = sorted(set(prices))
        except Exception:
            return None
        min_diff = None
        try:
            for i in range(1, len(prices)):
                diff = prices[i] - prices[i - 1]
                if diff > 0 and (min_diff is None or diff < min_diff):
                    min_diff = diff
        except Exception:
            return None
        return min_diff if min_diff and min_diff > 0 else None

    payload = payload or {}
    bids = payload.get("bids") or []
    asks = payload.get("asks") or []
    try:
        theme_light = bool(payload.get("theme_light", False))
    except Exception:
        theme_light = False

    bid_color = (46, 204, 113, 255)
    ask_color = (231, 76, 60, 255)
    bid_bg = (120, 230, 170, 65)  # lighter green bg for readability
    ask_bg = (245, 160, 150, 65)  # lighter red bg for readability
    best_bid_bg = (120, 230, 170, 150)
    best_ask_bg = (245, 160, 150, 150)
    if theme_light:
        bar_color = (70, 70, 70, 255)
        bar_text_color = (245, 245, 245, 255)
    else:
        bar_color = (255, 255, 255, 255)
        bar_text_color = (20, 20, 20, 255)
    transparent = (0, 0, 0, 0)
    pending_color = (243, 156, 18, 255)
    pending_bg = (243, 156, 18, 90)
    tp_color = (52, 152, 219, 255)
    tp_bg = (52, 152, 219, 70)
    sl_color = (231, 76, 60, 255)
    sl_bg = (231, 76, 60, 90)
    order_buy_bg = (46, 204, 113, 90)
    order_sell_bg = (231, 76, 60, 90)
    order_reduce_bg = (52, 152, 219, 90)
    order_mixed_bg = (149, 165, 166, 90)
    level_bg = (150, 150, 150, 70)
    pnl_gain_bg = (0, 255, 0, 120)
    pnl_loss_bg = (255, 0, 0, 120)

    p_prec = payload.get("p_prec", 2)
    q_prec = payload.get("q_prec", 3)
    try:
        vol_in_usd = bool(payload.get("vol_in_usd", globals().get("ORDERBOOK_VOL_IN_USD", False)))
    except Exception:
        vol_in_usd = False
    try:
        vol_compact = bool(payload.get("vol_compact", globals().get("ORDERBOOK_VOL_COMPACT", False)))
    except Exception:
        vol_compact = False

    def _format_num(val, decimals):
        try:
            text = f"{float(val):.{int(decimals)}f}"
        except Exception:
            return str(val)
        if "." in text:
            text = text.rstrip("0").rstrip(".")
        return text

    def _format_compact(val):
        try:
            val_f = float(val)
        except Exception:
            return str(val)
        abs_val = abs(val_f)
        if abs_val >= 1_000_000:
            return f"{_format_num(val_f / 1_000_000.0, 2)}M"
        if abs_val >= 1_000:
            return f"{_format_num(val_f / 1_000.0, 2)}K"
        return _format_num(val_f, 2 if vol_in_usd else q_prec)

    def _format_usd_compact(val):
        try:
            val_f = float(val)
        except Exception:
            return str(val)
        abs_val = abs(val_f)
        if abs_val >= 1_000_000:
            return f"{_format_num(val_f / 1_000_000.0, 2)}M"
        if abs_val >= 1_000:
            return f"{_format_num(val_f / 1_000.0, 2)}K"
        return _format_num(val_f, 2)
    try:
        current_mult = int(payload.get("tick_mult", globals().get("ORDERBOOK_TICK_MULT", 1) or 1) or 1)
    except Exception:
        current_mult = 1
    if current_mult < 1:
        current_mult = 1
    try:
        base_tick = float(payload.get("book_tick_base", 0.0) or 0.0)
    except Exception:
        base_tick = 0.0
    inferred = None
    try:
        inferred = _infer_tick_from_levels(bids, asks)
    except Exception:
        inferred = None
    if base_tick <= 0:
        if inferred and inferred > 0:
            base_tick = float(inferred)
    if base_tick <= 0:
        try:
            base_tick = 10 ** (-int(p_prec))
        except Exception:
            base_tick = 0.0
    tick = float(base_tick) * float(current_mult) if base_tick > 0 else 0.0
    book_tick = tick if tick and tick > 0 else 0.0

    auto_best_bid = None
    auto_best_ask = None
    try:
        for price, _ in bids or []:
            price_f = float(price)
            if auto_best_bid is None or price_f > auto_best_bid:
                auto_best_bid = price_f
    except Exception:
        pass
    try:
        for price, _ in asks or []:
            price_f = float(price)
            if auto_best_ask is None or price_f < auto_best_ask:
                auto_best_ask = price_f
    except Exception:
        pass

    auto_visible_rows = payload.get("visible_rows")
    try:
        if auto_visible_rows is not None:
            auto_visible_rows = int(auto_visible_rows)
            if auto_visible_rows < 10:
                auto_visible_rows = None
    except Exception:
        auto_visible_rows = None
    try:
        row_h = int(payload.get("row_height", ORDERBOOK_ROW_HEIGHT) or ORDERBOOK_ROW_HEIGHT)
    except Exception:
        try:
            row_h = int(ORDERBOOK_ROW_HEIGHT or 16)
        except Exception:
            row_h = 16
    try:
        book_autotick_pending = bool(payload.get("book_autotick_pending", False))
    except Exception:
        book_autotick_pending = False
    auto_tick_mult = None

    def _price_key(val):
        try:
            if tick and tick > 0:
                return int(round(float(val) / tick))
        except Exception:
            pass
        try:
            return int(round(float(val) * (10 ** int(p_prec))))
        except Exception:
            return None

    sym = (payload.get("symbol") or payload.get("s") or "").upper()
    pending_key = None
    sl_key = None
    tp_keys = set()
    entry_price = payload.get("entry_price")
    pos_side = payload.get("pos_side")
    entry_key = None
    entry_marker = None
    pnl_low_key = None
    pnl_high_key = None
    pnl_bg = None

    pending_price = payload.get("pending_price")
    has_pending = bool(payload.get("has_pending", False))
    if pending_price is not None and pending_price not in (0, ""):
        try:
            pending_price = float(pending_price)
            if not has_pending:
                has_pending = True
        except Exception:
            pending_price = None
    if has_pending and pending_price:
        pending_key = _price_key(pending_price)

    level_price = payload.get("level_price")
    level_key = None
    if level_price not in (None, "", 0):
        try:
            level_key = _price_key(float(level_price))
        except Exception:
            level_key = None

    sl_price = payload.get("sl_price")
    if sl_price not in (None, "", 0):
        try:
            sl_key = _price_key(float(sl_price))
        except Exception:
            sl_key = None

    try:
        if entry_price not in (None, "", 0):
            entry_price = float(entry_price)
    except Exception:
        entry_price = None
    pos_side = (pos_side or "").upper() if pos_side else None
    if entry_price and pos_side in ("LONG", "SHORT"):
        entry_key = _price_key(entry_price)
        entry_marker = "^" if pos_side == "LONG" else "v"

    try:
        tp_list = list(payload.get("tp_prices") or [])
    except Exception:
        tp_list = []
    for item in tp_list:
        try:
            tp_key = _price_key(float(item))
        except Exception:
            tp_key = None
        if tp_key is not None:
            tp_keys.add(tp_key)

    order_keys = {}
    try:
        order_levels = list(payload.get("order_levels") or [])
    except Exception:
        order_levels = []
    for item in order_levels:
        try:
            price_val = float(item.get("price"))
        except Exception:
            continue
        key = _price_key(price_val)
        if key is None:
            continue
        info = order_keys.get(key)
        if info is None:
            info = {"buy": 0, "sell": 0, "reduce": 0, "total": 0, "kinds": {}, "notional": 0.0, "order_ids": set(), "algo_ids": set()}
            order_keys[key] = info
        side = str(item.get("side") or "").upper()
        if side == "BUY":
            info["buy"] += 1
        elif side == "SELL":
            info["sell"] += 1
        try:
            if bool(item.get("reduce_only") or item.get("close_position")):
                info["reduce"] += 1
        except Exception:
            pass
        # classify order type for more informative markers
        otype = str(item.get("type") or item.get("origType") or item.get("orderType") or "").upper()
        kind = "O"
        if otype in ("TAKE_PROFIT", "TAKE_PROFIT_MARKET"):
            kind = "TP"
        elif otype in ("STOP", "STOP_MARKET"):
            kind = "ST"
        elif otype in ("TRAILING_STOP_MARKET",):
            kind = "TS"
        elif otype in ("LIMIT", "LIMIT_MAKER"):
            kind = "L"
        info["kinds"][kind] = int(info["kinds"].get(kind, 0)) + 1
        info["total"] += 1
        try:
            oid = item.get("order_id") or item.get("orderId") or item.get("id")
        except Exception:
            oid = None
        try:
            aid = item.get("algo_id") or item.get("algoId")
        except Exception:
            aid = None
        try:
            is_local = bool(item.get("local"))
        except Exception:
            is_local = False
        if oid not in (None, ""):
            try:
                if not is_local and aid in (None, ""):
                    info["order_ids"].add(str(oid))
            except Exception:
                pass
        if aid not in (None, ""):
            try:
                info["algo_ids"].add(str(aid))
            except Exception:
                pass
        try:
            n0 = item.get("notional")
        except Exception:
            n0 = None
        if n0 in (None, "", 0, 0.0, "0", "0.0"):
            try:
                qv = item.get("qty")
            except Exception:
                qv = None
            if qv not in (None, "", 0, 0.0, "0", "0.0"):
                try:
                    n0 = abs(float(qv) * float(price_val))
                except Exception:
                    n0 = None
        try:
            if n0 not in (None, "", 0, 0.0, "0", "0.0"):
                info["notional"] = float(info.get("notional") or 0.0) + abs(float(n0))
        except Exception:
            pass

    bid_map = {}
    ask_map = {}
    max_qty = 0.0
    best_bid = None
    best_ask = None
    # Persistent display cache (used for missing levels) - read-only lookup during render
    cache_bids = None
    cache_asks = None
    try:
        for price, qty in bids or []:
            key = _price_key(price)
            if key is None:
                continue
            qty_f = float(qty)
            if qty_f <= 0:
                continue
            bid_map[key] = bid_map.get(key, 0.0) + qty_f
            if best_bid is None or float(price) > float(best_bid):
                best_bid = float(price)
            if qty_f > max_qty:
                max_qty = qty_f
    except Exception:
        pass
    try:
        for price, qty in asks or []:
            key = _price_key(price)
            if key is None:
                continue
            qty_f = float(qty)
            if qty_f <= 0:
                continue
            ask_map[key] = ask_map.get(key, 0.0) + qty_f
            if best_ask is None or float(price) < float(best_ask):
                best_ask = float(price)
            if qty_f > max_qty:
                max_qty = qty_f
    except Exception:
        pass

    # --- Display cache: keep last known qty for price levels missing in the current update.
    # IMPORTANT: Per user requirement, cached levels are NEVER deleted.
    # We only overwrite cached values when a new value for the same price level arrives.
    cache_enabled = True
    try:
        cache_enabled = bool(globals().get('ORDERBOOK_DISPLAY_CACHE', True))
    except Exception:
        cache_enabled = True
    if cache_enabled and sym:
        # Display cache: keep last known qty for price levels missing in the current update.
        # SAFETY: clear cache when the price-keying scheme changes (tick compression / precision),
        # otherwise keys will accumulate forever and RAM will grow unbounded.
        now_ts = time.time()
        try:
            tick_key = (float(base_tick or 0.0), int(current_mult or 1), int(p_prec or 0))
        except Exception:
            tick_key = None
        try:
            with orderbook_display_cache_lock:
                cache = orderbook_display_cache.get(sym)
                if cache is None:
                    cache = {'bids': {}, 'asks': {}, '_tick_key': tick_key, '_prune_ts': 0.0}
                    orderbook_display_cache[sym] = cache
                else:
                    prev_tk = cache.get('_tick_key')
                    if tick_key is not None and prev_tk != tick_key:
                        # Reset when tick-mult/precision changes (prevents cache explosion).
                        cache['bids'] = {}
                        cache['asks'] = {}
                        cache['_tick_key'] = tick_key

                bids_cache = cache.get('bids')
                asks_cache = cache.get('asks')
                if bids_cache is None:
                    bids_cache = {}
                    cache['bids'] = bids_cache
                if asks_cache is None:
                    asks_cache = {}
                    cache['asks'] = asks_cache

                # update cache with current snapshot (overwrite values, never delete by default)
                for k, v in (bid_map or {}).items():
                    try:
                        bids_cache[k] = (float(v), now_ts)
                    except Exception:
                        continue
                for k, v in (ask_map or {}).items():
                    try:
                        asks_cache[k] = (float(v), now_ts)
                    except Exception:
                        continue

                # Optional safety cap (prune rarely, only when cache grows too large)
                try:
                    max_keys = int(globals().get('ORDERBOOK_CACHE_MAX_KEYS_PER_SIDE', 0) or 0)
                except Exception:
                    max_keys = 0
                if max_keys > 0 and (len(bids_cache) > max_keys or len(asks_cache) > max_keys):
                    try:
                        prune_iv = float(globals().get('ORDERBOOK_CACHE_PRUNE_SEC', 10.0) or 10.0)
                    except Exception:
                        prune_iv = 10.0
                    try:
                        last_pr = float(cache.get('_prune_ts', 0.0) or 0.0)
                    except Exception:
                        last_pr = 0.0
                    if (now_ts - last_pr) >= max(1.0, prune_iv):
                        def _prune(d):
                            try:
                                # Keep newest by timestamp
                                items = sorted(d.items(), key=lambda kv: float(kv[1][1] or 0.0), reverse=True)
                                return dict(items[:max_keys])
                            except Exception:
                                return d
                        if len(bids_cache) > max_keys:
                            cache['bids'] = _prune(bids_cache)
                            bids_cache = cache['bids']
                        if len(asks_cache) > max_keys:
                            cache['asks'] = _prune(asks_cache)
                            asks_cache = cache['asks']
                        cache['_prune_ts'] = now_ts

                # Keep references for O(visible_rows) lookup during row rendering.
                cache_bids = cache.get('bids')
                cache_asks = cache.get('asks')
        except Exception:
            pass

    # If current update didn't provide best bid/ask (rare), fall back to cached keys.
        try:
            if best_bid is None and cache_bids:
                mx_k = max(cache_bids.keys())
                best_bid = float(mx_k) * float(tick) if (tick and tick > 0) else float(mx_k) / float(10 ** int(p_prec))
            if best_ask is None and cache_asks:
                mn_k = min(cache_asks.keys())
                best_ask = float(mn_k) * float(tick) if (tick and tick > 0) else float(mn_k) / float(10 ** int(p_prec))
        except Exception:
            pass

    if best_bid is None and best_ask is None:
        return {
            "symbol": sym,
            "rows": [],
            "best_bid_row": None,
            "best_ask_row": None,
            "best_bid": None,
            "best_ask": None,
            "start_price": None,
            "tick": tick,
            "levels_total": 0,
            "book_tick_base": base_tick,
            "book_tick": book_tick,
            "book_start_price": None,
            "book_tick_used": 0.0,
            "book_levels_used": 0,
            "autotick_pending": book_autotick_pending,
            "auto_tick_mult": auto_tick_mult,
            "row_height": row_h,
            "clear": True,
            "raw_colors": True,
            "show_depth_bars": bool(payload.get("show_depth_bars", True)),
        }

    center_price = best_ask if best_ask is not None else best_bid
    if best_ask is not None and best_bid is not None:
        center_price = (best_ask + best_bid) / 2.0
    if tick and tick > 0:
        try:
            center_price = _round_to_tick(center_price, tick, p_prec)
        except Exception:
            pass
    try:
        levels_total = int(payload.get("levels_total") or globals().get("ORDERBOOK_LADDER_LEVELS", ORDERBOOK_LADDER_LEVELS) or ORDERBOOK_LADDER_LEVELS)
    except Exception:
        levels_total = int(ORDERBOOK_LADDER_LEVELS or 1000)
    if levels_total < 20:
        levels_total = 20
    try:
        if auto_visible_rows is not None:
            pad = int(globals().get("ORDERBOOK_VISIBLE_PAD", 40) or 40)
            if pad < 0:
                pad = 0
            target_levels = int(auto_visible_rows) + pad
            if target_levels < 20:
                target_levels = 20
            if bool(globals().get("ORDERBOOK_ADAPTIVE_LEVELS", False)):
                levels_total = min(levels_total, target_levels)
            else:
                levels_total = max(levels_total, target_levels)
    except Exception:
        pass
    try:
        if auto_visible_rows is None or auto_visible_rows < 10:
            auto_visible_rows = levels_total
    except Exception:
        pass
    if book_autotick_pending:
        auto_ready = False
        try:
            if not base_tick or base_tick <= 0:
                if tick and current_mult:
                    base_tick = float(tick) / float(current_mult)
            if base_tick and base_tick > 0 and auto_visible_rows and auto_visible_rows > 1:
                if auto_best_bid is not None or auto_best_ask is not None:
                    auto_center = auto_best_ask if auto_best_ask is not None else auto_best_bid
                    if auto_best_ask is not None and auto_best_bid is not None:
                        auto_center = (auto_best_ask + auto_best_bid) / 2.0
                    if auto_center and auto_center > 0:
                        try:
                            target_pct = float(payload.get("visible_range_pct", globals().get("ORDERBOOK_VISIBLE_RANGE_PCT", 3.0) or 3.0) or 3.0)
                        except Exception:
                            target_pct = 3.0
                        if target_pct <= 0:
                            target_pct = 3.0
                        target_range = float(auto_center) * (target_pct / 100.0)
                        target_tick = float(target_range) / float(max(auto_visible_rows - 1, 1))
                        target_mult = int(round(float(target_tick) / float(base_tick)))
                        if target_mult < 1:
                            target_mult = 1
                        if target_mult != current_mult:
                            auto_tick_mult = target_mult
                            current_mult = target_mult
                            tick = float(base_tick) * float(target_mult)
                            book_tick = tick if tick and tick > 0 else 0.0
                        auto_ready = True
        except Exception:
            pass
        if auto_ready:
            book_autotick_pending = False
    levels_above = levels_total // 2
    if not tick or tick <= 0:
        tick = 10 ** (-int(p_prec))
    book_tick = tick if tick and tick > 0 else 0.0
    start_price = None
    try:
        prev_start = payload.get("book_start_price")
        prev_tick = float(payload.get("book_tick_used", 0.0) or 0.0)
        prev_levels = int(payload.get("book_levels_used", 0) or 0)
    except Exception:
        prev_start = None
        prev_tick = 0.0
        prev_levels = 0
    reset_needed = False
    if prev_start is None or prev_tick <= 0 or prev_levels <= 0:
        reset_needed = True
    else:
        try:
            if abs(prev_tick - tick) > (tick * 1e-6 if tick else 0.0):
                reset_needed = True
            if prev_levels != levels_total:
                reset_needed = True
        except Exception:
            reset_needed = True
    if not reset_needed:
        try:
            start_price = float(prev_start)
            auto_center = bool(payload.get("auto_center", globals().get("ORDERBOOK_AUTO_CENTER", True)))
            if auto_center:
                top_price = start_price
                bottom_price = start_price - ((levels_total - 1) * tick)
                out_of_range = False
                # Auto-center only when spread is close to the edge of the visible window.
                # This prevents constant snapping while still keeping the spread in view.
                try:
                    edge_pct = float(globals().get("ORDERBOOK_AUTO_CENTER_EDGE_PCT", 20.0) or 20.0)
                except Exception:
                    edge_pct = 20.0
                if edge_pct > 0:
                    try:
                        margin_ticks = max(1, int(((levels_total - 1) * edge_pct) / 100.0))
                    except Exception:
                        margin_ticks = 1
                    top_inner = top_price - (margin_ticks * tick)
                    bottom_inner = bottom_price + (margin_ticks * tick)
                else:
                    top_inner = top_price
                    bottom_inner = bottom_price
                if best_ask is not None:
                    ba = float(best_ask)
                    if ba > top_inner or ba < bottom_inner:
                        out_of_range = True
                if best_bid is not None:
                    bb = float(best_bid)
                    if bb > top_inner or bb < bottom_inner:
                        out_of_range = True
                if out_of_range:
                    start_price = None
        except Exception:
            start_price = None
    if start_price is None:
        start_price = center_price + (levels_above * tick)
    try:
        if tick and tick > 0 and start_price is not None:
            sk = _price_key(start_price)
            if sk is not None:
                start_price = float(sk) * float(tick)
    except Exception:
        pass
    book_start_price = start_price
    book_tick_used = tick
    book_levels_used = levels_total
    # Depth bar reference volume is derived from the maximum volume in the *visible* zone,
    # but is "frozen" for a short period to avoid constant re-scaling flicker.
    try:
        max_qty_visible = 0.0
        price_val = start_price
        try:
            _start_key_vis = _price_key(price_val) if (tick and tick > 0) else None
        except Exception:
            _start_key_vis = None
        for row_idx in range(levels_total):
            if row_idx:
                price_val -= tick
            key = (_start_key_vis - row_idx) if (_start_key_vis is not None) else _price_key(price_val)
            if key is None:
                continue
            qty_row = 0.0
            try:
                qty_row = max(float(bid_map.get(key, 0.0)), float(ask_map.get(key, 0.0)))
            except Exception:
                qty_row = float(bid_map.get(key, 0.0) or ask_map.get(key, 0.0) or 0.0)
            if vol_in_usd:
                try:
                    qty_row *= float(price_val)
                except Exception:
                    pass
            if qty_row > max_qty_visible:
                max_qty_visible = qty_row
        if max_qty_visible > 0:
            max_qty = max_qty_visible
    except Exception:
        max_qty_visible = 0.0

    # Freeze/update depth scale reference (per symbol) every N seconds.
    try:
        freeze_sec = float(globals().get("ORDERBOOK_DEPTH_SCALE_FREEZE_SEC", 5.0))
    except Exception:
        freeze_sec = 5.0
    try:
        if sym:
            unit_key = "USD" if vol_in_usd else "QTY"
            now_ts = time.time()
            with orderbook_depth_scale_lock:
                st = orderbook_depth_scale.get((sym, unit_key))
                if st is None or (now_ts - float(st.get("ts", 0.0))) >= freeze_sec:
                    orderbook_depth_scale[(sym, unit_key)] = {"ref": float(max_qty or 1.0), "ts": now_ts}
                else:
                    try:
                        ref_v = float(st.get("ref") or 0.0)
                        if ref_v > 0:
                            max_qty = ref_v
                    except Exception:
                        pass
    except Exception:
        pass
    book_best_bid = best_bid
    book_best_ask = best_ask
    best_bid_key = _price_key(best_bid) if best_bid is not None else None
    best_ask_key = _price_key(best_ask) if best_ask is not None else None
    if max_qty <= 0:
        max_qty = 1.0

    best_bid_row = None
    best_ask_row = None
    try:
        if best_bid is not None and tick:
            row = int(round((start_price - float(best_bid)) / tick))
            row = max(0, min(levels_total - 1, row))
            best_bid_row = row
        if best_ask is not None and tick:
            row = int(round((start_price - float(best_ask)) / tick))
            row = max(0, min(levels_total - 1, row))
            best_ask_row = row
    except Exception:
        pass

    try:
        eps = max(float(tick or 0.0) * 0.5, (10 ** (-int(p_prec))) * 0.5)
    except Exception:
        eps = float(tick or 0.0) * 0.5
    try:
        if best_bid_row is not None and best_ask_row is not None and best_bid_row == best_ask_row:
            if best_ask is not None and best_bid is not None:
                if float(best_ask) > float(best_bid):
                    if best_ask_row > 0:
                        best_ask_row -= 1
                    elif best_bid_row < (levels_total - 1):
                        best_bid_row += 1
    except Exception:
        pass

    if entry_price and pos_side and (best_bid is not None or best_ask is not None):
        try:
            if best_bid is not None and best_ask is not None:
                current_price = (float(best_bid) + float(best_ask)) / 2.0
            else:
                current_price = float(best_bid if best_bid is not None else best_ask)
        except Exception:
            current_price = None
        try:
            if current_price is not None and current_price > 0:
                pnl_positive = None
                if pos_side == "LONG":
                    pnl_positive = current_price >= float(entry_price)
                elif pos_side == "SHORT":
                    pnl_positive = current_price <= float(entry_price)
                if pnl_positive is not None:
                    entry_key = _price_key(entry_price)
                    cur_key = _price_key(current_price)
                    if entry_key is not None and cur_key is not None:
                        pnl_low_key = min(entry_key, cur_key)
                        pnl_high_key = max(entry_key, cur_key)
                        pnl_bg = pnl_gain_bg if pnl_positive else pnl_loss_bg
        except Exception:
            pass

    default_fg = _ensure_rgba_tuple(payload.get("default_fg_rgba"), default_alpha=255) or (220, 220, 220, 255)
    try:
        theme_name = str(payload.get("theme_name") or "").strip().lower()
    except Exception:
        theme_name = ""
    if theme_name:
        if theme_name in ("nord", "light"):
            default_fg = (0, 0, 0, 255)
        else:
            default_fg = (255, 255, 255, 255)
    else:
        default_fg = (0, 0, 0, 255) if theme_light else (255, 255, 255, 255)
    try:
        show_depth_bars = bool(payload.get("show_depth_bars", True))
    except Exception:
        show_depth_bars = True
    # Price display precision (min 3 decimals as requested)
    try:
        price_display_prec = int(payload.get('price_display_prec', p_prec) or p_prec or 3)
    except Exception:
        try:
            price_display_prec = int(p_prec or 3)
        except Exception:
            price_display_prec = 3
    try:
        price_display_prec = max(3, int(price_display_prec))
    except Exception:
        price_display_prec = 3
    rows = []
    # Sharding support: render only a slice of rows when shard_start/shard_end are provided.
    shard_start = payload.get('shard_start')
    shard_end = payload.get('shard_end')
    try:
        shard_start = int(shard_start) if shard_start is not None else 0
    except Exception:
        shard_start = 0
    try:
        shard_end = int(shard_end) if shard_end is not None else int(levels_total)
    except Exception:
        shard_end = int(levels_total)
    if shard_start < 0:
        shard_start = 0
    if shard_end > int(levels_total):
        shard_end = int(levels_total)
    if shard_end < shard_start:
        shard_end = shard_start

    # Cache expiry controls (prevents stale levels from masking live updates)
    cache_now = time.time()
    try:
        cache_stale_sec = float(globals().get('ORDERBOOK_CACHE_STALE_SEC', 1.0) or 1.0)
    except Exception:
        cache_stale_sec = 1.0

    # Set starting price/key at shard_start so we don't iterate through earlier rows.
    try:
        price_val = float(start_price) - float(tick) * float(shard_start)
    except Exception:
        price_val = start_price
    try:
        _start_key_rows = _price_key(float(start_price)) if (tick and tick > 0) else None
    except Exception:
        _start_key_rows = None

    for row_idx in range(shard_start, shard_end):
        if row_idx:
            price_val -= tick
        key = (_start_key_rows - row_idx) if (_start_key_rows is not None) else _price_key(price_val)
        # Read from live maps first (current update). If a level is missing, fall back to
        # persistent display cache (user requirement: never delete cached levels).
        if key is not None:
            bid_qty = bid_map.get(key)
            if bid_qty is None and cache_bids is not None:
                try:
                    cv = cache_bids.get(key)
                    if cv is not None:
                        # ignore stale cached levels so bids/asks cannot "freeze"
                        try:
                            if cache_stale_sec > 0 and isinstance(cv, (tuple, list)) and len(cv) >= 2:
                                if (cache_now - float(cv[1] or 0.0)) > cache_stale_sec:
                                    cv = None
                        except Exception:
                            pass
                        if cv is not None:
                            bid_qty = cv[0] if isinstance(cv, (tuple, list)) else cv
                except Exception:
                    pass
            if bid_qty is None:
                bid_qty = 0.0

            ask_qty = ask_map.get(key)
            if ask_qty is None and cache_asks is not None:
                try:
                    cv = cache_asks.get(key)
                    if cv is not None:
                        # ignore stale cached levels so bids/asks cannot "freeze"
                        try:
                            if cache_stale_sec > 0 and isinstance(cv, (tuple, list)) and len(cv) >= 2:
                                if (cache_now - float(cv[1] or 0.0)) > cache_stale_sec:
                                    cv = None
                        except Exception:
                            pass
                        if cv is not None:
                            ask_qty = cv[0] if isinstance(cv, (tuple, list)) else cv
                except Exception:
                    pass
            if ask_qty is None:
                ask_qty = 0.0
        else:
            bid_qty = 0.0
            ask_qty = 0.0
        side = None
        if best_ask is not None:
            try:
                if float(price_val) >= float(best_ask) - float(eps or 0.0):
                    side = "ASK"
            except Exception:
                pass
        if side is None and best_bid is not None:
            try:
                if float(price_val) <= float(best_bid) + float(eps or 0.0):
                    side = "BID"
            except Exception:
                pass
        if best_ask_row is None and best_ask_key is not None and key == best_ask_key:
            best_ask_row = row_idx
        if best_bid_row is None and best_bid_key is not None and key == best_bid_key:
            best_bid_row = row_idx
        is_best_bid = bool(best_bid_row is not None and row_idx == best_bid_row)
        is_best_ask = bool(best_ask_row is not None and row_idx == best_ask_row)

        # Force correct side on best rows (prevents occasional blank best bid/ask volume)
        if is_best_bid:
            side = "BID"
        elif is_best_ask:
            side = "ASK"

        # If best row qty comes as 0 in a diff update, fall back to cached last-known qty.
        try:
            if is_best_bid and (bid_qty is None or float(bid_qty) <= 0) and cache_bids is not None and key is not None:
                cv = cache_bids.get(key)
                if cv is not None:
                    bid_qty = cv[0] if isinstance(cv, (tuple, list)) else cv
            if is_best_ask and (ask_qty is None or float(ask_qty) <= 0) and cache_asks is not None and key is not None:
                cv = cache_asks.get(key)
                if cv is not None:
                    ask_qty = cv[0] if isinstance(cv, (tuple, list)) else cv
        except Exception:
            pass

        # IMPORTANT: never let stale asks mask bids (or vice versa).
        # Display the correct side strictly based on row side.
        if side == "ASK":
            qty = ask_qty
        elif side == "BID":
            qty = bid_qty
        else:
            qty = ask_qty if ask_qty > 0 else bid_qty
        qty_display = qty
        if vol_in_usd:
            try:
                qty_display = float(qty) * float(price_val)
            except Exception:
                qty_display = qty
        try:
            price_txt = f"{float(price_val):.{price_display_prec}f}".replace('.', ',')
        except Exception:
            price_txt = str(price_val)
        if qty_display > 0:
            if vol_compact:
                qty_txt = _format_compact(qty_display)
            elif vol_in_usd:
                qty_txt = _format_num(qty_display, 2)
            else:
                try:
                    qty_txt = f"{float(qty_display):.{q_prec}f}"
                except Exception:
                    qty_txt = str(qty_display)
        else:
            qty_txt = "0" if (is_best_bid or is_best_ask) else ""

        price_fg = default_fg
        price_bg = transparent
        vol_fg = default_fg
        vol_bg = transparent
        vol_base_bg = transparent
        bar_color_row = bar_color
        vol_fg_locked = False
        if side == "ASK":
            price_bg = ask_bg
            vol_base_bg = ask_bg
        elif side == "BID":
            price_bg = bid_bg
            vol_base_bg = bid_bg

        in_pnl_band = False
        marker = None
        if sl_key is not None and key is not None and key == sl_key:
            marker = "SL"
        elif key is not None and key in tp_keys:
            marker = "TP"
        elif pending_key is not None and key is not None and key == pending_key:
            marker = "PENDING"

        price_txt_display = price_txt
        if marker == "SL":
            price_bg = sl_bg
            vol_fg_locked = True
        elif marker == "TP":
            price_bg = tp_bg
            vol_fg_locked = True
        elif marker == "PENDING":
            price_bg = pending_bg
            price_txt_display = f"{price_txt} V"
            vol_fg_locked = True
        elif pnl_low_key is not None and pnl_high_key is not None and pnl_bg is not None and key is not None:
            if pnl_low_key <= key <= pnl_high_key:
                price_bg = pnl_bg
                in_pnl_band = True

        if marker is None and (is_best_bid or is_best_ask):
            if is_best_bid:
                price_bg = best_bid_bg
                vol_base_bg = best_bid_bg
                bar_color_row = bid_color
            else:
                price_bg = best_ask_bg
                vol_base_bg = best_ask_bg
                bar_color_row = ask_color

        if marker is None and level_key is not None and key is not None and key == level_key:
            if not in_pnl_band and not (is_best_bid or is_best_ask):
                price_bg = level_bg

        order_info = order_keys.get(key) if key is not None else None
        if order_info:
            total = int(order_info.get("total") or 0)
            kinds = order_info.get("kinds") or {}
            kind_keys = [k for k, v in kinds.items() if int(v or 0) > 0]
            kind = kind_keys[0] if len(kind_keys) == 1 else "MIX"
            reduce_cnt = int(order_info.get("reduce") or 0)

            # derive compact label
            label = "O"
            if kind == "TP":
                label = "TP"
            elif kind == "ST":
                label = "SL" if reduce_cnt > 0 else "ST"
            elif kind == "TS":
                label = "TS"
            elif kind == "L":
                label = "RO" if reduce_cnt > 0 else "L"
            elif kind == "MIX":
                label = "O"

            try:
                if total > 1:
                    price_txt_display = f"{price_txt_display} {label}{total}"
                else:
                    price_txt_display = f"{price_txt_display} {label}"
            except Exception:
                pass

            order_bg = None
            try:
                order_stop_bg = pending_bg
                order_trail_bg = (155, 89, 182, 90)  # purple
                if label == "SL":
                    order_bg = sl_bg
                elif label == "TP":
                    order_bg = tp_bg
                elif label in ("L", "RO"):
                    # User request: ALL limit orders should be blue (same as TP)
                    order_bg = tp_bg
                elif label == "ST":
                    order_bg = order_stop_bg
                elif label == "TS":
                    order_bg = order_trail_bg
                elif label == "RO":
                    order_bg = order_reduce_bg
                else:
                    if reduce_cnt > 0:
                        order_bg = order_reduce_bg
                    elif int(order_info.get("buy") or 0) > 0 and int(order_info.get("sell") or 0) > 0:
                        order_bg = order_mixed_bg
                    elif int(order_info.get("buy") or 0) > 0:
                        order_bg = order_buy_bg
                    elif int(order_info.get("sell") or 0) > 0:
                        order_bg = order_sell_bg
            except Exception:
                order_bg = None

            in_pnl_band = False
            try:
                if pnl_low_key is not None and pnl_high_key is not None and key is not None:
                    in_pnl_band = pnl_low_key <= key <= pnl_high_key
            except Exception:
                in_pnl_band = False

            # apply background only if row is not already reserved by SL/TP/PENDING markers
            if marker is None and order_bg is not None and not in_pnl_band and not (is_best_bid or is_best_ask):
                price_bg = order_bg
                if vol_bg == transparent:
                    vol_bg = order_bg

        if marker in ("SL", "TP", "PENDING"):
            vol_bg = price_bg
        if marker is None and (is_best_bid or is_best_ask):
            vol_bg = transparent

        vol_marker = None
        if sl_key is not None and key is not None and key == sl_key:
            vol_marker = "X"
        elif entry_key is not None and key is not None and key == entry_key and entry_marker:
            vol_marker = entry_marker
        if vol_marker:
            vol_txt_display = f"{vol_marker} {qty_txt}" if qty_txt else vol_marker
        else:
            vol_txt_display = qty_txt

        try:
            vol_txt_display = str(vol_txt_display).lstrip()
        except Exception:
            pass

        # Depth bars: solid left->right fill with 3-stage scale
        # 1) The reference max volume (max_qty) maps to 70% width.
        # 2) Volumes between 100%..150% of reference map into the remaining 30%.
        # 3) Volumes >=150% of reference fill 100% with white.
        bar_frac = 0.0
        bar_color_final = None
        bar_qty = qty_display if vol_in_usd else qty
        if bar_qty and bar_qty > 0 and max_qty and max_qty > 0:
            ratio = 0.0
            try:
                ratio = float(bar_qty) / float(max_qty)
            except Exception:
                ratio = 0.0
            if ratio > 0:
                # Solid orange by default
                orange = (230, 140, 0, 255)  # darker orange
                if ratio >= 1.5:
                    bar_frac = 1.0
                    bar_color_final = (255, 255, 255, 255)
                elif ratio <= 1.0:
                    bar_frac = min(max(ratio * 0.70, 0.0), 1.0)
                    bar_color_final = orange
                else:
                    # ratio in (1.0, 1.5): 70%..100%
                    bar_frac = 0.70 + (ratio - 1.0) * (0.30 / 0.50)
                    if bar_frac > 1.0:
                        bar_frac = 1.0
                    bar_color_final = orange
        # Keep text color consistent with theme; do not override for depth bars.

        # Style flags for UI rendering (bold ONLY best bid/ask; major-tick bolding disabled)
        style_flags = 0
        try:
            if is_best_bid or is_best_ask:
                style_flags |= OB_STYLE_BOLD_ALL
        except Exception:
            pass

        rows.append(
            (
                vol_txt_display,
                price_txt_display,
                vol_fg,
                price_fg,
                vol_bg,
                price_bg,
                bar_frac,
                bar_color_final,
                vol_base_bg,
                None,
                float(price_val),
                int(style_flags),
            )
        )

    order_markers = []
    try:
        if order_keys:
            for key, info in order_keys.items():
                try:
                    total = int(info.get("total") or 0)
                except Exception:
                    total = 0
                try:
                    nsum = float(info.get("notional") or 0.0)
                except Exception:
                    nsum = 0.0
                if nsum <= 0.0 and total <= 0:
                    continue
                try:
                    if tick and tick > 0:
                        price_val = float(key) * float(tick)
                    else:
                        price_val = float(key) / float(10 ** int(p_prec))
                except Exception:
                    continue
                try:
                    order_ids = sorted(list(info.get("order_ids") or []))
                except Exception:
                    order_ids = []
                try:
                    algo_ids = sorted(list(info.get("algo_ids") or []))
                except Exception:
                    algo_ids = []
                order_markers.append({"price": price_val, "notional": nsum, "total": total, "order_ids": order_ids, "algo_ids": algo_ids})
            try:
                order_markers.sort(key=lambda it: float(it.get("price") or 0.0), reverse=True)
            except Exception:
                pass
    except Exception:
        order_markers = []

    result = {
        "symbol": sym,
        "rows": rows,
        "best_bid_row": best_bid_row,
        "best_ask_row": best_ask_row,
        "best_bid": book_best_bid,
        "best_ask": book_best_ask,
        "start_price": book_start_price,
        "tick": tick,
        "levels_total": levels_total,
        "book_tick_base": base_tick,
        "book_tick": book_tick,
        "book_start_price": book_start_price,
        "book_tick_used": book_tick_used,
        "book_levels_used": book_levels_used,
        "autotick_pending": book_autotick_pending,
        "auto_tick_mult": auto_tick_mult,
        "row_height": row_h,
        "clear": False,
        "raw_colors": True,
        "show_depth_bars": show_depth_bars,
        "order_markers": order_markers,
    }
    return result


def _orderbook_convert_raw_to_qt(result):
    if not isinstance(result, dict):
        return result
    if not result.get("raw_colors"):
        return result
    brush_cache = getattr(_orderbook_convert_raw_to_qt, "_brush_cache", None)
    if brush_cache is None:
        brush_cache = {}
        _orderbook_convert_raw_to_qt._brush_cache = brush_cache
    show_depth_bars = bool(result.get("show_depth_bars", True))
    rows = result.get("rows") or []
    new_rows = []
    for row in rows:
        if not row or len(row) < OB_ROW_STYLE_FLAGS + 1:
            continue
        vol_txt = row[OB_ROW_VOL_TEXT]
        price_txt = row[OB_ROW_PRICE_TEXT]
        vol_fg = _rgba_to_qcolor(row[OB_ROW_VOL_FG])
        price_fg = _rgba_to_qcolor(row[OB_ROW_PRICE_FG])
        vol_bg = _rgba_to_qcolor(row[OB_ROW_VOL_BG])
        price_bg = _rgba_to_qcolor(row[OB_ROW_PRICE_BG])
        bar_frac = row[OB_ROW_BAR_FRAC] or 0.0
        bar_color = _rgba_to_qcolor(row[OB_ROW_BAR_COLOR])
        vol_base_bg = _rgba_to_qcolor(row[OB_ROW_VOL_BASE_BG])
        price_val = row[OB_ROW_PRICE_VALUE]
        try:
            style_flags = int(row[OB_ROW_STYLE_FLAGS])
        except Exception:
            style_flags = 0
        # Depth bars are drawn directly in OrderbookDelegate (solid left->right),
        # so we intentionally do not create gradient brushes here.
        vol_brush = None
        # Precompute a lightweight signature so the model can diff rows fast.
        # This materially improves UI FPS on deep books (1000+ levels).
        try:
            sig = (
                vol_txt,
                price_txt,
                int(vol_fg.rgba()),
                int(price_fg.rgba()),
                int(vol_bg.rgba()),
                int(price_bg.rgba()),
                int(bar_color.rgba()),
                int(float(bar_frac or 0.0) * 1024),
                int(vol_base_bg.rgba()),
                int(style_flags),
            )
        except Exception:
            sig = None
        new_rows.append(
            (
                vol_txt,
                price_txt,
                vol_fg,
                price_fg,
                vol_bg,
                price_bg,
                bar_frac,
                bar_color,
                vol_base_bg,
                vol_brush,
                price_val,
                style_flags,
                sig,
            )
        )
    result["rows"] = new_rows
    result["raw_colors"] = False
    return result


def _is_orderbook_process_stop(payload):
    try:
        return isinstance(payload, dict) and payload.get("_cmd") == "stop"
    except Exception:
        return False



def _best_effort_pin_process_to_core(worker_idx=0, workers=1):
    """Best-effort CPU affinity for render workers (Windows 10/11 + Linux).

    Why: Windows may keep a process on one logical CPU for cache locality.
    Pinning each worker to a different core makes the distribution visible
    and prevents all render work from collapsing onto a single core.

    Notes:
    - Works without third-party deps (ctypes on Windows).
    - Limited to <=64 logical CPUs on Windows without CPU Groups.
      (You have 28, so it's fine.)
    """
    try:
        import os
        logical = os.cpu_count() or 1
        if logical <= 1:
            return

        try:
            w = int(workers) if int(workers) > 0 else 1
        except Exception:
            w = 1
        try:
            i = int(worker_idx)
        except Exception:
            i = 0

        # Spread workers across the full logical CPU range.
        try:
            step = max(1, logical // w)
        except Exception:
            step = 1
        core = (i * step) % logical

        if os.name == 'nt':
            # Prefer psutil when available, otherwise use native WinAPI.
            try:
                import psutil  # type: ignore
                psutil.Process(os.getpid()).cpu_affinity([core])
                return
            except Exception:
                pass

            # ctypes fallback: SetProcessAffinityMask
            try:
                import ctypes
                kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
                GetCurrentProcess = kernel32.GetCurrentProcess
                GetCurrentProcess.restype = ctypes.c_void_p
                SetProcessAffinityMask = kernel32.SetProcessAffinityMask
                SetProcessAffinityMask.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
                SetProcessAffinityMask.restype = ctypes.c_int

                if core >= 64:
                    return
                mask = ctypes.c_size_t(1 << core)
                SetProcessAffinityMask(GetCurrentProcess(), mask)
                return
            except Exception:
                return

        # Linux / other POSIX
        try:
            os.sched_setaffinity(0, {int(core)})
        except Exception:
            pass
    except Exception:
        pass


def _best_effort_pin_process_to_absolute_core(core=0):
    """Pin current process to a specific absolute logical core (best-effort)."""
    try:
        import os
        logical = os.cpu_count() or 1
        if logical <= 1:
            return
        try:
            c = int(core) % logical
        except Exception:
            c = 0

        if os.name == 'nt':
            try:
                import psutil  # type: ignore
                psutil.Process(os.getpid()).cpu_affinity([c])
                return
            except Exception:
                pass
            try:
                import ctypes
                kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
                GetCurrentProcess = kernel32.GetCurrentProcess
                GetCurrentProcess.restype = ctypes.c_void_p
                SetProcessAffinityMask = kernel32.SetProcessAffinityMask
                SetProcessAffinityMask.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
                SetProcessAffinityMask.restype = ctypes.c_int
                if c >= 64:
                    return
                mask = ctypes.c_size_t(1 << c)
                SetProcessAffinityMask(GetCurrentProcess(), mask)
                return
            except Exception:
                return

        try:
            os.sched_setaffinity(0, {int(c)})
        except Exception:
            pass
    except Exception:
        pass


def _orderbook_feeder_process_main(feeder_in_q, in_list, workers=1, pin_core=1):
    """Dedicated feeder process: drains latest frame and dispatches sharded parts into render workers.

    Goal: move sharding + Queue put() overhead off the GUI thread.
    Notes:
    - This does NOT write SHM itself; GUI thread prepares SHM meta (cheap) and sends a compact base payload.
    - On overload it drops older frames and keeps only the newest.
    """
    try:
        _best_effort_pin_process_to_absolute_core(int(pin_core or 0))
    except Exception:
        pass

    # Local imports for spawn friendliness
    try:
        from queue import Full
    except Exception:
        Full = Exception

    in_list = list(in_list or [])
    if not in_list:
        return

    while True:
        try:
            base = feeder_in_q.get()
        except Exception:
            continue

        try:
            if isinstance(base, dict) and base.get('_cmd') == 'stop':
                return
        except Exception:
            pass

        # Drain to latest (no backlog)
        try:
            while True:
                try:
                    nxt = feeder_in_q.get_nowait()
                    base = nxt
                    try:
                        if isinstance(base, dict) and base.get('_cmd') == 'stop':
                            return
                    except Exception:
                        pass
                except Exception:
                    break
        except Exception:
            pass

        if not isinstance(base, dict):
            continue

        # Sharding policy (same as GUI-side logic, but off-thread/off-core)
        try:
            do_shard = bool(globals().get('USE_ORDERBOOK_RENDER_SHARDING', True))
        except Exception:
            do_shard = True

        try:
            shards_total = int(len(in_list))
        except Exception:
            shards_total = 1

        if (not do_shard) or shards_total <= 1:
            # Round-robin single worker (still drops oldest on full)
            try:
                rr = int(base.get('_rr', 0) or 0)
            except Exception:
                rr = 0
            idx = rr % max(1, len(in_list))
            base['_rr'] = rr + 1
            q = in_list[idx]
            try:
                q.put_nowait(base)
            except Full:
                try:
                    q.get_nowait()
                except Exception:
                    pass
                try:
                    q.put_nowait(base)
                except Exception:
                    pass
            continue

        try:
            levels_total = int(base.get('levels_total') or 0)
        except Exception:
            levels_total = 0
        if levels_total <= 0:
            try:
                levels_total = int(globals().get('ORDERBOOK_LADDER_LEVELS', ORDERBOOK_LADDER_LEVELS) or ORDERBOOK_LADDER_LEVELS)
            except Exception:
                levels_total = 0
        if levels_total <= 0:
            levels_total = 1

        chunk = max(1, (levels_total + shards_total - 1) // shards_total)

        for shard_idx, q in enumerate(in_list):
            s = shard_idx * chunk
            e = min(levels_total, s + chunk)
            part = dict(base)
            part['shard_idx'] = int(shard_idx)
            part['shards_total'] = int(shards_total)
            part['shard_start'] = int(s)
            part['shard_end'] = int(e)
            try:
                q.put_nowait(part)
            except Full:
                try:
                    q.get_nowait()
                except Exception:
                    pass
                try:
                    q.put_nowait(part)
                except Exception:
                    pass


def _orderbook_image_renderer_process_main(img_in_q, img_out_q, pin_core=2):
    """Renders the visible orderbook slice into raw ARGB32 bytes in a dedicated process.

    Backend: Pillow (NO Qt / QPainter inside the child process).
    This avoids Windows GUI/plugin issues when using Qt in multiprocessing workers.
    """
    try:
        _best_effort_pin_process_to_absolute_core(int(pin_core or 0))
    except Exception:
        pass

    try:
        from PIL import Image, ImageDraw, ImageFont
    except Exception:
        # Pillow is required for this backend
        return

    import time

    # Font handling: prefer a readable mono font; fall back to default.
    _FONT_CACHE = {}
    _FONT_CANDIDATES = [
        # Windows (standard UI font preferred)
        (r"C:\Windows\Fonts\segoeuib.ttf", True),   # Segoe UI Bold
        (r"C:\Windows\Fonts\segoeui.ttf", False),   # Segoe UI Regular

        # Windows (preferred)
        (r"C:\Windows\Fonts\consolab.ttf", True),   # Consolas Bold
        (r"C:\Windows\Fonts\consola.ttf", False),   # Consolas Regular
        (r"C:\Windows\Fonts\courbd.ttf", True),     # Courier New Bold
        (r"C:\Windows\Fonts\cour.ttf", False),      # Courier New Regular
        # Pillow / Linux common
        ("DejaVuSansMono.ttf", False),
        ("DejaVuSans.ttf", False),
        ("/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf", False),
        ("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", False),
    ]

    def _get_font(px=11, bold=False):
        """Best-effort TrueType font loader with caching."""
        try:
            key = (int(px), bool(bold))
        except Exception:
            key = (11, bool(bold))
        if key in _FONT_CACHE:
            return _FONT_CACHE[key]
        try:
            size = int(px)
        except Exception:
            size = 11
        size = max(7, min(size, 22))

        # Try bold candidates first when bold requested
        try:
            if bold:
                # bold -> bold first, then regular
                try_order = [p for (p, b) in _FONT_CANDIDATES if b] + [p for (p, b) in _FONT_CANDIDATES if not b]
            else:
                # regular -> regular first, then bold (so we don't accidentally load a bold face everywhere)
                try_order = [p for (p, b) in _FONT_CANDIDATES if not b] + [p for (p, b) in _FONT_CANDIDATES if b]
        except Exception:
            try_order = []

        font_obj = None
        for fp in try_order:
            try:
                font_obj = ImageFont.truetype(fp, size=size)
                break
            except Exception:
                continue

        if font_obj is None:
            try:
                font_obj = ImageFont.load_default()
            except Exception:
                font_obj = None

        _FONT_CACHE[key] = font_obj
        return font_obj

    def _rgba(c, default=(0, 0, 0, 0)):
        """Accept (r,g,b,a) tuples/lists or None."""
        try:
            if c is None:
                return default
            if isinstance(c, (tuple, list)) and len(c) >= 3:
                r = int(c[0]); g = int(c[1]); b = int(c[2])
                a = int(c[3]) if len(c) >= 4 else 255
                # clamp
                r = max(0, min(255, r)); g = max(0, min(255, g)); b = max(0, min(255, b)); a = max(0, min(255, a))
                return (r, g, b, a)
        except Exception:
            pass
        return default

    def _safe_put(d):
        try:
            img_out_q.put_nowait(d)
            return
        except Exception:
            pass
        # Drop oldest and retry
        try:
            while True:
                img_out_q.get_nowait()
        except Exception:
            pass
        try:
            img_out_q.put_nowait(d)
        except Exception:
            pass

    while True:
        try:
            req = img_in_q.get()
        except Exception:
            time.sleep(0.005)
            continue

        try:
            if not isinstance(req, dict):
                continue
            cmd = req.get('_cmd')
        except Exception:
            continue

        if cmd == 'stop':
            break
        if cmd != 'render':
            continue

        try:
            rows = req.get('rows') or []
            w = int(req.get('w') or 0)
            row_h = int(req.get('row_h') or 8)
            price_w = int(req.get('price_w') or 104)
            show_depth_bars = bool(req.get('show_depth_bars', True))
            seq = req.get('seq')
            sym = (req.get('symbol') or '').upper()
        except Exception:
            continue

        if w <= 0 or row_h <= 0 or not rows:
            _safe_put({'_cmd': 'image', 'symbol': sym, 'seq': seq, 'row_h': row_h, 'w': int(w or 0), 'h': 0, 'stride': 0, 'img_bytes': b''})
            continue

        try:
            vol_w = max(10, int(w - price_w))
            price_w = max(40, int(w - vol_w))
        except Exception:
            vol_w = max(10, int(w * 0.55))
            price_w = max(40, int(w - vol_w))

        # --- Adaptive volume column width (prevents clipping like 'K' / commas) ---
        try:
            base_vol_w = int(globals().get("ORDERBOOK_VOL_COL_WIDTH", 160) or 160)
        except Exception:
            base_vol_w = 160

        try:
            pad_l = 1
            pad_r = 2  # tighter padding; we no longer do fake-bold text offsets
            min_price_w = 56

            # Estimate max text widths for this frame
            try:
                fs_meas = int(max(3, min(18, int(row_h * float(globals().get('ORDERBOOK_IMAGE_FONT_SCALE', 0.42) or 0.42)))))
            except Exception:
                fs_meas = 6

            try:
                any_bold_all = False
                for _r in rows:
                    try:
                        _sf = int(_r[11]) if len(_r) > 11 else 0
                        if (_sf & OB_STYLE_BOLD_ALL) != 0:
                            any_bold_all = True
                            break
                    except Exception:
                        continue
                if any_bold_all:
                    fs_meas += 1
            except Exception:
                pass

            font_meas = _get_font(fs_meas, bold=False) or _get_font(fs_meas, bold=True)

            max_vtw = 0
            max_ptw = 0

            if font_meas is not None:
                # Prefer fast font.getbbox; fall back to rough sizing
                try:
                    for _r in rows:
                        try:
                            _v = str(_r[0] or '').strip()
                            if _v:
                                bb = font_meas.getbbox(_v)
                                max_vtw = max(max_vtw, max(0, bb[2] - bb[0]))
                        except Exception:
                            pass
                        try:
                            _p = str(_r[1] or '').strip()
                            if _p:
                                bb = font_meas.getbbox(_p)
                                max_ptw = max(max_ptw, max(0, bb[2] - bb[0]))
                        except Exception:
                            pass
                except Exception:
                    for _r in rows:
                        try:
                            _v = str(_r[0] or '').strip()
                            max_vtw = max(max_vtw, len(_v) * 6)
                        except Exception:
                            pass
                        try:
                            _p = str(_r[1] or '').strip()
                            max_ptw = max(max_ptw, len(_p) * 6)
                        except Exception:
                            pass
            else:
                for _r in rows:
                    try:
                        _v = str(_r[0] or '').strip()
                        max_vtw = max(max_vtw, len(_v) * 6)
                    except Exception:
                        pass
                    try:
                        _p = str(_r[1] or '').strip()
                        max_ptw = max(max_ptw, len(_p) * 6)
                    except Exception:
                        pass

            req_vol_w = max(base_vol_w, int(max_vtw + pad_l + pad_r + 2))  # +2px safety to avoid edge clipping
            req_price_w = max(min_price_w, int(max_ptw + 6))

            # Constrain so both columns remain usable
            req_vol_w = max(10, min(req_vol_w, int(w - req_price_w)))

            # Make sure volume column is wide enough (no clipping)
            if req_vol_w > vol_w:
                vol_w = int(req_vol_w)

            vol_w = max(10, min(vol_w, int(w - req_price_w)))
            price_w = max(req_price_w, int(w - vol_w))

            # Final safety
            if vol_w + price_w != w:
                price_w = max(req_price_w, int(w - vol_w))
        except Exception:
            pass

        h = int(len(rows) * row_h)
        if h <= 0:
            _safe_put({'_cmd': 'image', 'symbol': sym, 'seq': seq, 'row_h': row_h, 'w': int(w or 0), 'h': 0, 'stride': 0, 'img_bytes': b''})
            continue

        # RGBA canvas with transparent background
        try:
            img = Image.new('RGBA', (w, h), (0, 0, 0, 0))
            draw = ImageDraw.Draw(img)
        except Exception:
            continue

        # Render rows
        for i, row in enumerate(rows):
            y0 = int(i * row_h)
            y1 = int(y0 + row_h)

            try:
                vol_txt = row[0]
                price_txt = row[1]
                vol_fg = _rgba(row[2], (230, 230, 230, 255))
                price_fg = _rgba(row[3], (230, 230, 230, 255))
                vol_bg = _rgba(row[4], (0, 0, 0, 0))
                price_bg = _rgba(row[5], (0, 0, 0, 0))
                bar_frac = float(row[6] or 0.0)
                bar_color = _rgba(row[7], (255, 150, 80, 160))
                vol_base_bg = _rgba(row[8], (0, 0, 0, 0))
                style_flags = int(row[11]) if len(row) > 11 else 0
            except Exception:
                continue

            # backgrounds
            try:
                if vol_bg[3] > 0:
                    draw.rectangle((0, y0, vol_w-1, y1), fill=vol_bg)
                elif vol_base_bg[3] > 0:
                    draw.rectangle((0, y0, vol_w-1, y1), fill=vol_base_bg)
            except Exception:
                pass

            try:
                if price_bg[3] > 0:
                    draw.rectangle((vol_w, y0, w-1, y1), fill=price_bg)
            except Exception:
                pass

            # depth bar inside volume column
            if show_depth_bars:
                try:
                    bf = max(0.0, min(1.0, float(bar_frac or 0.0)))
                    max_x_vol = max(0, int(vol_w - 1))
                    bw = int(max_x_vol * bf)
                    bw = max(0, min(bw, max_x_vol))
                    if bw > 0 and bar_color[3] > 0:
                        draw.rectangle((0, y0, bw, y1), fill=bar_color)
                except Exception:
                    pass

            # text (vertical center)
            try:
                vtxt = str(vol_txt).lstrip()
                ptxt = str(price_txt)

                # Font size based on row height (readability on dense ladders)
                try:
                    fs_base = int(max(3, min(18, int(row_h * float(globals().get('ORDERBOOK_IMAGE_FONT_SCALE', 0.42) or 0.42)))))
                except Exception:
                    fs_base = 11
                fs_base = int(max(5, min(11, fs_base)))

                # Normal (non-bold) font for the whole ladder
                font_normal = _get_font(fs_base, bold=False) or _get_font(fs_base, bold=True)

                # Bold ONLY for best bid/ask (+1pt)
                font_bold = None
                try:
                    if (style_flags & OB_STYLE_BOLD_ALL) != 0:
                        fs_b = int(max(5, min(14, fs_base + 1)))
                        font_bold = _get_font(fs_b, bold=True) or _get_font(fs_b, bold=False)
                except Exception:
                    font_bold = None

                font_v = font_bold if font_bold is not None else font_normal
                font_p = font_bold if font_bold is not None else font_normal

                if font_v is not None:
                    try:
                        vb = draw.textbbox((0, 0), vtxt, font=font_v)
                        pb = draw.textbbox((0, 0), ptxt, font=font_p)
                        vtw = max(1, vb[2] - vb[0]); vth = max(1, vb[3] - vb[1])
                        ptw = max(1, pb[2] - pb[0]); pth = max(1, pb[3] - pb[1])
                    except Exception:
                        vtw, vth = (len(vtxt) * 6, 10)
                        ptw, pth = (len(ptxt) * 6, 10)
                else:
                    # Fallback rough sizing
                    vtw, vth = (len(vtxt) * 6, 10)
                    ptw, pth = (len(ptxt) * 6, 10)

                yv = y0 + max(0, (row_h - vth) // 2)
                yp = y0 + max(0, (row_h - pth) // 2)

                # Volume text: LEFT-aligned inside the volume column (left-to-right reading).
                xv = 1
                draw.text((xv, yv), vtxt, fill=vol_fg, font=font_v)

                # Price text - right aligned in price column
                xp = max(vol_w + 1, int(vol_w + price_w - 3 - ptw))
                draw.text((xp, yp), ptxt, fill=price_fg, font=font_p)
            except Exception:
                pass

        # Convert to BGRA bytes for QImage.Format_ARGB32 (little-endian memory)
        try:
            bts = img.tobytes('raw', 'BGRA')
            stride = int(w * 4)
            _safe_put({'_cmd': 'image', 'symbol': sym, 'seq': seq, 'row_h': row_h, 'w': int(w), 'h': int(h), 'stride': int(stride), 'img_bytes': bts})
        except Exception:
            continue

def _orderbook_render_process_main(in_q, out_q, worker_idx=0, workers=1):
    """Dedicated orderbook render worker process.

    Supports:
    - CPU pinning (affinity)
    - SHM-backed bids/asks (reduces pickle overhead)
    - Sharded rendering (one frame split across all workers)

    Protocol:
    - init message: {'_cmd': 'init_shm', 'bids_name': str, 'asks_name': str, 'capacity_pairs': int}
    - frame message: includes '_seq', shard_start/shard_end/shard_idx/shards_total, bids_len/asks_len
    """
    _best_effort_pin_process_to_core(worker_idx, workers)

    shm_bids = None
    shm_asks = None
    bids_view = None
    asks_view = None
    cap_pairs = 0

    def _attach_shm(bname, aname, cap):
        nonlocal shm_bids, shm_asks, bids_view, asks_view, cap_pairs
        if _mp_shared_memory is None:
            return
        try:
            cap_pairs = int(cap or 0)
        except Exception:
            cap_pairs = 0
        try:
            if shm_bids is None or getattr(shm_bids, 'name', None) != bname:
                try:
                    if shm_bids is not None:
                        shm_bids.close()
                except Exception:
                    pass
                shm_bids = _mp_shared_memory.SharedMemory(name=str(bname))
                bids_view = shm_bids.buf.cast('d')
        except Exception:
            shm_bids = None
            bids_view = None
        try:
            if shm_asks is None or getattr(shm_asks, 'name', None) != aname:
                try:
                    if shm_asks is not None:
                        shm_asks.close()
                except Exception:
                    pass
                shm_asks = _mp_shared_memory.SharedMemory(name=str(aname))
                asks_view = shm_asks.buf.cast('d')
        except Exception:
            shm_asks = None
            asks_view = None

    while True:
        try:
            payload = in_q.get()
        except Exception:
            continue
        if _is_orderbook_process_stop(payload):
            break
        # Drain to latest payload to keep latency low
        try:
            while True:
                nxt = in_q.get_nowait()
                if _is_orderbook_process_stop(nxt):
                    payload = nxt
                    break
                payload = nxt
        except Exception:
            pass
        if _is_orderbook_process_stop(payload):
            break

        # Init SHM command
        try:
            if isinstance(payload, dict) and payload.get('_cmd') == 'init_shm':
                _attach_shm(payload.get('bids_name'), payload.get('asks_name'), payload.get('capacity_pairs'))
                continue
        except Exception:
            pass

        seq = None
        try:
            seq = (payload or {}).get('_seq')
        except Exception:
            seq = None

        # Ensure SHM attached for this frame (lazy)
        try:
            if isinstance(payload, dict) and payload.get('_shm_bids') and payload.get('_shm_asks'):
                _attach_shm(payload.get('_shm_bids'), payload.get('_shm_asks'), payload.get('capacity_pairs'))
        except Exception:
            pass

        # Reconstruct bids/asks from SHM if available; fallback to payload lists.
        bids = None
        asks = None
        try:
            if bids_view is not None and asks_view is not None and isinstance(payload, dict):
                b_len = int(payload.get('bids_len') or 0)
                a_len = int(payload.get('asks_len') or 0)
                if cap_pairs and b_len > cap_pairs:
                    b_len = cap_pairs
                if cap_pairs and a_len > cap_pairs:
                    a_len = cap_pairs
                bids = [(bids_view[2*i], bids_view[2*i+1]) for i in range(b_len)]
                asks = [(asks_view[2*i], asks_view[2*i+1]) for i in range(a_len)]
        except Exception:
            bids = None
            asks = None
        if bids is None or asks is None:
            try:
                bids = (payload or {}).get('bids') or []
                asks = (payload or {}).get('asks') or []
            except Exception:
                bids = []
                asks = []

        # Render: pass bids/asks into payload copy
        try:
            merged = dict(payload or {})
        except Exception:
            merged = payload or {}
        try:
            merged['bids'] = bids or []
            merged['asks'] = asks or []
        except Exception:
            pass

        try:
            result = _orderbook_render_raw(merged)
        except Exception:
            result = None
        if not result:
            continue
        try:
            if isinstance(result, dict) and seq is not None:
                result['_seq'] = seq
        except Exception:
            pass
        # carry shard meta for aggregation
        try:
            if isinstance(payload, dict):
                for k in ('shard_start','shard_end','shard_idx','shards_total'):
                    if k in payload:
                        result[k] = payload.get(k)
        except Exception:
            pass
        try:
            out_q.put(result)
        except Exception:
            pass

    # cleanup
    try:
        if shm_bids is not None:
            shm_bids.close()
    except Exception:
        pass
    try:
        if shm_asks is not None:
            shm_asks.close()
    except Exception:
        pass


class OrderbookModel(QAbstractTableModel):
    ROLE_META = Qt.UserRole + 1

    def __init__(self, parent=None):
        super().__init__(parent)
        self._rows = []
        self._headers = ["", ""]

    def rowCount(self, parent=QModelIndex()):
        if parent.isValid():
            return 0
        return len(self._rows)

    def columnCount(self, parent=QModelIndex()):
        if parent.isValid():
            return 0
        return 2

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            try:
                return self._headers[section]
            except Exception:
                return None
        return None

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        row_idx = index.row()
        if row_idx < 0 or row_idx >= len(self._rows):
            return None
        row = self._rows[row_idx]
        col = index.column()
        if role == Qt.DisplayRole:
            if col == ORDERBOOK_COL_VOL:
                try:
                    return str(row[OB_ROW_VOL_TEXT]).lstrip()
                except Exception:
                    return row[OB_ROW_VOL_TEXT]
            return row[OB_ROW_PRICE_TEXT]
        if role == Qt.TextAlignmentRole:
            if col == ORDERBOOK_COL_VOL:
                return int(Qt.AlignLeft | Qt.AlignVCenter)
            return int(Qt.AlignRight | Qt.AlignVCenter)
        if role == Qt.ForegroundRole:
            return row[OB_ROW_VOL_FG] if col == ORDERBOOK_COL_VOL else row[OB_ROW_PRICE_FG]
        if role == self.ROLE_META:
            return row
        return None

    def set_rows(self, rows):
        """Fast update path.

        The book is often 1k rows; emitting a full-range dataChanged each time
        can cap UI FPS hard. We diff rows and only emit for changed spans.
        """
        rows = rows or []
        old = self._rows
        if len(rows) != len(old):
            self.beginResetModel()
            self._rows = rows
            self.endResetModel()
            return

        # Diff + minimal dataChanged ranges.
        self._rows = rows
        if not rows:
            return
        try:
            changed = []
            def _rgba(c):
                try:
                    return int(c.rgba())
                except Exception:
                    try:
                        return (int(c.red()), int(c.green()), int(c.blue()), int(c.alpha()))
                    except Exception:
                        return c
            def _row_eq(a, b):
                if a is b:
                    return True
                # Fast-path: compare precomputed signatures if present
                try:
                    if (len(a) > OB_ROW_SIG) and (len(b) > OB_ROW_SIG):
                        sa = a[OB_ROW_SIG]
                        sb = b[OB_ROW_SIG]
                        if (sa is not None) and (sb is not None):
                            return sa == sb
                except Exception:
                    pass
                try:
                    if (a[OB_ROW_VOL_TEXT] != b[OB_ROW_VOL_TEXT]) or (a[OB_ROW_PRICE_TEXT] != b[OB_ROW_PRICE_TEXT]):
                        return False
                except Exception:
                    return False
                # Compare only fields that affect painting; ignore brushes/price_value to avoid false positives.
                try:
                    if _rgba(a[OB_ROW_VOL_FG]) != _rgba(b[OB_ROW_VOL_FG]):
                        return False
                    if _rgba(a[OB_ROW_PRICE_FG]) != _rgba(b[OB_ROW_PRICE_FG]):
                        return False
                    if _rgba(a[OB_ROW_VOL_BG]) != _rgba(b[OB_ROW_VOL_BG]):
                        return False
                    if _rgba(a[OB_ROW_PRICE_BG]) != _rgba(b[OB_ROW_PRICE_BG]):
                        return False
                    if _rgba(a[OB_ROW_BAR_COLOR]) != _rgba(b[OB_ROW_BAR_COLOR]):
                        return False
                    if _rgba(a[OB_ROW_VOL_BASE_BG]) != _rgba(b[OB_ROW_VOL_BASE_BG]):
                        return False
                except Exception:
                    return False
                try:
                    if abs(float(a[OB_ROW_BAR_FRAC]) - float(b[OB_ROW_BAR_FRAC])) > 1e-6:
                        return False
                except Exception:
                    return False
                try:
                    if int(a[OB_ROW_STYLE_FLAGS]) != int(b[OB_ROW_STYLE_FLAGS]):
                        return False
                except Exception:
                    pass
                return True

            for i in range(len(rows)):
                try:
                    if not _row_eq(rows[i], old[i]):
                        changed.append(i)
                except Exception:
                    changed.append(i)
            if not changed:
                return
            # Merge into contiguous spans
            spans = []
            s = e = changed[0]
            for idx in changed[1:]:
                if idx == e + 1:
                    e = idx
                else:
                    spans.append((s, e))
                    s = e = idx
            spans.append((s, e))
            for s, e in spans:
                top_left = self.index(s, 0)
                bottom_right = self.index(e, 1)
                self.dataChanged.emit(top_left, bottom_right, [Qt.DisplayRole, Qt.ForegroundRole, self.ROLE_META])
        except Exception:
            # Fallback: full repaint
            try:
                top_left = self.index(0, 0)
                bottom_right = self.index(len(rows) - 1, 1)
                self.dataChanged.emit(top_left, bottom_right, [Qt.DisplayRole, Qt.ForegroundRole, self.ROLE_META])
            except Exception:
                pass

    def clear(self):
        if not self._rows:
            return
        self.beginResetModel()
        self._rows = []
        self.endResetModel()

    def price_at_row(self, row):
        try:
            return self._rows[row][OB_ROW_PRICE_VALUE]
        except Exception:
            return None


class OrderbookDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        row = index.data(OrderbookModel.ROLE_META)
        if not row:
            super().paint(painter, option, index)
            return
        col = index.column()
        rect = option.rect
        painter.save()
        try:
            painter.fillRect(rect, option.palette.base())
        except Exception:
            pass
        if col == ORDERBOOK_COL_PRICE:
            price_bg = row[OB_ROW_PRICE_BG]
            if price_bg is not None and price_bg.alpha() > 0:
                painter.fillRect(rect, price_bg)
        else:
            vol_bg = row[OB_ROW_VOL_BG]
            vol_base_bg = row[OB_ROW_VOL_BASE_BG]
            try:
                show_depth_bars = bool(globals().get("ORDERBOOK_SHOW_DEPTH_BARS", True))
            except Exception:
                show_depth_bars = True
            # Base background (keep theme/order/marker highlights).
            if vol_bg is not None and vol_bg.alpha() > 0:
                painter.fillRect(rect, vol_bg)
            elif vol_base_bg is not None and vol_base_bg.alpha() > 0:
                painter.fillRect(rect, vol_base_bg)
            # Depth bar overlay: solid left->right fill.
            if show_depth_bars:
                try:
                    bar_frac = float(row[OB_ROW_BAR_FRAC] or 0.0)
                except Exception:
                    bar_frac = 0.0
                bar_color = row[OB_ROW_BAR_COLOR]
                if bar_color is not None and bar_frac > 0:
                    try:
                        w = int(rect.width() * max(0.0, min(bar_frac, 1.0)))
                    except Exception:
                        w = 0
                    if w > 0:
                        try:
                            bar_rect = QRect(rect.left(), rect.top(), w, rect.height())
                            painter.fillRect(bar_rect, bar_color)
                        except Exception:
                            pass
        if col == ORDERBOOK_COL_VOL:
            text = row[OB_ROW_VOL_TEXT]
            color = row[OB_ROW_VOL_FG]
            try:
                text = str(text).lstrip()
            except Exception:
                pass
        else:
            text = row[OB_ROW_PRICE_TEXT]
            color = row[OB_ROW_PRICE_FG]
        if color is None:
            try:
                color = option.palette.text().color()
            except Exception:
                color = QColor(220, 220, 220)
        painter.setPen(color)        # Font styling: normal by default; bold ONLY for best bid/ask (and optional price-bold flag)
        try:
            style_flags = int(row[OB_ROW_STYLE_FLAGS]) if len(row) > OB_ROW_STYLE_FLAGS else 0
        except Exception:
            try:
                style_flags = int(row[11]) if len(row) > 11 else 0
            except Exception:
                style_flags = 0
        try:
            fnt = QFont(option.font)
            try:
                fnt.setBold(False)
            except Exception:
                pass
            try:
                bold_this = False
                if (style_flags & OB_STYLE_BOLD_ALL) != 0:
                    bold_this = True
                elif (style_flags & OB_STYLE_BOLD_PRICE) != 0 and col == ORDERBOOK_COL_PRICE:
                    bold_this = True
                if bold_this:
                    fnt.setBold(True)
            except Exception:
                pass
        except Exception:
            fnt = option.font
        painter.setFont(fnt)
        if col == ORDERBOOK_COL_VOL:
            # VOL: left aligned, allow full width (avoid clipping last char)
            text_rect = rect.adjusted(1, 0, 0, 0)
            align = (Qt.AlignLeft | Qt.AlignVCenter)
        else:
            # PRICE: left aligned so there's no 'fake extra column' / gap between VOL and PRICE
            text_rect = rect.adjusted(0, 0, -1, 0)
            align = (Qt.AlignLeft | Qt.AlignVCenter)
        painter.drawText(text_rect, align, text or "")
        painter.restore()

GUI_THEMES = {
    "Nord": {
        "window_bg": "#2e3440",
        "panel_bg": "#3b4252",
        "text": "#eceff4",
        "muted": "#4c566a",
        "accent": "#88c0d0",
        "chart_bg": "#232831",
        "chart_pen": "#8fbcbb"
    },
    "Dark": {
        "window_bg": "#111417",
        "panel_bg": "#181c20",
        "text": "#e6edf3",
        "muted": "#8b949e",
        "accent": "#2f81f7",
        "chart_bg": "#0c1014",
        "chart_pen": "#58a6ff"
    },
    "Light": {
        "window_bg": "#f5f7fb",
        "panel_bg": "#ffffff",
        "text": "#0f172a",
        "muted": "#4c566a",
        "accent": "#2563eb",
        "chart_bg": "#f5f5f5",
        "chart_pen": "#1d4ed8"
    },
    "Monokai": {
        "window_bg": "#272822",
        "panel_bg": "#2f3129",
        "text": "#f8f8f2",
        "muted": "#a6e22e",
        "accent": "#f5f7fb",
        "chart_bg": "#1d1f19",
        "chart_pen": "#a6e22e"
    },
    "Solarized": {
        "window_bg": "#002b36",
        "panel_bg": "#073642",
        "text": "#eee8d5",
        "muted": "#93a1a1",
        "accent": "#f5f7fb",
        "chart_bg": "#003440",
        "chart_pen": "#b58900"
    },
    "Nord": {
        "window_bg": "#2e3440",
        "panel_bg": "#3b4252",
        "text": "#eceff4",
        "muted": "#4c566a",
        "accent": "#88c0d0",
        "chart_bg": "#232831",
        "chart_pen": "#8fbcbb"
    },
    "Dracula": {
        "window_bg": "#282a36",
        "panel_bg": "#343746",
        "text": "#f8f8f2",
        "muted": "#6272a4",
        "accent": "#bd93f9",
        "chart_bg": "#20222c",
        "chart_pen": "#50fa7b"
    },
    "Forest": {
        "window_bg": "#0f1f1a",
        "panel_bg": "#163026",
        "text": "#e0f2e9",
        "muted": "#4d6b5c",
        "accent": "#4caf50",
        "chart_bg": "#0b1813",
        "chart_pen": "#81c784"
    }
}

SETTINGS_UI_FIELDS = [
    {"key": "API_KEY", "label": "API Key"},
    {"key": "API_SECRET", "label": "API Secret", "secret": True},
    {"key": "TOP_N_GROWTH", "label": "Top N зростання"},
    {"key": "TOP_N_FALL", "label": "Top N падіння"},
    {"key": "TOP_N_VOLUME", "label": "Top N обсяг"},
    {"key": "TOP_N_NATR", "label": "Top N NATR"},
    {"key": "NATR_PERIOD", "label": "NATR період"},
    {"key": "NATR_1M_MIN", "label": "Мін. 1m NATR"},
    {"key": "LEVEL_WINDOW", "label": "Вікно рівнів"},
    {"key": "LEVEL_PRECISION", "label": "Точність рівнів"},
    {"key": "DYN_MIN_LEVEL_DISTANCE", "label": "Мін. дистанція до рівня"},
    {"key": "DYN_MAX_LEVEL_DISTANCE", "label": "Макс. дистанція до рівня"},
    {"key": "TOLERANCE", "label": "Допуск (tolerance)"},
    {"key": "MIN_TOUCHES", "label": "Мін. торкань"},
{"key": "MIN_INTERVAL", "label": "Мін. інтервал"},
{"key": "MIN_LEVEL_FRESHNESS_BARS", "label": "Мін. барів від торкання рівня"},
    {"key": "RR_MIN", "label": "RR мін"},
    {"key": "RR_MAX", "label": "RR макс"},
    {"key": "TP_PARTS", "label": "Кількість TP частин"},
    {"key": "TP_WEIGHT_POWER", "label": "TP weight power"},
    {"key": "MIN_STOP_BUFFER_PCT", "label": "Мін. буфер для пробоїв"},
    {"key": "TRAILING_NATR_FACTOR", "label": "Trailing NATR factor"},
    {"key": "TRAILING_MIN_PERCENT", "label": "Trailing мін %"},
    {"key": "TRAILING_MAX_PERCENT", "label": "Trailing макс %"},
    {"key": "CONSECUTIVE_LOSS_PROTECTION", "label": "Ліміт підряд збитків"},
    {"key": "CONSECUTIVE_LOSS_H", "label": "Інтервал збитків, год"},
    {"key": "PROFIT_STOP_THRESHOLD_PERCENT", "label": "Стоп по прибутку, %"},
    {"key": "LOSS_STOP_THRESHOLD_PERCENT", "label": "Стоп по збитку, %"},
    {"key": "VOLUME_24H_THRESHOLD", "label": "Мін. 24h обсяг, USDT"},
    {"key": "AMERICA_MULTI_MIN", "label": "Америка 15-19 мін плече"},
    {"key": "AMERICA_MULTI_MAX", "label": "Америка 15-19 макс плече"},
    {"key": "ASIA_MULTI_MIN", "label": "Азія 2-9 мін плече"},
    {"key": "ASIA_MULTI_MAX", "label": "Азія 2-9 макс плече"},
    {"key": "EUROPE_MULTI_MIN", "label": "Європа 10-14 мін плече"},
    {"key": "EUROPE_MULTI_MAX", "label": "Європа 10-14 макс плече"},
    {"key": "RESERVE_MULTI_MIN", "label": "Резервна гілка мін"},
    {"key": "RESERVE_MULTI_MAX", "label": "Резервна гілка макс"},
{"key": "LOG_DIR", "label": "Каталог логів"},
{"key": "SOUND_ENABLED", "label": "Trade sounds", "type": "toggle", "ai_toggle": False},
{"key": "TRADE_OPEN_SOUND_FILE", "label": "Open sound file (wav)", "type": "file", "ai_toggle": False},
{"key": "TRADE_CLOSE_SOUND_FILE", "label": "Close sound file (wav)", "type": "file", "ai_toggle": False},
{"key": "TELEGRAM_USERS_FILE", "label": "Файл Telegram користувачів"},
{"key": "TELEGRAM_TOKEN", "label": "Telegram бот-токен"},
{"key": "EQUITY_HISTORY_FILE", "label": "Файл еквіті"},
{"key": "SETTINGS_HISTORY_FILE", "label": "Файл історії налаштувань"},
    {"key": "WINDOWS_TIME_SYNC_ENABLED", "label": "Синхронізація часу Windows"},
    {"key": "WINDOWS_TIME_SYNC_INTERVAL", "label": "Інтервал синхронізації, с"},
    {"key": "TEMP_WIDEN_THRESHOLD_PCT", "label": "Temp widen threshold, %"},
    {"key": "TEMP_WIDEN_AMOUNT_PCT", "label": "Temp widen delta, %"},
    # GPT Advisor UI
    {"key": "GPT_ENABLED", "label": "GPT advisor enabled"},
    {"key": "GPT_API_KEY", "label": "GPT API Key", "secret": True},
    {"key": "GPT_BASE_URL", "label": "GPT Base URL"},
    {"key": "GPT_MODEL", "label": "GPT Model"},
    {"key": "GPT_ADVISOR_INTERVAL", "label": "GPT advisor interval, s"},
    {"key": "GPT_FORCE_JSON", "label": "GPT force JSON"},
    {"key": "GPT_MAX_TOKENS", "label": "GPT max tokens"},
    {"key": "GPT_AUTO_APPLY", "label": "GPT auto-apply suggestions"},
    {"key": "GPT_TIMEOUT_SEC", "label": "GPT timeout, s"},
    {"key": "GPT_RECENT_LOG_LINES", "label": "GPT recent log lines"},
    {"key": "GPT_INCLUDE_LOGS", "label": "GPT include logs"},
    {"key": "GPT_LOG_FILTER", "label": "GPT log filter (regex)"},
    # Advisor gate (pauses GPT requests)
    {"key": "ADVISOR_GATE_ENABLED", "label": "Advisor gate enabled"},
    {"key": "ADVISOR_GATE_MIN_WINRATE_PCT", "label": "Gate min winrate, %"},
    {"key": "ADVISOR_GATE_IDLE_HOURS", "label": "Gate idle hours"},
    {"key": "ADVISOR_GATE_MAX_DRAWDOWN_PCT", "label": "Gate max drawdown, %"},
    # Extra tuning
    {"key": "STOP_NATR_BUFFER_FACTOR", "label": "Stop NATR buffer factor"},
    {"key": "FAST_APPROACH_MIN_BUFFER", "label": "Fast-approach min buffer %"},
    {"key": "DYN_NATR_FACTOR", "label": "Dyn dist NATR factor"},
    {"key": "DYN_VOL_FACTOR", "label": "Dyn dist vol factor"},
    {"key": "DYN_VOL_WINDOW", "label": "Dyn dist vol window"},
    {"key": "HARD_SL_OFFSET_PCT", "label": "Risk anchor (fraction)"},
    {"key": "STOP_LOSS_MIN_PCT", "label": "Hard SL min dist (fraction)"},
    {"key": "STOP_LOSS_MAX_PCT", "label": "Hard SL max dist (fraction)"},
    {"key": "MIN_POS_NOTIONAL_MULT", "label": "Min pos notional = bal*x (0=off)"},
    {"key": "MAX_POS_NOTIONAL_MULT", "label": "Max pos notional = bal*x (0=off)"},
    {"key": "MAX_APPROACH_PERCENT", "label": "Max approach %"},
    {"key": "MIN_MULTI", "label": "Min position multiplier"},
    {"key": "MAX_MULTI", "label": "Max position multiplier"},
    {"key": "POS_VOL_FACTOR", "label": "Position vol factor"},
    {"key": "POS_VOL_WINDOW", "label": "Position vol window"},
]

# Compose a superset for UI: include any keys from SETTINGS_KEYS that are
# not explicitly listed in SETTINGS_UI_FIELDS (fallback label = key)
def _build_all_settings_fields():
    try:
        ui_keys = set([f.get("key") for f in SETTINGS_UI_FIELDS if isinstance(f, dict)])
    except Exception:
        ui_keys = set()
    extra = []
    try:
        for k in _iter_setting_keys():
            if k not in ui_keys:
                extra.append({"key": k, "label": k})
    except Exception:
        pass
    return SETTINGS_UI_FIELDS + extra

SETTINGS_ALL_FIELDS = _build_all_settings_fields()

SWITCH_CHECKBOX_CSS = (
    "QCheckBox { spacing: 6px; }"
    "QCheckBox::indicator { width: 38px; height: 18px; border-radius: 9px; }"
    "QCheckBox::indicator:unchecked { background: rgba(120,120,120,140); }"
    "QCheckBox::indicator:checked { background: rgba(80,180,120,170); }"
)


def _apply_switch_style(widget):
    try:
        widget.setStyleSheet(SWITCH_CHECKBOX_CSS)
    except Exception:
        pass


class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Налаштування")
        self.setMinimumWidth(420)
        layout = QVBoxLayout(self)
        self.inputs = {}
        self.ai_toggles = {}

        scroll = QScrollArea(self)
        scroll.setWidgetResizable(True)
        container = QWidget()
        form = QFormLayout(container)
        # Prepare current allow list and forbidden set for toggles
        try:
            allowed_now = set(_advisor_allowed_keys())
        except Exception:
            allowed_now = set()
        try:
            forbidden = set(globals().get('ADVISOR_FORBIDDEN_KEYS') or set())
        except Exception:
            forbidden = set()
        for field in SETTINGS_ALL_FIELDS:
            key = field["key"]
            field_type = (field.get("type") or "text").lower()
            value = globals().get(key)
            # Build a row widget with the editor and optional AI toggle
            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 0, 0, 0)
            editor = None
            if field_type == "toggle":
                slider = QSlider(Qt.Horizontal)
                slider.setMinimum(0)
                slider.setMaximum(1)
                slider.setSingleStep(1)
                slider.setPageStep(1)
                slider.setFixedWidth(90)
                slider.setValue(1 if value else 0)
                state_label = QLabel("On" if slider.value() else "Off")
                slider.valueChanged.connect(lambda val, lbl=state_label: lbl.setText("On" if val else "Off"))
                row_layout.addWidget(slider)
                row_layout.addWidget(state_label)
                editor = slider
            else:
                editor = QLineEdit()
                editor.setText("" if value is None else str(value))
                if field.get("secret"):
                    editor.setEchoMode(QLineEdit.PasswordEchoOnEdit)
                if field_type == "file":
                    browse_btn = QPushButton("...")
                    browse_btn.setFixedWidth(32)
                    browse_btn.clicked.connect(lambda _, line=editor: self._choose_sound_file(line))
                    row_layout.addWidget(editor)
                    row_layout.addWidget(browse_btn)
                else:
                    row_layout.addWidget(editor)
            show_toggle = (key not in forbidden) and field.get("ai_toggle", True)
            if show_toggle:
                ai_toggle = QCheckBox("AI")
                ai_toggle.setToolTip("Дозволити ШІ змінювати це налаштування")
                ai_toggle.setChecked(key in allowed_now)
                _apply_switch_style(ai_toggle)
                self.ai_toggles[key] = ai_toggle
                row_layout.addStretch(1)
                row_layout.addWidget(ai_toggle)
            form.addRow(field["label"], row_widget)
            self.inputs[key] = editor
        scroll.setWidget(container)
        layout.addWidget(scroll)

        btn_row = QHBoxLayout()
        self.reload_btn = QPushButton("Завантажити з файлу")
        self.save_btn = QPushButton("Зберегти")
        self.cancel_btn = QPushButton("Скасувати")
        btn_row.addStretch(1)
        btn_row.addWidget(self.reload_btn)
        btn_row.addWidget(self.save_btn)
        btn_row.addWidget(self.cancel_btn)
        layout.addLayout(btn_row)

        self.save_btn.clicked.connect(self.handle_save)
        self.reload_btn.clicked.connect(self.handle_reload)
        self.cancel_btn.clicked.connect(self.reject)

    def _set_editor_value(self, editor, value):
        if editor is None:
            return
        if isinstance(editor, QLineEdit):
            editor.setText("" if value is None else str(value))
        elif isinstance(editor, QSlider):
            editor.setValue(1 if bool(value) else 0)
        elif isinstance(editor, QCheckBox):
            editor.setChecked(bool(value))

    def _get_editor_value(self, editor):
        if isinstance(editor, QLineEdit):
            return editor.text().strip()
        if isinstance(editor, QSlider):
            return editor.value()
        if isinstance(editor, QCheckBox):
            return editor.isChecked()
        return None

    def _choose_sound_file(self, target_line: QLineEdit):
        path, _ = QFileDialog.getOpenFileName(self, "�������� �����", "", "Audio files (*.wav *.mp3 *.ogg);;All files (*.*)")
        if path:
            target_line.setText(path)

    def refresh_fields(self):
        for key, editor in self.inputs.items():
            if editor is None:
                continue
            value = globals().get(key)
            self._set_editor_value(editor, value)
        # Refresh AI toggles based on current allow-list
        try:
            allowed_now = set(_advisor_allowed_keys())
        except Exception:
            allowed_now = set()
        for k, cb in self.ai_toggles.items():
            try:
                cb.setChecked(k in allowed_now)
            except Exception:
                pass

    def handle_reload(self):
        if load_settings_from_file():
            self.refresh_fields()
        else:
            QMessageBox.warning(self, "Помилка", "Не вдалося перезавантажити налаштування. Перевір файли логів.")

    def handle_save(self):
        # Persist AI toggles into global map before saving
        try:
            amap = {}
            for k, cb in self.ai_toggles.items():
                amap[k] = bool(cb.isChecked())
            globals()['ADVISOR_ALLOWED_MAP'] = amap
        except Exception:
            pass
        for field in SETTINGS_ALL_FIELDS:
            key = field["key"]
            editor = self.inputs.get(key)
            if editor is None:
                continue
            raw = self._get_editor_value(editor)
            try:
                _set_setting_value(key, raw, silent=False)
            except Exception as exc:
                QMessageBox.warning(
                    self,
                    "Некоректне значення",
                    f"Поле «{field['label']}» має невірний формат: {exc}"
                )
                editor.setFocus()
                editor.selectAll()
                return

        if save_settings_to_file():
            try:
                global client
                client = Client(API_KEY, API_SECRET)
                log_message(
                    f"[SETTINGS] Client reinitialized "
                    f"API_KEY={_secret_fingerprint(globals().get('API_KEY'))} "
                    f"API_SECRET={_secret_fingerprint(globals().get('API_SECRET'))}"
                )
            except Exception as e:
                try:
                    log_message(f"[SETTINGS] Client reinit failed: {e}")
                except Exception:
                    pass
            try:
                if WINDOWS_TIME_SYNC_ENABLED:
                    QTimer.singleShot(600, start_windows_time_sync)
            except Exception:
                pass
            self.accept()
        else:
             QMessageBox.warning(self, 'Помилка', 'Не вдалося зберегти налаштування. Перевір файли логів.')

def load_settings_from_file():
    global last_recorded_equity_balance
    global client
    try:
        if not os.path.exists(SETTINGS_FILE):
            log_message(f"ℹ️ Файл {SETTINGS_FILE} не знайдено — використовую стандартні значення.")
            return False
        with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
        data, _ = _strip_locked_settings_keys(data, persist=True, source="load")
        _apply_settings_dict(data, silent=False)
        try:
            _apply_prints_agg_extra()
        except Exception:
            pass
        # Enforce fixed candle count (user request)
        try:
            globals()['CHART_CANDLE_LIMIT'] = 450
        except Exception:
            pass
        # POST-LOAD clamp prints tape FPS (avoid stale slow timers)
        try:
            globals()['PRINTS_TAPE_FRAME_MS'] = max(0, min(int(globals().get('PRINTS_TAPE_FRAME_MS', 8) or 8), 8))
        except Exception:
            globals()['PRINTS_TAPE_FRAME_MS'] = 8
        try:
            globals()['PRINTS_UI_FRAME_MS'] = max(0, min(int(globals().get('PRINTS_UI_FRAME_MS', 8) or 8), 16))
        except Exception:
            globals()['PRINTS_UI_FRAME_MS'] = 8
        try:
            log_message(
                f"[SETTINGS] Loaded from {SETTINGS_FILE} "
                f"API_KEY={_secret_fingerprint(globals().get('API_KEY'))} "
                f"API_SECRET={_secret_fingerprint(globals().get('API_SECRET'))}"
            )
        except Exception:
            pass

        # Restore last recorded equity for the daily reset logic
        try:
            with equity_history_lock:
                last_point = equity_history[-1] if equity_history else None
            if last_point:
                last_recorded_equity_balance = float(last_point.get('balance', 0.0))
        except Exception:
            pass

        if not load_equity_history_from_file():
            save_equity_history_to_file()
        if not load_trade_journal_from_file():
            save_trade_journal_to_file()

        log_message(f"ℹ️ Налаштування завантажено з {SETTINGS_FILE}")

        # Reinitialize client immediately after loading keys so PRE-START order/position sync works
        try:
            client = Client(API_KEY, API_SECRET)
            sync_time()
        except Exception:
            pass

        # Start lightweight Futures user-data stream immediately so MANUAL orders/positions appear BEFORE bot start
        try:
            if USE_MANUAL_USER_STREAM and API_KEY and API_SECRET:
                _manual_user_stream_start()
        except Exception:
            pass

        return True
    except Exception as e:
        log_message(f"⚠️ Не вдалося завантажити налаштування з {SETTINGS_FILE}: {e}")
        log_message(traceback.format_exc())
        return False



def save_settings_to_file():

    try:
        # Start with existing file (preserve unknown keys), then update known ones
        current = {}
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    current = json.load(f) or {}
        except Exception:
            current = {}
        current, _ = _strip_locked_settings_keys(current, persist=False, source="save")

        for key in _iter_setting_keys():
            if key in globals():
                val = globals().get(key)
                current[key] = bool(val) if isinstance(val, bool) else val
        # Also persist any advisor-allowed keys even if not in SETTINGS_KEYS
        try:
            for key in (globals().get('ADVISOR_ALLOWED_KEYS') or []):
                if key in globals():
                    val = globals().get(key)
                    current[key] = bool(val) if isinstance(val, bool) else val
        except Exception:
            pass
        # Persist advisor per-key allow map
        try:
            amap = globals().get('ADVISOR_ALLOWED_MAP')
            if isinstance(amap, dict):
                # Only include boolean flags for known keys
                current['ADVISOR_ALLOWED_MAP'] = {k: bool(v) for k, v in amap.items() if k in globals()}
        except Exception:
            pass

        # Prefer atomic save (and ensure dirs exist).
        try:
            save_settings_atomic(current, SETTINGS_FILE)
        except Exception:
            # Fallback (non-atomic) if atomic helper fails for any reason.
            d = os.path.dirname(SETTINGS_FILE)
            if d and not os.path.exists(d):
                os.makedirs(d, exist_ok=True)
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(current, f, indent=2, ensure_ascii=False)

        # Verify we actually saved the intended values (especially keys) to the active file.
        try:
            with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                verify = json.load(f) or {}
        except Exception as ve:
            log_message(f"[SETTINGS] Save verify failed for {SETTINGS_FILE}: {ve}")
            log_message(traceback.format_exc())
            return False

        try:
            runtime_key = _secret_fingerprint(globals().get("API_KEY"))
            runtime_secret = _secret_fingerprint(globals().get("API_SECRET"))
            file_key = _secret_fingerprint(verify.get("API_KEY"))
            file_secret = _secret_fingerprint(verify.get("API_SECRET"))
            if runtime_key != file_key or runtime_secret != file_secret:
                log_message(
                    f"[SETTINGS] WARNING: saved keys mismatch. File={SETTINGS_FILE} "
                    f"runtime_key={runtime_key} file_key={file_key} "
                    f"runtime_secret={runtime_secret} file_secret={file_secret}"
                )
        except Exception:
            pass

        log_message(f"[SETTINGS] Saved to {SETTINGS_FILE}")
        return True
    except Exception as e:
        log_message(f"⚠️ Не вдалося зберегти налаштування: {e}")
        log_message(traceback.format_exc())
        return False
class BotWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        # UI visibility toggles
        self._book_enabled = True
        self._tape_enabled = True

        self.setWindowTitle("Tetra")
        self.resize(1280, 820)
        self.current_theme = "Nord"
        self.current_symbol = "RIVERUSDT"
        self.current_level = None
        self._equity_history_local = []
        self._trade_journal_local = []
        self._orderbook_local = None
        self._prints_local = []
        self._prints_pending = []
        self._prints_flush_timer = None
        self._orderbook_render_lock = threading.Lock()
        self._orderbook_render_event = threading.Event()
        self._orderbook_render_pending = None
        self._orderbook_render_thread = None
        self._orderbook_render_stop = threading.Event()
        self._orderbook_render_proc = None
        self._orderbook_render_procs = []
        self._orderbook_render_in_list = []
        self._orderbook_render_rr = 0
        self._orderbook_render_seq = 0
        self._orderbook_render_last_seq = -1
        self._orderbook_render_in = None
        self._orderbook_render_out = None
        self._orderbook_render_reader = None
        self._orderbook_render_reader_stop = threading.Event()
        self._orderbook_render_use_process = bool(globals().get("USE_ORDERBOOK_RENDER_PROCESS", True))
        self._chart_last_symbol = None

        # Some window managers ignore early showMaximized(); enforce once in showEvent.
        self._start_maximize_once = True
        try:
            QTimer.singleShot(0, self._ensure_start_maximized)
        except Exception:
            pass
        self._chart_last_candle_ts = None
        self._chart_last_candle_sig = None
        self._chart_last_candle_count = 0
        self._chart_last_trade_id = None
        self._chart_last_level = None
        self._chart_cached_xs = None
        self._book_price_prec = 2
        self._book_qty_prec = 4
        self._book_tick = 0.0
        self._book_tick_base = 0.0
        self._book_start_price = None
        self._book_tick_used = 0.0
        self._book_levels_used = 0
        self._book_symbol = None
        self._book_autotick_pending = False
        self._book_tick_mult_by_symbol = {}
        self._book_vol_user_resized = False
        self._book_vol_last_set_by_code = False
        self._book_scroll_anim = None
        self._book_scroll_target = None
        self._book_force_center_pending = False
        self._book_user_scroll_ts = 0.0
        self._book_scroll_last_render_ts = 0.0
        self._book_scroll_render_scheduled = False
        self._book_scroll_render_need_full = False
        self._settings_dialog = None
        self._splitter_sizes_applied = False
        try:
            ico = _get_app_icon()
            if ico:
                self.setWindowIcon(ico)
        except Exception:
            pass
        self._setup_ui()
        self._connect_signals()
        # --- Активація/підписка: відображення залишку днів та авто-оновлення щодня ---
        self._activation_timer = QTimer(self)
        self._activation_timer.setSingleShot(True)
        self._activation_timer.timeout.connect(self._refresh_activation_status)
        QTimer.singleShot(0, self._refresh_activation_status)
        # Auto-open стакан/тейп одразу після запуску (без натискання "Показати")
        try:
            if bool(globals().get('AUTO_START_BOOK_ON_LAUNCH', True)):
                QTimer.singleShot(50, self._autostart_book_on_launch)
        except Exception:
            pass
        self.apply_theme(self.current_theme)
        QTimer.singleShot(0, self._apply_initial_splitter_sizes)
        self.chart_timer = QTimer(self)
        self.chart_timer.timeout.connect(self.refresh_chart)
        self.chart_timer.start(1000)
        self._prestart_refresh_lock = threading.Lock()
        self._prestart_last_balance = 0.0
        self._prestart_last_orders = 0.0
        self._prestart_last_pos = 0.0
        self._prestart_timer = QTimer(self)
        self._prestart_timer.timeout.connect(self._refresh_prestart_state)
        self._prestart_timer.start(3000)
        QTimer.singleShot(200, self._refresh_prestart_state)

        # Force periodic repaint of the orderbook viewport for smoother highlights (UI FPS)
        # even when market-data updates are only ~10 Hz (Binance depth@100ms).
        self._book_repaint_timer = QTimer(self)
        try:
            self._book_repaint_timer.setTimerType(Qt.PreciseTimer)
        except Exception:
            pass
        self._book_repaint_timer.timeout.connect(self._force_book_repaint)
        try:
            self._book_repaint_timer.start(int(globals().get('BOOK_FORCE_REPAINT_MS', 8) or 13))
        except Exception:
            self._book_repaint_timer.start(8)


    def _on_toggle_tape_changed(self, checked: bool):
        try:
            self._tape_enabled = bool(checked)
        except Exception:
            self._tape_enabled = True
        self._apply_panel_visibility()

    def _on_toggle_book_changed(self, checked: bool):
        try:
            self._book_enabled = bool(checked)
        except Exception:
            self._book_enabled = True
        self._apply_panel_visibility()

    def _apply_panel_visibility(self):
        """Show/hide main market panels (tape / orderbook) and drop workload when hidden."""
        tape_on = bool(getattr(self, '_tape_enabled', True))
        book_on = bool(getattr(self, '_book_enabled', True))

        # containers
        try:
            pw = getattr(self, 'prints_container', None)
            if pw is not None:
                pw.setVisible(tape_on)
        except Exception:
            pass
        try:
            bw = getattr(self, 'book_container', None)
            if bw is not None:
                bw.setVisible(book_on)
        except Exception:
            pass

        # splitter sizing
        try:
            sp = getattr(self, 'book_tape_splitter', None)
            if sp is not None:
                try:
                    sp.setChildrenCollapsible(False)
                except Exception:
                    pass
                try:
                    if tape_on and book_on:
                        sp.setSizes([260, 520])
                    elif tape_on and not book_on:
                        sp.setSizes([1, 0])
                    elif (not tape_on) and book_on:
                        sp.setSizes([0, 1])
                    else:
                        sp.setSizes([0, 0])
                except Exception:
                    pass
        except Exception:
            pass

        # tape off => clear pending backlog and stop flush timer
        if not tape_on:
            try:
                self._prints_pending = []
            except Exception:
                pass
            try:
                if getattr(self, '_prints_flush_timer', None) is not None:
                    self._prints_flush_timer.stop()
            except Exception:
                pass


        # Persist orderbook VOL column width across hide/show (toggle switch)
        try:
            table = getattr(self, 'book_table', None)
            if table is not None:
                if not book_on:
                    try:
                        self._book_vol_saved_width = int(table.columnWidth(ORDERBOOK_COL_VOL))
                    except Exception:
                        pass
                    try:
                        self._book_price_saved_width = int(table.columnWidth(ORDERBOOK_COL_PRICE))
                    except Exception:
                        pass
                else:
                    # Ensure VOL can keep a fixed width; restore previous width if any
                    try:
                        hdr = table.horizontalHeader()
                        hdr.setSectionResizeMode(ORDERBOOK_COL_VOL, QHeaderView.Interactive)
                    except Exception:
                        pass
                    try:
                        saved_w = int(getattr(self, '_book_vol_saved_width', 0) or 0)
                    except Exception:
                        saved_w = 0
                    if saved_w > 0:
                        try:
                            self._book_vol_user_resized = True
                        except Exception:
                            pass
                        try:
                            QTimer.singleShot(0, lambda w=saved_w: self._apply_book_volume_width(override=w))
                        except Exception:
                            try:
                                self._apply_book_volume_width(override=saved_w)
                            except Exception:
                                pass
        except Exception:
            pass

        # book off => stop forced repaint timer (CPU saver)
        try:
            rt = getattr(self, '_book_repaint_timer', None)
            if rt is not None:
                if not book_on:
                    rt.stop()
                else:
                    if not rt.isActive():
                        try:
                            rt.start(int(globals().get('BOOK_FORCE_REPAINT_MS', 8) or 13))
                        except Exception:
                            rt.start(8)
        except Exception:
            pass


    def _ensure_start_maximized(self):
        """Ensure the main window opens maximized (robust on Windows + some WMs)."""
        try:
            if self.isMaximized():
                return
        except Exception:
            pass
        # Force geometry to the active screen's available area (helps on multi-monitor / 2K setups).
        try:
            from PySide6.QtGui import QGuiApplication, QCursor
            scr = None
            try:
                scr = QGuiApplication.screenAt(QCursor.pos())
            except Exception:
                scr = None
            if scr is None:
                try:
                    wh = self.windowHandle()
                    scr = wh.screen() if wh is not None else None
                except Exception:
                    scr = None
            if scr is None:
                try:
                    scr = QGuiApplication.primaryScreen()
                except Exception:
                    scr = None
            if scr is not None:
                try:
                    geo = scr.availableGeometry()
                    if geo is not None:
                        self.setGeometry(geo)
                except Exception:
                    pass
        except Exception:
            pass
        try:
            self.setWindowState(self.windowState() | Qt.WindowMaximized)
        except Exception:
            pass
        try:
            self.showMaximized()
        except Exception:
            pass
        try:
            QTimer.singleShot(50, self.showMaximized)
        except Exception:
            pass

        # After maximizing, re-apply initial splitter sizes so the orderbook/prints area
        # takes ~1/3 of the workspace by default (user can still resize manually).
        try:
            self._splitter_sizes_applied = False
            QTimer.singleShot(0, self._apply_initial_splitter_sizes)
        except Exception:
            pass

    def showEvent(self, event):
        try:
            super().showEvent(event)
        except Exception:
            pass
        try:
            if getattr(self, '_start_maximize_once', False):
                self._start_maximize_once = False
                self._ensure_start_maximized()
        except Exception:
            pass

    def _force_book_repaint(self):
        """Repaint orderbook table viewport (smooth UI even with low data rate)."""
        try:
            if not self.isVisible() or self.isMinimized():
                return
            try:
                if self._book_scroll_recent():
                    return
            except Exception:
                pass
            if (
                hasattr(self, 'book_table')
                and self.book_table is not None
                and self.book_table.isVisible()
            ):
                self.book_table.viewport().update()
        except Exception:
            pass




    def _dedup_incoming_prints(self, prints, ttl_s=2.0, max_keys=8000):
        """Drop duplicate prints to avoid WS/REST double-emits.

        Uses trade id if present, otherwise falls back to a rounded signature.
        Keeps a small TTL set (LRU-like) to prevent tape spam.
        """
        if not prints:
            return []
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()

        # init structures
        if not hasattr(self, '_prints_dedup_set'):
            self._prints_dedup_set = set()
            self._prints_dedup_q = deque()

        # purge old keys
        try:
            while self._prints_dedup_q:
                k, ts = self._prints_dedup_q[0]
                if (now_m - float(ts)) > float(ttl_s):
                    self._prints_dedup_q.popleft()
                    try:
                        self._prints_dedup_set.discard(k)
                    except Exception:
                        pass
                else:
                    break
        except Exception:
            pass

        out = []
        for it in prints:
            if not isinstance(it, dict):
                continue
            tid = None
            try:
                tid = it.get('id') or it.get('trade_id') or it.get('tradeId') or it.get('a') or it.get('t')
            except Exception:
                tid = None

            if tid is not None:
                key = f'id:{tid}'
            else:
                # fallback signature: (side, price, qty, ts_bucket)
                try:
                    side = str(it.get('side') or '').upper()
                except Exception:
                    side = ''
                try:
                    price = float(it.get('price') or 0.0)
                except Exception:
                    price = 0.0
                try:
                    qty = float(it.get('qty') or 0.0)
                except Exception:
                    qty = 0.0
                try:
                    ts = float(it.get('ts') or 0.0)
                except Exception:
                    ts = 0.0
                ts_bucket = int(ts * 10.0) if ts else 0  # 100ms buckets
                key = f's:{side}|p:{price:.8f}|q:{qty:.8f}|t:{ts_bucket}'

            if key in self._prints_dedup_set:
                continue
            self._prints_dedup_set.add(key)
            self._prints_dedup_q.append((key, now_m))

            # hard cap
            try:
                if max_keys > 0 and len(self._prints_dedup_q) > int(max_keys):
                    old_k, _ = self._prints_dedup_q.popleft()
                    self._prints_dedup_set.discard(old_k)
            except Exception:
                pass

            out.append(it)

        return out

    def _normalize_click_entry_preset_values(self, values):
        try:
            defaults = list(globals().get("CLICK_ENTRY_PRESET_VALUES_DEFAULT") or [15.0, 200.0, 300.0, 400.0, 500.0])
        except Exception:
            defaults = [15.0, 200.0, 300.0, 400.0, 500.0]
        out = []
        for i in range(5):
            v = None
            if isinstance(values, (list, tuple)) and i < len(values):
                v = values[i]
            if v is None:
                v = defaults[i] if i < len(defaults) else defaults[-1]
            try:
                v = float(v)
            except Exception:
                v = defaults[i] if i < len(defaults) else defaults[-1]
            if v <= 0:
                v = defaults[i] if i < len(defaults) else 1.0
            out.append(float(v))
        return out

    def _sync_click_entry_presets_ui(self):
        spins = getattr(self, "click_entry_preset_spins", None)
        toggles = getattr(self, "click_entry_preset_toggles", None)
        if not spins or not toggles:
            return
        try:
            values = self._normalize_click_entry_preset_values(globals().get("CLICK_ENTRY_PRESET_VALUES"))
            globals()["CLICK_ENTRY_PRESET_VALUES"] = list(values)
        except Exception:
            values = self._normalize_click_entry_preset_values(None)
        try:
            active = int(globals().get("CLICK_ENTRY_PRESET_ACTIVE", 0) or 0)
        except Exception:
            active = 0
        active = max(0, min(active, len(spins) - 1))
        try:
            self._click_entry_preset_block = True
            for i, spin in enumerate(spins):
                try:
                    spin.blockSignals(True)
                    spin.setValue(float(values[i]))
                finally:
                    try:
                        spin.blockSignals(False)
                    except Exception:
                        pass
            for i, chk in enumerate(toggles):
                try:
                    chk.blockSignals(True)
                    chk.setChecked(i == active)
                finally:
                    try:
                        chk.blockSignals(False)
                    except Exception:
                        pass
        finally:
            try:
                self._click_entry_preset_block = False
            except Exception:
                pass
        try:
            globals()["CLICK_ENTRY_NOTIONAL_USD"] = float(values[active])
        except Exception:
            pass

    def _set_active_click_entry_preset(self, idx, apply_value=True, save=True):
        spins = getattr(self, "click_entry_preset_spins", None)
        toggles = getattr(self, "click_entry_preset_toggles", None)
        if not spins or not toggles:
            return
        try:
            idx = int(idx)
        except Exception:
            idx = 0
        idx = max(0, min(idx, len(spins) - 1))
        try:
            self._click_entry_preset_block = True
            for i, chk in enumerate(toggles):
                try:
                    chk.blockSignals(True)
                    chk.setChecked(i == idx)
                finally:
                    try:
                        chk.blockSignals(False)
                    except Exception:
                        pass
        finally:
            try:
                self._click_entry_preset_block = False
            except Exception:
                pass
        try:
            globals()["CLICK_ENTRY_PRESET_ACTIVE"] = int(idx)
        except Exception:
            pass
        if apply_value:
            try:
                val = float(spins[idx].value())
            except Exception:
                val = None
            if val is not None:
                try:
                    globals()["CLICK_ENTRY_NOTIONAL_USD"] = float(val)
                except Exception:
                    pass
        if save:
            try:
                save_settings_to_file()
            except Exception:
                pass

    def _on_click_entry_preset_toggled(self, idx, checked):
        try:
            if bool(getattr(self, "_click_entry_preset_block", False)):
                return
        except Exception:
            pass
        if checked:
            self._set_active_click_entry_preset(idx, apply_value=True, save=True)
            return
        toggles = getattr(self, "click_entry_preset_toggles", None)
        if not toggles:
            return
        any_checked = False
        for chk in toggles:
            try:
                if chk.isChecked():
                    any_checked = True
                    break
            except Exception:
                continue
        if not any_checked:
            self._set_active_click_entry_preset(idx, apply_value=True, save=True)

    def _on_click_entry_preset_value_changed(self, idx, val):
        try:
            values = self._normalize_click_entry_preset_values(globals().get("CLICK_ENTRY_PRESET_VALUES"))
        except Exception:
            values = self._normalize_click_entry_preset_values(None)
        try:
            idx = int(idx)
        except Exception:
            idx = 0
        idx = max(0, min(idx, len(values) - 1))
        try:
            values[idx] = int(round(float(val)))
        except Exception:
            pass
        try:
            globals()["CLICK_ENTRY_PRESET_VALUES"] = list(values)
        except Exception:
            pass
        try:
            active = int(globals().get("CLICK_ENTRY_PRESET_ACTIVE", 0) or 0)
        except Exception:
            active = 0
        if idx == active:
            try:
                globals()["CLICK_ENTRY_NOTIONAL_USD"] = int(round(float(val)))
            except Exception:
                pass
        try:
            save_settings_to_file()
        except Exception:
            pass

    def _build_click_entry_panel(self):
        try:
            panel = QFrame()
        except Exception:
            panel = QWidget()
        try:
            panel.setObjectName("clickEntryPanel")
        except Exception:
            pass
        try:
            panel.setFrameShape(QFrame.NoFrame)
        except Exception:
            pass
        try:
            panel.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
        except Exception:
            pass
        try:
            panel.setStyleSheet(
                "QFrame#clickEntryPanel {"
                " background-color: rgba(0, 0, 0, 0);"
                " border: 1px solid rgba(255, 255, 255, 30);"
                " border-radius: 4px;"
                " }"
            )
        except Exception:
            pass
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(2)

        grid = QGridLayout()
        grid.setContentsMargins(0, 0, 0, 0)
        grid.setHorizontalSpacing(3)
        grid.setVerticalSpacing(2)
        layout.addLayout(grid)

        self.click_entry_preset_spins = []
        self.click_entry_preset_toggles = []
        try:
            self._click_entry_preset_block = False
        except Exception:
            pass

        values = self._normalize_click_entry_preset_values(globals().get("CLICK_ENTRY_PRESET_VALUES"))
        for i in range(5):
            chk = QCheckBox()
            try:
                _apply_switch_style(chk)
            except Exception:
                pass
            usd_lbl = QLabel("$")
            try:
                usd_lbl.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
                usd_lbl.setFixedWidth(10)
            except Exception:
                pass
            spin = QDoubleSpinBox()
            spin.setDecimals(0)
            spin.setRange(1.0, 100000000.0)
            spin.setSingleStep(10.0)
            spin.setKeyboardTracking(True)
            try:
                spin.setButtonSymbols(QAbstractSpinBox.NoButtons)
            except Exception:
                pass
            try:
                spin.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            except Exception:
                pass
            try:
                spin.setValue(int(round(float(values[i]))))
            except Exception:
                spin.setValue(50)
            try:
                spin.setFixedWidth(72)
            except Exception:
                pass
            self.click_entry_preset_toggles.append(chk)
            self.click_entry_preset_spins.append(spin)
            grid.addWidget(chk, i, 0, 1, 1, Qt.AlignLeft)
            grid.addWidget(usd_lbl, i, 1, 1, 1, Qt.AlignRight)
            grid.addWidget(spin, i, 2, 1, 1)
            try:
                chk.toggled.connect(lambda checked, idx=i: self._on_click_entry_preset_toggled(idx, checked))
            except Exception:
                pass
            try:
                spin.valueChanged.connect(lambda val, idx=i: self._on_click_entry_preset_value_changed(idx, val))
            except Exception:
                pass

        try:
            panel.setFixedHeight(120)
        except Exception:
            pass
        try:
            panel.setMinimumWidth(110)
            panel.setMaximumWidth(150)
        except Exception:
            pass
        return panel

    def _refresh_activation_status(self):
        """Оновлює індикатор підписки в top-bar та планує наступне оновлення раз на добу."""
        try:
            import time as _time
            import math as _math
            from datetime import datetime, timedelta, timezone

            lbl = getattr(self, "activation_label", None)
            if lbl is None:
                return

            now_ts = int(_time.time())
            end_ts = int(globals().get("ACCESS_SUB_END_TS") or 0)
            active_flag = globals().get("ACCESS_SUB_ACTIVE", None)

            # Якщо немає дати завершення — показуємо базовий статус
            if end_ts <= 0:
                if active_flag is True:
                    lbl.setText("Активація: активна")
                elif active_flag is False:
                    lbl.setText("Активація: неактивна")
                else:
                    lbl.setText("Активація: —")
            else:
                remaining = end_ts - now_ts
                days_left = int(_math.ceil(remaining / 86400.0)) if remaining > 0 else 0

                # Вивід дати завершення в локальній TZ (Kyiv за замовчуванням)
                end_str = "?"
                try:
                    tz_name = globals().get("APP_TIMEZONE") or "Europe/Kyiv"
                    try:
                        import zoneinfo
                        tz = zoneinfo.ZoneInfo(tz_name)
                        end_dt = datetime.fromtimestamp(end_ts, tz=timezone.utc).astimezone(tz)
                    except Exception:
                        end_dt = datetime.fromtimestamp(end_ts)
                    end_str = end_dt.strftime("%Y-%m-%d")
                except Exception:
                    pass

                if remaining > 0:
                    lbl.setText(f"Активація: {days_left} дн. (до {end_str})")
                else:
                    lbl.setText(f"Активація: 0 дн. (закінчилась {end_str})")

        except Exception:
            pass

        # Плануємо наступне добове оновлення (00:01 локального часу)
        try:
            from datetime import datetime, timedelta
            # QTimer уже створено як singleShot=True
            tmr = getattr(self, "_activation_timer", None)
            if not tmr:
                return

            try:
                tz_name = globals().get("APP_TIMEZONE") or "Europe/Kyiv"
                import zoneinfo
                tz = zoneinfo.ZoneInfo(tz_name)
                now = datetime.now(tz)
            except Exception:
                now = datetime.now()

            target = now.replace(hour=0, minute=1, second=0, microsecond=0)
            if now >= target:
                target = target + timedelta(days=1)

            ms = int((target - now).total_seconds() * 1000)
            ms = max(1000, min(ms, 24 * 60 * 60 * 1000))  # safety clamp
            tmr.start(ms)
        except Exception:
            pass

    def _setup_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)

        top_row = QHBoxLayout()
        self.balance_label = QLabel("Баланс: 0.00 USDT | PnL: 0.00%")
        self.balance_label.setObjectName("balanceLabel")
        top_row.addWidget(self.balance_label)
        self.offset_label = QLabel("TimeS: 0 ms")
        self.offset_label.setObjectName("offsetLabel")
        top_row.addWidget(self.offset_label)
        self.ping_label = QLabel("Ping: -- ms")
        self.ping_label.setObjectName("pingLabel")
        top_row.addWidget(self.ping_label)
        self.ws_status_label = QLabel("WS: стакан OFF | принти OFF | графік OFF")
        self.ws_status_label.setObjectName("wsStatusLabel")
        top_row.addWidget(self.ws_status_label)
        # --- Активація/підписка ---
        self.activation_label = QLabel("Активація: —")
        self.activation_label.setObjectName("activationLabel")
        top_row.addWidget(self.activation_label)
        self.view_tabs = QTabBar()
        self.view_tabs.addTab("Logs")
        self.view_tabs.addTab("Journal")
        self.view_tabs.setExpanding(False)
        self.view_tabs.setDocumentMode(True)
        top_row.addWidget(self.view_tabs)
        top_row.addStretch(1)
        self.sound_label = QLabel(self._sound_status_text())
        self.sound_toggle = QCheckBox()
        self.sound_toggle.setChecked(bool(SOUND_ENABLED))
        _apply_switch_style(self.sound_toggle)
        self.sound_toggle.toggled.connect(self._on_sound_toggle_changed)
        top_row.addWidget(self.sound_label)
        top_row.addWidget(self.sound_toggle)
        top_row.addWidget(QLabel("Тема:"))
        self.theme_combo = QComboBox()
        self.theme_combo.addItems(list(GUI_THEMES.keys()))
        self.theme_combo.setCurrentText(self.current_theme)
        top_row.addWidget(self.theme_combo)
        top_row.addWidget(QLabel("Book step:"))
        self.book_tick_top_spin = QSpinBox()
        self.book_tick_top_spin.setRange(1, 100000)
        self.book_tick_top_spin.setKeyboardTracking(True)
        try:
            self.book_tick_top_spin.setValue(int(ORDERBOOK_TICK_MULT or 1))
        except Exception:
            self.book_tick_top_spin.setValue(1)
        top_row.addWidget(self.book_tick_top_spin)
        top_row.addWidget(QLabel("Book depth:"))
        self.book_depth_top_spin = QSpinBox()
        self.book_depth_top_spin.setRange(20, 20000)
        try:
            self.book_depth_top_spin.setValue(int(ORDERBOOK_LADDER_LEVELS or 1000))
        except Exception:
            self.book_depth_top_spin.setValue(1000)
        top_row.addWidget(self.book_depth_top_spin)
        top_row.addWidget(QLabel("Book levels:"))
        self.book_levels_top_spin = QSpinBox()
        self.book_levels_top_spin.setRange(20, 2000)
        try:
            self.book_levels_top_spin.setValue(int(ORDERBOOK_LEVELS or 500))
        except Exception:
            self.book_levels_top_spin.setValue(500)
        top_row.addWidget(self.book_levels_top_spin)
        self.book_auto_center_chk = QCheckBox("Auto-center book")
        try:
            self.book_auto_center_chk.setChecked(bool(ORDERBOOK_AUTO_CENTER))
        except Exception:
            self.book_auto_center_chk.setChecked(True)
        _apply_switch_style(self.book_auto_center_chk)
        top_row.addWidget(self.book_auto_center_chk)
        self.logout_button = QPushButton("Вийти з акаунту")
        self.logout_button.setObjectName("logoutButton")
        self.logout_button.clicked.connect(self._on_logout_clicked)
        top_row.addWidget(self.logout_button)
        self.settings_button = QPushButton("Налаштування")
        top_row.addWidget(self.settings_button)
        main_layout.addLayout(top_row)

        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)
        self._main_splitter = splitter

        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        self.log_view = QPlainTextEdit()
        self.log_view.setReadOnly(True)
        self.log_view.setMaximumBlockCount(2000)
        log_page = QWidget()
        log_layout = QVBoxLayout(log_page)
        log_layout.setContentsMargins(0, 0, 0, 0)
        log_layout.addWidget(self.log_view)

        journal_page = QWidget()
        journal_layout = QVBoxLayout(journal_page)
        journal_layout.setContentsMargins(0, 0, 0, 0)
        journal_range_row = QHBoxLayout()
        journal_range_row.addWidget(QLabel("Journal range:"))
        self.journal_range_combo = QComboBox()
        self.journal_range_combo.addItem("All time", "all")
        self.journal_range_combo.addItem("This week", "week")
        self.journal_range_combo.addItem("Last week", "last_week")
        self.journal_range_combo.addItem("Today", "today")
        journal_range_row.addWidget(self.journal_range_combo)
        journal_layout.addLayout(journal_range_row)

        self.journal_table = QTableWidget(0, 5)
        self.journal_table.setHorizontalHeaderLabels(["Time", "Ticker", "PnL %", "PnL USDT", "Тег"])
        self.journal_table.setEditTriggers(
            QTableWidget.DoubleClicked | QTableWidget.EditKeyPressed | QTableWidget.SelectedClicked
        )
        self.journal_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.journal_table.setSelectionMode(QTableWidget.SingleSelection)
        self.journal_table.setAlternatingRowColors(True)
        self.journal_table.verticalHeader().setVisible(False)
        self.journal_table.horizontalHeader().setStretchLastSection(True)
        self.journal_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        journal_layout.addWidget(self.journal_table)
        try:
            self._journal_tag_col = 4
            self._journal_updating = False
            self.journal_table.itemChanged.connect(self.on_trade_journal_item_changed)
        except Exception:
            pass

        self.left_stack = QStackedWidget()
        self.left_stack.addWidget(log_page)
        self.left_stack.addWidget(journal_page)
        self.left_stack.setCurrentIndex(0)
        left_layout.addWidget(self.left_stack)

        equity_axis = DateAxisItem(orientation='bottom')
        self.equity_chart = pg.PlotWidget(axisItems={'bottom': equity_axis})
        self.equity_chart.setMinimumHeight(180)
        try:
            if globals().get("GUI_USE_OPENGL", False):
                self.equity_chart.useOpenGL(False)
        except Exception:
            pass
        self.equity_chart.plotItem.setLabel('left', 'Equity (USDT)')
        self.equity_chart.plotItem.setLabel('bottom', 'Time')
        self.equity_curve = self.equity_chart.plot([], [], pen=pg.mkPen('#2ecc71', width=2))
        left_layout.addWidget(self.equity_chart)

        equity_range_row = QHBoxLayout()
        equity_range_row.addWidget(QLabel("Equity range:"))
        self.equity_range_combo = QComboBox()
        self.equity_range_combo.addItem("All time", "all")
        self.equity_range_combo.addItem("This week", "week")
        self.equity_range_combo.addItem("Last week", "last_week")
        self.equity_range_combo.addItem("Today", "today")
        equity_range_row.addWidget(self.equity_range_combo)
        left_layout.addLayout(equity_range_row)

        btn_row = QHBoxLayout()
        self.start_button = QPushButton("Запустити бота")
        self.stop_button = QPushButton("Зупинити бота")
        btn_row.addWidget(self.start_button)
        btn_row.addWidget(self.stop_button)
        left_layout.addLayout(btn_row)

        # --- Main panels toggles (switches) ---
        toggles_row = QHBoxLayout()
        toggles_row.setSpacing(8)
        self.toggle_tape_chk = QCheckBox("Лєнта")
        self.toggle_book_chk = QCheckBox("Стакан")
        try:
            self.toggle_tape_chk.setChecked(True)
            self.toggle_book_chk.setChecked(True)
        except Exception:
            pass
        _apply_switch_style(self.toggle_tape_chk)
        _apply_switch_style(self.toggle_book_chk)
        toggles_row.addWidget(self.toggle_tape_chk)
        toggles_row.addWidget(self.toggle_book_chk)
        toggles_row.addStretch(1)
        left_layout.addLayout(toggles_row)
        try:
            self.toggle_tape_chk.toggled.connect(self._on_toggle_tape_changed)
            self.toggle_book_chk.toggled.connect(self._on_toggle_book_changed)
        except Exception:
            pass


        # --- GPT Advisor panel ---
        advisor_panel = QWidget()
        advisor_layout = QVBoxLayout(advisor_panel)
        advisor_layout.setContentsMargins(0, 0, 0, 0)
        self.advisor_status = QLabel("GPT Advisor: idle")
        advisor_layout.addWidget(self.advisor_status)
        self.advisor_text = QPlainTextEdit()
        self.advisor_text.setPlaceholderText("Введіть підказку для радника (необов'язково), натисніть 'Ask Advisor'. Відповідь з'явиться тут у форматі JSON.")
        self.advisor_text.setMaximumBlockCount(2000)
        advisor_layout.addWidget(self.advisor_text)
        advisor_btns = QHBoxLayout()
        self.advisor_ask_btn = QPushButton("Ask Advisor")
        self.advisor_apply_btn = QPushButton("Apply Suggestion")
        advisor_btns.addWidget(self.advisor_ask_btn)
        advisor_btns.addWidget(self.advisor_apply_btn)
        advisor_layout.addLayout(advisor_btns)
        left_layout.addWidget(advisor_panel)

        splitter.addWidget(left_widget)

        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        try:
            right_layout.setContentsMargins(0, 0, 0, 0)
            right_layout.setSpacing(0)
        except Exception:
            pass
        axis = DateAxisItem(orientation='bottom')
        self.chart_widget = pg.PlotWidget(axisItems={'bottom': axis})
        self.plot_item = self.chart_widget.getPlotItem()
        self.view_box = self.plot_item.getViewBox()
        try:
            if globals().get("GUI_USE_OPENGL", False):
                self.chart_widget.useOpenGL(False)
        except Exception:
            pass
        self.chart_widget.setBackground("#111417")
        self.plot_item.showGrid(x=True, y=True, alpha=0.2)
        self.plot_item.setLabel('left', 'Price')
        self.plot_item.setLabel('bottom', 'Time (UTC)')
        self.plot_item.setMenuEnabled(False)
        self.candles_item = CandlestickItem()
        self.plot_item.addItem(self.candles_item)
        self.level_line = pg.PlotCurveItem([], [], pen=pg.mkPen('#ff5370', width=2, style=Qt.DashLine))
        self.level_line.setVisible(False)
        self.plot_item.addItem(self.level_line)
        self.price_line = pg.PlotCurveItem([], [], pen=pg.mkPen('#ffffff', width=1, style=Qt.DashDotLine))
        self.price_line.setVisible(False)
        self.price_line.setZValue(30)
        self.plot_item.addItem(self.price_line)
        self.price_label = pg.TextItem("", color="#ffffff", anchor=(1, 0.5),
                                       border=pg.mkPen("#ffffff"), fill=pg.mkBrush(0, 0, 0, 200))
        self.price_label.setVisible(False)
        self.price_label.setZValue(31)
        self.plot_item.addItem(self.price_label)
        self.hist_level_items = []
        self.chart_cursor_line = pg.PlotCurveItem([], [], pen=pg.mkPen(QColor(160, 160, 160, 120), width=1))
        self.chart_cursor_line.setVisible(False)
        self.chart_cursor_line.setZValue(32)
        self.plot_item.addItem(self.chart_cursor_line)
        self.chart_cursor_label = pg.TextItem(
            "",
            color="#111111",
            anchor=(1, 0.5),
            border=pg.mkPen(QColor(150, 150, 150, 220)),
            fill=pg.mkBrush(200, 200, 200, 220),
        )
        self.chart_cursor_label.setVisible(False)
        self.chart_cursor_label.setZValue(33)
        self.plot_item.addItem(self.chart_cursor_label)
        try:
            self.chart_widget.setMouseTracking(True)
            self.chart_widget.viewport().setMouseTracking(True)
            self.chart_widget.viewport().installEventFilter(self)
        except Exception:
            pass
        try:
            self._chart_mouse_proxy = pg.SignalProxy(
                self.chart_widget.scene().sigMouseMoved, rateLimit=30, slot=self._on_chart_mouse_moved
            )
        except Exception:
            self._chart_mouse_proxy = None

        chart_controls_widget = QWidget()
        chart_controls_layout = QVBoxLayout(chart_controls_widget)
        chart_controls_layout.setContentsMargins(0, 0, 0, 0)

        def _init_book_table(table):
            table.setModel(self.book_model)
            table.setItemDelegate(self.book_delegate)
            table.setEditTriggers(QAbstractItemView.NoEditTriggers)
            table.setSelectionMode(QAbstractItemView.NoSelection)
            table.setSelectionBehavior(QAbstractItemView.SelectRows)
            table.setAlternatingRowColors(True)
            try:
                table.setShowGrid(False)
            except Exception:
                pass
            table.verticalHeader().setVisible(False)
            try:
                table.horizontalHeader().setVisible(False)
            except Exception:
                pass
            # Keep exactly two adjacent columns with no 'middle spacer':
            # - VOL stretches (gets all remaining space -> no clipping)
            # - PRICE stays fixed and tight
            table.horizontalHeader().setStretchLastSection(False)
            try:
                table.horizontalHeader().setSectionResizeMode(ORDERBOOK_COL_VOL, QHeaderView.Stretch)
                table.horizontalHeader().setSectionResizeMode(ORDERBOOK_COL_PRICE, QHeaderView.Fixed)
            except Exception:
                pass
            try:
                # Reasonable default; will be refined dynamically in _update_book_price_column_width()
                table.setColumnWidth(ORDERBOOK_COL_PRICE, int(getattr(self, '_book_price_col_width', 64) or 64))
            except Exception:
                pass
            try:
                table.setUniformRowHeights(True)
            except Exception:
                pass
            # Smaller font in the orderbook (more rows visible, less clipping)
            try:
                f = QFont(table.font())
                try:
                    f.setFamily('Segoe UI')
                except Exception:
                    pass
                try:
                    _rh = int(ORDERBOOK_ROW_HEIGHT or 14)
                except Exception:
                    _rh = 14
                # keep it small but readable
                _pt = int(max(5, min(7, int(_rh * 0.42))))
                try:
                    f.setPointSize(_pt)
                except Exception:
                    pass
                table.setFont(f)
            except Exception:
                pass

            try:
                table.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
            except Exception:
                pass
            try:
                table.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
            except Exception:
                pass
            try:
                bar = table.verticalScrollBar()
                row_h = int(ORDERBOOK_ROW_HEIGHT or 14)
                bar.setSingleStep(max(1, row_h))
                bar.setPageStep(max(1, row_h * 12))
            except Exception:
                pass
            try:
                table.setViewportUpdateMode(QAbstractItemView.MinimalViewportUpdate)
            except Exception:
                pass

        orderbook_panel = QWidget()
        orderbook_layout = QVBoxLayout(orderbook_panel)
        orderbook_layout.setContentsMargins(0, 0, 0, 0)
        # Orderbook panel should be resizable (user can expand prints area).
        # Keep a reasonable minimum width so price text is not clipped.
        try:
            orderbook_panel.setMinimumWidth(int(globals().get('ORDERBOOK_PANEL_MIN_W', 260) or 260))
            orderbook_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        except Exception:
            pass

        book_widget = QWidget()
        self.book_container = book_widget
        book_layout = QVBoxLayout(book_widget)
        book_layout.setContentsMargins(0, 0, 0, 0)
        book_layout.setSpacing(0)
        self.book_table = QTableView()
        try:
            self.book_table.setLayoutDirection(Qt.LeftToRight)
            self.book_table.viewport().setLayoutDirection(Qt.LeftToRight)
        except Exception:
            pass
        self.book_model = OrderbookModel(self.book_table)
        self.book_delegate = OrderbookDelegate(self.book_table)
        _init_book_table(self.book_table)
        try:
            self.book_table.setFrameShape(QFrame.NoFrame)
            self.book_table.setLineWidth(0)
        except Exception:
            pass
        self.book_table.setAlternatingRowColors(False)
        self.book_table.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.book_table.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
        try:
            self.book_table.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        except Exception:
            pass
        try:
            self.book_table.setShowGrid(False)
        except Exception:
            pass
        # Disable item selection/hover highlight (we draw our own best bid/ask and ruler).
        try:
            self.book_table.setSelectionMode(QAbstractItemView.NoSelection)
            self.book_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
            self.book_table.setFocusPolicy(Qt.NoFocus)
        except Exception:
            pass
        try:
            ss = self.book_table.styleSheet() or ''
            ss += ' QTableView::item:hover{background: transparent;} QTableView::item:selected{background: transparent;}'
            self.book_table.setStyleSheet(ss)
        except Exception:
            pass
        try:
            self.book_table.horizontalHeader().setVisible(True)
        except Exception:
            pass
        try:
            self.book_table.verticalHeader().setDefaultSectionSize(int(ORDERBOOK_ROW_HEIGHT))
        except Exception:
            pass
        try:
            self.book_table.verticalHeader().setMinimumSectionSize(int(ORDERBOOK_ROW_HEIGHT))
        except Exception:
            pass
        # --- FORCE compact row height for the orderbook table (applies after show / model resets)
        try:
            self.book_table.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        except Exception:
            pass
        try:
            self.book_model.modelReset.connect(self._force_book_row_height)
        except Exception:
            pass
        try:
            QTimer.singleShot(0, self._force_book_row_height)
        except Exception:
            pass
        try:
            hdr = self.book_table.horizontalHeader()
            try:
                hdr.setHighlightSections(False)
            except Exception:
                pass
            try:
                hdr.setSectionsClickable(False)
            except Exception:
                pass
            # Hide header to avoid any top protrusion; keep columns programmatic.
            hdr.setVisible(False)
            # PRICE column: fixed adaptive width. VOL column: stretches to fill so price stays pinned.
            hdr.setStretchLastSection(False)
            hdr.setSectionResizeMode(ORDERBOOK_COL_PRICE, QHeaderView.Fixed)
            hdr.setSectionResizeMode(ORDERBOOK_COL_VOL, QHeaderView.Interactive)
            try:
                hdr.sectionResized.connect(self._on_book_section_resized)
            except Exception:
                pass
            try:
                QTimer.singleShot(0, self._apply_book_volume_width)
            except Exception:
                pass
        except Exception:
            pass
        except Exception:
            pass
        try:
            self.book_table.setMouseTracking(True)
            self.book_table.viewport().setMouseTracking(True)
            self.book_table.viewport().installEventFilter(self)
        except Exception:
            pass
        try:
            self.book_ruler_label = QLabel("", self.book_table.viewport())
            self.book_ruler_label.setStyleSheet(
                "QLabel { background-color: rgba(30, 120, 255, 70); color: rgba(255,255,255,0); "
                "border: none; padding: 0px; }"
            )
            try:
                self.book_ruler_label.setAutoFillBackground(True)
                self.book_ruler_label.setAttribute(Qt.WA_StyledBackground, True)
                self.book_ruler_label.setAttribute(Qt.WA_OpaquePaintEvent, True)
            except Exception:
                pass
            try:
                self.book_ruler_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            except Exception:
                pass
            self.book_ruler_label.setVisible(False)
            self.book_ruler_label.setAttribute(Qt.WA_TransparentForMouseEvents)
        except Exception:
            self.book_ruler_label = None
        # --- B1: stack orderbook table + image label (image is cheap to draw) ---
        try:
            self.book_image_label = QLabel()
            try:
                self.book_image_label.setAlignment(Qt.AlignLeft | Qt.AlignTop)
            except Exception:
                pass
            try:
                self.book_image_label.setScaledContents(False)
            except Exception:
                pass
            try:
                self.book_image_label.setMinimumWidth(10)
                self.book_image_label.setMinimumHeight(10)
            except Exception:
                pass
            try:
                self.book_image_label.setStyleSheet("background: transparent;")
            except Exception:
                pass
            # --- B1: enable interactivity on image book (wheel scroll + ruler hover) ---
            try:
                self.book_image_label.setMouseTracking(True)
                self.book_image_label.installEventFilter(self)
            except Exception:
                pass
            try:
                # Separate ruler overlay for image-mode (table ruler lives on table viewport)
                self.book_ruler_label_img = QLabel("", self.book_image_label)
                self.book_ruler_label_img.setStyleSheet(
                    "QLabel { background-color: rgba(30, 120, 255, 70); color: rgba(255,255,255,0); "
                    "border: none; padding: 0px; }"
                )
                try:
                    self.book_ruler_label_img.setAutoFillBackground(True)
                    self.book_ruler_label_img.setAttribute(Qt.WA_TransparentForMouseEvents)
                except Exception:
                    pass
                try:
                    self.book_ruler_label_img.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                except Exception:
                    pass
                self.book_ruler_label_img.setVisible(False)
            except Exception:
                self.book_ruler_label_img = None

            try:
                self._book_img_offset = 0
                self._book_img_user_scrolled = False
            except Exception:
                pass

            except Exception:
                pass

            self.book_stack = QStackedWidget()
            self.book_stack.addWidget(self.book_table)
            self.book_stack.addWidget(self.book_image_label)

            try:
                self._book_use_image = bool(globals().get('ORDERBOOK_RENDER_AS_IMAGE', False))
            except Exception:
                self._book_use_image = False

            try:
                if self._book_use_image:
                    self.book_stack.setCurrentWidget(self.book_image_label)
                else:
                    self.book_stack.setCurrentWidget(self.book_table)
            except Exception:
                pass

            book_layout.addWidget(self.book_stack)
        except Exception:
            self.book_stack = None
            self.book_image_label = None
            book_layout.addWidget(self.book_table)
        prints_widget = QWidget()
        self.prints_container = prints_widget
        prints_layout = QVBoxLayout(prints_widget)
        prints_layout.setContentsMargins(0, 0, 0, 0)
        prints_layout.setSpacing(0)
        try:
            self.prints_hotkey_indicator = QFrame()
            self.prints_hotkey_indicator.setObjectName("printsHotkeyIndicator")
            self.prints_hotkey_indicator.setFixedHeight(8)
            try:
                self.prints_hotkey_indicator.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            except Exception:
                pass
            try:
                self.prints_hotkey_indicator.setStyleSheet(
                    "QFrame#printsHotkeyIndicator { background-color: rgba(0, 0, 0, 0); border: none; }"
                )
            except Exception:
                pass
            try:
                self.prints_hotkey_indicator.setAttribute(Qt.WA_TransparentForMouseEvents)
            except Exception:
                pass
        except Exception:
            self.prints_hotkey_indicator = None
        self.prints_tape = PrintsTapeWidget()
        self.prints_tape.setMinimumWidth(120)
        try:
            self.prints_tape.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        except Exception:
            pass
        try:
            if getattr(self, "prints_hotkey_indicator", None) is not None:
                self.prints_tape.set_top_overlay(self.prints_hotkey_indicator, 8)
        except Exception:
            pass
        try:
            self.prints_ruler_label = QLabel('', self.prints_tape)
            self.prints_ruler_label.setStyleSheet(
                'QLabel { background-color: rgba(30, 120, 255, 90); color: rgba(255,255,255,240); '
                'border: none; padding-left: 6px; padding-right: 6px; }'
            )
            self.prints_ruler_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            self.prints_ruler_label.setVisible(False)
            self.prints_ruler_label.setAttribute(Qt.WA_TransparentForMouseEvents)
            self.prints_ruler_label.raise_()
        except Exception:
            self.prints_ruler_label = None
        try:
            self.click_entry_panel = self._build_click_entry_panel()
            try:
                self._sync_click_entry_presets_ui()
            except Exception:
                pass
        except Exception:
            self.click_entry_panel = None
        self.position_summary_table = QTableWidget(1, 3)
        self.position_summary_table.setHorizontalHeaderLabels(["Entry", "Notional $", "PnL %"])
        try:
            self.position_summary_table.verticalHeader().setVisible(False)
            self.position_summary_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
            self.position_summary_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
            self.position_summary_table.setSelectionMode(QAbstractItemView.NoSelection)
            self.position_summary_table.setFocusPolicy(Qt.NoFocus)
            self.position_summary_table.setRowCount(1)
            self.position_summary_table.setColumnCount(3)
            self.position_summary_table.verticalHeader().setDefaultSectionSize(22)
            self.position_summary_table.horizontalHeader().setFixedHeight(20)
            self.position_summary_table.setFixedHeight(44)
            self.position_summary_table.setFrameShape(QFrame.NoFrame)
            self.position_summary_table.setShowGrid(False)
            self.position_summary_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        except Exception:
            pass
        try:
            self.position_summary_table.setStyleSheet(
                "QTableWidget, QTableView, QTableWidget::viewport, QTableView::viewport { background: transparent; }"
                "QTableWidget::item { background: transparent; }"
                "QHeaderView::section { background: transparent; }"
                "QTableView { gridline-color: rgba(0, 0, 0, 0); }"
            )
            self.position_summary_table.setAttribute(Qt.WA_TranslucentBackground, True)
            self.position_summary_table.setAttribute(Qt.WA_NoSystemBackground, True)
            self.position_summary_table.setAutoFillBackground(False)
            try:
                self.position_summary_table.viewport().setAttribute(Qt.WA_TranslucentBackground, True)
                self.position_summary_table.viewport().setAttribute(Qt.WA_NoSystemBackground, True)
                self.position_summary_table.viewport().setAutoFillBackground(False)
            except Exception:
                pass
        except Exception:
            pass
        try:
            self.click_entry_panel_holder = None
            if getattr(self, "click_entry_panel", None) is not None:
                holder = QWidget()
                holder_layout = QVBoxLayout(holder)
                holder_layout.setContentsMargins(0, 0, 0, 0)
                holder_layout.setSpacing(0)
                try:
                    holder_layout.addWidget(self.click_entry_panel)
                except Exception:
                    pass
                try:
                    holder_layout.addStretch(1)
                except Exception:
                    pass
                try:
                    panel_h = int(self.click_entry_panel.height() or 120)
                except Exception:
                    panel_h = 120
                try:
                    table_h = int(self.position_summary_table.height() or 44)
                except Exception:
                    table_h = 44
                try:
                    holder.setFixedHeight(panel_h + table_h + 6)
                except Exception:
                    pass
                try:
                    holder.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
                except Exception:
                    pass
                self.click_entry_panel_holder = holder
        except Exception:
            self.click_entry_panel_holder = None
        try:
            self.prints_overlay_container = QWidget()
            try:
                self.prints_overlay_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            except Exception:
                pass
            overlay_layout = QGridLayout(self.prints_overlay_container)
            overlay_layout.setContentsMargins(0, 0, 0, 0)
            overlay_layout.setSpacing(0)
            overlay_layout.addWidget(self.prints_tape, 0, 0)
            panel_widget = getattr(self, "click_entry_panel_holder", None)
            if panel_widget is None:
                panel_widget = getattr(self, "click_entry_panel", None)
            if panel_widget is not None:
                overlay_layout.addWidget(panel_widget, 0, 0, Qt.AlignLeft | Qt.AlignBottom)
            overlay_layout.addWidget(self.position_summary_table, 0, 0, Qt.AlignBottom)
            prints_layout.addWidget(self.prints_overlay_container)
        except Exception:
            prints_layout.addWidget(self.prints_tape)
            try:
                panel_widget = getattr(self, "click_entry_panel_holder", None)
                if panel_widget is None:
                    panel_widget = getattr(self, "click_entry_panel", None)
                if panel_widget is not None:
                    prints_layout.addWidget(panel_widget)
            except Exception:
                pass
            prints_layout.addWidget(self.position_summary_table)
        try:
            prints_layout.setStretch(0, 1)
        except Exception:
            pass

        book_tape_splitter = QSplitter(Qt.Horizontal)
        self.book_tape_splitter = book_tape_splitter
        book_tape_splitter.addWidget(prints_widget)
        book_tape_splitter.addWidget(book_widget)
        book_tape_splitter.setStretchFactor(0, 1)  # prints
        book_tape_splitter.setStretchFactor(1, 3)  # book
        try:
            book_tape_splitter.setSizes([260, 520])
        except Exception:
            pass
        try:
            book_tape_splitter.setChildrenCollapsible(False)
            book_tape_splitter.setHandleWidth(6)
        except Exception:
            pass

        orderbook_layout.addWidget(book_tape_splitter)
        self._book_tape_splitter = book_tape_splitter
        self.prints_tape.bind_book_table(self.book_table)
        try:
            self.prints_tape.set_order_click_callback(self._handle_prints_order_marker_click)
        except Exception:
            pass
        try:
            self.prints_tape.installEventFilter(self)
        except Exception:
            pass
        try:
            QTimer.singleShot(0, self._apply_panel_visibility)
        except Exception:
            try:
                self._apply_panel_visibility()
            except Exception:
                pass

        try:
            # Allow prints tape wheel to scroll image-mode orderbook as well
            self.prints_tape.set_external_scroll_rows(None, None, scroll_callback=getattr(self, "_book_image_scroll_rows", None))
        except Exception:
            pass

        # Ruler bar for the splitter handle (fills the gap between prints + book).
        try:
            handle = book_tape_splitter.handle(1)
            self._ruler_bar = QFrame(handle)
            self._ruler_bar.setStyleSheet("background-color: rgba(30, 120, 255, 80); border: none;")
            try:
                self._ruler_bar.setAttribute(Qt.WA_TransparentForMouseEvents)
            except Exception:
                pass
            self._ruler_bar.setVisible(False)
        except Exception:
            self._ruler_bar = None
        try:
            # Keep ruler visible even when the mouse is stationary.
            self._book_ruler_timer = QTimer(self)
            try:
                self._book_ruler_timer.setTimerType(Qt.PreciseTimer)
            except Exception:
                pass
            self._book_ruler_timer.timeout.connect(self._update_book_ruler_auto)
            self._book_ruler_timer.start(60)
        except Exception:
            self._book_ruler_timer = None
        # Update prints rate indicator in main UI (lightweight timer)
        try:
            self._prints_rate_ui_timer = QTimer(self)
            try:
                self._prints_rate_ui_timer.setTimerType(Qt.PreciseTimer)
            except Exception:
                pass
            self._prints_rate_ui_timer.timeout.connect(self._update_prints_speedometer_ui)
            self._prints_rate_ui_timer.start(250)
        except Exception:
            self._prints_rate_ui_timer = None
        self._orderbook_last_render_ts = 0.0
        self._orderbook_render_scheduled = False
        self._orderbook_force_render = False
        try:
            self._prints_pending = []
            self._prints_flush_timer = QTimer(self)
            try:
                self._prints_flush_timer.setTimerType(Qt.PreciseTimer)
            except Exception:
                pass
            self._prints_flush_timer.setSingleShot(True)
            self._prints_flush_timer.timeout.connect(self._flush_prints_pending)
        except Exception:
            self._prints_flush_timer = None
        try:
            max_workers = min(16, max(4, (os.cpu_count() or 4)))
        except Exception:
            max_workers = 8
        try:
            self._order_io_executor = ThreadPoolExecutor(max_workers=max_workers)
        except Exception:
            self._order_io_executor = None

        symbol_row = QHBoxLayout()
        symbol_row.addWidget(QLabel("Символ графіку:"))
        self.symbol_input = QLineEdit(self.current_symbol)
        symbol_row.addWidget(self.symbol_input)
        self.symbol_apply_btn = QPushButton("Показати")
        symbol_row.addWidget(self.symbol_apply_btn)
        symbol_row.addSpacing(8)
        symbol_row.addWidget(QLabel("TF:"))
        self.chart_interval_combo = QComboBox()
        try:
            self.chart_interval_combo.addItems(list(CHART_INTERVAL_OPTIONS))
        except Exception:
            pass
        try:
            interval_val = str(globals().get("CANDLE_WS_INTERVAL", "5m") or "").strip()
        except Exception:
            interval_val = ""
        if interval_val:
            try:
                if self.chart_interval_combo.findText(interval_val) == -1:
                    self.chart_interval_combo.addItem(interval_val)
            except Exception:
                pass
            try:
                self.chart_interval_combo.setCurrentText(interval_val)
            except Exception:
                pass
        symbol_row.addWidget(self.chart_interval_combo)
        symbol_row.addWidget(QLabel("Candles:"))
        self.chart_candles_spin = QSpinBox()
        # Fixed candle count (user request)
        self.chart_candles_spin.setRange(450, 450)
        self.chart_candles_spin.setValue(450)
        try:
            self.chart_candles_spin.setEnabled(False)
        except Exception:
            pass
        symbol_row.addWidget(self.chart_candles_spin)
        self.chart_fullscreen_btn = QPushButton('FS')
        self.chart_fullscreen_btn.setToolTip('Графік на весь екран (для якісного скріну)')
        try:
            self.chart_fullscreen_btn.setFixedWidth(40)
        except Exception:
            pass
        try:
            self.chart_fullscreen_btn.clicked.connect(self.toggle_chart_fullscreen)
        except Exception:
            pass
        symbol_row.addWidget(self.chart_fullscreen_btn)
        symbol_row.addStretch(1)
        chart_controls_layout.addLayout(symbol_row)
        chart_controls_layout.addWidget(self.chart_widget)
        # Chart embed/fullscreen state
        self._chart_embed_parent = chart_controls_widget
        self._chart_embed_layout = chart_controls_layout
        try:
            self._chart_embed_index = chart_controls_layout.indexOf(self.chart_widget)
        except Exception:
            self._chart_embed_index = -1
        self._chart_fullscreen_dialog = None
        self._chart_fullscreen_state = None
        self._chart_fullscreen_restoring = False

        quick_form = QFormLayout()

        self.book_tick_mult_spin = QSpinBox()
        self.book_tick_mult_spin.setRange(1, 100000)
        self.book_tick_mult_spin.setKeyboardTracking(True)
        try:
            self.book_tick_mult_spin.setValue(int(ORDERBOOK_TICK_MULT or 1))
        except Exception:
            self.book_tick_mult_spin.setValue(1)
        quick_form.addRow('BOOK_TICK_MULT', self.book_tick_mult_spin)

        self.book_vol_usd_chk = QCheckBox()
        try:
            self.book_vol_usd_chk.setChecked(bool(globals().get("ORDERBOOK_VOL_IN_USD", False)))
        except Exception:
            self.book_vol_usd_chk.setChecked(False)
        _apply_switch_style(self.book_vol_usd_chk)
        quick_form.addRow('Book vol $', self.book_vol_usd_chk)

        self.book_vol_compact_chk = QCheckBox()
        try:
            self.book_vol_compact_chk.setChecked(bool(globals().get("ORDERBOOK_VOL_COMPACT", False)))
        except Exception:
            self.book_vol_compact_chk.setChecked(False)
        _apply_switch_style(self.book_vol_compact_chk)
        quick_form.addRow('Book vol compact', self.book_vol_compact_chk)

        self.book_vol_width_spin = QSpinBox()
        self.book_vol_width_spin.setRange(0, 800)
        self.book_vol_width_spin.setSingleStep(10)
        try:
            self.book_vol_width_spin.setSpecialValueText("auto")
        except Exception:
            pass
        try:
            self.book_vol_width_spin.setValue(int(globals().get("ORDERBOOK_VOL_COL_WIDTH", 0) or 0))
        except Exception:
            self.book_vol_width_spin.setValue(0)
        quick_form.addRow('Book vol width', self.book_vol_width_spin)

        self.min_pos_notional_spin = QDoubleSpinBox()
        self.min_pos_notional_spin.setDecimals(4)
        self.min_pos_notional_spin.setRange(0.0, 100.0)
        self.min_pos_notional_spin.setSingleStep(0.05)
        try:
            self.min_pos_notional_spin.setValue(float(MIN_POS_NOTIONAL_MULT or 0.0))
        except Exception:
            self.min_pos_notional_spin.setValue(0.0)
        quick_form.addRow('Min notional (bal*x, 0=off)', self.min_pos_notional_spin)

        self.max_pos_notional_spin = QDoubleSpinBox()
        self.max_pos_notional_spin.setDecimals(4)
        self.max_pos_notional_spin.setRange(0.0, 100.0)
        self.max_pos_notional_spin.setSingleStep(0.05)
        try:
            self.max_pos_notional_spin.setValue(float(MAX_POS_NOTIONAL_MULT or 0.0))
        except Exception:
            self.max_pos_notional_spin.setValue(0.0)
        quick_form.addRow('Max notional (bal*x, 0=off)', self.max_pos_notional_spin)

        # --- Click trading ---
        self.click_trading_chk = QCheckBox()
        try:
            self.click_trading_chk.setChecked(bool(globals().get("CLICK_TRADING_ENABLED", False)))
        except Exception:
            self.click_trading_chk.setChecked(False)
        _apply_switch_style(self.click_trading_chk)
        try:
            self.click_trading_chk.setToolTip("Enable click trading on the orderbook ladder")
        except Exception:
            pass
        quick_form.addRow('Click trading', self.click_trading_chk)
        try:
            self.click_trading_chk.toggled.connect(self._on_click_trading_toggled)
        except Exception:
            pass


        self.stop_loss_min_spin = QDoubleSpinBox()
        self.stop_loss_min_spin.setDecimals(3)
        self.stop_loss_min_spin.setRange(0.0, 50.0)
        self.stop_loss_min_spin.setSingleStep(0.05)
        try:
            self.stop_loss_min_spin.setValue(float(STOP_LOSS_MIN_PCT or 0.0) * 100.0)
        except Exception:
            self.stop_loss_min_spin.setValue(0.2)
        quick_form.addRow('SL min %', self.stop_loss_min_spin)

        self.stop_loss_max_spin = QDoubleSpinBox()
        self.stop_loss_max_spin.setDecimals(3)
        self.stop_loss_max_spin.setRange(0.0, 50.0)
        self.stop_loss_max_spin.setSingleStep(0.05)
        try:
            self.stop_loss_max_spin.setValue(float(STOP_LOSS_MAX_PCT or 0.0) * 100.0)
        except Exception:
            self.stop_loss_max_spin.setValue(4.0)
        quick_form.addRow('SL max %', self.stop_loss_max_spin)

        self.loss_close_ban_spin = QSpinBox()
        self.loss_close_ban_spin.setRange(0, 10080)  # up to 7 days
        self.loss_close_ban_spin.setSingleStep(5)
        try:
            self.loss_close_ban_spin.setValue(int(LOSS_CLOSE_BAN_MINUTES or 0))
        except Exception:
            self.loss_close_ban_spin.setValue(240)
        quick_form.addRow('Loss ban after -PnL close (min)', self.loss_close_ban_spin)

        self.prints_min_notional_spin = QDoubleSpinBox()
        self.prints_min_notional_spin.setDecimals(2)
        self.prints_min_notional_spin.setRange(0.0, 1000000000.0)
        self.prints_min_notional_spin.setSingleStep(10.0)
        try:
            self.prints_min_notional_spin.setValue(float(globals().get("PRINTS_MIN_NOTIONAL_USD", 0.0) or 0.0))
            try:
                if hasattr(self, 'prints_speed_auto_chk') and self.prints_speed_auto_chk is not None:
                    self.prints_speed_auto_chk.setChecked(bool(globals().get('PRINTS_SPEED_AUTO', False)))
            except Exception:
                pass
            try:
                self._on_prints_speed_auto_toggled(bool(globals().get('PRINTS_SPEED_AUTO', False)))
            except Exception:
                pass
        except Exception:
            self.prints_min_notional_spin.setValue(0.0)
        quick_form.addRow('Prints min $', self.prints_min_notional_spin)
        try:
            self.prints_min_notional_spin.valueChanged.connect(self._on_prints_min_notional_changed)
        except Exception:
            pass
        self.prints_text_min_notional_spin = QDoubleSpinBox()
        self.prints_text_min_notional_spin.setDecimals(2)
        self.prints_text_min_notional_spin.setRange(0.0, 1000000000.0)
        self.prints_text_min_notional_spin.setSingleStep(10.0)
        try:
            self.prints_text_min_notional_spin.setValue(float(globals().get("PRINTS_TEXT_MIN_NOTIONAL_USD", 0.0) or 0.0))
        except Exception:
            self.prints_text_min_notional_spin.setValue(0.0)
        try:
            self.prints_text_min_notional_spin.setToolTip("Hide print text below this USD notional")
        except Exception:
            pass
        quick_form.addRow('Prints text min $', self.prints_text_min_notional_spin)
        try:
            self.prints_text_min_notional_spin.valueChanged.connect(self._on_prints_text_min_notional_changed)
        except Exception:
            pass
        self.prints_speed_auto_chk = QCheckBox()
        self.prints_speed_auto_chk.setText('AUTO')
        try:
            self.prints_speed_auto_chk.setChecked(bool(globals().get('PRINTS_SPEED_AUTO', False)))
        except Exception:
            self.prints_speed_auto_chk.setChecked(True)
        _apply_switch_style(self.prints_speed_auto_chk)
        try:
            self.prints_speed_auto_chk.toggled.connect(self._on_prints_speed_auto_toggled)
        except Exception:
            pass
        quick_form.addRow('Prints speed AUTO', self.prints_speed_auto_chk)


        self.prints_speed_spin = QDoubleSpinBox()
        self.prints_speed_spin.setDecimals(2)
        self.prints_speed_spin.setRange(float(globals().get("PRINTS_SPEED_MIN", 0.7) or 0.7), float(globals().get("PRINTS_SPEED_MAX", 2.5) or 2.5))
        self.prints_speed_spin.setSingleStep(0.05)
        try:
            self.prints_speed_spin.setValue((float(globals().get("PRINTS_SPEED_MULT")) if globals().get("PRINTS_SPEED_MULT") is not None else 1.0))
        except Exception:
            self.prints_speed_spin.setValue(1.0)
        quick_form.addRow('Prints speed x', self.prints_speed_spin)
        # Prints aggregation controls removed from UI (always OFF by default)
        self.prints_agg_ms_spin = None
        self.prints_agg_chk = None

        self.prints_agg_extra_ms_spin = QSpinBox()
        self.prints_agg_extra_ms_spin.setRange(0, 10000)
        self.prints_agg_extra_ms_spin.setSingleStep(10)
        try:
            self.prints_agg_extra_ms_spin.setValue(int(globals().get("PRINTS_AGG_WINDOW_MS_EXTRA", 0) or 0))
        except Exception:
            self.prints_agg_extra_ms_spin.setValue(0)
        quick_form.addRow('Prints agg +ms', self.prints_agg_extra_ms_spin)
        try:
            self.prints_agg_extra_ms_spin.valueChanged.connect(self._on_prints_agg_extra_ms_changed)
        except Exception:
            pass


        # Live prints rate indicator (speedometer): how many prints appear per time window
        self.prints_speedometer_lbl = QLabel('0 / 5s')
        try:
            self.prints_speedometer_lbl.setMinimumWidth(90)
        except Exception:
            pass
        quick_form.addRow('Prints rate', self.prints_speedometer_lbl)
        self.prints_fps_lbl = QLabel('FPS: --')
        quick_form.addRow('Prints FPS', self.prints_fps_lbl)

        # Orderbook UI FPS indicator (how often the table is re-rendered)
        self.book_fps_lbl = QLabel('FPS: --')
        try:
            self.book_fps_lbl.setMinimumWidth(90)
        except Exception:
            pass
        quick_form.addRow('Book FPS', self.book_fps_lbl)
        try:
            self._on_prints_speed_auto_toggled(bool(getattr(self, 'prints_speed_auto_chk', None) and self.prints_speed_auto_chk.isChecked()))
        except Exception:
            pass

        # --- Book UI paint driver (smooth 60 FPS repaint even if market updates are slower) ---
        # This does NOT fabricate new market data; it only keeps the table repainting smoothly.
        try:
            self._book_ui_fps_marks = deque()
            self._book_ui_fps_val = 0.0
            self._book_data_fps_val = 0.0
        except Exception:
            pass
        try:
            self._book_paint_timer = QTimer(self)
            try:
                self._book_paint_timer.setTimerType(Qt.PreciseTimer)
            except Exception:
                pass
            self._book_paint_timer.timeout.connect(self._on_book_paint_tick)
            # 8ms ~= 120 FPS target for the book view (best-effort).
            self._book_paint_timer.start(8)  # ~120 FPS target
        except Exception:
            pass

        quick_widget = QWidget()
        quick_widget.setLayout(quick_form)
        chart_controls_layout.addWidget(quick_widget)

        path_widget = QWidget()
        path_form = QFormLayout(path_widget)
        path_form.setFieldGrowthPolicy(QFormLayout.AllNonFixedFieldsGrow)

        self.log_dir_edit = QLineEdit(LOG_DIR or '')
        self.log_dir_browse_btn = QPushButton('...')
        self.log_dir_browse_btn.setFixedWidth(32)
        log_row_widget = QWidget()
        log_row = QHBoxLayout(log_row_widget)
        log_row.setContentsMargins(0, 0, 0, 0)
        log_row.addWidget(self.log_dir_edit)
        log_row.addWidget(self.log_dir_browse_btn)
        path_form.addRow('LOG DIR', log_row_widget)

        self.telegram_file_edit = QLineEdit(TELEGRAM_USERS_FILE or '')
        self.telegram_file_browse_btn = QPushButton('...')
        self.telegram_file_browse_btn.setFixedWidth(32)
        tg_row_widget = QWidget()
        tg_row = QHBoxLayout(tg_row_widget)
        tg_row.setContentsMargins(0, 0, 0, 0)
        tg_row.addWidget(self.telegram_file_edit)
        tg_row.addWidget(self.telegram_file_browse_btn)
        path_form.addRow('TELEGRAM FILE', tg_row_widget)

        self.settings_file_edit = QLineEdit(SETTINGS_FILE or DEFAULT_SETTINGS_FILE)
        self.settings_file_browse_btn = QPushButton('...')
        self.settings_file_browse_btn.setFixedWidth(32)
        settings_row_widget = QWidget()
        settings_row = QHBoxLayout(settings_row_widget)
        settings_row.setContentsMargins(0, 0, 0, 0)
        settings_row.addWidget(self.settings_file_edit)
        settings_row.addWidget(self.settings_file_browse_btn)
        path_form.addRow('SETTINGS FILE', settings_row_widget)

        self.equity_file_edit = QLineEdit(EQUITY_HISTORY_FILE or '')
        self.equity_file_browse_btn = QPushButton('...')
        self.equity_file_browse_btn.setFixedWidth(32)
        equity_row_widget = QWidget()
        equity_row = QHBoxLayout(equity_row_widget)
        equity_row.setContentsMargins(0, 0, 0, 0)
        equity_row.addWidget(self.equity_file_edit)
        equity_row.addWidget(self.equity_file_browse_btn)
        path_form.addRow('EQUITY FILE', equity_row_widget)

        self.trade_journal_file_edit = QLineEdit(TRADE_JOURNAL_FILE or '')
        self.trade_journal_file_browse_btn = QPushButton('...')
        self.trade_journal_file_browse_btn.setFixedWidth(32)
        trade_journal_row_widget = QWidget()
        trade_journal_row = QHBoxLayout(trade_journal_row_widget)
        trade_journal_row.setContentsMargins(0, 0, 0, 0)
        trade_journal_row.addWidget(self.trade_journal_file_edit)
        trade_journal_row.addWidget(self.trade_journal_file_browse_btn)
        path_form.addRow('TRADE JOURNAL FILE', trade_journal_row_widget)

        self.pnl_snapshot_edit = QLineEdit(PNL_SNAPSHOT_FILE or '')
        self.pnl_snapshot_browse_btn = QPushButton('...')
        self.pnl_snapshot_browse_btn.setFixedWidth(32)
        pnl_row_widget = QWidget()
        pnl_row = QHBoxLayout(pnl_row_widget)
        pnl_row.setContentsMargins(0, 0, 0, 0)
        pnl_row.addWidget(self.pnl_snapshot_edit)
        pnl_row.addWidget(self.pnl_snapshot_browse_btn)
        path_form.addRow('PNL SNAPSHOT FILE', pnl_row_widget)

        chart_controls_layout.addWidget(path_widget)

        self.clear_data_btn = QPushButton("Очистити дані")
        self.clear_data_btn.setObjectName("clearDataButton")
        chart_controls_layout.addWidget(self.clear_data_btn)

        self.quick_apply_btn = QPushButton('Apply')
        chart_controls_layout.addWidget(self.quick_apply_btn)

        right_splitter = QSplitter(Qt.Horizontal)
        try:
            right_splitter.setHandleWidth(int(globals().get('RIGHT_SPLITTER_HANDLE_W', 6) or 6))
        except Exception:
            pass
        right_splitter.addWidget(chart_controls_widget)
        right_splitter.addWidget(orderbook_panel)
        right_splitter.setStretchFactor(0, 2)
        right_splitter.setStretchFactor(1, 1)
        right_layout.addWidget(right_splitter)
        self._right_splitter = right_splitter
        # --- Code editor tab removed ---
        try:
            self.code_path_edit = None
            self.code_reload_btn = None
            self.code_save_btn = None
            self.code_editor = None
        except Exception:
            pass
        self.sync_quick_controls()
        try:
            self._sync_book_symbol(self.current_symbol)
        except Exception:
            pass

        right_tabs = QTabWidget()
        right_tabs.addTab(right_widget, "Charts/Controls")
        # --- Hotkeys tab (interactive) ---
        try:
            hotkeys_widget = QWidget()
            hotkeys_layout = QVBoxLayout(hotkeys_widget)

            title = QLabel("Hotkeys (натисни 'Змінити' і потім натисни клавішу)")
            title.setWordWrap(True)
            hotkeys_layout.addWidget(title)

            hotkeys_form = QFormLayout()
            hotkeys_form.setFieldGrowthPolicy(QFormLayout.AllNonFixedFieldsGrow)
            hotkeys_layout.addLayout(hotkeys_form)

            # Store editors for live update
            try:
                self._hotkey_edit_fields = {}
            except Exception:
                self._hotkey_edit_fields = {}

            def _mk_hotkey_row(var_name, default_value, desc_text):
                row = QWidget()
                row_l = QHBoxLayout(row)
                row_l.setContentsMargins(0, 0, 0, 0)

                edit = QLineEdit()
                edit.setReadOnly(True)
                edit.setFixedWidth(120)
                try:
                    edit.setText(str(globals().get(var_name) or ""))
                except Exception:
                    edit.setText("")
                row_l.addWidget(edit)

                btn_set = QPushButton("Змінити")
                btn_set.setFixedWidth(85)
                btn_set.clicked.connect(lambda _=None, v=var_name, e=edit: self._start_hotkey_capture(v, e, desc_text))
                row_l.addWidget(btn_set)

                btn_reset = QPushButton("Default")
                btn_reset.setFixedWidth(75)
                btn_reset.clicked.connect(lambda _=None, v=var_name, dv=default_value, e=edit: self._set_hotkey_value(v, dv, e))
                row_l.addWidget(btn_reset)

                btn_clear = QPushButton("Clear")
                btn_clear.setFixedWidth(60)
                btn_clear.clicked.connect(lambda _=None, v=var_name, e=edit: self._set_hotkey_value(v, "", e))
                row_l.addWidget(btn_clear)

                row_l.addStretch(1)

                try:
                    self._hotkey_edit_fields[var_name] = edit
                except Exception:
                    pass
                return row

            hotkeys_form.addRow("Close+Cancel", _mk_hotkey_row("HOTKEY_CLOSE_AND_CANCEL", "D",
                                                              "Close position (market) + cancel all orders (symbol)"))
            hotkeys_form.addRow("Force-center", _mk_hotkey_row("HOTKEY_FORCE_CENTER", "SHIFT",
                                                              "Force-center orderbook"))
            hotkeys_form.addRow("Cancel all", _mk_hotkey_row("HOTKEY_CANCEL_ALL", "SPACE",
                                                            "Cancel all orders (symbol)"))
            hotkeys_form.addRow("Pending (hold+L/R)", _mk_hotkey_row("HOTKEY_PENDING_ORDER", "V",
                                                                    "Hold key + LMB/RMB to place pending entry"))
            hotkeys_form.addRow("Stop-loss (hold+L)", _mk_hotkey_row("HOTKEY_STOPLOSS_CLICK", "C",
                                                                    "Hold key + LMB to place stop-loss"))

            hint = QLabel("Note: Hotkeys are ignored while typing in input fields. "
                          "Для скасування зміни натисни ESC. "
                          "Літерні хоткеї працюють незалежно від розкладки (UA/RU/EN) завдяки physical scan-code.")
            hint.setWordWrap(True)
            hotkeys_layout.addWidget(hint)

            right_tabs.addTab(hotkeys_widget, "Hotkeys")
        except Exception:
            pass
        except Exception:
            pass


        splitter.addWidget(right_tabs)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 2)

        # --- Global event filter for hotkeys ---
        try:
            app = QApplication.instance()
            if app is not None and not getattr(self, "_global_event_filter_installed", False):
                app.installEventFilter(self)
                self._global_event_filter_installed = True
        except Exception:
            pass


    def _connect_signals(self):
        self.start_button.clicked.connect(lambda: threading.Thread(target=start_bot, daemon=True).start())
        self.stop_button.clicked.connect(stop_bot)
        self.symbol_apply_btn.clicked.connect(self.update_chart_symbol)
        try:
            self.symbol_input.returnPressed.connect(self.update_chart_symbol)
        except Exception:
            pass
        try:
            self.chart_interval_combo.currentTextChanged.connect(self.apply_chart_settings)
            self.chart_candles_spin.valueChanged.connect(self.apply_chart_settings)
        except Exception:
            pass
        self.quick_apply_btn.clicked.connect(self.apply_quick_settings)
        self.clear_data_btn.clicked.connect(self.clear_persistent_data)
        self.log_dir_browse_btn.clicked.connect(self.browse_log_dir)
        self.telegram_file_browse_btn.clicked.connect(self.browse_telegram_file)
        self.settings_file_browse_btn.clicked.connect(self.browse_settings_file)
        self.equity_file_browse_btn.clicked.connect(self.browse_equity_file)
        self.trade_journal_file_browse_btn.clicked.connect(self.browse_trade_journal_file)
        self.pnl_snapshot_browse_btn.clicked.connect(self.browse_pnl_snapshot_file)
        self.equity_range_combo.currentIndexChanged.connect(self.on_equity_range_changed)
        try:
            self.view_tabs.currentChanged.connect(self.on_view_tab_changed)
        except Exception:
            pass
        try:
            self.journal_range_combo.currentIndexChanged.connect(self.on_trade_journal_range_changed)
        except Exception:
            pass
        try:
            self.code_reload_btn.clicked.connect(lambda: self.load_code_editor())
            self.code_save_btn.clicked.connect(self.save_code_editor)
        except Exception:
            pass
        self.theme_combo.currentTextChanged.connect(self.apply_theme)
        try:
            self.book_tick_top_spin.valueChanged.connect(self._on_book_tick_changed)
            try:
                self.book_tick_top_spin.editingFinished.connect(
                    lambda: self._on_book_tick_changed(self.book_tick_top_spin.value())
                )
            except Exception:
                pass
            self.book_depth_top_spin.valueChanged.connect(self._on_book_depth_changed)
            self.book_levels_top_spin.valueChanged.connect(self._on_book_levels_changed)
            self.book_auto_center_chk.toggled.connect(self._on_book_auto_center_changed)
            try:
                self.book_tick_mult_spin.valueChanged.connect(self._on_book_tick_changed)
                self.book_tick_mult_spin.editingFinished.connect(
                    lambda: self._on_book_tick_changed(self.book_tick_mult_spin.value())
                )
            except Exception:
                pass
        except Exception:
            pass
        self.settings_button.clicked.connect(self.show_settings_dialog)
        self.advisor_ask_btn.clicked.connect(self.request_gpt_advice)
        self.advisor_apply_btn.clicked.connect(self.apply_gpt_advice)

    def _on_logout_clicked(self):
        """Вийти з акаунту: очистити локальну сесію та повернутись на екран логіну."""
        try:
            resp = QMessageBox.question(
                self,
                "Вийти з акаунту",
                "Ви точно хочете вийти з акаунту?\n\nПісля виходу потрібно буде знову увійти.",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if resp != QMessageBox.Yes:
                return
        except Exception:
            # якщо діалог з будь-якої причини не показався — виходимо без підтвердження
            pass

        # На всякий випадок зупиняємо бота (якщо він запущений)
        try:
            if globals().get("bot_running", False):
                try:
                    stop_bot()
                except Exception:
                    pass
        except Exception:
            pass

        # Очистити Supabase-сесію (локальний кеш токенів)
        try:
            mgr = AccessManagerFixed()
            mgr.logout()
        except Exception:
            pass

        # Скидаємо показ у верхньому рядку
        try:
            globals()["ACCESS_SUB_ACTIVE"] = None
            globals()["ACCESS_SUB_REASON"] = ""
            globals()["ACCESS_SUB_END_TS"] = 0
        except Exception:
            pass
        try:
            self._refresh_activation_status()
        except Exception:
            pass

        # Повторно запускаємо gate доступу (логін + підписка) без закриття програми
        try:
            app = QApplication.instance()
            if app is None:
                return
            if not ensure_access(app):
                try:
                    self.close()
                except Exception:
                    pass
                try:
                    app.quit()
                except Exception:
                    pass
                return
        except Exception:
            # якщо щось пішло не так — закриваємо програму (безпечний варіант)
            try:
                self.close()
            except Exception:
                pass
            try:
                QApplication.instance().quit()
            except Exception:
                pass
            return

        # Оновлюємо напис про активацію після повторного входу
        try:
            QTimer.singleShot(0, self._refresh_activation_status)
        except Exception:
            pass

    def _apply_initial_splitter_sizes(self, attempt=0):
        if self._splitter_sizes_applied:
            return
        main_splitter = getattr(self, "_main_splitter", None)
        right_splitter = getattr(self, "_right_splitter", None)
        if main_splitter is None or right_splitter is None:
            return
        main_width = main_splitter.size().width() or main_splitter.width()
        if main_width <= 0:
            if attempt < 10:
                QTimer.singleShot(50, lambda: self._apply_initial_splitter_sizes(attempt + 1))
                return
            main_width = self.width()
            if main_width <= 0:
                return
        left_width = max(1, int(main_width / 3))
        right_width = max(1, int(main_width - left_width))
        try:
            main_splitter.setSizes([left_width, right_width])
        except Exception:
            pass
        right_width_actual = right_splitter.size().width() or right_splitter.width() or right_width
        ob_w = max(1, int(right_width_actual / 3))
        chart_w = max(1, int(right_width_actual - ob_w))
        try:
            right_splitter.setSizes([chart_w, ob_w])
        except Exception:
            pass
        book_splitter = getattr(self, "_book_tape_splitter", None)
        if book_splitter is not None:
            book_width = book_splitter.size().width() or book_splitter.width()
            if book_width <= 0:
                book_width = 3
            prints_width = max(1, int(book_width * 2 / 3))
            book_width = max(1, int(book_width - prints_width))
            try:
                book_splitter.setSizes([prints_width, book_width])
            except Exception:
                pass
        self._splitter_sizes_applied = True

    def _sound_status_text(self):
        try:
            return f"Sound: {'On' if SOUND_ENABLED else 'Off'}"
        except Exception:
            return "Sound: --"

    def _update_sound_ui(self, enabled=None):
        state = SOUND_ENABLED if enabled is None else bool(enabled)
        try:
            self.sound_label.setText(self._sound_status_text())
        except Exception:
            pass
        try:
            # Avoid feedback loop if value change originates from toggle
            self.sound_toggle.blockSignals(True)
            self.sound_toggle.setChecked(bool(state))
            self.sound_toggle.blockSignals(False)
        except Exception:
            pass

    def _on_sound_toggle_changed(self, value):
        global SOUND_ENABLED
        SOUND_ENABLED = bool(value)
        self._update_sound_ui(SOUND_ENABLED)
        try:
            save_settings_to_file()
        except Exception:
            pass

    def update_ws_status(self, name, status):
        try:
            if not hasattr(self, "_ws_status_map"):
                self._ws_status_map = {}
            if name:
                self._ws_status_map[str(name)] = str(status)
            book = self._ws_status_map.get("book", "OFF")
            prints = self._ws_status_map.get("prints", "OFF")
            chart = self._ws_status_map.get("chart", "OFF")
            self.ws_status_label.setText(f"WS: стакан {book} | принти {prints} | графік {chart}")
        except Exception:
            pass

    def _on_book_tick_changed(self, value):
        global ORDERBOOK_TICK_MULT
        try:
            new_val = int(value)
        except Exception:
            new_val = int(ORDERBOOK_TICK_MULT or 1)
        if new_val < 1:
            new_val = 1
        if new_val == int(ORDERBOOK_TICK_MULT or 1):
            return
        ORDERBOOK_TICK_MULT = new_val
        try:
            self._book_start_price = None
            self._book_tick_used = 0.0
            self._book_levels_used = 0
        except Exception:
            pass
        try:
            self._update_book_precision(self.current_symbol)
            if self._orderbook_local:
                self._queue_orderbook_render(self._orderbook_local.get('bids') or [], self._orderbook_local.get('asks') or [])
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass
        try:
            self.sync_quick_controls()
        except Exception:
            pass


    def _on_click_trading_toggled(self, checked):
        try:
            globals()['CLICK_TRADING_ENABLED'] = bool(checked)
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass

    def _on_click_entry_usd_changed(self, val):
        try:
            globals()['CLICK_ENTRY_NOTIONAL_USD'] = float(val)
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass

    def _on_book_auto_center_changed(self, checked):
        global ORDERBOOK_AUTO_CENTER
        ORDERBOOK_AUTO_CENTER = bool(checked)
        try:
            if ORDERBOOK_AUTO_CENTER:
                self._book_start_price = None
                self._book_tick_used = 0.0
                self._book_levels_used = 0
                # Reset image-mode scroll state so auto-centering works immediately
                try:
                    self._book_img_offset = 0
                    self._book_img_user_scrolled = False
                except Exception:
                    pass
        except Exception:
            pass
        try:
            if self._orderbook_local:
                self._queue_orderbook_render(self._orderbook_local.get('bids') or [], self._orderbook_local.get('asks') or [])
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass

    def _on_book_depth_changed(self, value):
        global ORDERBOOK_LADDER_LEVELS
        try:
            new_val = int(value)
        except Exception:
            new_val = int(ORDERBOOK_LADDER_LEVELS or 1000)
        if new_val < 20:
            new_val = 20
        if new_val == int(ORDERBOOK_LADDER_LEVELS or 0):
            return
        ORDERBOOK_LADDER_LEVELS = new_val
        try:
            self._book_start_price = None
            self._book_tick_used = 0.0
            self._book_levels_used = 0
        except Exception:
            pass
        try:
            if self._orderbook_local:
                self._queue_orderbook_render(self._orderbook_local.get('bids') or [], self._orderbook_local.get('asks') or [])
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass

    def _on_book_levels_changed(self, value):
        global ORDERBOOK_LEVELS
        try:
            new_val = int(value)
        except Exception:
            new_val = int(ORDERBOOK_LEVELS or 500)
        if new_val < 20:
            new_val = 20
        if new_val == int(ORDERBOOK_LEVELS or 0):
            return
        ORDERBOOK_LEVELS = new_val
        try:
            self._book_start_price = None
            self._book_tick_used = 0.0
            self._book_levels_used = 0
        except Exception:
            pass
        try:
            if _use_full_orderbook(self.current_symbol):
                if _orderbook_rest_seeded((self.current_symbol or "").upper()):
                    _force_orderbook_partial(self.current_symbol, reason="level change without REST")
                else:
                    _seed_full_orderbook_async(self.current_symbol, force=True)
            else:
                subscribe_orderbook(self.current_symbol)
        except Exception:
            pass
        try:
            if self._orderbook_local:
                self._queue_orderbook_render(self._orderbook_local.get('bids') or [], self._orderbook_local.get('asks') or [])
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass
        try:
            self.sync_quick_controls()
        except Exception:
            pass

    def show_settings_dialog(self):
        dlg = SettingsDialog(self)
        try:
            self._settings_dialog = dlg
            dlg.exec()
        finally:
            self._settings_dialog = None
        self.sync_quick_controls()

    def sync_quick_controls(self):
        try:
            self._update_sound_ui(SOUND_ENABLED)
        except Exception:
            pass
        try:
            if hasattr(self, "chart_candles_spin"):
                self.chart_candles_spin.blockSignals(True)
                self.chart_candles_spin.setValue(int(CHART_CANDLE_LIMIT))
                self.chart_candles_spin.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "chart_interval_combo"):
                self.chart_interval_combo.blockSignals(True)
                interval_val = str(globals().get("CANDLE_WS_INTERVAL", "5m") or "").strip()
                if interval_val:
                    try:
                        if self.chart_interval_combo.findText(interval_val) == -1:
                            self.chart_interval_combo.addItem(interval_val)
                    except Exception:
                        pass
                    self.chart_interval_combo.setCurrentText(interval_val)
                self.chart_interval_combo.blockSignals(False)
        except Exception:
            pass
        try:
            self.book_tick_mult_spin.blockSignals(True)
            self.book_tick_mult_spin.setValue(int(globals().get("ORDERBOOK_TICK_MULT", 1) or 1))
            self.book_tick_mult_spin.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "book_tick_top_spin"):
                self.book_tick_top_spin.blockSignals(True)
                self.book_tick_top_spin.setValue(int(globals().get("ORDERBOOK_TICK_MULT", 1) or 1))
                self.book_tick_top_spin.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "book_depth_top_spin"):
                self.book_depth_top_spin.blockSignals(True)
                self.book_depth_top_spin.setValue(int(globals().get("ORDERBOOK_LADDER_LEVELS", 1000) or 1000))
                self.book_depth_top_spin.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "book_levels_top_spin"):
                self.book_levels_top_spin.blockSignals(True)
                self.book_levels_top_spin.setValue(int(globals().get("ORDERBOOK_LEVELS", 500) or 500))
                self.book_levels_top_spin.blockSignals(False)
        except Exception:
            pass
        try:
            if hasattr(self, "book_auto_center_chk"):
                self.book_auto_center_chk.blockSignals(True)
                self.book_auto_center_chk.setChecked(bool(globals().get("ORDERBOOK_AUTO_CENTER", True)))
                self.book_auto_center_chk.blockSignals(False)
        except Exception:
            pass
        try:
            self.min_pos_notional_spin.setValue(float(MIN_POS_NOTIONAL_MULT or 0.0))
        except Exception:
            pass
        try:
            self.max_pos_notional_spin.setValue(float(MAX_POS_NOTIONAL_MULT or 0.0))
        except Exception:
            pass
        try:
            self.stop_loss_min_spin.setValue(float(STOP_LOSS_MIN_PCT or 0.0) * 100.0)
        except Exception:
            pass
        try:
            self.stop_loss_max_spin.setValue(float(STOP_LOSS_MAX_PCT or 0.0) * 100.0)
        except Exception:
            pass
        try:
            self.loss_close_ban_spin.setValue(int(LOSS_CLOSE_BAN_MINUTES or 0))
        except Exception:
            pass
        try:
            if hasattr(self, "prints_min_notional_spin"):
                self.prints_min_notional_spin.setValue(float(globals().get("PRINTS_MIN_NOTIONAL_USD", 0.0) or 0.0))
            if hasattr(self, "prints_text_min_notional_spin"):
                self.prints_text_min_notional_spin.setValue(float(globals().get("PRINTS_TEXT_MIN_NOTIONAL_USD", 0.0) or 0.0))
            try:
                if hasattr(self, 'prints_speed_auto_chk') and self.prints_speed_auto_chk is not None:
                    self.prints_speed_auto_chk.setChecked(bool(globals().get('PRINTS_SPEED_AUTO', False)))
            except Exception:
                pass
            try:
                self._on_prints_speed_auto_toggled(bool(globals().get('PRINTS_SPEED_AUTO', False)))
            except Exception:
                pass
        except Exception:
            pass
        try:
            if hasattr(self, "prints_speed_spin"):
                _v = globals().get('PRINTS_SPEED_MULT', 1.0)
                self.prints_speed_spin.setValue(float(_v) if _v is not None else 1.0)
                
        except Exception:
            pass
        try:
            if hasattr(self, "prints_agg_extra_ms_spin") and self.prints_agg_extra_ms_spin is not None:
                self.prints_agg_extra_ms_spin.setValue(int(globals().get("PRINTS_AGG_WINDOW_MS_EXTRA", 0) or 0))
        except Exception:
            pass
        try:
            self._sync_click_entry_presets_ui()
        except Exception:
            pass
        try:
            if hasattr(self, "book_vol_usd_chk"):
                self.book_vol_usd_chk.setChecked(bool(globals().get("ORDERBOOK_VOL_IN_USD", False)))
        except Exception:
            pass
        try:
            if hasattr(self, "book_vol_compact_chk"):
                self.book_vol_compact_chk.setChecked(bool(globals().get("ORDERBOOK_VOL_COMPACT", False)))
        except Exception:
            pass
        try:
            if hasattr(self, "book_vol_width_spin"):
                self.book_vol_width_spin.setValue(int(globals().get("ORDERBOOK_VOL_COL_WIDTH", 0) or 0))
        except Exception:
            pass
        try:
            self._apply_book_volume_width()
        except Exception:
            pass
        try:
            self.log_dir_edit.setText(LOG_DIR or '')
        except Exception:
            pass
        try:
            self.telegram_file_edit.setText(TELEGRAM_USERS_FILE or '')
        except Exception:
            pass
        try:
            self.settings_file_edit.setText(SETTINGS_FILE or DEFAULT_SETTINGS_FILE)
        except Exception:
            pass
        try:
            self.equity_file_edit.setText(EQUITY_HISTORY_FILE or '')
        except Exception:
            pass
        try:
            self.trade_journal_file_edit.setText(TRADE_JOURNAL_FILE or '')
        except Exception:
            pass
        try:
            self.pnl_snapshot_edit.setText(PNL_SNAPSHOT_FILE or '')
        except Exception:
            pass

    def _refresh_balance_background(self):
        if bot_running:
            return
        try:
            min_sec = float(globals().get("PRESTART_BALANCE_REFRESH_SEC", 30.0) or 30.0)
        except Exception:
            min_sec = 30.0
        try:
            now_ts = time.time()
            last_ts = float(getattr(self, "_prestart_last_balance", 0.0) or 0.0)
            if (now_ts - last_ts) < min_sec:
                return
            self._prestart_last_balance = now_ts
        except Exception:
            pass
        def _worker():
            try:
                bal = get_balance()
                if bal is None:
                    return
                try:
                    base = float(initial_balance) if initial_balance else float(bal)
                except Exception:
                    base = float(bal)
                pnl_pct = 0.0
                try:
                    if base:
                        pnl_pct = ((float(bal) - base) / base) * 100.0
                except Exception:
                    pnl_pct = 0.0
                update_balance_display(float(bal), float(pnl_pct))
            except Exception:
                pass
        threading.Thread(target=_worker, daemon=True).start()

    def _poll_open_orders_cache(self):
        if bot_running:
            return
        try:
            if not bool(globals().get("OPEN_ORDERS_REST_PRESTART_SYNC", True)):
                return
        except Exception:
            return
        try:
            min_sec = float(globals().get("PRESTART_ORDERS_REFRESH_SEC", 60.0) or 60.0)
        except Exception:
            min_sec = 60.0
        try:
            now_ts = time.time()
            last_ts = float(getattr(self, "_prestart_last_orders", 0.0) or 0.0)
            if (now_ts - last_ts) < min_sec:
                return
            self._prestart_last_orders = now_ts
        except Exception:
            pass
        if not self._prestart_refresh_lock.acquire(False):
            return
        def _worker():
            try:
                try:
                    now_ts = time.time()
                except Exception:
                    now_ts = 0.0
                poll_ts = now_ts
                do_pos_sync = True
                try:
                    min_pos_sec = float(globals().get("PRESTART_POS_REFRESH_SEC", 60.0) or 60.0)
                except Exception:
                    min_pos_sec = 60.0
                try:
                    last_pos_ts = float(getattr(self, "_prestart_last_pos", 0.0) or 0.0)
                    if now_ts and (now_ts - last_pos_ts) < min_pos_sec:
                        do_pos_sync = False
                    else:
                        self._prestart_last_pos = now_ts
                except Exception:
                    do_pos_sync = True
                if do_pos_sync:
                    try:
                        sync_open_positions_from_exchange(trigger_trailing=False)
                    except Exception:
                        pass
                try:
                    _sym0 = (self._book_symbol or self.current_symbol or "").upper()
                except Exception:
                    _sym0 = ""
                rest_ok = True
                try:
                    if _sym0:
                        open_orders = signed_request(client.futures_get_open_orders, symbol=_sym0) or []
                    else:
                        open_orders = signed_request(client.futures_get_open_orders) or []
                except Exception:
                    open_orders = []
                    rest_ok = False
                book_map = {}
                for _o in open_orders or []:
                    norm = _normalize_open_order_for_book(_o)
                    if not norm:
                        continue
                    try:
                        if _should_suppress_order_after_cancel_all(norm.get("symbol") or _sym0, norm.get("ts")):
                            continue
                    except Exception:
                        pass
                    try:
                        if _should_suppress_order_id(
                            norm.get("order_id") or norm.get("orderId") or norm.get("id"),
                            norm.get("algo_id") or norm.get("algoId"),
                        ):
                            continue
                    except Exception:
                        pass
                    book_map.setdefault(norm["symbol"], []).append(norm)
                algo_ok = True
                algo_orders = []
                try:
                    algo_orders = get_open_conditional_orders() or []
                except Exception:
                    algo_orders = []
                    algo_ok = False
                # Keep only conditional orders for current symbol in prestart mode
                if '_sym0' in locals() and _sym0:
                    try:
                        algo_orders = [o for o in (algo_orders or []) if ((o.get('symbol') or o.get('s') or '').upper() == _sym0)]
                    except Exception:
                        pass
                for _o in algo_orders or []:
                    norm = _normalize_open_order_for_book(_o)
                    if not norm:
                        continue
                    try:
                        if _should_suppress_order_after_cancel_all(norm.get("symbol") or _sym0, norm.get("ts")):
                            continue
                    except Exception:
                        pass
                    try:
                        if _should_suppress_order_id(
                            norm.get("order_id") or norm.get("orderId") or norm.get("id"),
                            norm.get("algo_id") or norm.get("algoId"),
                        ):
                            continue
                    except Exception:
                        pass
                    book_map.setdefault(norm["symbol"], []).append(norm)
                try:
                    if '_sym0' in locals() and _sym0 and _sym0 not in book_map:
                        book_map[_sym0] = []
                    for _sym_k, _list in list(book_map.items()):
                        book_map[_sym_k] = _merge_recent_cached_orders(_sym_k, _list)
                except Exception:
                    pass
                if (not rest_ok) and (not algo_ok):
                    return
                try:
                    book_map = _merge_local_orders_into_book_map(book_map)
                except Exception:
                    pass
                partial_update = False
                if _sym0 and (not rest_ok or not algo_ok):
                    partial_update = True
                    try:
                        book_list = list(book_map.get(_sym0) or [])
                    except Exception:
                        book_list = []
                    try:
                        with open_orders_cache_lock:
                            prev_items = list(open_orders_cache.get(_sym0) or [])
                    except Exception:
                        prev_items = []
                    if prev_items:
                        if not rest_ok:
                            for it in prev_items:
                                try:
                                    if it.get("algo_id") or it.get("algoId"):
                                        continue
                                except Exception:
                                    pass
                                book_list.append(it)
                        if not algo_ok:
                            for it in prev_items:
                                try:
                                    if not (it.get("algo_id") or it.get("algoId")):
                                        continue
                                except Exception:
                                    pass
                                book_list.append(it)
                        merged = []
                        seen = set()
                        for it in book_list:
                            try:
                                oid = str(it.get("order_id") or it.get("orderId") or it.get("id") or "")
                            except Exception:
                                oid = ""
                            try:
                                aid = str(it.get("algo_id") or it.get("algoId") or "")
                            except Exception:
                                aid = ""
                            if aid:
                                key = f"algo:{aid}"
                            elif oid:
                                key = f"oid:{oid}"
                            else:
                                try:
                                    key = f"p:{float(it.get('price') or 0.0)}:{it.get('side')}:{it.get('type')}"
                                except Exception:
                                    key = None
                            if key and key in seen:
                                continue
                            if key:
                                seen.add(key)
                            merged.append(it)
                        book_list = merged
                    try:
                        with open_orders_cache_lock:
                            try:
                                book_list = _filter_suppressed_order_list(book_list)
                            except Exception:
                                pass
                            open_orders_cache[_sym0] = list(book_list or [])
                            globals()["open_orders_cache_ts"] = time.time()
                    except Exception:
                        pass
                if not partial_update:
                    try:
                        with open_orders_cache_lock:
                            for _sym_k, _list in (book_map or {}).items():
                                try:
                                    merged_list = list(_list or [])
                                except Exception:
                                    merged_list = []
                                try:
                                    merged_list = _filter_suppressed_order_list(merged_list)
                                except Exception:
                                    pass
                                open_orders_cache[_sym_k] = list(merged_list)
                            globals()["open_orders_cache_ts"] = time.time()
                    except Exception:
                        pass
                try:
                    sym = (self._book_symbol or self.current_symbol or "").upper()
                except Exception:
                    sym = ""
                if sym and gui_bus is not None:
                    ob_snapshot = None
                    try:
                        with orderbook_lock:
                            ob_snapshot = orderbook_state.get(sym)
                    except Exception:
                        ob_snapshot = None
                    if ob_snapshot is not None:
                        gui_bus.orderbook_signal.emit(ob_snapshot)
            except Exception:
                pass
            finally:
                try:
                    self._prestart_refresh_lock.release()
                except Exception:
                    pass
        threading.Thread(target=_worker, daemon=True).start()


    def _prestart_seed_symbol_snapshot(self, symbol: str):
        """One-shot REST snapshot per symbol to seed open orders + position for UI (then WS-only)."""
        if bot_running:
            return
        try:
            if not bool(globals().get("OPEN_ORDERS_REST_PRESTART_SYNC", True)):
                return
        except Exception:
            return
        sym = (symbol or "").upper().strip()
        if not sym:
            return
        try:
            done = getattr(self, "_prestart_snapshot_done", None)
            if done is None:
                done = set()
                setattr(self, "_prestart_snapshot_done", done)
            if sym in done:
                return
            done.add(sym)
        except Exception:
            pass

        def _worker():
            try:
                snapshot_ts = time.time()
            except Exception:
                snapshot_ts = 0.0
            # --- Open orders (normal + optional algo/conditional) ---
            book_list = []
            try:
                open_orders = signed_request(client.futures_get_open_orders, symbol=sym) or []
            except Exception as e:
                open_orders = []
                try:
                    log_message(f"⚠️ SNAPSHOT openOrders {sym}: {e}")
                except Exception:
                    pass
            algo_orders = []
            if bool(globals().get("SNAPSHOT_INCLUDE_ALGO_ORDERS", True)):
                try:
                    algo_orders = get_open_conditional_orders(sym) or []
                except Exception as e:
                    algo_orders = []
                    try:
                        log_message(f"⚠️ SNAPSHOT algoOrders {sym}: {e}")
                    except Exception:
                        pass
            try:
                for _o in (open_orders or []) + (algo_orders or []):
                    norm = _normalize_open_order_for_book(_o)
                    if not norm:
                        continue
                    if str(norm.get("symbol", "")).upper() != sym:
                        continue
                    try:
                        if _should_suppress_order_after_cancel_all(sym, norm.get("ts")):
                            continue
                    except Exception:
                        pass
                    try:
                        if _should_suppress_order_id(
                            norm.get("order_id") or norm.get("orderId") or norm.get("id"),
                            norm.get("algo_id") or norm.get("algoId"),
                        ):
                            continue
                    except Exception:
                        pass
                    book_list.append(norm)
            except Exception:
                pass
            try:
                book_list = _merge_local_orders_for_symbol(sym, book_list)
            except Exception:
                pass
            try:
                book_list = _filter_suppressed_order_list(book_list)
            except Exception:
                pass
            # Merge snapshot with recent local/force-added markers.
            try:
                keep_sec = 10.0
            except Exception:
                keep_sec = 10.0
            try:
                now_ts = time.time()
            except Exception:
                now_ts = 0.0
            cutoff = float(now_ts) - float(keep_sec or 0.0)
            try:
                with open_orders_cache_lock:
                    prev_items = list(open_orders_cache.get(sym) or [])
            except Exception:
                prev_items = []
            merged = list(book_list or [])
            seen = set()
            def _snap_key(it):
                try:
                    oid = it.get("order_id") or it.get("orderId") or it.get("id")
                except Exception:
                    oid = None
                if oid not in (None, ""):
                    return f"oid:{oid}"
                try:
                    aid = it.get("algo_id") or it.get("algoId")
                except Exception:
                    aid = None
                if aid not in (None, ""):
                    return f"algo:{aid}"
                try:
                    price_val = float(it.get("price"))
                except Exception:
                    price_val = None
                try:
                    side_val = str(it.get("side") or "").upper()
                except Exception:
                    side_val = ""
                try:
                    type_val = str(it.get("type") or "").upper()
                except Exception:
                    type_val = ""
                if price_val is None or not side_val:
                    return None
                return f"p:{price_val:.10f}:{side_val}:{type_val}"
            for it in merged:
                key = _snap_key(it)
                if key:
                    seen.add(key)
            for it in prev_items:
                keep = False
                try:
                    if bool(it.get("local")):
                        keep = True
                except Exception:
                    keep = False
                if not keep:
                    try:
                        ts_val = float(it.get("ts") or 0.0)
                    except Exception:
                        ts_val = 0.0
                    if ts_val and ts_val >= cutoff:
                        keep = True
                if not keep:
                    continue
                try:
                    if _should_suppress_order_id(
                        it.get("order_id") or it.get("orderId") or it.get("id"),
                        it.get("algo_id") or it.get("algoId"),
                    ):
                        continue
                except Exception:
                    pass
                try:
                    if _should_suppress_order_after_cancel_all(sym, it.get("ts")):
                        continue
                except Exception:
                    pass
                key = _snap_key(it)
                if key and key in seen:
                    continue
                merged.append(it)
                if key:
                    seen.add(key)
            book_list = merged
            try:
                book_list = _filter_suppressed_order_list(book_list)
            except Exception:
                pass
            try:
                with open_orders_cache_lock:
                    open_orders_cache[sym] = list(book_list or [])
                    globals()["open_orders_cache_ts"] = time.time()
                    book_list = list(book_list or [])
            except Exception:
                pass
            try:
                if gui_bus is not None:
                    ob_snapshot = None
                    try:
                        with orderbook_lock:
                            ob_snapshot = orderbook_state.get(sym)
                    except Exception:
                        ob_snapshot = None
                    if ob_snapshot is not None:
                        gui_bus.orderbook_signal.emit(ob_snapshot)
            except Exception:
                pass

            # --- Position (for marker in orderbook) ---
            pos_side = None
            pos_qty = 0.0
            pos_entry = 0.0
            try:
                positions = signed_request(client.futures_position_information) or []
                for it in positions or []:
                    try:
                        if str(it.get("symbol", "")).upper() != sym:
                            continue
                        amt = float(it.get("positionAmt") or 0.0)
                        if abs(amt) <= float(eps or 1e-12):
                            continue
                        pos_side = "LONG" if amt > 0 else "SHORT"
                        pos_qty = abs(amt)
                        pos_entry = float(it.get("entryPrice") or 0.0)
                        break
                    except Exception:
                        continue
            except Exception as e:
                try:
                    log_message(f"⚠️ SNAPSHOT position {sym}: {e}")
                except Exception:
                    pass

            try:
                if pos_side and pos_qty > float(eps or 1e-12):
                    with positions_lock:
                        # minimal fields for rendering (no trading side effects)
                        open_positions[sym] = {
                            "symbol": sym,
                            "side": pos_side,
                            "qty": float(pos_qty),
                            "entry_price": float(pos_entry or 0.0),
                        }
            except Exception:
                pass

            # --- Log summary ---
            try:
                log_message(f"📌 SNAPSHOT {sym}: orders={len(book_list)} pos={'ON' if pos_side else 'OFF'}")
            except Exception:
                pass

        threading.Thread(target=_worker, daemon=True).start()

    def _refresh_prestart_state(self):
        if bot_running:
            return
        try:
            self._refresh_balance_background()
        except Exception:
            pass
        try:
            if (not WS_ONLY_MODE) and WS_PLUS_ONE_SNAPSHOT:
                sym = (getattr(self, "_book_symbol", None) or getattr(self, "current_symbol", "") or "").upper().strip()
                if sym:
                    self._prestart_seed_symbol_snapshot(sym)
            elif (not WS_ONLY_MODE) and (not WS_PLUS_ONE_SNAPSHOT):
                self._poll_open_orders_cache()
        except Exception:
            pass

    def load_code_editor(self, path: str | None = None):
        target = path or self.code_path_edit.text().strip() or os.path.abspath(__file__)
        try:
            p = Path(target)
            text = p.read_text(encoding='utf-8')
            self.code_editor.setPlainText(text)
            self.code_path_edit.setText(str(p))
            log_message(f"[CODE_TAB] Loaded {p}")
            return True
        except Exception as e:
            QMessageBox.warning(self, "Code", f"Не вдалося завантажити файл: {e}")
            return False

    def save_code_editor(self):
        target = self.code_path_edit.text().strip() or os.path.abspath(__file__)
        try:
            p = Path(target)
            p.write_text(self.code_editor.toPlainText(), encoding='utf-8')
            log_message(f"[CODE_TAB] Saved {p}")
            return True
        except Exception as e:
            QMessageBox.warning(self, "Code", f"Не вдалося зберегти файл: {e}")
            return False

    def update_advisor_text(self, text: str):
        try:
            self.advisor_text.setPlainText(text or '')
            # cache last changes if JSON
            try:
                obj = json.loads(text)
            except Exception:
                obj = None
            if isinstance(obj, dict):
                # Prefer full settings -> compute diff; else take 'changes'
                ch = obj.get('changes') if isinstance(obj.get('changes'), dict) else None
                st = obj.get('settings') if isinstance(obj.get('settings'), dict) else None
                if st:
                    try:
                        current = _current_settings_snapshot()
                        diff = {}
                        for k, v in st.items():
                            if current.get(k) != v:
                                diff[k] = v
                        self._advisor_last_changes = diff
                    except Exception:
                        self._advisor_last_changes = st
                else:
                    self._advisor_last_changes = ch or {}
                self.advisor_status.setText("GPT Advisor: suggestion ready")
                try:
                    advisor_suggestions.append({'ts': time.time(), 'rationale': obj.get('rationale'), 'changes': self._advisor_last_changes})
                except Exception:
                    pass
                # Apply suggestions immediately (no gate, no delay, do not clear input)
                try:
                    if isinstance(self._advisor_last_changes, dict) and self._advisor_last_changes:
                        ok = apply_settings_changes(self._advisor_last_changes)
                        if ok:
                            self.advisor_status.setText("GPT Advisor: changes applied")
                            try:
                                load_settings_from_file()
                            except Exception:
                                pass
                            self.sync_quick_controls()
                        else:
                            self.advisor_status.setText("GPT Advisor: failed to apply")
                except Exception:
                    pass
            else:
                self._advisor_last_changes = None
        except Exception:
            pass

    def request_gpt_advice(self):
        self.advisor_status.setText("GPT Advisor: requesting...")
        def _worker():
            # treat current text as optional user hint unless це вже JSON-відповідь радника
            hint = self.advisor_text.toPlainText()
            try:
                obj = json.loads(hint)
                if isinstance(obj, dict) and ('changes' in obj or 'rationale' in obj):
                    hint = ''
            except Exception:
                pass
            # remember manual request time to suppress background loop collisions
            try:
                globals()['_advisor_last_manual_ts'] = time.time()
            except Exception:
                pass
            rec = make_gpt_recommendation(user_hint=hint)
            # Only overwrite panel if валідні changes
            txt = None
            if isinstance(rec, dict) and isinstance(rec.get('changes'), dict) and len(rec.get('changes')) > 0:
                txt = json.dumps(rec, ensure_ascii=False, indent=2)
            if txt is None and isinstance(rec, dict):
                txt = json.dumps(rec, ensure_ascii=False, indent=2)
            if gui_bus is not None and txt:
                try:
                    gui_bus.advisor_signal.emit(txt)
                except Exception:
                    pass
            else:
                # keep старий текст, лише оновимо статус
                try:
                    self.advisor_status.setText("GPT Advisor: no suggestion")
                except Exception:
                    pass
        threading.Thread(target=_worker, daemon=True).start()

    def apply_gpt_advice(self):
        try:
            # prefer cached parsed changes
            changes = getattr(self, '_advisor_last_changes', None)
            if not changes:
                obj = None
                try:
                    obj = json.loads(self.advisor_text.toPlainText())
                except Exception:
                    obj = _extract_json_block(self.advisor_text.toPlainText())
                if isinstance(obj, dict):
                    # Use full settings to compute diff if available
                    st = obj.get('settings') if isinstance(obj.get('settings'), dict) else None
                    if st:
                        try:
                            current = _current_settings_snapshot()
                            diff = {}
                            for k, v in st.items():
                                if current.get(k) != v:
                                    diff[k] = v
                            changes = diff
                        except Exception:
                            changes = st
                    else:
                        changes = obj.get('changes') or {}
            if not isinstance(changes, dict) or not changes:
                QMessageBox.information(self, "Advisor", "Немає валідних змін у пропозиції.")
                return
            # Apply immediately (no delay timer)
            try:
                ok = apply_settings_changes(changes)
            except Exception:
                ok = False
            if ok:
                self.advisor_status.setText("GPT Advisor: changes applied")
                try:
                    load_settings_from_file()
                except Exception:
                    pass
                self.sync_quick_controls()
            else:
                self.advisor_status.setText("GPT Advisor: failed to apply")
        except Exception as e:
            try:
                self.advisor_status.setText(f"GPT Advisor: error {e}")
            except Exception:
                pass

    def browse_log_dir(self):
        current = self.log_dir_edit.text().strip() or LOG_DIR or BASE_DIR
        directory = QFileDialog.getExistingDirectory(self, "Виберіть каталог для логів", current)
        if directory:
            self.log_dir_edit.setText(directory)

    def browse_telegram_file(self):
        current = self.telegram_file_edit.text().strip() or TELEGRAM_USERS_FILE or os.path.join(BASE_DIR, "ID.txt")
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "Виберіть файл Telegram користувачів",
            current,
            "Text Files (*.txt);;All Files (*.*)"
        )
        if filename:
            self.telegram_file_edit.setText(filename)

    def browse_settings_file(self):
        current = self.settings_file_edit.text().strip() or SETTINGS_FILE or DEFAULT_SETTINGS_FILE
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "Виберіть файл налаштувань",
            current,
            "JSON Files (*.json);;Text Files (*.txt);;All Files (*.*)"
        )
        if filename:
            self.settings_file_edit.setText(filename)


    def browse_equity_file(self):
        current = self.equity_file_edit.text().strip() or EQUITY_HISTORY_FILE or DEFAULT_EQUITY_HISTORY_FILE
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "???????? ???? ??? equity",
            current,
            "JSON Files (*.json);;All Files (*.*)"
        )
        if filename:
            self.equity_file_edit.setText(filename)

    def browse_trade_journal_file(self):
        current = self.trade_journal_file_edit.text().strip() or TRADE_JOURNAL_FILE or DEFAULT_TRADE_JOURNAL_FILE
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "Select trade journal file",
            current,
            "JSON Files (*.json);;All Files (*.*)"
        )
        if filename:
            self.trade_journal_file_edit.setText(filename)

    def browse_pnl_snapshot_file(self):
        current = self.pnl_snapshot_edit.text().strip() or PNL_SNAPSHOT_FILE or os.path.join(BASE_DIR, "pnl_snapshot.txt")
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "???????? ???? ??? PnL snapshot",
            current,
            "Text Files (*.txt);;All Files (*.*)"
        )
        if filename:
            self.pnl_snapshot_edit.setText(filename)

    def append_log(self, line: str):
        self.log_view.appendPlainText(line)
        self.log_view.verticalScrollBar().setValue(self.log_view.verticalScrollBar().maximum())

    def set_balance_text(self, text: str):
        try:
            self.balance_label.setText(text)
            try:
                self.refresh_equity_chart()
            except Exception:
                pass
        except Exception:
            pass
        try:
            self.refresh_equity_chart()
        except Exception:
            pass

    def set_offset_text(self, ms: int):
        try:
            self.offset_label.setText(f"TimeS: {ms} ms")
        except Exception:
            pass

    def set_ping_text(self, ms: int):
        try:
            if ms is None or int(ms) < 0:
                self.ping_label.setText("Ping: -- ms")
            else:
                self.ping_label.setText(f"Ping: {int(ms)} ms")
        except Exception:
            pass

    def _update_book_precision(self, symbol):
        try:
            qty_prec, price_prec = get_symbol_precision(symbol)
        except Exception:
            qty_prec, price_prec = 0, 0
        try:
            self._book_price_prec = max(2, int(price_prec))
        except Exception:
            self._book_price_prec = 2
        try:
            self._book_qty_prec = max(3, int(qty_prec))
        except Exception:
            self._book_qty_prec = 3
        tick = 0.0
        try:
            filt = order_placement_service._filters(symbol)
            tick = float(filt.get("tick", 0.0) or 0.0)
        except Exception:
            tick = 0.0
        if not tick:
            try:
                tick = 10 ** (-int(self._book_price_prec))
            except Exception:
                tick = 0.0
        try:
            self._book_tick_base = tick if tick and tick > 0 else 0.0
        except Exception:
            pass
        try:
            mult = int(globals().get("ORDERBOOK_TICK_MULT", 1) or 1)
        except Exception:
            mult = 1
        if mult < 1:
            mult = 1
        if tick:
            tick = tick * float(mult)
        self._book_tick = tick if tick and tick > 0 else 0.0

    def _sync_book_symbol(self, symbol):
        global _orderbook_rest_thread_started
        sym = (symbol or "").upper()
        if not sym:
            return
        prev_sym = getattr(self, "_book_symbol", None)
        try:
            if prev_sym and prev_sym != sym:
                self._book_tick_mult_by_symbol[str(prev_sym).upper()] = int(ORDERBOOK_TICK_MULT or 1)
        except Exception:
            pass
        changed = (prev_sym != sym)
        self._book_symbol = sym
        if changed:
            try:
                self._book_force_center_pending = True
            except Exception:
                pass
            # Restore tick-mult per symbol so step doesn't leak between tickers.
            try:
                restored = int(self._book_tick_mult_by_symbol.get(sym, 1) or 1)
                if restored < 1:
                    restored = 1
                globals()['ORDERBOOK_TICK_MULT'] = restored
                try:
                    if hasattr(self, 'book_tick_top_spin') and self.book_tick_top_spin is not None:
                        self.book_tick_top_spin.blockSignals(True)
                        self.book_tick_top_spin.setValue(restored)
                        self.book_tick_top_spin.blockSignals(False)
                except Exception:
                    pass
                try:
                    if hasattr(self, 'book_tick_mult_spin') and self.book_tick_mult_spin is not None:
                        self.book_tick_mult_spin.blockSignals(True)
                        self.book_tick_mult_spin.setValue(restored)
                        self.book_tick_mult_spin.blockSignals(False)
                except Exception:
                    pass
            except Exception:
                pass
            try:
                self._book_autotick_pending = True
            except Exception:
                pass
            try:
                self._book_tick_base = 0.0
                self._book_tick = 0.0
            except Exception:
                pass
            try:
                with orderbook_force_partial_lock:
                    orderbook_force_partial.discard(prev_sym)
                    orderbook_force_partial.discard(sym)
            except Exception:
                pass
        try:
            self._update_book_precision(sym)
        except Exception:
            pass
        try:
            subscribe_orderbook(sym)
            subscribe_trade_prints(sym)
            # Prestart visibility of manual orders/positions.
            # Two supported modes:
            # - WS_ONLY_MODE: no REST snapshot; only WS events after connect.
            # - WS_PLUS_ONE_SNAPSHOT: one lightweight REST snapshot per symbol, then WS-only.
            try:
                if (not WS_ONLY_MODE) and WS_PLUS_ONE_SNAPSHOT:
                    self._prestart_seed_symbol_snapshot(sym)
                elif (not WS_ONLY_MODE) and (not WS_PLUS_ONE_SNAPSHOT):
                    # legacy periodic refresh (can be noisy)
                    self._prestart_last_orders = 0.0
                    threading.Thread(target=self._poll_open_orders_cache, daemon=True).start()
            except Exception:
                pass
            # Start USER DATA stream immediately so manual orders/cancels show up live
            # without hammering REST limits.
            try:
                # Start USER DATA stream in background so it never blocks the UI/startup
                def _prestart_user_stream():
                    try:
                        _ensure_asyncio_event_loop()
                        ensure_twm_started()
                        twm_obj = globals().get('twm')
                        # Start once; keep it running even before pressing "Start bot"
                        if twm_obj is not None and globals().get('user_socket_key') is None:
                            ok = _start_user_socket_safe(max_attempts=10, delay_s=0.25)
                            try:
                                if ok:
                                    log_message("🟢 USER WS started (prestart)")
                                else:
                                    log_message("🔴 USER WS not started (prestart)")
                            except Exception:
                                pass
                    except Exception as e:
                        try:
                            log_message(f"❌ prestart user ws error: {e}")
                        except Exception:
                            pass
                threading.Thread(target=_prestart_user_stream, daemon=True).start()
            except Exception:
                pass
        except Exception:
            pass
        try:
            if USE_ORDERBOOK_REST_FALLBACK and not _orderbook_rest_thread_started:
                threading.Thread(target=orderbook_prints_rest_loop, daemon=True).start()
                _orderbook_rest_thread_started = True
        except Exception:
            pass
        if changed:
            try:
                # Clear any local cached snapshot so tick/step cannot leak between tickers
                self._orderbook_local = None
            except Exception:
                pass
            try:
                with orderbook_lock:
                    orderbook_state.pop(sym, None)
            except Exception:
                pass
            try:
                with orderbook_full_lock:
                    orderbook_full_state.pop(prev_sym, None)
                    orderbook_diff_buffer.pop(prev_sym, None)
                    orderbook_seed_inflight.discard(prev_sym)
                    orderbook_full_state.pop(sym, None)
                    orderbook_diff_buffer.pop(sym, None)
                    orderbook_seed_inflight.discard(sym)
            except Exception:
                pass
            try:
                with orderbook_rest_seed_lock:
                    orderbook_rest_seeded.discard(prev_sym)
                    orderbook_rest_seeded.discard(sym)
            except Exception:
                pass
            try:
                orderbook_emit_ts.pop(sym, None)
                orderbook_rest_poll_ts.pop(sym, None)
            except Exception:
                pass
            try:
                with trade_prints_lock:
                    dq = trade_prints.get(sym)
                    if dq is not None:
                        dq.clear()
            except Exception:
                pass
            try:
                trade_prints_state_ts.pop(sym, None)
                trade_prints_emit_ts.pop(sym, None)
                trade_prints_rest_poll_ts.pop(sym, None)
            except Exception:
                pass
            try:
                self._book_start_price = None
                self._book_tick_used = 0.0
                self._book_levels_used = 0
            except Exception:
                pass
            try:
                if hasattr(self, "book_model") and self.book_model is not None:
                    self.book_model.clear()
            except Exception:
                pass
            try:
                if hasattr(self, "prints_tape") and self.prints_tape is not None:
                    self.prints_tape.clear()
            except Exception:
                pass

    def _subscribe_book_startup(self):
        try:
            sym = (self.symbol_input.text().strip() or self.current_symbol or "").upper()
        except Exception:
            sym = (self.current_symbol or "").upper()
        if not sym:
            return
        try:
            self.current_symbol = sym
        except Exception:
            pass
        try:
            self._sync_book_symbol(sym)
        except Exception:
            pass

    def _start_orderbook_worker(self):
        if getattr(self, "_orderbook_render_use_process", False):
            try:
                self._start_orderbook_render_process()
            except Exception:
                pass
            return
        try:
            t = getattr(self, "_orderbook_render_thread", None)
            if t is not None and t.is_alive():
                return
        except Exception:
            pass
        try:
            self._orderbook_render_stop.clear()
        except Exception:
            pass
        t = threading.Thread(target=self._orderbook_render_loop, daemon=True)
        self._orderbook_render_thread = t
        t.start()

    def _start_orderbook_render_process(self):

        """Start a *pool* of orderbook render worker processes.


        Rationale: a single render process will saturate one logical CPU core

        when ORDERBOOK_LADDER_LEVELS is high (e.g. 1000). A small worker pool

        increases total render throughput and distributes load across cores,

        improving Book FPS.

        """

        procs = getattr(self, '_orderbook_render_procs', None)

        try:

            if procs:

                for p in procs:

                    if p is not None and p.is_alive():

                        return

        except Exception:

            pass

        try:

            ctx = mp.get_context('spawn')

        except Exception:

            ctx = mp

        try:

            maxsize = int(globals().get('ORDERBOOK_RENDER_QUEUE_MAX', 2) or 2)

        except Exception:

            maxsize = 2

        if maxsize < 1:

            maxsize = 1

        try:

            workers = int(globals().get('ORDERBOOK_RENDER_WORKERS', ORDERBOOK_RENDER_WORKERS) or ORDERBOOK_RENDER_WORKERS)

        except Exception:

            workers = int(ORDERBOOK_RENDER_WORKERS or 1)

        if workers < 1:

            workers = 1

        # Hard safety cap: too many workers increases IPC + context-switch overhead.

        if workers > 16:

            workers = 16


        # Shared memory buffers for bids/asks (one per main process; workers attach by name)
        try:
            if not hasattr(self, '_ob_shm_mgr') or self._ob_shm_mgr is None:
                # capacity pairs: keep a bit above ladder levels
                try:
                    cap_pairs = int(max(int(globals().get('ORDERBOOK_LADDER_LEVELS', ORDERBOOK_LADDER_LEVELS) or ORDERBOOK_LADDER_LEVELS) * 3, 5000))
                except Exception:
                    cap_pairs = 5000
                self._ob_shm_mgr = _OrderbookSHMManager(capacity_pairs=cap_pairs)
            else:
                self._ob_shm_mgr.ensure()
        except Exception:
            pass


        try:

            out_q = ctx.Queue(maxsize=max(4, maxsize * max(2, workers)))

        except Exception:

            out_q = None

        if out_q is None:

            return


        in_list = []

        for _ in range(workers):

            try:

                in_list.append(ctx.Queue(maxsize=maxsize))

            except Exception:

                pass

        if not in_list:

            return


        # Store queues

        try:

            self._orderbook_render_in_list = list(in_list)

        except Exception:

            self._orderbook_render_in_list = in_list

        try:

            self._orderbook_render_in = in_list[0]

        except Exception:

            pass

        try:

            self._orderbook_render_out = out_q

        except Exception:

            pass


        # Start reader thread once

        try:

            self._orderbook_render_reader_stop.clear()

        except Exception:

            pass

        try:

            t = threading.Thread(target=self._orderbook_render_reader_loop, daemon=True)

            self._orderbook_render_reader = t

            t.start()

        except Exception:

            pass


        # Start worker processes

        procs = []

        for _w_idx, q in enumerate(in_list):

            try:

                p = ctx.Process(target=_orderbook_render_process_main, args=(q, out_q, _w_idx, workers), daemon=True)

                p.start()

                procs.append(p)

            except Exception:

                pass


        # Send SHM init to workers (best-effort).
        try:
            mgr = getattr(self, '_ob_shm_mgr', None)
            if mgr is not None and mgr.ensure():
                init_msg = {'_cmd': 'init_shm', 'bids_name': mgr.bids_name, 'asks_name': mgr.asks_name, 'capacity_pairs': int(mgr.capacity_pairs)}
                for q in (in_list or []):
                    try:
                        q.put_nowait(init_msg)
                    except Exception:
                        pass
        except Exception:
            pass

        # ---------------------- Feeder (dispatch off GUI core) ----------------------
        try:
            feeder_proc = getattr(self, '_orderbook_feeder_proc', None)
            alive = False
            try:
                alive = (feeder_proc is not None and feeder_proc.is_alive())
            except Exception:
                alive = False
            if not alive:
                try:
                    self._orderbook_feeder_in = ctx.Queue(maxsize=maxsize)
                except Exception:
                    self._orderbook_feeder_in = None
                if self._orderbook_feeder_in is not None:
                    try:
                        pin_core = int(globals().get('ORDERBOOK_FEEDER_CORE', 1) or 1)
                    except Exception:
                        pin_core = 1
                    try:
                        p = ctx.Process(
                            target=_orderbook_feeder_process_main,
                            args=(self._orderbook_feeder_in, in_list, workers, pin_core),
                            daemon=True
                        )
                        p.start()
                        self._orderbook_feeder_proc = p
                    except Exception:
                        pass
        except Exception:
            pass

        # ---------------------- Image renderer (QPainter off GUI core) ----------------------
        try:
            img_proc = getattr(self, '_book_imgproc_proc', None)
            alive = False
            try:
                alive = (img_proc is not None and img_proc.is_alive())
            except Exception:
                alive = False
            if not alive:
                try:
                    self._book_imgproc_in = ctx.Queue(maxsize=1)
                    self._book_imgproc_out = ctx.Queue(maxsize=4)
                except Exception:
                    self._book_imgproc_in = None
                    self._book_imgproc_out = None
                if self._book_imgproc_in is not None and self._book_imgproc_out is not None:
                    try:
                        pin_core = int(globals().get('ORDERBOOK_IMAGE_WORKER_CORE', 2) or 2)
                    except Exception:
                        pin_core = 2
                    try:
                        p = ctx.Process(
                            target=_orderbook_image_renderer_process_main,
                            args=(self._book_imgproc_in, self._book_imgproc_out, pin_core),
                            daemon=True
                        )
                        p.start()
                        self._book_imgproc_proc = p
                    except Exception:
                        pass

                    # Reader thread for image bytes -> GUI signal
                    try:
                        if not hasattr(self, '_book_imgproc_reader_stop') or self._book_imgproc_reader_stop is None:
                            self._book_imgproc_reader_stop = threading.Event()
                    except Exception:
                        self._book_imgproc_reader_stop = threading.Event()
                    try:
                        t = getattr(self, '_book_imgproc_reader', None)
                        if t is None or (hasattr(t, 'is_alive') and not t.is_alive()):
                            try:
                                self._book_imgproc_reader_stop.clear()
                            except Exception:
                                pass
                            t2 = threading.Thread(target=self._book_imgproc_reader_loop, daemon=True)
                            self._book_imgproc_reader = t2
                            t2.start()
                    except Exception:
                        pass
        except Exception:
            pass

        try:

            self._orderbook_render_procs = procs

            self._orderbook_render_proc = procs[0] if procs else None

        except Exception:

            self._orderbook_render_procs = procs

        try:

            self._orderbook_render_rr = 0

        except Exception:

            pass



    def _orderbook_render_reader_loop(self):
        """Read results from the render worker pool.

        IMPORTANT (sharding): each frame produces N shard messages (one per worker).
        We must NOT drain the output queue down to a single newest message, otherwise
        we would drop shards and never complete a frame.

        This reader:
        - drains a *batch* of messages
        - assembles shards by _seq
        - emits only completed frames (or unsharded frames)
        """
        while True:
            try:
                if getattr(self, "_orderbook_render_reader_stop", None) is not None and self._orderbook_render_reader_stop.is_set():
                    break
            except Exception:
                pass

            out_q = getattr(self, "_orderbook_render_out", None)
            if out_q is None:
                time.sleep(0.05)
                continue

            try:
                timeout = float(globals().get("ORDERBOOK_RENDER_READER_TIMEOUT", 0.2) or 0.2)
            except Exception:
                timeout = 0.2

            try:
                first = out_q.get(timeout=timeout)
            except Exception:
                continue

            # Collect a small batch so we can complete shard sets fast.
            msgs = [first]
            try:
                for _ in range(128):
                    nxt = out_q.get_nowait()
                    msgs.append(nxt)
                    if _is_orderbook_process_stop(nxt):
                        break
            except Exception:
                pass

            for result in msgs:
                if _is_orderbook_process_stop(result):
                    return

                # ---- Sharded aggregation (by _seq) ----
                seq = None
                try:
                    if isinstance(result, dict):
                        seq = result.get('_seq')
                except Exception:
                    seq = None

                # Drop truly stale shards only after we have emitted a newer *complete* frame.
                try:
                    last_complete = int(getattr(self, '_orderbook_render_last_complete_seq', -1))
                except Exception:
                    last_complete = -1
                try:
                    if seq is not None and last_complete >= 0 and int(seq) < int(last_complete):
                        continue
                except Exception:
                    pass

                # If this is a shard, accumulate; emit only when complete.
                try:
                    if isinstance(result, dict) and result.get('shards_total') and result.get('shard_idx') is not None:
                        shards_total = int(result.get('shards_total') or 0)
                        shard_idx = int(result.get('shard_idx') or 0)
                        if shards_total > 1 and seq is not None:
                            acc = getattr(self, '_ob_shard_acc', None)
                            if acc is None:
                                acc = {}
                                self._ob_shard_acc = acc

                            entry = acc.get(int(seq))
                            if entry is None:
                                entry = {'parts': {}, 'meta': None, 'ts': time.time()}
                                acc[int(seq)] = entry

                            # store meta from the first arriving shard
                            if entry.get('meta') is None:
                                try:
                                    meta = dict(result)
                                    meta.pop('rows', None)
                                    meta.pop('raw_colors', None)
                                    entry['meta'] = meta
                                except Exception:
                                    entry['meta'] = None

                            # store rows slice
                            try:
                                entry['parts'][int(shard_idx)] = list(result.get('rows') or [])
                            except Exception:
                                entry['parts'][int(shard_idx)] = result.get('rows') or []

                            # keep best rows if present
                            try:
                                if result.get('best_bid_row') is not None:
                                    entry.setdefault('best_bid_row', result.get('best_bid_row'))
                                if result.get('best_ask_row') is not None:
                                    entry.setdefault('best_ask_row', result.get('best_ask_row'))
                            except Exception:
                                pass

                            # Cleanup older/incomplete sequences to avoid growth.
                            try:
                                now_ts = time.time()
                                for k in list(acc.keys()):
                                    try:
                                        if int(k) < int(seq) - 6:
                                            acc.pop(k, None)
                                            continue
                                        st = acc.get(int(k))
                                        if st and (now_ts - float(st.get('ts', now_ts))) > 1.5:
                                            acc.pop(k, None)
                                    except Exception:
                                        pass
                            except Exception:
                                pass

                            if len(entry['parts']) < shards_total:
                                # not complete yet -> wait for more shards
                                continue

                            # Merge in shard order
                            try:
                                merged_rows = []
                                for i in range(shards_total):
                                    merged_rows.extend(entry['parts'].get(i) or [])
                                meta = entry.get('meta') or {}
                                final = dict(meta)
                                final['rows'] = merged_rows
                                # carry best rows if captured
                                if entry.get('best_bid_row') is not None:
                                    final['best_bid_row'] = entry.get('best_bid_row')
                                if entry.get('best_ask_row') is not None:
                                    final['best_ask_row'] = entry.get('best_ask_row')
                                final['raw_colors'] = True
                                result = final
                            except Exception:
                                # if merge fails, skip this frame
                                try:
                                    acc.pop(int(seq), None)
                                except Exception:
                                    pass
                                continue

                            try:
                                acc.pop(int(seq), None)
                            except Exception:
                                pass
                except Exception:
                    pass

                # Mark this frame as the latest emitted complete sequence.
                try:
                    if isinstance(result, dict):
                        _seq2 = result.get('_seq')
                        if _seq2 is not None:
                            self._orderbook_render_last_complete_seq = int(_seq2)
                except Exception:
                    pass

                # ---- Emit throttled ----
                try:
                    try:
                        now_ts = time.monotonic()
                    except Exception:
                        now_ts = time.time()
                    try:
                        frame_ms = float(globals().get("ORDERBOOK_UI_FRAME_MS", 40) or 40.0)
                        # Clamp UI frame interval to keep orderbook FPS high (best-effort)
                        try:
                            frame_ms = max(0, min(int(frame_ms), 8))
                        except Exception:
                            frame_ms = 8.0
                    except Exception:
                        frame_ms = 40.0
                    if frame_ms < 0:
                        frame_ms = 0.0
                    frame_s = frame_ms / 1000.0 if frame_ms else 0.0
                    last_emit = getattr(self, "_orderbook_render_last_emit", 0.0)
                    # Throttle without busy-spinning on a single CPU core
                    if frame_s > 0:
                        try:
                            dt = float(now_ts - float(last_emit))
                        except Exception:
                            dt = 0.0
                        if dt < frame_s:
                            try:
                                time.sleep(max(0.0, frame_s - dt))
                            except Exception:
                                pass
                            try:
                                now_ts = time.monotonic()
                            except Exception:
                                now_ts = time.time()
                    self._orderbook_render_last_emit = now_ts
                    if gui_bus is not None:
                        gui_bus.orderbook_render_signal.emit(result)
                except Exception:
                    pass

    def _book_imgproc_reader_loop(self):
        """Background thread: receives rendered image bytes from img process and emits to GUI."""
        out_q = getattr(self, '_book_imgproc_out', None)
        if out_q is None:
            return
        while True:
            try:
                st = getattr(self, '_book_imgproc_reader_stop', None)
                if st is not None and st.is_set():
                    return
            except Exception:
                pass
            try:
                msg = out_q.get(timeout=0.2)
            except Exception:
                continue
            try:
                if isinstance(msg, dict) and msg.get('_cmd') == 'stop':
                    return
            except Exception:
                pass
            try:
                if gui_bus is not None:
                    gui_bus.orderbook_image_signal.emit(msg)
            except Exception:
                pass


    def _stop_orderbook_render_process(self):

        try:

            if getattr(self, '_orderbook_render_reader_stop', None) is not None:

                self._orderbook_render_reader_stop.set()

        except Exception:

            pass

        # Stop feeder process (dispatch)
        try:
            qf = getattr(self, '_orderbook_feeder_in', None)
            if qf is not None:
                try:
                    qf.put_nowait({'_cmd': 'stop'})
                except Exception:
                    pass
        except Exception:
            pass
        try:
            pf = getattr(self, '_orderbook_feeder_proc', None)
            if pf is not None:
                try:
                    pf.join(timeout=0.8)
                except Exception:
                    pass
                try:
                    if pf.is_alive():
                        pf.terminate()
                except Exception:
                    pass
        except Exception:
            pass

        # Stop image renderer process
        try:
            sti = getattr(self, '_book_imgproc_reader_stop', None)
            if sti is not None:
                try:
                    sti.set()
                except Exception:
                    pass
        except Exception:
            pass
        try:
            qi = getattr(self, '_book_imgproc_in', None)
            if qi is not None:
                try:
                    qi.put_nowait({'_cmd': 'stop'})
                except Exception:
                    pass
        except Exception:
            pass
        try:
            pi = getattr(self, '_book_imgproc_proc', None)
            if pi is not None:
                try:
                    pi.join(timeout=0.8)
                except Exception:
                    pass
                try:
                    if pi.is_alive():
                        pi.terminate()
                except Exception:
                    pass
        except Exception:
            pass


        # Signal all workers to stop

        try:

            in_list = getattr(self, '_orderbook_render_in_list', None)

        except Exception:

            in_list = None

        if not in_list:

            in_list = []

            try:

                q0 = getattr(self, '_orderbook_render_in', None)

                if q0 is not None:

                    in_list = [q0]

            except Exception:

                in_list = []


        for q in (in_list or []):

            try:

                q.put_nowait({'_cmd': 'stop'})

            except Exception:

                pass


        # Join/terminate workers

        try:

            procs = getattr(self, '_orderbook_render_procs', None)

        except Exception:

            procs = None

        if not procs:

            procs = []

            try:

                p0 = getattr(self, '_orderbook_render_proc', None)

                if p0 is not None:

                    procs = [p0]

            except Exception:

                procs = []


        for p in (procs or []):

            try:

                if p is None:

                    continue

                p.join(timeout=1.0)

                if p.is_alive():

                    p.terminate()

            except Exception:

                pass


        try:

            self._orderbook_render_procs = []

            self._orderbook_render_in_list = []

            self._orderbook_render_proc = None

            self._orderbook_render_in = None

            self._orderbook_render_out = None

        except Exception:

            pass


    def _queue_orderbook_render(self, bids, asks):
        try:
            sym = (getattr(self, "_book_symbol", None) or getattr(self, "current_symbol", None) or "").upper()
        except Exception:
            sym = (getattr(self, "current_symbol", None) or "").upper()
        try:
            row_h = int(ORDERBOOK_ROW_HEIGHT or 16)
        except Exception:
            row_h = 16
        visible_rows = None
        try:
            # If image-mode is active, book_table is hidden and its viewport height becomes 0.
            lbl = getattr(self, "book_image_label", None)
            if lbl is not None and getattr(lbl, "isVisible", lambda: False)():
                vh = int(lbl.height() or 0)
            else:
                vh = int(self.book_table.viewport().height() or 0)
            if vh > 0:
                visible_rows = int(vh / max(row_h, 1))
        except Exception:
            visible_rows = None
        default_fg = None
        try:
            default_fg = self.book_table.palette().color(QPalette.Text)
        except Exception:
            default_fg = QColor(220, 220, 220)
        default_fg_rgba = _ensure_rgba_tuple(default_fg, default_alpha=255) or (220, 220, 220, 255)
        theme_light = False
        theme_name = None
        try:
            theme_name = getattr(self, "current_theme", None)
            pal = GUI_THEMES.get(theme_name) or GUI_THEMES.get("Dark") or {}
            bg = pal.get("panel_bg") or pal.get("window_bg") or ""
            theme_light = _color_is_light_hex(bg)
        except Exception:
            theme_light = False
        pending_price = None
        has_pending = False
        meta = None
        try:
            locked = orders_lock.acquire(False)
            if locked:
                try:
                    if isinstance(active_orders, dict) and sym in active_orders:
                        has_pending = True
                    if isinstance(pending_meta, dict):
                        meta = pending_meta.get(sym)
                finally:
                    orders_lock.release()
        except Exception:
            meta = None
        try:
            if meta:
                for key_name in ("stop_price", "pending_stop", "stopPrice", "level"):
                    if meta.get(key_name) not in (None, "", 0):
                        pending_price = float(meta.get(key_name))
                        break
                if meta.get("entry1_order_id"):
                    has_pending = True
        except Exception:
            pass
        try:
            if (not has_pending) and (relocator is not None):
                pending_obj = getattr(relocator, "pending_orders", {}).get(sym)
                if pending_obj:
                    has_pending = True
                    if pending_price is None:
                        try:
                            pending_price = float(pending_obj.get("stopPrice") or pending_obj.get("stop_price") or 0)
                        except Exception:
                            pending_price = None
        except Exception:
            pass
        entry_price = None
        pos_side = None
        sl_price = None
        pos_qty = 0.0
        try:
            pos = None
            locked = positions_lock.acquire(False)
            if locked:
                try:
                    pos = open_positions.get(sym)
                finally:
                    positions_lock.release()
            if pos:
                qty_val = float(pos.get("qty") or 0.0)
                pos_qty = qty_val
                if qty_val > 0:
                    entry_price = float(pos.get("entry_price") or 0.0)
                    pos_side = _norm_side(pos.get("side"))
                    sl_candidate = pos.get("hard_sl_trigger") or pos.get("sl_anchor")
                    if sl_candidate not in (None, "", 0):
                        sl_price = float(sl_candidate)
        except Exception:
            pass
        tp_prices = []
        try:
            tp_queue = []
            locked = tp_lock.acquire(False)
            if locked:
                try:
                    tp_queue = list(pending_tps.get(sym) or [])
                finally:
                    tp_lock.release()
        except Exception:
            tp_queue = []
        for item in tp_queue:
            try:
                tp_prices.append(float(item[0]))
            except Exception:
                continue
        try:
            now_ts = time.time()
            clear_until = None
            try:
                with book_pos_clear_lock:
                    clear_until = book_pos_clear_until.get(sym)
            except Exception:
                clear_until = None
            if clear_until and now_ts >= float(clear_until or 0.0):
                try:
                    with book_pos_clear_lock:
                        book_pos_clear_until.pop(sym, None)
                except Exception:
                    pass
                clear_until = None
            if clear_until:
                entry_price = None
                pos_side = None
                sl_price = None
                tp_prices = []
            else:
                pos_active = bool(pos_qty > eps and entry_price and pos_side in ("LONG", "SHORT"))
                if pos_active:
                    try:
                        with book_pos_clear_lock:
                            book_pos_clear_until.pop(sym, None)
                    except Exception:
                        pass
        except Exception:
            pass
        order_levels = []
        try:
            now_ts = time.time()
            with open_orders_cache_lock:
                if (now_ts - float(open_orders_cache_ts or 0.0)) <= float(OPEN_ORDERS_CACHE_TTL or 5.0):
                    order_levels = list(open_orders_cache.get(sym) or [])
        except Exception:
            order_levels = []
        level_price = None
        try:
            if getattr(self, "current_level", None) not in (None, "", 0):
                level_price = float(getattr(self, "current_level"))
        except Exception:
            level_price = None
        payload = {
            "symbol": sym,
            "bids": bids or [],
            "asks": asks or [],
            "p_prec": getattr(self, "_book_price_prec", 2),
            "q_prec": getattr(self, "_book_qty_prec", 3),
            "tick_mult": int(ORDERBOOK_TICK_MULT or 1),
            "book_tick_base": float(getattr(self, "_book_tick_base", 0.0) or 0.0),
            "book_tick_used": float(getattr(self, "_book_tick_used", 0.0) or 0.0),
            "book_levels_used": int(getattr(self, "_book_levels_used", 0) or 0),
            "book_start_price": getattr(self, "_book_start_price", None),
            "book_autotick_pending": bool(getattr(self, "_book_autotick_pending", False)),
            "visible_rows": visible_rows,
            "row_height": row_h,
            "default_fg_rgba": default_fg_rgba,
            "theme_light": theme_light,
            "theme_name": theme_name,
            "show_depth_bars": bool(globals().get("ORDERBOOK_SHOW_DEPTH_BARS", True)),
            "vol_in_usd": bool(globals().get("ORDERBOOK_VOL_IN_USD", False)),
            "vol_compact": bool(globals().get("ORDERBOOK_VOL_COMPACT", False)),
            "auto_center": bool(globals().get("ORDERBOOK_AUTO_CENTER", True)),
            "visible_range_pct": float(globals().get("ORDERBOOK_VISIBLE_RANGE_PCT", 3.0) or 3.0),
            "levels_total": int(globals().get("ORDERBOOK_LADDER_LEVELS", ORDERBOOK_LADDER_LEVELS) or ORDERBOOK_LADDER_LEVELS),
            "pending_price": pending_price,
            "has_pending": has_pending,
            "entry_price": entry_price,
            "pos_side": pos_side,
            "sl_price": sl_price,
            "tp_prices": tp_prices,
            "order_levels": order_levels,
            "level_price": level_price,
        }
        # Sequence number to drop stale frames from a multi-worker pool
        try:
            self._orderbook_render_seq = int(getattr(self, '_orderbook_render_seq', 0)) + 1
            payload['_seq'] = int(self._orderbook_render_seq)
        except Exception:
            pass
        if getattr(self, "_orderbook_render_use_process", False):
            try:
                self._start_orderbook_worker()
            except Exception:
                pass
            in_list = getattr(self, '_orderbook_render_in_list', None)
            if not in_list:
                in_list = []
                try:
                    q0 = getattr(self, '_orderbook_render_in', None)
                    if q0 is not None:
                        in_list = [q0]
                except Exception:
                    in_list = []
            if in_list:
                # Write bids/asks to SHM (so we don't pickle large lists into each worker queue).
                shm_meta = None
                try:
                    mgr = getattr(self, '_ob_shm_mgr', None)
                    if mgr is None:
                        try:
                            cap_pairs = int(max(int(payload.get('levels_total') or 0) * 3, 5000))
                        except Exception:
                            cap_pairs = 5000
                        mgr = _OrderbookSHMManager(capacity_pairs=cap_pairs)
                        self._ob_shm_mgr = mgr
                    shm_meta = mgr.write_pairs(bids, asks)
                except Exception:
                    shm_meta = None

                # Prepare sharded payload base (small scalars only).
                base = dict(payload)
                # Remove bids/asks from IPC payload when SHM is available
                try:
                    base.pop('bids', None)
                    base.pop('asks', None)
                except Exception:
                    pass
                if isinstance(shm_meta, dict) and shm_meta.get('bids_name') and shm_meta.get('asks_name'):
                    base['_shm_bids'] = shm_meta.get('bids_name')
                    base['_shm_asks'] = shm_meta.get('asks_name')
                    base['capacity_pairs'] = int(shm_meta.get('capacity_pairs') or 0)
                    base['bids_len'] = int(shm_meta.get('bids_len') or 0)
                    base['asks_len'] = int(shm_meta.get('asks_len') or 0)
                else:
                    # Fallback: include bids/asks directly (older behavior)
                    base['bids'] = bids or []
                    base['asks'] = asks or []


                # If feeder process is active, hand off dispatching/sharding to it (keeps GUI core cooler)
                try:
                    feeder_q = getattr(self, '_orderbook_feeder_in', None)
                except Exception:
                    feeder_q = None
                if feeder_q is not None:
                    try:
                        feeder_q.put_nowait(base)
                    except Exception:
                        try:
                            feeder_q.get_nowait()
                        except Exception:
                            pass
                        try:
                            feeder_q.put_nowait(base)
                        except Exception:
                            pass
                    return
                try:
                    do_shard = bool(globals().get('USE_ORDERBOOK_RENDER_SHARDING', True))
                except Exception:
                    do_shard = True
                try:
                    shards_total = int(len(in_list))
                except Exception:
                    shards_total = 1
                if not do_shard or shards_total <= 1:
                    # Send to one worker (round-robin)
                    try:
                        rr = int(getattr(self, '_orderbook_render_rr', 0) or 0)
                    except Exception:
                        rr = 0
                    idx = rr % max(1, len(in_list))
                    try:
                        self._orderbook_render_rr = rr + 1
                    except Exception:
                        pass
                    in_q = in_list[idx]
                    try:
                        in_q.put_nowait(base)
                    except Full:
                        try:
                            in_q.get_nowait()
                        except Exception:
                            pass
                        try:
                            in_q.put_nowait(base)
                        except Exception:
                            pass
                    return

                # Shard one frame across all workers (max parallelism).
                try:
                    levels_total = int(base.get('levels_total') or 0)
                except Exception:
                    levels_total = 0
                if levels_total <= 0:
                    levels_total = int(globals().get('ORDERBOOK_LADDER_LEVELS', ORDERBOOK_LADDER_LEVELS) or ORDERBOOK_LADDER_LEVELS)
                chunk = max(1, (levels_total + shards_total - 1) // shards_total)

                for shard_idx, q in enumerate(in_list):
                    s = shard_idx * chunk
                    e = min(levels_total, s + chunk)
                    part = dict(base)
                    part['shard_idx'] = int(shard_idx)
                    part['shards_total'] = int(shards_total)
                    part['shard_start'] = int(s)
                    part['shard_end'] = int(e)
                    try:
                        q.put_nowait(part)
                    except Full:
                        try:
                            q.get_nowait()
                        except Exception:
                            pass
                        try:
                            q.put_nowait(part)
                        except Exception:
                            pass
                return
        try:
            with self._orderbook_render_lock:
                self._orderbook_render_pending = payload
        except Exception:
            self._orderbook_render_pending = payload
        try:
            self._orderbook_render_event.set()
        except Exception:
            pass
        self._start_orderbook_worker()

    def _orderbook_render_loop(self):
        while True:
            try:
                if self._orderbook_render_stop.is_set():
                    break
            except Exception:
                pass
            try:
                self._orderbook_render_event.wait()
            except Exception:
                time.sleep(0.01)
                continue
            try:
                self._orderbook_render_event.clear()
            except Exception:
                pass
            try:
                if self._orderbook_render_stop.is_set():
                    break
            except Exception:
                pass
            while True:
                try:
                    with self._orderbook_render_lock:
                        payload = self._orderbook_render_pending
                        self._orderbook_render_pending = None
                except Exception:
                    payload = getattr(self, "_orderbook_render_pending", None)
                    self._orderbook_render_pending = None
                if not payload:
                    break
                try:
                    bids = payload.get("bids") or []
                    asks = payload.get("asks") or []
                    result = self._render_orderbook(bids, asks, payload=payload)
                except Exception:
                    result = None
                if result is None:
                    continue
                try:
                    if gui_bus is not None:
                        gui_bus.orderbook_render_signal.emit(result)
                except Exception:
                    pass
                try:
                    if self._orderbook_render_stop.is_set():
                        break
                except Exception:
                    pass

    def _maybe_recover_orderbook_depth(self, payload, bids, asks):
        sym = (payload.get('symbol') or payload.get('s') or self.current_symbol or "").upper()
        if not sym:
            return
        try:
            expected_levels = int(globals().get("ORDERBOOK_LEVELS", ORDERBOOK_LEVELS) or ORDERBOOK_LEVELS)
        except Exception:
            expected_levels = 0
        if expected_levels <= 20:
            return
        try:
            min_ratio = float(globals().get("ORDERBOOK_LOW_DEPTH_MIN_RATIO", 0.1) or 0.1)
        except Exception:
            min_ratio = 0.1
        try:
            min_levels = int(globals().get("ORDERBOOK_LOW_DEPTH_MIN_LEVELS", 20) or 20)
        except Exception:
            min_levels = 20
        try:
            min_levels = max(min_levels, int(expected_levels * float(min_ratio)))
        except Exception:
            min_levels = max(min_levels, 10)
        if min_levels <= 0:
            min_levels = 1
        if len(bids) >= min_levels and len(asks) >= min_levels:
            try:
                self._orderbook_low_depth_since = 0.0
            except Exception:
                pass
            return
        try:
            now = time.monotonic()
        except Exception:
            now = time.time()
        since = getattr(self, "_orderbook_low_depth_since", 0.0) or 0.0
        if since <= 0:
            try:
                self._orderbook_low_depth_since = now
            except Exception:
                pass
            return
        try:
            persist_sec = float(globals().get("ORDERBOOK_LOW_DEPTH_PERSIST_SEC", 1.5) or 1.5)
        except Exception:
            persist_sec = 1.5
        if (now - since) < persist_sec:
            return
        try:
            cooldown = float(globals().get("ORDERBOOK_LOW_DEPTH_RECOVER_COOLDOWN_SEC", 15.0) or 15.0)
        except Exception:
            cooldown = 15.0
        last_fix = getattr(self, "_orderbook_low_depth_last_fix", 0.0) or 0.0
        if (now - last_fix) < cooldown:
            return
        try:
            self._orderbook_low_depth_last_fix = now
        except Exception:
            pass
        try:
            with orderbook_force_partial_lock:
                orderbook_force_partial.discard(sym)
        except Exception:
            pass
        try:
            _rest_fill_orderbook_state_async(sym, reason='low-depth', limit_override=int(expected_levels))
        except Exception:
            pass
        try:
            _seed_full_orderbook_async(sym, force=True)
        except Exception:
            pass
        try:
            subscribe_orderbook(sym)
        except Exception:
            pass

    def update_orderbook_view(self, payload):
        if not isinstance(payload, dict):
            return
        if not bool(getattr(self, '_book_enabled', True)):
            return
        symbol = (payload.get('symbol') or payload.get('s') or "").upper()
        current = (self.current_symbol or "").upper()
        if symbol and current and symbol != current:
            return
        self._orderbook_local = payload
        bids = payload.get('bids') or []
        asks = payload.get('asks') or []
        try:
            self._maybe_recover_orderbook_depth(payload, bids, asks)
        except Exception:
            pass
        try:
            now = time.monotonic()
        except Exception:
            now = time.time()
        try:
            force_render = bool(getattr(self, "_orderbook_force_render", False))
        except Exception:
            force_render = False
        if force_render:
            try:
                self._orderbook_force_render = False
            except Exception:
                pass
            try:
                self._orderbook_last_render_ts = now
            except Exception:
                pass
            self._queue_orderbook_render(bids, asks)
            return
        try:
            frame_ms = float(globals().get("ORDERBOOK_UI_FRAME_MS", 8) or 33.0)
        except Exception:
            frame_ms = 33.0
        if frame_ms < 0:
            frame_ms = 0
        # Keep high FPS, but relax while the user is actively scrolling the book.
        try:
            scroll_recent = self._book_scroll_recent()
        except Exception:
            scroll_recent = False
        try:
            max_frame_ms = int(frame_ms) if frame_ms > 0 else 0
            if scroll_recent:
                try:
                    scroll_frame_ms = float(globals().get("ORDERBOOK_SCROLL_FRAME_MS", 16) or 16)
                except Exception:
                    scroll_frame_ms = 16
                if scroll_frame_ms < 0:
                    scroll_frame_ms = 0
                frame_ms = max(frame_ms, scroll_frame_ms)
                try:
                    max_frame_ms = max(max_frame_ms, int(scroll_frame_ms))
                except Exception:
                    max_frame_ms = max_frame_ms
            frame_ms = max(0, min(int(frame_ms), max_frame_ms))
        except Exception:
            frame_ms = 8.0
        frame_s = frame_ms / 1000.0 if frame_ms else 0.0
        last_ts = getattr(self, "_orderbook_last_render_ts", 0.0)
        scheduled = bool(getattr(self, "_orderbook_render_scheduled", False))
        if frame_s <= 0 or (now - last_ts) >= frame_s:
            try:
                self._orderbook_last_render_ts = now
            except Exception:
                pass
            self._queue_orderbook_render(bids, asks)
            return
        if scheduled:
            return
        delay_ms = int(max((frame_s - (now - last_ts)) * 1000.0, 1.0))
        try:
            self._orderbook_render_scheduled = True
        except Exception:
            pass
        QTimer.singleShot(delay_ms, self._flush_orderbook_render)

    def _flush_orderbook_render(self):
        try:
            self._orderbook_render_scheduled = False
        except Exception:
            pass
        payload = self._orderbook_local if isinstance(getattr(self, "_orderbook_local", None), dict) else None
        if not payload:
            return
        try:
            now = time.monotonic()
        except Exception:
            now = time.time()
        try:
            self._orderbook_last_render_ts = now
        except Exception:
            pass
        bids = payload.get('bids') or []
        asks = payload.get('asks') or []
        self._queue_orderbook_render(bids, asks)

    def apply_orderbook_render(self, result):
        global ORDERBOOK_TICK_MULT
        if not isinstance(result, dict):
            return
        symbol = (result.get("symbol") or "").upper()
        current = (self.current_symbol or "").upper()
        if symbol and current and symbol != current:
            return
        # Convert raw RGBA tuples to Qt QColor only when using TABLE-mode.
        # In IMAGE-mode we keep raw tuples so rows are picklable for multiprocessing workers.
        try:
            _use_img_for_colors = bool(getattr(self, "_book_use_image", False)) and (getattr(self, "book_image_label", None) is not None)
        except Exception:
            _use_img_for_colors = False
        try:
            if result.get("raw_colors") and not _use_img_for_colors:
                result = _orderbook_convert_raw_to_qt(result)
        except Exception:
            pass
        if result.get("clear"):
            try:
                if hasattr(self, "book_model") and self.book_model is not None:
                    self.book_model.clear()
            except Exception:
                pass
            try:
                if hasattr(self, "prints_tape") and self.prints_tape is not None:
                    self.prints_tape.clear()
            except Exception:
                pass
            try:
                self._book_start_price = None
                self._book_tick_used = 0.0
                self._book_levels_used = 0
                self._book_best_bid = None
                self._book_best_ask = None
            except Exception:
                pass
            try:
                self._book_autotick_pending = bool(result.get("autotick_pending", False))
            except Exception:
                pass
            return
        try:
            target_mult = result.get("auto_tick_mult")
            if target_mult is not None:
                target_mult = int(target_mult)
                if target_mult < 1:
                    target_mult = 1
                ORDERBOOK_TICK_MULT = target_mult
                try:
                    self._book_tick_mult_by_symbol[str(symbol).upper()] = int(target_mult)
                except Exception:
                    pass
                try:
                    if hasattr(self, "book_tick_top_spin"):
                        self.book_tick_top_spin.blockSignals(True)
                        self.book_tick_top_spin.setValue(target_mult)
                        self.book_tick_top_spin.blockSignals(False)
                except Exception:
                    pass
                try:
                    if hasattr(self, "book_tick_mult_spin"):
                        self.book_tick_mult_spin.blockSignals(True)
                        self.book_tick_mult_spin.setValue(target_mult)
                        self.book_tick_mult_spin.blockSignals(False)
                except Exception:
                    pass
        except Exception:
            pass
        try:
            self._book_tick_base = result.get("book_tick_base", self._book_tick_base)
            self._book_tick = result.get("book_tick", self._book_tick)
            self._book_start_price = result.get("book_start_price", self._book_start_price)
            self._book_tick_used = result.get("book_tick_used", self._book_tick_used)
            self._book_levels_used = result.get("book_levels_used", self._book_levels_used)
            self._book_best_bid = result.get("best_bid")
            self._book_best_ask = result.get("best_ask")
            self._book_autotick_pending = bool(result.get("autotick_pending", self._book_autotick_pending))
        except Exception:
            pass
        rows = result.get("rows") or []
        try:
            self._book_last_rows = rows
            self._book_last_result = result
        except Exception:
            pass


        # --- B1: single-pixmap orderbook (cheap UI) ---
        use_img = False
        try:
            use_img = bool(getattr(self, "_book_use_image", False)) and (getattr(self, "book_image_label", None) is not None)
        except Exception:
            use_img = False

        if use_img:
            try:
                self._apply_orderbook_image_from_rows(rows, result)
                try:
                    if getattr(self, "book_stack", None) is not None and getattr(self, "book_image_label", None) is not None:
                        self.book_stack.setCurrentWidget(self.book_image_label)
                except Exception:
                    pass
            except Exception:
                use_img = False

        if not use_img:
            # In table-mode, disable external image scroll override for the tape.
            try:
                if hasattr(self, 'prints_tape') and self.prints_tape is not None:
                    self.prints_tape.set_external_scroll_rows(None, None)
            except Exception:
                pass
            model = getattr(self, "book_model", None)
            if model is not None:
                try:
                    self.book_table.setUpdatesEnabled(False)
                except Exception:
                    pass
                try:
                    model.set_rows(rows)
                finally:
                    try:
                        self.book_table.setUpdatesEnabled(True)
                    except Exception:
                        pass
            try:
                if getattr(self, "book_stack", None) is not None:
                    self.book_stack.setCurrentWidget(self.book_table)
            except Exception:
                pass

        try:
            start_price = result.get("start_price")
            tick = result.get("tick")
            levels_total = int(result.get("levels_total") or 0)
            row_h = None
            try:
                row_h = int(self.book_table.rowHeight(0))
            except Exception:
                row_h = None
            if not row_h:
                row_h = int(result.get("row_height") or ORDERBOOK_ROW_HEIGHT or 16)
            if start_price is not None and tick and levels_total:
                if hasattr(self, "prints_tape") and self.prints_tape is not None:
                    self.prints_tape.update_ladder(
                        start_price,
                        tick,
                        levels_total,
                        row_h,
                        best_bid=result.get("best_bid"),
                        best_ask=result.get("best_ask"),
                    )
        except Exception:
            pass
        try:
            if hasattr(self, "prints_tape") and self.prints_tape is not None:
                self.prints_tape.set_order_markers(result.get("order_markers"))
        except Exception:
            pass
        try:
            rb = getattr(self, "_ruler_bar", None)
            if rb is not None and rb.isVisible():
                if use_img:
                    self._update_book_ruler_label_image()
                else:
                    self._update_book_ruler_label()
        except Exception:
            pass
        try:
            if bool(getattr(self, "_book_force_center_pending", False)):
                ba = result.get("best_ask_row")
                bb = result.get("best_bid_row")
                if ba is not None and bb is not None:
                    try:
                        self._book_force_center_pending = False
                    except Exception:
                        pass
                    self._maybe_center_book(ba, bb, force=True)
                else:
                    self._maybe_center_book(result.get("best_ask_row"), result.get("best_bid_row"))
            else:
                self._maybe_center_book(result.get("best_ask_row"), result.get("best_bid_row"))
        except Exception:
            pass
        try:
            self._update_book_price_column_width(result.get("best_bid"), result.get("best_ask"))
        except Exception:
            pass
        try:
            self._update_position_summary(symbol, result.get("best_bid"), result.get("best_ask"))
        except Exception:
            pass

        # --- Book FPS tracking (UI refresh rate) ---
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            if not hasattr(self, '_book_fps_marks') or self._book_fps_marks is None:
                self._book_fps_marks = deque()
            self._book_fps_marks.append(float(now_m))
            # Keep last ~1s of marks
            while self._book_fps_marks and (float(now_m) - float(self._book_fps_marks[0])) > 1.0:
                self._book_fps_marks.popleft()
            self._book_data_fps_val = float(len(self._book_fps_marks))
        except Exception:
            pass

    def _on_orderbook_image_ready(self, payload):
        """GUI slot: apply rendered image bytes produced by the image-renderer process."""
        try:
            if not isinstance(payload, dict):
                return
        except Exception:
            return

        try:
            sym = (payload.get('symbol') or '').upper()
        except Exception:
            sym = ''
        try:
            cur = (self.current_symbol or '').upper()
        except Exception:
            cur = ''
        if sym and cur and sym != cur:
            return

        try:
            seq = payload.get('seq')
            if seq is not None:
                last = int(getattr(self, '_book_img_last_seq', 0) or 0)
                if int(seq) < last:
                    return
                self._book_img_last_seq = int(seq)
        except Exception:
            pass

        try:
            bts = payload.get('img_bytes') or b''
            w = int(payload.get('w') or 0)
            h = int(payload.get('h') or 0)
            stride = int(payload.get('stride') or 0)
        except Exception:
            return

        if not bts or w <= 0 or h <= 0 or stride <= 0:
            return

        try:
            # Keep bytes alive for QImage lifetime
            self._book_last_img_bytes = bts
        except Exception:
            pass

        try:
            img = QImage(self._book_last_img_bytes, w, h, stride, QImage.Format_ARGB32)
            pm = QPixmap.fromImage(img)
        except Exception:
            return

        try:
            lbl = getattr(self, 'book_image_label', None)
            if lbl is None:
                return
            lbl.setPixmap(pm)
        except Exception:
            return

        try:
            if getattr(self, "book_stack", None) is not None:
                self.book_stack.setCurrentWidget(lbl)
        except Exception:
            pass

        try:
            self._book_img_row_h = int(payload.get('row_h') or getattr(self, '_book_img_row_h', 8) or 8)
        except Exception:
            pass


    def _apply_orderbook_image_from_rows(self, rows, result=None):
        """Render visible portion of orderbook rows into a single QImage and blit into QLabel.
        Keeps UI work to one pixmap draw instead of repainting thousands of QTableView cells.
        """
        try:
            from PySide6.QtGui import QImage, QPainter, QFont, QPixmap, QColor
            from PySide6.QtCore import Qt, QRect
        except Exception:
            return
        try:
            lbl = getattr(self, "book_image_label", None)
            if lbl is None:
                return
            w = int(lbl.width() or 0)
            h = int(lbl.height() or 0)
            if w <= 8 or h <= 8:
                return

            row_h = None
            try:
                row_h = int(self.book_table.rowHeight(0))
            except Exception:
                row_h = None
            if not row_h or row_h <= 0:
                try:
                    row_h = int(globals().get("ORDERBOOK_ROW_HEIGHT", 8))
                except Exception:
                    row_h = 8
            if row_h <= 0:
                row_h = 8

            visible_rows = max(1, h // row_h)
            pad = int(globals().get("ORDERBOOK_IMAGE_PAD_ROWS", 20) or 0)
            draw_rows = min(len(rows), visible_rows + max(0, pad))

            try:
                off = int(getattr(self, "_book_img_offset", 0) or 0)
            except Exception:
                off = 0
            max_start = max(0, len(rows) - draw_rows)
            start = max(0, min(off, max_start))
            subset = rows[start:start + draw_rows]


            # ---- Offload QPainter work to a dedicated image renderer process (big FPS win on Windows) ----
            try:
                img_in = getattr(self, '_book_imgproc_in', None)
            except Exception:
                img_in = None
            # If renderer process is dead, do NOT route frames into the queue (it will black-hole updates).
            try:
                p = getattr(self, '_book_imgproc_proc', None)
                if p is None or (hasattr(p, "is_alive") and not p.is_alive()):
                    img_in = None
            except Exception:
                pass
            if img_in is not None:
                try:
                    price_w = int(globals().get("ORDERBOOK_IMAGE_PRICE_COL_W", 92) or 104)
                except Exception:
                    price_w = 104
                price_w = max(60, min(price_w, w - 40))
                try:
                    show_depth_bars = bool(globals().get("ORDERBOOK_SHOW_DEPTH_BARS", True))
                except Exception:
                    show_depth_bars = True
                try:
                    if hasattr(self, "prints_tape") and self.prints_tape is not None:
                        self.prints_tape.set_external_scroll_rows(start, row_h)
                except Exception:
                    pass
                try:
                    if hasattr(self, "prints_tape") and self.prints_tape is not None:
                        try:
                            sp = getattr(self, "_book_start_price", None)
                        except Exception:
                            sp = None
                        try:
                            tk = getattr(self, "_book_tick_used", None) or getattr(self, "_book_tick", None)
                        except Exception:
                            tk = None
                        try:
                            lv = int(getattr(self, "_book_levels_used", None) or (len(rows) if rows is not None else 0))
                        except Exception:
                            lv = (len(rows) if rows is not None else 0)
                        bb = None
                        ba = None
                        try:
                            if result:
                                bb = result.get("best_bid")
                                ba = result.get("best_ask")
                        except Exception:
                            pass
                        try:
                            self.prints_tape.update_ladder(sp, tk, lv, row_h, best_bid=bb, best_ask=ba)
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    seq = int(getattr(self, '_book_imgproc_seq', 0) or 0) + 1
                except Exception:
                    seq = 1
                try:
                    self._book_imgproc_seq = int(seq)
                except Exception:
                    pass
                try:
                    sym = (self.current_symbol or '').upper()
                except Exception:
                    sym = ''
                req = {
                    '_cmd': 'render',
                    'seq': int(seq),
                    'symbol': sym,
                    'start': int(start),
                    'rows': subset,
                    'w': int(w),
                    'row_h': int(row_h),
                    'price_w': int(price_w),
                    'show_depth_bars': bool(show_depth_bars),
                }
                try:
                    img_in.put_nowait(req)
                except Exception:
                    try:
                        img_in.get_nowait()
                    except Exception:
                        pass
                    try:
                        img_in.put_nowait(req)
                    except Exception:
                        pass
                return
            try:
                if hasattr(self, "prints_tape") and self.prints_tape is not None:
                    self.prints_tape.set_external_scroll_rows(start, row_h)
            except Exception:
                pass

            # Keep prints ladder mapping in sync *even during image-mode user scroll / auto-centering*.
            # Otherwise bubbles can appear to "lag behind" and only catch up on the next depth update.
            try:
                if hasattr(self, "prints_tape") and self.prints_tape is not None:
                    try:
                        sp = getattr(self, "_book_start_price", None)
                    except Exception:
                        sp = None
                    try:
                        tk = getattr(self, "_book_tick_used", None) or getattr(self, "_book_tick", None)
                    except Exception:
                        tk = None
                    try:
                        lv = int(getattr(self, "_book_levels_used", None) or (len(rows) if rows is not None else 0))
                    except Exception:
                        lv = (len(rows) if rows is not None else 0)
                    bb = None
                    ba = None
                    try:
                        if result:
                            bb = result.get("best_bid")
                            ba = result.get("best_ask")
                    except Exception:
                        pass
                    try:
                        self.prints_tape.update_ladder(sp, tk, lv, row_h, best_bid=bb, best_ask=ba)
                    except Exception:
                        pass
            except Exception:
                pass

            try:
                self._book_img_row_h = int(row_h)
                self._book_img_start = int(start)
                self._book_img_draw_rows = int(draw_rows)
            except Exception:
                pass

            img_h = draw_rows * row_h
            img = QImage(w, img_h, QImage.Format_ARGB32)
            img.fill(QColor(0, 0, 0, 0))

            painter = QPainter(img)
            try:
                painter.setRenderHint(QPainter.TextAntialiasing, False)
            except Exception:
                pass

            font = QFont()
            try:
                font.setFamily("Consolas")
            except Exception:
                pass
            try:
                font.setBold(False)
            except Exception:
                pass
            try:
                try:
                    base_pt = int(max(7, min(12, int(row_h * 0.80) + 0)))
                except Exception:
                    base_pt = 9
                try:
                    font.setPointSize(int(base_pt))
                except Exception:
                    pass
            except Exception:
                pass
            painter.setFont(font)

            bold_font = QFont(font)
            try:
                bold_font.setBold(True)
            except Exception:
                pass

            price_w = int(globals().get("ORDERBOOK_IMAGE_PRICE_COL_W", 104) or 104)
            price_w = max(60, min(price_w, w - 40))
            vol_w = w - price_w
            if vol_w < 20:
                vol_w = max(20, w // 2)
                price_w = w - vol_w

            def _qc(col):
                """Convert raw color (tuple/list/QColor/int) into QColor for QPainter."""
                if col is None:
                    return None
                try:
                    if isinstance(col, QColor):
                        return col
                except Exception:
                    pass
                try:
                    # tuple/list like (r,g,b) or (r,g,b,a)
                    if isinstance(col, (tuple, list)) and len(col) in (3, 4):
                        r = int(col[0]); g = int(col[1]); b = int(col[2])
                        a = int(col[3]) if len(col) == 4 else 255
                        return QColor(r, g, b, a)
                except Exception:
                    return None
                try:
                    # ARGB integer
                    if isinstance(col, int):
                        a = (col >> 24) & 0xFF
                        # If color is 0xRRGGBB (no alpha), treat as opaque.
                        if a == 0 and col <= 0x00FFFFFF:
                            a = 0xFF
                        r = (col >> 16) & 0xFF
                        g = (col >> 8) & 0xFF
                        b = col & 0xFF
                        return QColor(r, g, b, a)
                except Exception:
                    pass
                return col

            try:
                show_depth_bars = bool(globals().get("ORDERBOOK_SHOW_DEPTH_BARS", True))
            except Exception:
                show_depth_bars = True

            for i, row in enumerate(subset):
                try:
                    y = i * row_h
                    vol_txt = row[OB_ROW_VOL_TEXT] if len(row) > OB_ROW_VOL_TEXT else ""
                    price_txt = row[OB_ROW_PRICE_TEXT] if len(row) > OB_ROW_PRICE_TEXT else ""
                    vol_fg = row[OB_ROW_VOL_FG] if len(row) > OB_ROW_VOL_FG else None
                    price_fg = row[OB_ROW_PRICE_FG] if len(row) > OB_ROW_PRICE_FG else None
                    vol_bg = row[OB_ROW_VOL_BG] if len(row) > OB_ROW_VOL_BG else None
                    price_bg = row[OB_ROW_PRICE_BG] if len(row) > OB_ROW_PRICE_BG else None
                    # Accept both raw (r,g,b,a) tuples and Qt QColor
                    try:
                        if isinstance(vol_fg, (tuple, list)):
                            vol_fg = _rgba_to_qcolor(vol_fg)
                        if isinstance(price_fg, (tuple, list)):
                            price_fg = _rgba_to_qcolor(price_fg)
                        if isinstance(vol_bg, (tuple, list)):
                            vol_bg = _rgba_to_qcolor(vol_bg)
                        if isinstance(price_bg, (tuple, list)):
                            price_bg = _rgba_to_qcolor(price_bg)
                    except Exception:
                        pass
                    vol_base_bg = row[OB_ROW_VOL_BASE_BG] if len(row) > OB_ROW_VOL_BASE_BG else None
                    try:
                        bar_frac = float(row[OB_ROW_BAR_FRAC] or 0.0) if len(row) > OB_ROW_BAR_FRAC else 0.0
                    except Exception:
                        bar_frac = 0.0
                    bar_color = row[OB_ROW_BAR_COLOR] if len(row) > OB_ROW_BAR_COLOR else None
                    try:
                        style_flags = int(row[OB_ROW_STYLE_FLAGS]) if len(row) > OB_ROW_STYLE_FLAGS else 0
                    except Exception:
                        style_flags = 0

                    # Normalize colors for QPainter (tuple/list -> QColor)
                    vol_fg = _qc(vol_fg)
                    price_fg = _qc(price_fg)
                    vol_bg = _qc(vol_bg)
                    price_bg = _qc(price_bg)
                    vol_base_bg = _qc(vol_base_bg)
                    bar_color = _qc(bar_color)

                    if vol_fg is None:
                        vol_fg = QColor(230, 230, 230, 235)
                    if price_fg is None:
                        price_fg = QColor(230, 230, 230, 235)

                    # Volume column background (match OrderbookDelegate logic)
                    try:
                        if vol_bg is not None and getattr(vol_bg, "alpha", lambda: 255)() > 0:
                            painter.fillRect(0, y, vol_w, row_h, vol_bg)
                        elif vol_base_bg is not None and getattr(vol_base_bg, "alpha", lambda: 255)() > 0:
                            painter.fillRect(0, y, vol_w, row_h, vol_base_bg)
                    except Exception:
                        try:
                            if vol_bg is not None:
                                painter.fillRect(0, y, vol_w, row_h, vol_bg)
                        except Exception:
                            pass

                    # Depth bar overlay (solid left->right fill)
                    if show_depth_bars and bar_color is not None:
                        try:
                            bf = float(bar_frac or 0.0)
                        except Exception:
                            bf = 0.0
                        if bf > 0.0:
                            try:
                                bw = int(vol_w * max(0.0, min(bf, 1.0)))
                            except Exception:
                                bw = 0
                            if bw > 0:
                                try:
                                    painter.fillRect(0, y, bw, row_h, bar_color)
                                except Exception:
                                    pass

                    # Price column background
                    if price_bg is not None:
                        try:
                            painter.fillRect(vol_w, y, price_w, row_h, price_bg)
                        except Exception:
                            pass

                    # Best bid/ask: slightly larger bold font (+1pt) for readability
                    row_font = font
                    try:
                        if (int(style_flags or 0) & OB_STYLE_BOLD_ALL) != 0:
                            row_font = QFont(bold_font)
                            try:
                                row_font.setPointSize(int(max(1, bold_font.pointSize() + 1)))
                            except Exception:
                                pass
                    except Exception:
                        row_font = font

                    if vol_fg is not None:
                        painter.setPen(vol_fg)
                    painter.setFont(row_font)
                    painter.drawText(QRect(2, y, max(0, vol_w - 4), row_h), Qt.AlignVCenter | Qt.AlignLeft, str(vol_txt))

                    if price_fg is not None:
                        painter.setPen(price_fg)
                    painter.setFont(row_font)
                    painter.drawText(QRect(vol_w + 1, y, price_w - 2, row_h), Qt.AlignVCenter | Qt.AlignRight, str(price_txt))
                except Exception:
                    continue

            painter.end()

            try:
                pm = QPixmap.fromImage(img)
            except Exception:
                return
            try:
                lbl.setPixmap(pm)
            except Exception:
                pass
            try:
                if getattr(self, "book_stack", None) is not None:
                    self.book_stack.setCurrentWidget(lbl)
            except Exception:
                pass
        except Exception:
            return

    def _render_orderbook(self, bids, asks, payload=None):
        payload = payload or {}
        try:
            merged = dict(payload)
        except Exception:
            merged = {}
        merged["bids"] = bids or []
        merged["asks"] = asks or []
        return _orderbook_render_raw(merged)

    def _maybe_center_book(self, best_ask_row, best_bid_row, force=False):
        if not force:
            try:
                if not bool(globals().get("ORDERBOOK_AUTO_CENTER", True)):
                    return
            except Exception:
                return
        auto_instant = False
        if not force:
            try:
                auto_instant = bool(globals().get("ORDERBOOK_AUTO_CENTER_INSTANT", True))
            except Exception:
                auto_instant = False
        # If the user scrolled manually, pause auto-centering for a short grace period,
        # then resume auto-centering automatically.
        if not force:
            try:
                if bool(getattr(self, "_book_img_user_scrolled", False)):
                    try:
                        grace = float(globals().get("ORDERBOOK_AUTO_CENTER_USER_GRACE_SEC", 1.2) or 1.2)
                    except Exception:
                        grace = 1.2
                    try:
                        ts = getattr(self, "_book_img_user_scroll_ts", None)
                    except Exception:
                        ts = None
                    try:
                        now_m = time.monotonic()
                    except Exception:
                        now_m = time.time()
                    if ts is not None:
                        try:
                            if (now_m - float(ts)) < grace:
                                return
                        except Exception:
                            return
                    # Grace expired -> let auto-centering run again
                    try:
                        self._book_img_user_scrolled = False
                    except Exception:
                        pass
            except Exception:
                pass
        if best_ask_row is None or best_bid_row is None:
            return
        now_ts = None
        if not force:
            try:
                min_ms = float(globals().get("ORDERBOOK_CENTER_MIN_MS", 250) or 250)
            except Exception:
                min_ms = 250
            if auto_instant:
                min_ms = 0.0
            if min_ms > 0:
                try:
                    now_ts = time.monotonic()
                except Exception:
                    now_ts = time.time()
                last_ts = getattr(self, "_book_last_center_ts", 0.0)
                if last_ts and (now_ts - last_ts) < (min_ms / 1000.0):
                    return
        # --- Image-mode auto-centering (does NOT depend on QTableView visibility) ---
        # When the orderbook is rendered as an image (QLabel), QTableView rowAt()/viewport() can return -1
        # because the table is hidden. In that case we center by adjusting _book_img_offset.
        try:
            if bool(getattr(self, "_book_use_image", False)) and getattr(self, "book_stack", None) is not None:
                if getattr(self, "book_image_label", None) is not None and self.book_stack.currentWidget() is self.book_image_label:
                    rows = getattr(self, "_book_last_rows", None) or []
                    if rows:
                        lbl = getattr(self, "book_image_label", None)
                        try:
                            row_h = int(getattr(self, "_book_img_row_h", globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8))
                        except Exception:
                            row_h = int(globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8)
                        row_h = max(4, min(row_h, 64))
                        # How many rows are currently visible in the image widget
                        try:
                            visible_rows = max(1, int((lbl.height() or 1) // row_h))
                        except Exception:
                            visible_rows = max(1, int((getattr(lbl, "height", lambda: 1)() or 1) // row_h))
                        start_row = int(getattr(self, "_book_img_offset", 0) or 0)
                        end_row = int(start_row + visible_rows - 1)
                        target = int((int(best_ask_row) + int(best_bid_row)) / 2)
                        # Center only when spread approaches the edges (avoid constant re-centering)
                        try:
                            edge_pct = float(globals().get("ORDERBOOK_AUTO_CENTER_EDGE_PCT", 20.0) or 20.0)
                        except Exception:
                            edge_pct = 20.0
                        try:
                            edge_pct = max(0.0, min(float(edge_pct), 49.0))
                        except Exception:
                            edge_pct = 20.0
                        try:
                            margin = int(float(visible_rows) * float(edge_pct) / 100.0)
                        except Exception:
                            margin = 0
                        try:
                            margin = max(0, min(int(margin), max(0, (int(visible_rows) // 2) - 1)))
                        except Exception:
                            pass
                        safe_top = int(start_row + margin)
                        safe_bottom = int(end_row - margin)
                        if (not force) and (safe_top <= int(target) <= safe_bottom):
                            return
                        try:
                            pad = int(globals().get("ORDERBOOK_IMAGE_PAD_ROWS", 20) or 0)
                        except Exception:
                            pad = 0
                        draw_rows = min(len(rows), visible_rows + max(0, pad))
                        max_start = max(0, len(rows) - draw_rows)
                        new_start = int(target - (visible_rows // 2))
                        new_start = max(0, min(new_start, max_start))
                        self._book_img_user_scrolled = False
                        if force or auto_instant:
                            self._book_img_offset = int(new_start)
                            try:
                                self._apply_orderbook_image_from_rows(rows, getattr(self, "_book_last_result", None))
                            except Exception:
                                pass
                        else:
                            try:
                                self._book_image_center_to(int(new_start), rows, getattr(self, "_book_last_result", None))
                            except Exception:
                                # Fallback: immediate jump
                                self._book_img_offset = int(new_start)
                                try:
                                    self._apply_orderbook_image_from_rows(rows, getattr(self, "_book_last_result", None))
                                except Exception:
                                    pass
                        try:
                            self._book_last_center_ts = now_ts if now_ts is not None else time.monotonic()
                        except Exception:
                            pass
                        return
        except Exception:
            pass

        try:
            top = self.book_table.rowAt(0)
            bottom = self.book_table.rowAt(self.book_table.viewport().height() - 1)
        except Exception:
            return
        if top < 0 or bottom < 0:
            return
        target = int((int(best_ask_row) + int(best_bid_row)) / 2)
        # Edge-based gating: only auto-center when spread approaches edges of visible area
        try:
            visible_rows = int(bottom - top + 1)
        except Exception:
            visible_rows = 0
        try:
            edge_pct = float(globals().get("ORDERBOOK_AUTO_CENTER_EDGE_PCT", 20.0) or 20.0)
        except Exception:
            edge_pct = 20.0
        try:
            edge_pct = max(0.0, min(float(edge_pct), 49.0))
        except Exception:
            edge_pct = 20.0
        try:
            margin = int(float(visible_rows) * float(edge_pct) / 100.0)
        except Exception:
            margin = 0
        try:
            margin = max(0, min(int(margin), max(0, (int(visible_rows) // 2) - 1)))
        except Exception:
            pass
        safe_top = int(top + margin)
        safe_bottom = int(bottom - margin)
        if (not force) and (safe_top <= int(target) <= safe_bottom):
            return
        try:
            tol = int(globals().get("ORDERBOOK_CENTER_TOLERANCE_ROWS", ORDERBOOK_CENTER_TOLERANCE_ROWS) or ORDERBOOK_CENTER_TOLERANCE_ROWS)
        except Exception:
            tol = 1
        mid = int((int(top) + int(bottom)) / 2)
        if (not force) and (abs(int(target) - int(mid)) <= int(tol)):
            return

        # If book is rendered as an image, center by adjusting the image offset (no QTableView scroll).
        try:
            if bool(getattr(self, "_book_use_image", False)) and getattr(self, "book_stack", None) is not None:
                if getattr(self, "book_image_label", None) is not None and self.book_stack.currentWidget() is self.book_image_label:
                    rows = getattr(self, "_book_last_rows", None) or []
                    if rows:
                        lbl = getattr(self, "book_image_label", None)
                        try:
                            row_h = int(getattr(self, "_book_img_row_h", globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8))
                        except Exception:
                            row_h = int(globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8)
                        row_h = max(4, min(row_h, 64))
                        try:
                            pad = int(globals().get("ORDERBOOK_IMAGE_PAD_ROWS", 20) or 0)
                        except Exception:
                            pad = 0
                        visible_rows = max(1, int((lbl.height() or 1) // row_h))
                        start_row = int(getattr(self, "_book_img_offset", 0) or 0)
                        end_row = int(start_row + visible_rows - 1)
                        # Edge-based gating: only auto-center when spread approaches the edges
                        try:
                            edge_pct = float(globals().get("ORDERBOOK_AUTO_CENTER_EDGE_PCT", 20.0) or 20.0)
                        except Exception:
                            edge_pct = 20.0
                        try:
                            edge_pct = max(0.0, min(float(edge_pct), 49.0))
                        except Exception:
                            edge_pct = 20.0
                        try:
                            margin = int(float(visible_rows) * float(edge_pct) / 100.0)
                        except Exception:
                            margin = 0
                        try:
                            margin = max(0, min(int(margin), max(0, (int(visible_rows) // 2) - 1)))
                        except Exception:
                            pass
                        safe_top = int(start_row + margin)
                        safe_bottom = int(end_row - margin)
                        if (not force) and (safe_top <= int(target) <= safe_bottom):
                            return
                        draw_rows = min(len(rows), visible_rows + max(0, pad))
                        max_start = max(0, len(rows) - draw_rows)
                        new_start = int(target - (visible_rows // 2))
                        new_start = max(0, min(new_start, max_start))
                        self._book_img_user_scrolled = False
                        if force or auto_instant:
                            self._book_img_offset = int(new_start)
                            try:
                                self._apply_orderbook_image_from_rows(rows, getattr(self, "_book_last_result", None))
                            except Exception:
                                pass
                        else:
                            try:
                                self._book_image_center_to(int(new_start), rows, getattr(self, "_book_last_result", None))
                            except Exception:
                                # Fallback: immediate jump
                                self._book_img_offset = int(new_start)
                                try:
                                    self._apply_orderbook_image_from_rows(rows, getattr(self, "_book_last_result", None))
                                except Exception:
                                    pass
                        try:
                            self._book_last_center_ts = now_ts if now_ts is not None else time.monotonic()
                        except Exception:
                            self._book_last_center_ts = time.time()
                        return
        except Exception:
            pass
        try:
            if target < 0:
                target = 0
            row_count = 0
            try:
                if getattr(self, "book_model", None) is not None:
                    row_count = self.book_model.rowCount()
            except Exception:
                row_count = 0
            if row_count <= 0:
                return
            if target >= row_count:
                target = row_count - 1
        except Exception:
            pass
        try:
            bar = self.book_table.verticalScrollBar()
            if bar is None:
                return
            try:
                header = self.book_table.verticalHeader()
                row_pos = header.sectionPosition(target)
                row_h = header.sectionSize(target)
            except Exception:
                row_pos = 0
                row_h = self.book_table.rowHeight(target)
            viewport_h = self.book_table.viewport().height()
            target_val = int(row_pos + (row_h / 2.0) - (viewport_h / 2.0))
            target_val = max(bar.minimum(), min(bar.maximum(), target_val))
            if abs(int(bar.value()) - int(target_val)) <= 1:
                return
            if (
                self._book_scroll_anim is not None
                and self._book_scroll_target == target_val
                and self._book_scroll_anim.state() == QAbstractAnimation.Running
            ):
                return
            if (
                self._book_scroll_anim is not None
                and self._book_scroll_anim.state() == QAbstractAnimation.Running
            ):
                self._book_scroll_target = target_val
                try:
                    self._book_scroll_anim.setEndValue(target_val)
                except Exception:
                    pass
                return
            self._book_scroll_target = target_val
            try:
                anim_ms = int(globals().get("ORDERBOOK_SCROLL_ANIM_MS", 160) or 160)
            except Exception:
                anim_ms = 160
            if force or auto_instant:
                anim_ms = 0
            if anim_ms <= 0:
                bar.setValue(target_val)
                try:
                    self._book_last_center_ts = now_ts if now_ts is not None else time.monotonic()
                except Exception:
                    self._book_last_center_ts = time.time()
                return
            try:
                if self._book_scroll_anim is not None:
                    self._book_scroll_anim.stop()
            except Exception:
                pass
            anim = QPropertyAnimation(bar, b"value", self)
            anim.setDuration(anim_ms)
            anim.setStartValue(bar.value())
            anim.setEndValue(target_val)
            anim.setEasingCurve(QEasingCurve.InOutCubic)
            anim.start()
            self._book_scroll_anim = anim
            try:
                self._book_last_center_ts = now_ts if now_ts is not None else time.monotonic()
            except Exception:
                self._book_last_center_ts = time.time()
        except Exception:
            pass

    def _on_book_section_resized(self, logicalIndex, oldSize, newSize):
        # Track user resize of VOL column so we don't override it on refresh.
        try:
            if int(logicalIndex) != int(ORDERBOOK_COL_VOL):
                return
        except Exception:
            return
        try:
            if bool(getattr(self, '_book_vol_last_set_by_code', False)):
                return
        except Exception:
            pass

        # Mark as user-resized
        try:
            if int(newSize) != int(oldSize):
                self._book_vol_user_resized = True
        except Exception:
            pass

        # Enforce a minimum VOL column width so the text never gets clipped,
        # even if the user drags the divider too far.
        table = getattr(self, 'book_table', None)
        if table is None:
            return
        try:
            fm = QFontMetrics(table.font())
            exemplars = [
                # Include both upper/lower suffixes and comma formats (Windows glyph metrics vary)
                "888.88K", "888.88k", "888.88M", "888.88m", "888.88B", "888.88b",
                "888,888", "888,888,888", "888,888,888,888"
            ]
            min_w = 0
            for s in exemplars:
                try:
                    min_w = max(min_w, int(fm.horizontalAdvance(s)))
                except Exception:
                    pass
            # + padding to avoid edge/glyph clipping (Windows/ClearType)
            min_w = int(max(60, min_w + 18))
            min_w = int(min(min_w, 260))
            self._book_vol_min_width = min_w
        except Exception:
            min_w = int(getattr(self, '_book_vol_min_width', 60) or 60)

        try:
            if int(newSize) < int(min_w):
                self._book_vol_last_set_by_code = True
                try:
                    table.setColumnWidth(ORDERBOOK_COL_VOL, int(min_w))
                finally:
                    self._book_vol_last_set_by_code = False
        except Exception:
            try:
                self._book_vol_last_set_by_code = False
            except Exception:
                pass

    def _update_book_price_column_width(self, best_bid=None, best_ask=None):
        table = getattr(self, 'book_table', None)
        if table is None:
            return
        price_val = None
        try:
            if best_ask is not None:
                price_val = float(best_ask)
            elif best_bid is not None:
                price_val = float(best_bid)
        except Exception:
            price_val = None
        if not price_val or price_val <= 0:
            return
        # Always keep 2 decimals in the ladder display.
        p_prec = 2
        try:
            pv = float(price_val)
        except Exception:
            return

        # Compute an adaptive width tight to text, but with enough padding
        # to avoid glyph clipping (especially on Windows/ClearType).
        try:
            import math
            if pv >= 1:
                digits = int(math.floor(math.log10(pv))) + 1
            else:
                digits = 1
        except Exception:
            digits = 4
        digits = max(1, min(digits, 10))
        exemplar = ('8' * digits) + ',' + ('8' * p_prec)
        try:
            fm = QFontMetrics(table.font())
            # Extra padding: prevents Windows glyph clipping and keeps full "31,39" visible.
            width = int(fm.horizontalAdvance(exemplar) + 22)
        except Exception:
            return
        width = max(52, min(width, 180))
        try:
            if int(getattr(self, '_book_price_col_width', 0) or 0) != width:
                self._book_price_col_width = width
                table.setColumnWidth(ORDERBOOK_COL_PRICE, width)
                try:
                    table.horizontalHeader().setSectionResizeMode(ORDERBOOK_COL_PRICE, QHeaderView.Fixed)
                except Exception:
                    pass
        except Exception:
            pass

    def _apply_book_volume_width(self, override=None):
        table = getattr(self, "book_table", None)
        if table is None:
            return
        # If user manually resized volume column, don't override unless explicit override is given
        try:
            if override is None and bool(getattr(self, '_book_vol_user_resized', False)):
                # Even if user resized manually, never allow the VOL column to become too narrow,
                # otherwise the volume text will be cut off.
                try:
                    min_w = int(getattr(self, '_book_vol_min_width', 60) or 60)
                except Exception:
                    min_w = 60
                try:
                    cur_w = int(table.columnWidth(ORDERBOOK_COL_VOL))
                    if cur_w < min_w:
                        self._book_vol_last_set_by_code = True
                        try:
                            table.setColumnWidth(ORDERBOOK_COL_VOL, min_w)
                        finally:
                            self._book_vol_last_set_by_code = False
                except Exception:
                    try:
                        self._book_vol_last_set_by_code = False
                    except Exception:
                        pass
                return
        except Exception:
            pass
        # Respect user's manual resize of VOL column (unless override is forced).
        try:
            if override is None and bool(getattr(self, '_book_vol_user_resized', False)):
                return
        except Exception:
            pass
        try:
            price_w = int(getattr(self, "_book_price_col_width", 0) or table.columnWidth(ORDERBOOK_COL_PRICE))
        except Exception:
            price_w = 0
        try:
            viewport_w = int(table.viewport().width() or 0)
        except Exception:
            viewport_w = 0
        try:
            target = int(override) if override is not None else int(globals().get("ORDERBOOK_VOL_COL_WIDTH", 0) or 0)
        except Exception:
            target = 0
        if target <= 0:
            if viewport_w > 0 and price_w > 0:
                target = max(60, int((viewport_w - price_w - 2)))
            else:
                return
        if viewport_w > 0 and price_w > 0:
            max_target = max(60, int((viewport_w - price_w - 2)))
            if target > max_target:
                target = max_target
        target = max(40, target)
        try:
            self._book_vol_last_set_by_code = True
            try:
                self._book_vol_last_set_by_code = True
            except Exception:
                pass
            table.setColumnWidth(ORDERBOOK_COL_VOL, target)
            try:
                self._book_vol_last_set_by_code = False
            except Exception:
                pass
            self._book_vol_last_set_by_code = False
        except Exception:
            pass

    def _force_book_row_height(self):
        """Force a fixed, uniform row height for the orderbook table.

        Important: Qt will not visibly shrink below the font metrics unless we explicitly
        fix the resize mode and apply the height after the view is shown / model resets.
        """
        table = getattr(self, 'book_table', None)
        if table is None:
            return
        try:
            h = int(globals().get('ORDERBOOK_ROW_HEIGHT', ORDERBOOK_ROW_HEIGHT) or ORDERBOOK_ROW_HEIGHT)
        except Exception:
            try:
                h = int(ORDERBOOK_ROW_HEIGHT)
            except Exception:
                h = 12
        if h < 1:
            h = 1
        try:
            vh = table.verticalHeader()
            try:
                vh.setSectionResizeMode(QHeaderView.Fixed)
            except Exception:
                pass
            try:
                vh.setMinimumSectionSize(1)
            except Exception:
                pass
            try:
                vh.setDefaultSectionSize(h)
            except Exception:
                pass
        except Exception:
            pass
        # Apply per-row height explicitly (keeps it stable across model changes).
        try:
            rows = int(self.book_model.rowCount())
        except Exception:
            rows = 0
        if rows <= 0:
            return
        try:
            for r in range(rows):
                table.setRowHeight(r, h)
        except Exception:
            pass

    @staticmethod
    def _parse_book_price(text):
        try:
            token = str(text or "").strip().split()[0]
            if not token:
                return None
            return float(token.replace(',', '.'))
        except Exception:
            return None

    def _hide_book_ruler_label(self):
        """Hide ladder ruler overlays."""
        try:
            rb = getattr(self, "_ruler_bar", None)
            if rb is not None:
                rb.hide()
        except Exception:
            pass
        try:
            if getattr(self, 'prints_ruler_label', None) is not None:
                self.prints_ruler_label.hide()
        except Exception:
            pass
        try:
            if getattr(self, 'book_ruler_label', None) is not None:
                self.book_ruler_label.hide()
        except Exception:
            pass
        try:
            if getattr(self, 'book_ruler_label_img', None) is not None:
                self.book_ruler_label_img.hide()
        except Exception:
            pass

    def _update_book_ruler_label(self, pos=None):
        """Show a horizontal ruler line on the book row, with text on the prints side."""
        table = getattr(self, 'book_table', None)
        if table is None:
            return
        try:
            viewport = table.viewport()
        except Exception:
            self._hide_book_ruler_label()
            return

        if pos is None:
            try:
                pos = viewport.mapFromGlobal(QCursor.pos())
            except Exception:
                pos = None
        if pos is None:
            self._hide_book_ruler_label()
            return

        try:
            rect = viewport.rect()
            if not rect.contains(pos):
                self._hide_book_ruler_label()
                return
        except Exception:
            self._hide_book_ruler_label()
            return

        idx = None
        row = None
        try:
            idx = table.indexAt(pos)
            if idx is not None and idx.isValid():
                row = idx.row()
        except Exception:
            idx = None
            row = None

        scroll_y = 0
        row_h_guess = None
        if row is None:
            try:
                scroll_y = int(table.verticalScrollBar().value())
            except Exception:
                scroll_y = 0
            try:
                row_h_guess = int(table.rowHeight(0) or 0)
            except Exception:
                row_h_guess = 0
            if row_h_guess <= 0:
                try:
                    row_h_guess = int(globals().get("ORDERBOOK_ROW_HEIGHT", ORDERBOOK_ROW_HEIGHT) or ORDERBOOK_ROW_HEIGHT)
                except Exception:
                    row_h_guess = int(ORDERBOOK_ROW_HEIGHT or 12)
            row_h_guess = max(1, row_h_guess)
            try:
                row = int((scroll_y + int(pos.y())) // row_h_guess)
            except Exception:
                row = None
        if row is None:
            self._hide_book_ruler_label()
            return
        try:
            if idx is None or not idx.isValid():
                idx = table.model().index(row, ORDERBOOK_COL_PRICE)
        except Exception:
            idx = None
        if idx is None or not idx.isValid():
            self._hide_book_ruler_label()
            return

        # Resolve row price
        price = None
        try:
            if getattr(self, 'book_model', None) is not None:
                price = self.book_model.price_at_row(row)
        except Exception:
            price = None
        if price is None:
            try:
                text = idx.sibling(row, ORDERBOOK_COL_PRICE).data()
            except Exception:
                text = None
            price = self._parse_book_price(text)
        if price is None:
            self._hide_book_ruler_label()
            return

        # Read meta (volume text)
        row_meta = None
        try:
            row_meta = idx.data(OrderbookModel.ROLE_META)
        except Exception:
            row_meta = None

        # Best bid/ask (optional; keep ruler visible even if missing)
        best_bid = getattr(self, '_book_best_bid', None)
        best_ask = getattr(self, '_book_best_ask', None)
        try:
            best_bid = float(best_bid)
            best_ask = float(best_ask)
        except Exception:
            best_bid = None
            best_ask = None

        if best_bid and best_ask and best_bid > 0 and best_ask > 0:
            if price >= best_ask:
                dist_pct = (price - best_ask) / best_ask * 100.0
            elif price <= best_bid:
                dist_pct = (best_bid - price) / best_bid * 100.0
            else:
                dist_pct = 0.0
        else:
            dist_pct = 0.0

        vol_txt = ''
        try:
            if row_meta and len(row_meta) > OB_ROW_VOL_TEXT:
                vol_txt = str(row_meta[OB_ROW_VOL_TEXT] or '').strip()
                if vol_txt:
                    parts = vol_txt.split()
                    if len(parts) > 1 and parts[0] in ('X', '^', 'v'):
                        vol_txt = ' '.join(parts[1:])
        except Exception:
            vol_txt = ''

        text = f"{dist_pct:.2f}%"
        if vol_txt:
            text = f"{text} {vol_txt}"

        try:
            row_rect = table.visualRect(idx)
        except Exception:
            row_rect = QRect()
        row_h = None
        if getattr(row_rect, 'isValid', lambda: False)() and row_rect.height() > 0:
            row_h = int(row_rect.height())
        if row_h is None or row_h <= 0:
            if row_h_guess is None:
                try:
                    row_h_guess = int(table.rowHeight(0) or 0)
                except Exception:
                    row_h_guess = 0
                if row_h_guess <= 0:
                    try:
                        row_h_guess = int(globals().get("ORDERBOOK_ROW_HEIGHT", ORDERBOOK_ROW_HEIGHT) or ORDERBOOK_ROW_HEIGHT)
                    except Exception:
                        row_h_guess = int(ORDERBOOK_ROW_HEIGHT or 12)
                row_h_guess = max(1, row_h_guess)
            row_h = int(row_h_guess)
        if row_h <= 0:
            self._hide_book_ruler_label()
            return

        if getattr(row_rect, 'isValid', lambda: False)() and row_rect.height() > 0:
            try:
                y_in_vp = max(0, min(rect.height() - row_h, int(row_rect.top())))
            except Exception:
                y_in_vp = int(row_rect.top())
        else:
            try:
                y_in_vp = int((row * row_h) - scroll_y)
            except Exception:
                y_in_vp = int(pos.y())

        # Book line (table)
        try:
            if getattr(self, "book_ruler_label_img", None) is not None:
                self.book_ruler_label_img.hide()
        except Exception:
            pass
        try:
            if getattr(self, "book_ruler_label", None) is not None:
                self.book_ruler_label.setText("")
                self.book_ruler_label.setGeometry(0, int(y_in_vp), int(viewport.width()), int(row_h))
                self.book_ruler_label.setVisible(True)
                self.book_ruler_label.raise_()
        except Exception:
            pass

        # Splitter handle bar
        try:
            splitter = getattr(self, "_book_tape_splitter", None)
            bar = getattr(self, "_ruler_bar", None)
            handle = splitter.handle(1) if splitter is not None else None
            if bar is not None and handle is not None:
                try:
                    pt = viewport.mapTo(splitter, QPoint(0, int(y_in_vp)))
                    y_split = int(pt.y())
                except Exception:
                    y_split = int(y_in_vp)
                y_in_handle = int(y_split - int(handle.y()))
                bar.setGeometry(0, y_in_handle, int(handle.width()), int(row_h))
                bar.setVisible(True)
                bar.raise_()
        except Exception:
            pass

        # Prints text label (small bleed into prints)
        try:
            prints = getattr(self, "prints_tape", None)
            if prints is not None and getattr(self, "prints_ruler_label", None) is not None:
                self.prints_ruler_label.setText(text)
                try:
                    fm = QFontMetrics(self.prints_ruler_label.font())
                    text_w = int(fm.horizontalAdvance(text))
                except Exception:
                    text_w = max(40, len(text) * 7)
                try:
                    bleed_px = int(globals().get("BOOK_RULER_BLEED_PX", 4) or 4)
                except Exception:
                    bleed_px = 4
                pad = 6
                w = max(10, text_w + (pad * 2) + max(0, bleed_px))
                try:
                    pw = int(prints.width())
                except Exception:
                    pw = w
                if w > pw:
                    w = pw
                x = max(0, pw - w)
                try:
                    gpt = viewport.mapToGlobal(QPoint(0, int(y_in_vp)))
                    y_in_prints = int(prints.mapFromGlobal(gpt).y())
                except Exception:
                    y_in_prints = int(y_in_vp)
                self.prints_ruler_label.setGeometry(int(x), int(y_in_prints), int(w), int(row_h))
                self.prints_ruler_label.setVisible(True)
                self.prints_ruler_label.raise_()
            elif getattr(self, "prints_ruler_label", None) is not None:
                self.prints_ruler_label.hide()
        except Exception:
            pass

    def _update_book_ruler_auto(self):
        """Periodic ruler refresh so the line stays visible while the mouse is still."""
        try:
            use_img = False
            stack = getattr(self, "book_stack", None)
            if stack is not None and getattr(self, "book_image_label", None) is not None:
                try:
                    use_img = stack.currentWidget() is self.book_image_label
                except Exception:
                    use_img = bool(getattr(self, "_book_use_image", False))
            else:
                use_img = bool(getattr(self, "_book_use_image", False))
        except Exception:
            use_img = False
        try:
            if use_img:
                lbl = getattr(self, "book_image_label", None)
                if lbl is None:
                    return
                try:
                    pos = lbl.mapFromGlobal(QCursor.pos())
                except Exception:
                    pos = None
                if pos is None or not lbl.rect().contains(pos):
                    self._hide_book_ruler_label()
                    return
                self._update_book_ruler_label_image(pos)
            else:
                table = getattr(self, "book_table", None)
                if table is None:
                    return
                try:
                    viewport = table.viewport()
                except Exception:
                    viewport = None
                if viewport is None:
                    return
                try:
                    pos = viewport.mapFromGlobal(QCursor.pos())
                except Exception:
                    pos = None
                if pos is None or not viewport.rect().contains(pos):
                    self._hide_book_ruler_label()
                    return
                self._update_book_ruler_label(pos)
        except Exception:
            pass

    def _hide_chart_cursor_ruler(self):
        try:
            if getattr(self, "chart_cursor_line", None) is not None:
                self.chart_cursor_line.setVisible(False)
            if getattr(self, "chart_cursor_label", None) is not None:
                self.chart_cursor_label.setVisible(False)
        except Exception:
            pass

    def _on_chart_mouse_moved(self, evt):
        try:
            pos = evt[0] if isinstance(evt, (tuple, list)) else evt
        except Exception:
            pos = None
        if pos is None:
            self._hide_chart_cursor_ruler()
            return
        try:
            vb = getattr(self, "view_box", None) or self.plot_item.getViewBox()
            if vb is None or not vb.sceneBoundingRect().contains(pos):
                self._hide_chart_cursor_ruler()
                return
            mouse_point = vb.mapSceneToView(pos)
            x = float(mouse_point.x())
            y = float(mouse_point.y())
        except Exception:
            self._hide_chart_cursor_ruler()
            return
        try:
            if math.isnan(y) or math.isinf(y):
                self._hide_chart_cursor_ruler()
                return
        except Exception:
            pass
        try:
            x_range, _ = vb.viewRange()
            x_end = float(x_range[1])
            if x > x_end:
                x = x_end
        except Exception:
            x_end = x
        try:
            self.chart_cursor_line.setData([x, x_end], [y, y])
            self.chart_cursor_line.setVisible(True)
        except Exception:
            pass
        try:
            sym = (self.current_symbol or "").upper()
        except Exception:
            sym = ""
        try:
            if (getattr(self, "_book_symbol", None) or "").upper() == sym:
                price_prec = int(getattr(self, "_book_price_prec", 6) or 6)
            else:
                _, price_prec = get_symbol_precision(sym)
                price_prec = int(price_prec)
            if price_prec < 0:
                price_prec = 6
        except Exception:
            price_prec = 6
        try:
            price_text = f"{float(y):.{price_prec}f}"
        except Exception:
            price_text = str(y)
        try:
            self.chart_cursor_label.setText(price_text)
            self.chart_cursor_label.setPos(x_end, y)
            self.chart_cursor_label.setVisible(True)
        except Exception:
            pass

    def _mark_book_user_scroll(self):
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            self._book_user_scroll_ts = float(now_m)
        except Exception:
            pass
        # Reuse image-scroll flags to pause auto-centering during manual scroll.
        try:
            self._book_img_user_scrolled = True
            self._book_img_user_scroll_ts = float(now_m)
        except Exception:
            pass

    def _book_scroll_recent(self):
        try:
            last_ts = float(getattr(self, "_book_user_scroll_ts", 0.0) or 0.0)
        except Exception:
            last_ts = 0.0
        if not last_ts:
            return False
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            grace = float(globals().get("ORDERBOOK_SCROLL_THROTTLE_SEC", 0.18) or 0.18)
        except Exception:
            grace = 0.18
        return (now_m - last_ts) <= grace

    def _run_book_scroll_render(self, full_render=False):
        if full_render:
            payload = getattr(self, "_orderbook_local", None)
            if isinstance(payload, dict):
                try:
                    self._queue_orderbook_render(payload.get("bids") or [], payload.get("asks") or [])
                except Exception:
                    pass
            return
        rows = getattr(self, "_book_last_rows", None)
        if rows:
            try:
                self._apply_orderbook_image_from_rows(rows, getattr(self, "_book_last_result", None))
            except Exception:
                pass

    def _schedule_book_scroll_render(self, full_render=False):
        try:
            frame_ms = float(globals().get("ORDERBOOK_SCROLL_FRAME_MS", 16) or 16)
        except Exception:
            frame_ms = 16
        if frame_ms < 0:
            frame_ms = 0
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            last_ts = float(getattr(self, "_book_scroll_last_render_ts", 0.0) or 0.0)
        except Exception:
            last_ts = 0.0
        if frame_ms and last_ts and (now_m - last_ts) < (frame_ms / 1000.0):
            try:
                self._book_scroll_render_need_full = bool(getattr(self, "_book_scroll_render_need_full", False)) or bool(full_render)
            except Exception:
                self._book_scroll_render_need_full = bool(full_render)
            if bool(getattr(self, "_book_scroll_render_scheduled", False)):
                return
            try:
                self._book_scroll_render_scheduled = True
            except Exception:
                pass
            delay_ms = int(max((frame_ms / 1000.0 - (now_m - last_ts)) * 1000.0, 1.0))
            QTimer.singleShot(delay_ms, self._flush_book_scroll_render)
            return
        try:
            self._book_scroll_last_render_ts = float(now_m)
        except Exception:
            pass
        self._run_book_scroll_render(full_render=full_render)

    def _flush_book_scroll_render(self):
        try:
            self._book_scroll_render_scheduled = False
        except Exception:
            pass
        try:
            full_render = bool(getattr(self, "_book_scroll_render_need_full", False))
        except Exception:
            full_render = False
        try:
            self._book_scroll_render_need_full = False
        except Exception:
            pass
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            self._book_scroll_last_render_ts = float(now_m)
        except Exception:
            pass
        self._run_book_scroll_render(full_render=full_render)

    # --- B1 helpers: image-mode scroll + ruler (works when book is drawn as a single pixmap) ---
    def _book_image_scroll_rows(self, delta_rows):
        try:
            rows = getattr(self, "_book_last_rows", None)
            if not rows:
                return
            self._mark_book_user_scroll()
            # Stop any running auto-center animation while the user scrolls
            try:
                t = getattr(self, "_book_img_center_timer", None)
                if t is not None and t.isActive():
                    t.stop()
            except Exception:
                pass
            lbl = getattr(self, "book_image_label", None)
            if lbl is None:
                return
            try:
                row_h = int(getattr(self, "_book_img_row_h", globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8))
            except Exception:
                row_h = int(globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8)
            row_h = max(4, min(row_h, 64))
            try:
                pad = int(globals().get("ORDERBOOK_IMAGE_PAD_ROWS", 20) or 0)
            except Exception:
                pad = 0
            visible_rows = max(1, int((lbl.height() or 1) // row_h))
            draw_rows = min(len(rows), visible_rows + max(0, pad))
            max_start = max(0, len(rows) - draw_rows)

            try:
                off = int(getattr(self, "_book_img_offset", 0) or 0)
            except Exception:
                off = 0
            off_new = int(off) + int(delta_rows)

            extra_up = 0
            extra_down = 0
            if off_new < 0:
                extra_up = -off_new
                off_new = 0
            if off_new > max_start:
                extra_down = off_new - max_start
                off_new = max_start

            # Unlimited scroll when auto-centering is OFF:
            # Instead of stopping at the ends, shift ladder start price by tick * extra rows.
            try:
                auto_center = bool(globals().get("ORDERBOOK_AUTO_CENTER", True))
            except Exception:
                auto_center = True

            # Unlimited scroll even when auto-centering is ON (user can still scroll freely)
            if (extra_up or extra_down):
                try:
                    tick_used = float(getattr(self, "_book_tick_used", 0.0) or getattr(self, "_book_tick", 0.0) or 0.0)
                except Exception:
                    tick_used = 0.0
                try:
                    start_price = float(getattr(self, "_book_start_price", None))
                except Exception:
                    start_price = None

                if tick_used and tick_used > 0 and start_price is not None:
                    try:
                        start_price = float(start_price) + float(extra_up - extra_down) * float(tick_used)
                    except Exception:
                        pass

                    # Clamp so bottom never goes below 0.0 (allows scrolling "to zero" safely).
                    try:
                        levels_total = int(getattr(self, "_book_levels_used", len(rows)) or len(rows))
                    except Exception:
                        levels_total = len(rows)
                    try:
                        min_start = float(max(levels_total - 1, 0)) * float(tick_used)
                        if start_price < min_start:
                            start_price = min_start
                    except Exception:
                        pass

                    try:
                        self._book_start_price = float(start_price)
                        self._book_tick_used = float(tick_used)
                        self._book_levels_used = int(levels_total)
                    except Exception:
                        pass

                    try:
                        self._book_img_offset = int(off_new)
                        self._book_img_user_scrolled = True
                        try:
                            self._book_img_user_scroll_ts = time.monotonic()
                        except Exception:
                            self._book_img_user_scroll_ts = time.time()
                    except Exception:
                        pass

                    # Trigger a re-render using the cached depth snapshot (fast; no wall).
                    try:
                        if getattr(self, "_orderbook_local", None):
                            self._schedule_book_scroll_render(full_render=True)
                            return
                    except Exception:
                        pass

            try:
                self._book_img_offset = int(off_new)
                self._book_img_user_scrolled = True
                try:
                    self._book_img_user_scroll_ts = time.monotonic()
                except Exception:
                    self._book_img_user_scroll_ts = time.time()
            except Exception:
                pass
            try:
                self._schedule_book_scroll_render(full_render=False)
            except Exception:
                pass
        except Exception:
            return


    def _book_image_center_to(self, target_offset, rows=None, result=None):
        """Smooth auto-centering for image-mode orderbook (when book is drawn as a pixmap)."""
        try:
            target_offset = int(target_offset)
        except Exception:
            return
        try:
            self._book_img_center_target = int(target_offset)
        except Exception:
            return
        try:
            if rows is None:
                rows = getattr(self, "_book_last_rows", None)
            self._book_img_center_rows_ref = rows
        except Exception:
            self._book_img_center_rows_ref = rows
        try:
            if result is None:
                result = getattr(self, "_book_last_result", None)
            self._book_img_center_result_ref = result
        except Exception:
            self._book_img_center_result_ref = result

        # Create/update timer
        try:
            timer = getattr(self, "_book_img_center_timer", None)
        except Exception:
            timer = None
        if timer is None:
            try:
                timer = QTimer(self)
                try:
                    tick_ms = int(globals().get("ORDERBOOK_IMAGE_CENTER_TICK_MS", 16) or 16)
                except Exception:
                    tick_ms = 16
                tick_ms = max(8, min(tick_ms, 60))
                timer.setInterval(tick_ms)
                timer.timeout.connect(self._book_image_center_step)
                self._book_img_center_timer = timer
            except Exception:
                return
        try:
            if not timer.isActive():
                timer.start()
        except Exception:
            try:
                timer.start()
            except Exception:
                pass

    def _book_image_center_step(self):
        try:
            # Stop auto-center animation while user is actively scrolling
            if bool(getattr(self, "_book_img_user_scrolled", False)):
                try:
                    timer = getattr(self, "_book_img_center_timer", None)
                    if timer is not None:
                        timer.stop()
                except Exception:
                    pass
                return
        except Exception:
            pass

        try:
            target = getattr(self, "_book_img_center_target", None)
        except Exception:
            target = None
        if target is None:
            try:
                timer = getattr(self, "_book_img_center_timer", None)
                if timer is not None:
                    timer.stop()
            except Exception:
                pass
            return

        try:
            off = int(getattr(self, "_book_img_offset", 0) or 0)
        except Exception:
            off = 0
        delta = int(target) - int(off)
        if delta == 0:
            try:
                timer = getattr(self, "_book_img_center_timer", None)
                if timer is not None:
                    timer.stop()
            except Exception:
                pass
            return

        # Smooth step (ease): move a fraction of remaining distance each tick, capped.
        try:
            max_step = int(globals().get("ORDERBOOK_IMAGE_CENTER_MAX_STEP", 10) or 10)
        except Exception:
            max_step = 10
        max_step = max(1, min(max_step, 50))
        step = max(1, min(max_step, int(abs(delta) * 0.22) + 1))
        off_new = int(off) + (step if delta > 0 else -step)
        if (delta > 0 and off_new > int(target)) or (delta < 0 and off_new < int(target)):
            off_new = int(target)

        try:
            self._book_img_offset = int(off_new)
        except Exception:
            return

        try:
            rows = getattr(self, "_book_img_center_rows_ref", None) or getattr(self, "_book_last_rows", None) or []
        except Exception:
            rows = []
        if not rows:
            return
        try:
            result = getattr(self, "_book_img_center_result_ref", None)
        except Exception:
            result = None
        try:
            self._apply_orderbook_image_from_rows(rows, result)
        except Exception:
            pass


    def _update_book_ruler_label_image(self, pos=None):
        """Ruler overlay for image-mode (book rendered as a pixmap)."""
        lbl = getattr(self, "book_image_label", None)
        if lbl is None:
            return
        rows = getattr(self, "_book_last_rows", None)
        if not rows:
            self._hide_book_ruler_label()
            return

        try:
            if pos is None:
                pos = lbl.mapFromGlobal(QCursor.pos())
            else:
                # Qt6 mouse gives QPointF in .position()
                try:
                    pos = pos.toPoint()
                except Exception:
                    pass
        except Exception:
            self._hide_book_ruler_label()
            return

        try:
            row_h = int(getattr(self, "_book_img_row_h", globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8))
        except Exception:
            row_h = int(globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8)
        row_h = max(4, min(row_h, 64))

        try:
            off = int(getattr(self, "_book_img_offset", 0) or 0)
        except Exception:
            off = 0

        y = int(pos.y())
        if y < 0:
            self._hide_book_ruler_label()
            return
        idx_in_view = int(y // row_h)
        row_idx = int(off) + int(idx_in_view)
        if row_idx < 0 or row_idx >= len(rows):
            self._hide_book_ruler_label()
            return

        row_meta = rows[row_idx]
        price_txt = ""
        vol_txt = ""
        try:
            if row_meta and len(row_meta) > OB_ROW_PRICE_TEXT:
                price_txt = str(row_meta[OB_ROW_PRICE_TEXT] or "").strip()
            if row_meta and len(row_meta) > OB_ROW_VOL_TEXT:
                vol_txt = str(row_meta[OB_ROW_VOL_TEXT] or "").strip()
                if vol_txt:
                    parts = vol_txt.split()
                    if len(parts) > 1 and parts[0] in ('X', '^', 'v'):
                        vol_txt = ' '.join(parts[1:])
        except Exception:
            pass

        # Parse price for distance %, tolerate comma decimal separator
        try:
            p_clean = price_txt.replace(" ", "").replace(",", ".")
            price = float(p_clean)
        except Exception:
            self._hide_book_ruler_label()
            return

        best_bid = getattr(self, "_book_best_bid", None)
        best_ask = getattr(self, "_book_best_ask", None)
        try:
            best_bid = float(best_bid)
            best_ask = float(best_ask)
        except Exception:
            best_bid = None
            best_ask = None

        dist_pct = 0.0
        try:
            if best_bid and best_ask and best_bid > 0 and best_ask > 0:
                if price >= best_ask:
                    dist_pct = (price - best_ask) / best_ask * 100.0
                elif price <= best_bid:
                    dist_pct = (best_bid - price) / best_bid * 100.0
                else:
                    dist_pct = 0.0
        except Exception:
            dist_pct = 0.0

        text = f"{dist_pct:.2f}%"
        if vol_txt:
            text += f"  {vol_txt}"

        y_in_lbl = int(idx_in_view * row_h)

        # Book line (image)
        try:
            if getattr(self, "book_ruler_label", None) is not None:
                self.book_ruler_label.hide()
        except Exception:
            pass
        try:
            if getattr(self, "book_ruler_label_img", None) is not None:
                self.book_ruler_label_img.setText("")
                self.book_ruler_label_img.setGeometry(0, int(y_in_lbl), int(lbl.width()), int(row_h))
                self.book_ruler_label_img.setVisible(True)
                self.book_ruler_label_img.raise_()
        except Exception:
            pass

        # Splitter handle bar
        try:
            splitter = getattr(self, "_book_tape_splitter", None)
            bar = getattr(self, "_ruler_bar", None)
            handle = splitter.handle(1) if splitter is not None else None
            if bar is not None and handle is not None:
                try:
                    pt = lbl.mapTo(splitter, QPoint(0, int(y_in_lbl)))
                    y_split = int(pt.y())
                except Exception:
                    y_split = int(y_in_lbl)
                y_in_handle = int(y_split - int(handle.y()))
                bar.setGeometry(0, y_in_handle, int(handle.width()), int(row_h))
                bar.setVisible(True)
                bar.raise_()
        except Exception:
            pass

        # Prints text label (small bleed into prints)
        try:
            prints = getattr(self, "prints_tape", None)
            if prints is not None and getattr(self, "prints_ruler_label", None) is not None:
                self.prints_ruler_label.setText(text)
                try:
                    fm = QFontMetrics(self.prints_ruler_label.font())
                    text_w = int(fm.horizontalAdvance(text))
                except Exception:
                    text_w = max(40, len(text) * 7)
                try:
                    bleed_px = int(globals().get("BOOK_RULER_BLEED_PX", 4) or 4)
                except Exception:
                    bleed_px = 4
                pad = 6
                w = max(10, text_w + (pad * 2) + max(0, bleed_px))
                try:
                    pw = int(prints.width())
                except Exception:
                    pw = w
                if w > pw:
                    w = pw
                x = max(0, pw - w)
                try:
                    gpt = lbl.mapToGlobal(QPoint(0, int(y_in_lbl)))
                    y_in_prints = int(prints.mapFromGlobal(gpt).y())
                except Exception:
                    y_in_prints = int(y_in_lbl)
                self.prints_ruler_label.setGeometry(int(x), int(y_in_prints), int(w), int(row_h))
                self.prints_ruler_label.setVisible(True)
                self.prints_ruler_label.raise_()
            elif getattr(self, "prints_ruler_label", None) is not None:
                self.prints_ruler_label.hide()
        except Exception:
            pass

    def eventFilter(self, obj, event):
        try:
            if event.type() in (QEvent.MouseButtonPress, QEvent.Wheel):
                try:
                    self._maybe_clear_input_focus_on_click(obj)
                except Exception:
                    pass
            try:
                if event.type() == QEvent.ApplicationDeactivate:
                    self._clear_held_keys()
            except Exception:
                pass
            # --- Global hotkeys (ignore when typing in inputs) ---
            try:
                if event.type() == QEvent.KeyPress:
                    # Hotkey editing capture has priority
                    try:
                        if getattr(self, "_hotkey_capture_var", None):
                            if self._capture_hotkey_from_event(event):
                                return True
                    except Exception:
                        pass
                    try:
                        if not self._hotkeys_should_ignore_focus():
                            self._update_held_keys(event, True)
                    except Exception:
                        pass
                    if self._handle_hotkeys(event):
                        return True
                elif event.type() == QEvent.KeyRelease:
                    try:
                        if not getattr(self, "_hotkey_capture_var", None):
                            self._update_held_keys(event, False)
                    except Exception:
                        pass
            except Exception:
                pass
            if hasattr(self, "book_table") and obj is self.book_table.viewport():
                if event.type() == QEvent.Wheel:
                    # Faster mouse-wheel scrolling: ~2 rows per notch (instead of ~1)
                    try:
                        self._mark_book_user_scroll()
                    except Exception:
                        pass
                    try:
                        dy = event.angleDelta().y()
                    except Exception:
                        dy = 0
                    if dy:
                        try:
                            row_h = float(self.book_table.rowHeight(0) or ORDERBOOK_ROW_HEIGHT or 14)
                        except Exception:
                            row_h = float(ORDERBOOK_ROW_HEIGHT or 14)
                        if row_h <= 0:
                            row_h = 14.0
                        steps = dy / 120.0
                        # Scroll per pixel (table is ScrollPerPixel)
                        delta_px = int(round(steps * row_h * 6.0))
                        try:
                            bar = self.book_table.verticalScrollBar()
                            bar.setValue(int(bar.value() - delta_px))
                        except Exception:
                            pass
                        return True
                if event.type() == QEvent.MouseButtonPress:
                    try:
                        if self._handle_book_mouse_click(event, source="table"):
                            return True
                    except Exception:
                        pass
                if event.type() == QEvent.MouseMove:
                    # Show continuous ruler on hover (custom overlay).
                    # Built-in hover/selection highlight is disabled, so we only draw our ruler.
                    try:
                        
                        try:
                            p = event.position().toPoint()
                        except Exception:
                            try:
                                p = event.position().toPoint()
                            except Exception:
                                p = None
                        self._update_book_ruler_label(p)

                    except Exception:
                        pass
                elif event.type() == QEvent.Leave:
                    pass
                elif event.type() == QEvent.Enter:
                    # do nothing; ruler will be shown on mouse move
                    pass
                elif event.type() == QEvent.Resize:
                    try:
                        self._apply_book_volume_width()
                    except Exception:
                        pass
            if hasattr(self, "prints_tape") and obj is getattr(self, "prints_tape", None):
                if event.type() == QEvent.MouseButtonPress:
                    try:
                        btn = event.button()
                    except Exception:
                        btn = Qt.LeftButton
                    if btn == Qt.LeftButton:
                        try:
                            pos = event.position()
                        except Exception:
                            pos = event.pos()
                        try:
                            price = self.prints_tape.hit_test_order_marker(pos)
                        except Exception:
                            price = None
                        if price is not None:
                            try:
                                self._handle_prints_order_marker_click(price)
                            except Exception:
                                pass
                            return True
            # --- B1: image-mode orderbook interactivity (wheel scroll + ruler hover) ---
            try:
                if hasattr(self, "book_image_label") and obj is getattr(self, "book_image_label", None):
                    et = event.type()
                    if et == QEvent.MouseButtonPress:
                        try:
                            if self._handle_book_mouse_click(event, source="image"):
                                return True
                        except Exception:
                            pass
                    if et == QEvent.Wheel:
                        try:
                            self._mark_book_user_scroll()
                        except Exception:
                            pass
                        try:
                            dy = event.angleDelta().y()
                        except Exception:
                            dy = 0
                        if dy:
                            try:
                                step_rows = int(globals().get("ORDERBOOK_IMAGE_SCROLL_STEP_ROWS", 6) or 6)
                            except Exception:
                                step_rows = 6
                            step_rows = max(1, min(step_rows, 50))
                            # One notch is ~120.
                            try:
                                notches = int(dy / 120)
                            except Exception:
                                notches = 1 if dy > 0 else -1
                            delta_rows = -notches * step_rows
                            try:
                                self._book_image_scroll_rows(delta_rows)
                            except Exception:
                                pass
                            return True
                    elif et == QEvent.MouseMove:
                        try:
                            self._update_book_ruler_label_image(event.position())
                        except Exception:
                            try:
                                self._update_book_ruler_label_image(event.pos())
                            except Exception:
                                pass
                    elif et == QEvent.Leave:
                        pass
                    elif et == QEvent.Resize:
                        try:
                            self._apply_orderbook_image_from_rows(getattr(self, "_book_last_rows", []) or [], getattr(self, "_book_last_result", None))
                        except Exception:
                            pass
            except Exception:
                pass

            if hasattr(self, "chart_widget") and obj is self.chart_widget.viewport():
                if event.type() == QEvent.Leave:
                    self._hide_chart_cursor_ruler()
        except Exception:
            pass
        return super().eventFilter(obj, event)


    def _maybe_clear_input_focus_on_click(self, obj):
        try:
            fw = QApplication.focusWidget()
            if fw is None:
                return False
            from PySide6.QtWidgets import QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDoubleSpinBox, QComboBox
            if not isinstance(fw, (QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDoubleSpinBox, QComboBox)):
                return False
            try:
                if obj is fw or fw.isAncestorOf(obj):
                    return False
            except Exception:
                pass
            try:
                if not self.isAncestorOf(fw):
                    return False
            except Exception:
                pass
            try:
                fw.clearFocus()
            except Exception:
                pass
            try:
                self.setFocus(Qt.OtherFocusReason)
            except Exception:
                pass
            return True
        except Exception:
            return False


    def _hotkeys_should_ignore_focus(self):
        try:
            fw = QApplication.focusWidget()
            if fw is None:
                return False
            # Ignore hotkeys while typing / adjusting inputs
            from PySide6.QtWidgets import QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDoubleSpinBox, QComboBox
            if isinstance(fw, (QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDoubleSpinBox, QComboBox)):
                return True
        except Exception:
            pass
        return False

    def _clear_held_keys(self):
        try:
            self._held_keys = set()
        except Exception:
            pass
        try:
            self._update_hotkey_indicator()
        except Exception:
            pass

    def _update_held_keys(self, event, pressed):
        try:
            if event is None:
                return
        except Exception:
            return
        try:
            hk = self._hotkey_string_from_event(event)
        except Exception:
            hk = ""
        if not hk:
            return
        try:
            _mods, base = self._parse_hotkey(hk)
        except Exception:
            base = hk
        base = _normalize_hotkey_str(base)
        if not base or base in ("SHIFT", "CTRL", "ALT"):
            return
        try:
            held = getattr(self, "_held_keys", None)
        except Exception:
            held = None
        if held is None:
            held = set()
        if pressed:
            held.add(base)
        else:
            try:
                held.discard(base)
            except Exception:
                pass
        try:
            self._held_keys = held
        except Exception:
            pass
        try:
            self._update_hotkey_indicator()
        except Exception:
            pass

    def _update_hotkey_indicator(self):
        try:
            bar = getattr(self, "prints_hotkey_indicator", None)
        except Exception:
            bar = None
        if bar is None:
            return
        try:
            hk_pending = _normalize_hotkey_str(globals().get("HOTKEY_PENDING_ORDER", "V"))
            hk_sl = _normalize_hotkey_str(globals().get("HOTKEY_STOPLOSS_CLICK", "C"))
        except Exception:
            hk_pending, hk_sl = "V", "C"
        active = False
        try:
            if hk_pending and self._hotkey_is_held(hk_pending):
                active = True
            elif hk_sl and self._hotkey_is_held(hk_sl):
                active = True
        except Exception:
            active = False
        try:
            if active:
                bar.setStyleSheet(
                    "QFrame#printsHotkeyIndicator { background-color: rgba(255, 215, 0, 200); border: none; }"
                )
            else:
                bar.setStyleSheet(
                    "QFrame#printsHotkeyIndicator { background-color: rgba(0, 0, 0, 0); border: none; }"
                )
        except Exception:
            pass

    def _hotkey_is_held(self, hotkey_str, event=None):
        hk = _normalize_hotkey_str(hotkey_str)
        if not hk:
            return False
        try:
            req_mods, base = self._parse_hotkey(hk)
        except Exception:
            req_mods, base = (set(), hk)
        base = _normalize_hotkey_str(base)
        try:
            mods = event.modifiers() if event is not None else Qt.NoModifier
        except Exception:
            mods = Qt.NoModifier
        try:
            if "CTRL" in req_mods and not bool(mods & Qt.ControlModifier):
                return False
            if "ALT" in req_mods and not bool(mods & Qt.AltModifier):
                return False
            if "SHIFT" in req_mods and not bool(mods & Qt.ShiftModifier):
                return False
        except Exception:
            pass
        if base in ("SHIFT", "CTRL", "ALT"):
            return True
        try:
            held = getattr(self, "_held_keys", None)
        except Exception:
            held = None
        if not held:
            return False
        return base in held

    def _handle_hotkeys(self, event):
        # Hotkeys are ignored when focus is in editable widgets (to avoid typing interference).
        try:
            hk_center = _normalize_hotkey_str(globals().get("HOTKEY_FORCE_CENTER", "SHIFT"))
            hk_cancel = _normalize_hotkey_str(globals().get("HOTKEY_CANCEL_ALL", "SPACE"))
            hk_close  = _normalize_hotkey_str(globals().get("HOTKEY_CLOSE_AND_CANCEL", "D"))
        except Exception:
            hk_center, hk_cancel, hk_close = "SHIFT", "SPACE", "D"

        try:
            ignore = self._hotkeys_should_ignore_focus()
        except Exception:
            ignore = False
        if ignore:
            try:
                if hk_center and self._hotkey_matches(event, hk_center):
                    try:
                        self._force_center_book()
                    except Exception:
                        pass
                    return True
            except Exception:
                pass
            return False

        # Force-center
        try:
            if hk_center and self._hotkey_matches(event, hk_center):
                try:
                    self._force_center_book()
                except Exception:
                    pass
                return True
        except Exception:
            pass

        # Cancel all orders (symbol)
        try:
            if hk_cancel and self._hotkey_matches(event, hk_cancel):
                threading.Thread(target=self._cancel_all_orders_current_symbol, daemon=True).start()
                return True
        except Exception:
            pass

        # Close position (market) + cancel orders (symbol) ; ignore if no position
        try:
            if hk_close and self._hotkey_matches(event, hk_close):
                try:
                    if not self._has_open_position_current_symbol():
                        return True  # ignore, but consume key
                except Exception:
                    return True
                threading.Thread(target=self._close_position_and_cancel_current_symbol, daemon=True).start()
                return True
        except Exception:
            pass

        return False

    def _set_hotkey_value(self, var_name: str, value: str, edit_widget=None):
        try:
            value_norm = _normalize_hotkey_str(value)
        except Exception:
            value_norm = str(value or "")
        try:
            globals()[var_name] = value_norm
        except Exception:
            pass
        try:
            if edit_widget is not None:
                edit_widget.setText(str(value_norm))
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass
        try:
            log_message(f"[HOTKEYS] {var_name} = {value_norm}")
        except Exception:
            pass

    def _start_hotkey_capture(self, var_name: str, edit_widget=None, friendly: str | None = None):
        try:
            self._hotkey_capture_var = str(var_name)
            self._hotkey_capture_edit = edit_widget
            self._hotkey_capture_friendly = friendly or var_name
            if edit_widget is not None:
                edit_widget.setText("Press key...")
        except Exception:
            pass
        try:
            log_message(f"[HOTKEYS] Capture start for {var_name} ({friendly})")
        except Exception:
            pass

    def _end_hotkey_capture(self):
        try:
            self._hotkey_capture_var = None
            self._hotkey_capture_edit = None
            self._hotkey_capture_friendly = None
        except Exception:
            pass

    def _capture_hotkey_from_event(self, event):
        """Returns True if capture consumed this event."""
        var_name = getattr(self, "_hotkey_capture_var", None)
        if not var_name:
            return False

        hk = ""
        try:
            hk = self._hotkey_string_from_event(event)
        except Exception:
            hk = ""

        # ESC cancels capture
        try:
            if hk == "ESC":
                # restore current value
                try:
                    cur = _normalize_hotkey_str(globals().get(var_name, ""))
                except Exception:
                    cur = ""
                try:
                    if getattr(self, "_hotkey_capture_edit", None) is not None:
                        self._hotkey_capture_edit.setText(str(cur))
                except Exception:
                    pass
                self._end_hotkey_capture()
                return True
        except Exception:
            pass

        if not hk:
            return True  # consume anyway

        # Apply new hotkey
        try:
            self._set_hotkey_value(var_name, hk, getattr(self, "_hotkey_capture_edit", None))
        except Exception:
            pass

        self._end_hotkey_capture()
        return True

    def _hotkey_string_from_event(self, event) -> str:
        """Convert QKeyEvent to a normalized hotkey string (layout-independent for letters)."""
        try:
            key = event.key()
        except Exception:
            key = None
        try:
            mods = event.modifiers()
        except Exception:
            mods = Qt.NoModifier

        base = ""
        # Prefer physical scan-code mapping for letters/digits on Windows
        try:
            if bool(globals().get("HOTKEYS_PHYSICAL_KEYS", True)):
                base = _us_key_from_keyevent(event) or ""
        except Exception:
            base = ""

        if not base:
            # Fallback to Qt key mapping for specials
            try:
                if key == Qt.Key_Space:
                    base = "SPACE"
                elif key == Qt.Key_Shift:
                    base = "SHIFT"
                elif key == Qt.Key_Control:
                    base = "CTRL"
                elif key == Qt.Key_Alt:
                    base = "ALT"
                elif key == Qt.Key_Escape:
                    base = "ESC"
                elif key in (Qt.Key_Return, Qt.Key_Enter):
                    base = "ENTER"
                elif key == Qt.Key_Tab:
                    base = "TAB"
                elif key == Qt.Key_Backspace:
                    base = "BACKSPACE"
                else:
                    # letter from event.text (can be non-latin in UA layout)
                    try:
                        t = (event.text() or "").strip()
                        if t:
                            base = t.upper()
                    except Exception:
                        base = ""
            except Exception:
                base = ""

        base = _normalize_hotkey_str(base)

        # Add modifiers if key is not itself a modifier
        parts = []
        try:
            if base not in ("SHIFT", "CTRL", "ALT"):
                if bool(mods & Qt.ControlModifier):
                    parts.append("CTRL")
                if bool(mods & Qt.AltModifier):
                    parts.append("ALT")
                if bool(mods & Qt.ShiftModifier):
                    parts.append("SHIFT")
        except Exception:
            pass
        if base:
            parts.append(base)
        return "+".join(parts) if parts else ""

    def _hotkey_matches(self, event, hotkey_str: str) -> bool:
        """Match incoming key event against hotkey string (supports CTRL/ALT/SHIFT modifiers)."""
        hk = _normalize_hotkey_str(hotkey_str)
        if not hk:
            return False
        try:
            req_mods, base = self._parse_hotkey(hk)
        except Exception:
            req_mods, base = (set(), hk)

        try:
            mods = event.modifiers()
        except Exception:
            mods = Qt.NoModifier

        # Required modifiers must be present
        try:
            if "CTRL" in req_mods and not bool(mods & Qt.ControlModifier):
                return False
            if "ALT" in req_mods and not bool(mods & Qt.AltModifier):
                return False
            if "SHIFT" in req_mods and not bool(mods & Qt.ShiftModifier):
                return False
        except Exception:
            pass

        # Base key match
        # Prefer physical scan code for letters/digits on Windows
        try:
            if bool(globals().get("HOTKEYS_PHYSICAL_KEYS", True)):
                sc = _native_scancode_from_keyevent(event)
                if sc is not None:
                    try:
                        want_sc = _US_USKEY_TO_SCANCODE.get(base)
                        if want_sc is not None and int(sc) == int(want_sc):
                            return True
                    except Exception:
                        pass
        except Exception:
            pass

        # Fallback to derived normalized string compare
        try:
            ev_hk = self._hotkey_string_from_event(event)
        except Exception:
            ev_hk = ""
        return _normalize_hotkey_str(ev_hk) == hk

    def _parse_hotkey(self, hk: str):
        parts = [p.strip().upper() for p in str(hk or "").split("+") if p.strip()]
        mods = set()
        base = ""
        for p in parts:
            if p in ("CTRL", "ALT", "SHIFT"):
                mods.add(p)
            else:
                base = p
        if not base and parts:
            # e.g. "SHIFT" only
            base = parts[-1]
        base = _normalize_hotkey_str(base)
        return mods, base
    def _get_click_entry_notional(self):
        try:
            spins = getattr(self, "click_entry_preset_spins", None)
        except Exception:
            spins = None
        if spins:
            try:
                idx = int(globals().get("CLICK_ENTRY_PRESET_ACTIVE", 0) or 0)
            except Exception:
                idx = 0
            idx = max(0, min(idx, len(spins) - 1))
            try:
                v = float(spins[idx].value())
                if v > 0:
                    return v
            except Exception:
                pass
        try:
            v = float(getattr(self, "click_entry_usd_spin", None).value())
            if v > 0:
                return v
        except Exception:
            pass
        try:
            v = float(globals().get("CLICK_ENTRY_NOTIONAL_USD", 50.0) or 50.0)
            return max(1.0, v)
        except Exception:
            return 50.0

    def _rate_limit_click(self):
        try:
            ms = int(globals().get("CLICK_TRADING_MIN_CLICK_INTERVAL_MS", 120) or 120)
        except Exception:
            ms = 120
        try:
            now = time.monotonic()
        except Exception:
            now = time.time()
        last = getattr(self, "_last_click_trade_ts", 0.0) or 0.0
        if last and (now - last) < (ms / 1000.0):
            return False
        self._last_click_trade_ts = now
        return True

    def _submit_order_task(self, func, *args, **kwargs):
        try:
            ex = getattr(self, "_order_io_executor", None)
        except Exception:
            ex = None
        if ex is not None:
            try:
                ex.submit(func, *args, **kwargs)
                return
            except Exception:
                pass
        try:
            threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True).start()
        except Exception:
            pass

    def _refresh_orderbook_markers(self):
        try:
            sym = (getattr(self, "current_symbol", None) or "").upper()
        except Exception:
            sym = ""
        if not sym:
            return
        try:
            if gui_bus is None:
                return
        except Exception:
            return
        ob_snapshot = None
        try:
            with orderbook_lock:
                ob_snapshot = orderbook_state.get(sym)
        except Exception:
            ob_snapshot = None
        if ob_snapshot is None:
            try:
                ob_snapshot = getattr(self, "_orderbook_local", None)
            except Exception:
                ob_snapshot = None
        if ob_snapshot is None:
            return
        try:
            self._orderbook_force_render = True
        except Exception:
            pass
        try:
            gui_bus.orderbook_signal.emit(ob_snapshot)
        except Exception:
            pass

    def _add_local_order_marker(self, sym, side, price, qty, order_type="LIMIT", reduce_only=False, force=False):
        try:
            if (not force) and (not bool(globals().get("OPEN_ORDERS_USE_LOCAL_MARKERS", False))):
                return None
        except Exception:
            pass
        try:
            sym = (sym or "").upper()
        except Exception:
            sym = ""
        if not sym:
            return None
        try:
            local_id = f"local-{int(time.time() * 1000)}-{int(threading.get_ident() or 0)}"
        except Exception:
            local_id = f"local-{time.time()}"
        try:
            px = float(price)
        except Exception:
            px = price
        try:
            qv = float(qty)
        except Exception:
            qv = qty
        entry = {
            "symbol": sym,
            "price": px,
            "side": (side or "").upper(),
            "type": (order_type or "").upper(),
            "reduce_only": bool(reduce_only),
            "close_position": False,
            "order_id": local_id,
            "algo_id": None,
            "qty": qv,
            "notional": abs(float(qv) * float(px)) if qv is not None and px is not None else None,
            "local": True,
            "ts": time.time(),
        }
        try:
            with open_orders_cache_lock:
                existing = list(open_orders_cache.get(sym) or [])
                existing.append(entry)
                open_orders_cache[sym] = existing
                globals()["open_orders_cache_ts"] = time.time()
        except Exception:
            pass
        self._refresh_orderbook_markers()
        return local_id

    def _remove_local_order_marker(self, sym, local_id=None):
        try:
            sym = (sym or "").upper()
        except Exception:
            sym = ""
        if not sym:
            return
        try:
            with open_orders_cache_lock:
                existing = list(open_orders_cache.get(sym) or [])
                if not existing:
                    return
                kept = []
                for it in existing:
                    try:
                        if not bool(it.get("local")):
                            kept.append(it)
                            continue
                    except Exception:
                        kept.append(it)
                        continue
                    try:
                        oid = str(it.get("order_id") or it.get("orderId") or it.get("id") or "")
                    except Exception:
                        oid = ""
                    if local_id and oid == str(local_id):
                        continue
                    if local_id:
                        kept.append(it)
                        continue
                    # If no local_id provided, drop all local markers.
                open_orders_cache[sym] = kept
                globals()["open_orders_cache_ts"] = time.time()
        except Exception:
            pass
        self._refresh_orderbook_markers()

    def _book_price_key(self, price):
        try:
            p = float(price)
        except Exception:
            return None
        try:
            tick = float(getattr(self, "_book_tick_used", 0.0) or 0.0)
        except Exception:
            tick = 0.0
        if tick <= 0:
            try:
                tick = float(getattr(self, "_book_tick", 0.0) or 0.0)
            except Exception:
                tick = 0.0
        if tick and tick > 0:
            try:
                return int(round(p / float(tick)))
            except Exception:
                return None
        try:
            p_prec = int(getattr(self, "_book_price_prec", 2) or 2)
        except Exception:
            p_prec = 2
        try:
            return int(round(p * (10 ** int(p_prec))))
        except Exception:
            return None

    def _find_open_orders_at_price(self, symbol, price):
        sym = (symbol or "").upper()
        if not sym:
            return []
        try:
            with open_orders_cache_lock:
                items = list(open_orders_cache.get(sym) or [])
        except Exception:
            items = []
        if not items:
            return []
        try:
            tick = float(getattr(self, "_book_tick_used", 0.0) or 0.0)
        except Exception:
            tick = 0.0
        if tick <= 0:
            try:
                tick = float(getattr(self, "_book_tick", 0.0) or 0.0)
            except Exception:
                tick = 0.0
        try:
            target_key = self._book_price_key(price)
        except Exception:
            target_key = None
        try:
            if tick > 0:
                tol = max(float(tick) * 0.5, 1e-9)
            else:
                tol = max(abs(float(price)) * 1e-6, 1e-9)
        except Exception:
            tol = 1e-6
        out = []
        for it in items:
            try:
                if bool(it.get("local")):
                    continue
            except Exception:
                pass
            try:
                oid_chk = str(it.get("order_id") or it.get("orderId") or it.get("id") or "")
            except Exception:
                oid_chk = ""
            if oid_chk.startswith("local-"):
                continue
            try:
                p0 = float(it.get("price"))
            except Exception:
                continue
            matched = False
            if target_key is not None:
                try:
                    if self._book_price_key(p0) == target_key:
                        out.append(it)
                        matched = True
                except Exception:
                    matched = False
            if matched:
                continue
            try:
                if abs(float(p0) - float(price)) <= tol:
                    out.append(it)
            except Exception:
                continue
        return out

    def _cancel_orders_at_price(self, symbol, price):
        sym = (symbol or "").upper()
        orders = self._find_open_orders_at_price(sym, price)
        if not orders:
            self._cancel_orders_at_price_rest(sym, price)
            return
        order_ids = []
        algo_ids = []
        for it in orders:
            try:
                oid = it.get("order_id") or it.get("orderId") or it.get("id")
            except Exception:
                oid = None
            try:
                aid = it.get("algo_id") or it.get("algoId")
            except Exception:
                aid = None
            if oid not in (None, ""):
                try:
                    oid_s = str(oid)
                except Exception:
                    oid_s = ""
                if oid_s and not oid_s.startswith("local-"):
                    order_ids.append(oid_s)
            if aid not in (None, ""):
                algo_ids.append(str(aid))
        if not order_ids and not algo_ids:
            self._cancel_orders_at_price_rest(sym, price)
            return
        self._cancel_orders_by_ids(sym, order_ids, algo_ids)

    def _cancel_orders_at_price_rest(self, symbol, price):
        sym = (symbol or "").upper()
        if not sym:
            return
        try:
            c = globals().get("client", None)
            if c is None:
                return
        except Exception:
            pass
        try:
            tick = float(getattr(self, "_book_tick_used", 0.0) or 0.0)
        except Exception:
            tick = 0.0
        if tick <= 0:
            try:
                tick = float(getattr(self, "_book_tick", 0.0) or 0.0)
            except Exception:
                tick = 0.0
        try:
            target_key = self._book_price_key(price)
        except Exception:
            target_key = None
        try:
            if tick > 0:
                tol = max(float(tick) * 0.5, 1e-9)
            elif auto_place:
                tol = max(abs(float(price)) * 1e-6, 1e-9)
        except Exception:
            tol = 1e-6
        def _match_price(val):
            try:
                p0 = float(val)
            except Exception:
                return False
            if target_key is not None:
                try:
                    return self._book_price_key(p0) == target_key
                except Exception:
                    pass
            try:
                return abs(float(p0) - float(price)) <= tol
            except Exception:
                return False
        items = []
        try:
            open_orders = signed_request(client.futures_get_open_orders, symbol=sym) or []
        except Exception:
            open_orders = []
        for it in open_orders or []:
            try:
                norm = _normalize_open_order_for_book(it)
            except Exception:
                norm = None
            if norm:
                items.append(norm)
        try:
            if bool(globals().get("SNAPSHOT_INCLUDE_ALGO_ORDERS", True)):
                algo_orders = get_open_conditional_orders(sym) or []
            else:
                algo_orders = []
        except Exception:
            algo_orders = []
        for it in algo_orders or []:
            try:
                norm = _normalize_open_order_for_book(it)
            except Exception:
                norm = None
            if norm:
                items.append(norm)
        order_ids = []
        algo_ids = []
        for it in items:
            try:
                if not _match_price(it.get("price")):
                    continue
            except Exception:
                continue
            try:
                oid = it.get("order_id") or it.get("orderId") or it.get("id")
            except Exception:
                oid = None
            try:
                aid = it.get("algo_id") or it.get("algoId")
            except Exception:
                aid = None
            if oid not in (None, ""):
                try:
                    oid_s = str(oid)
                except Exception:
                    oid_s = ""
                if oid_s and not oid_s.startswith("local-"):
                    order_ids.append(oid_s)
            if aid not in (None, ""):
                algo_ids.append(str(aid))
        if not order_ids and not algo_ids:
            return
        self._cancel_orders_by_ids(sym, order_ids, algo_ids)

    def _cancel_orders_by_ids(self, symbol, order_ids, algo_ids):
        sym = (symbol or "").upper()
        if not sym:
            return
        try:
            order_ids = [str(oid) for oid in (order_ids or []) if oid not in (None, "")]
        except Exception:
            order_ids = list(order_ids or [])
        try:
            order_ids = [oid for oid in order_ids if not str(oid).startswith("local-")]
        except Exception:
            pass
        try:
            algo_ids = [str(aid) for aid in (algo_ids or []) if aid not in (None, "")]
        except Exception:
            algo_ids = list(algo_ids or [])
        if not order_ids and not algo_ids:
            return
        try:
            c = globals().get("client", None)
            if c is None:
                return
        except Exception:
            pass
        def _cancel_order_direct(**kwargs):
            return client.futures_cancel_order(**kwargs)
        seen = set()
        canceled_orders = set()
        canceled_algos = set()
        for oid in order_ids or []:
            try:
                key = str(oid)
            except Exception:
                key = None
            if not key or key in seen:
                continue
            seen.add(key)
            try:
                oid_val = int(oid)
            except Exception:
                oid_val = oid
            try:
                resp = signed_request(_cancel_order_direct, symbol=sym, orderId=oid_val)
                canceled_orders.add(str(oid))
            except Exception as e:
                pass
        for aid in algo_ids or []:
            try:
                key = f"algo:{aid}"
            except Exception:
                key = None
            if not key or key in seen:
                continue
            seen.add(key)
            try:
                resp = cancel_conditional_order(sym, aid)
                canceled_algos.add(str(aid))
            except Exception as e:
                pass
        if canceled_orders or canceled_algos:
            try:
                _mark_cancel_ids_suppress(canceled_orders, canceled_algos)
            except Exception:
                pass
            try:
                with open_orders_cache_lock:
                    items = list(open_orders_cache.get(sym) or [])
                    if items:
                        kept = []
                        for it in items:
                            try:
                                oid = str(it.get("order_id") or it.get("orderId") or it.get("id") or "")
                            except Exception:
                                oid = ""
                            try:
                                aid = str(it.get("algo_id") or it.get("algoId") or "")
                            except Exception:
                                aid = ""
                            if oid and oid in canceled_orders:
                                continue
                            if aid and aid in canceled_algos:
                                continue
                            kept.append(it)
                        open_orders_cache[sym] = kept
                        globals()["open_orders_cache_ts"] = time.time()
            except Exception:
                pass
            try:
                self._refresh_orderbook_markers()
            except Exception:
                pass

    def _handle_prints_order_marker_click(self, price):
        sym = (getattr(self, "current_symbol", None) or "").upper()
        if not sym:
            return
        if isinstance(price, dict):
            try:
                order_ids = list(price.get("order_ids") or [])
            except Exception:
                order_ids = []
            try:
                algo_ids = list(price.get("algo_ids") or [])
            except Exception:
                algo_ids = []
            try:
                price_val = float(price.get("price") or 0.0)
            except Exception:
                price_val = 0.0
            try:
                order_ids = [str(oid) for oid in order_ids if oid not in (None, "")]
            except Exception:
                pass
            try:
                order_ids = [oid for oid in order_ids if not str(oid).startswith("local-")]
            except Exception:
                pass
            if order_ids or algo_ids:
                self._submit_order_task(self._cancel_orders_by_ids, sym, order_ids, algo_ids)
                return
            price = price_val
        try:
            price_f = float(price)
        except Exception:
            return
        if price_f <= 0:
            return
        try:
            orders_at = self._find_open_orders_at_price(sym, price_f)
        except Exception:
            orders_at = []
        if not orders_at:
            return
        self._submit_order_task(self._cancel_orders_at_price, sym, price_f)

    def _handle_book_mouse_click(self, event, source="table"):
        sym = (getattr(self, "current_symbol", None) or "").upper()
        if not sym:
            return False

        # Determine clicked price
        price = None
        cancel_hit = False
        try:
            if source == "table":
                vp = self.book_table.viewport()
                try:
                    p = event.position().toPoint()
                except Exception:
                    p = event.pos()
                row = self.book_table.rowAt(p.y())
                if row < 0:
                    return False
                try:
                    col = self.book_table.columnAt(p.x())
                except Exception:
                    col = None
                idx = self.book_model.index(row, ORDERBOOK_COL_PRICE)
                txt = self.book_model.data(idx, Qt.DisplayRole)
                if txt is None:
                    return False
                s = str(txt).strip().replace(",", "")
                price = float(s)
                if col == ORDERBOOK_COL_VOL:
                    cancel_hit = True
            else:
                # image
                try:
                    pos = event.position()
                except Exception:
                    pos = event.pos()
                try:
                    pos = pos.toPoint()
                except Exception:
                    pass
                rows = getattr(self, "_book_last_rows", None) or []
                if not rows:
                    return False
                try:
                    row_h = int(getattr(self, "_book_img_row_h", globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8))
                except Exception:
                    row_h = int(globals().get("ORDERBOOK_ROW_HEIGHT", 8) or 8)
                row_h = max(4, min(row_h, 64))
                try:
                    off = int(getattr(self, "_book_img_offset", 0) or 0)
                except Exception:
                    off = 0
                y = int(pos.y())
                idx_in_view = int(y // row_h)
                row_idx = int(off) + int(idx_in_view)
                if row_idx < 0 or row_idx >= len(rows):
                    return False
                row_meta = rows[row_idx]
                try:
                    if row_meta and len(row_meta) > OB_ROW_PRICE_VALUE and row_meta[OB_ROW_PRICE_VALUE] is not None:
                        price = float(row_meta[OB_ROW_PRICE_VALUE])
                    else:
                        price_txt = str(row_meta[OB_ROW_PRICE_TEXT] or "").strip().replace(",", "")
                        price = float(price_txt)
                except Exception:
                    return False
                try:
                    lbl = getattr(self, "book_image_label", None)
                    w = int(lbl.width() or 0) if lbl is not None else 0
                except Exception:
                    w = 0
                try:
                    price_w = int(globals().get("ORDERBOOK_IMAGE_PRICE_COL_W", 92) or 104)
                except Exception:
                    price_w = 104
                if w > 0 and price_w > 0 and int(pos.x()) < max(0, int(w) - int(price_w)):
                    cancel_hit = True
        except Exception:
            return False

        if price is None or price <= 0:
            return False

        # Cancel order on X click (volume column / left side).
        try:
            btn = event.button()
        except Exception:
            btn = Qt.LeftButton
        if cancel_hit and btn == Qt.LeftButton:
            try:
                should_cancel = False
                try:
                    orders_at = self._find_open_orders_at_price(sym, price)
                except Exception:
                    orders_at = []
                if orders_at:
                    should_cancel = True
                if not should_cancel:
                    try:
                        markers = (getattr(self, "_book_last_result", None) or {}).get("order_markers") or []
                    except Exception:
                        markers = []
                    if markers:
                        try:
                            target_key = self._book_price_key(price)
                        except Exception:
                            target_key = None
                        try:
                            tick = float(getattr(self, "_book_tick_used", 0.0) or 0.0)
                        except Exception:
                            tick = 0.0
                        if tick <= 0:
                            try:
                                tick = float(getattr(self, "_book_tick", 0.0) or 0.0)
                            except Exception:
                                tick = 0.0
                        try:
                            if tick > 0:
                                tol = max(float(tick) * 0.5, 1e-9)
                            else:
                                tol = max(abs(float(price)) * 1e-6, 1e-9)
                        except Exception:
                            tol = 1e-6
                        for mk in markers:
                            try:
                                mp = float(mk.get("price"))
                            except Exception:
                                continue
                            if target_key is not None:
                                try:
                                    if self._book_price_key(mp) == target_key:
                                        should_cancel = True
                                        break
                                except Exception:
                                    pass
                            try:
                                if abs(float(mp) - float(price)) <= tol:
                                    should_cancel = True
                                    break
                            except Exception:
                                continue
                if should_cancel:
                    self._submit_order_task(self._cancel_orders_at_price, sym, price)
                    return True
            except Exception:
                pass

        try:
            if not bool(globals().get("CLICK_TRADING_ENABLED", False)):
                return False
        except Exception:
            return False
        try:
            if not self._rate_limit_click():
                return True
        except Exception:
            pass

        # Determine bid/ask region by best bid/ask
        best_bid = None
        best_ask = None
        try:
            ob = getattr(self, "_orderbook_local", None) or {}
            bids = ob.get("bids") or []
            asks = ob.get("asks") or []
            if bids:
                best_bid = float(bids[0][0])
            if asks:
                best_ask = float(asks[0][0])
        except Exception:
            best_bid = None
            best_ask = None

        region = None
        try:
            if best_bid is not None and price <= best_bid:
                region = "bid"
            elif best_ask is not None and price >= best_ask:
                region = "ask"
            elif best_bid is not None and best_ask is not None:
                mid = (best_bid + best_ask) / 2.0
                region = "bid" if price < mid else "ask"
            else:
                region = "ask"
        except Exception:
            region = "ask"

        notional = self._get_click_entry_notional()
        try:
            hk_pending = _normalize_hotkey_str(globals().get("HOTKEY_PENDING_ORDER", "V"))
        except Exception:
            hk_pending = "V"
        try:
            hk_sl = _normalize_hotkey_str(globals().get("HOTKEY_STOPLOSS_CLICK", "C"))
        except Exception:
            hk_sl = "C"
        try:
            if hk_sl and btn == Qt.LeftButton and self._hotkey_is_held(hk_sl, event):
                self._submit_order_task(self._place_click_stop_loss, sym, price)
                return True
        except Exception:
            pass
        try:
            if hk_pending and self._hotkey_is_held(hk_pending, event):
                if btn == Qt.LeftButton:
                    side = "BUY"
                elif btn == Qt.RightButton:
                    side = "SELL"
                else:
                    side = None
                if side:
                    self._submit_order_task(self._place_click_pending, sym, side, price, notional)
                    return True
        except Exception:
            pass

        if btn == Qt.LeftButton:
            # BUY actions
            if region == "bid":
                # LIMIT BUY at clicked price
                try:
                    px, qty = self._prepare_click_order_qty(sym, price, notional, "LIMIT")
                except Exception:
                    px, qty = price, 0.0
                local_id = None
                if qty and qty > 0:
                    try:
                        local_id = self._add_local_order_marker(
                            sym, "BUY", px, qty, order_type="LIMIT", reduce_only=False, force=True
                        )
                    except Exception:
                        local_id = None
                self._submit_order_task(self._place_click_order, sym, "BUY", price, notional, "LIMIT", px, qty, local_id)
            else:
                # MARKET BUY
                self._submit_order_task(self._place_click_market, sym, "BUY", price, notional)
            return True
        elif btn == Qt.RightButton:
            # SELL actions
            if region == "ask":
                # LIMIT SELL at clicked price
                try:
                    px, qty = self._prepare_click_order_qty(sym, price, notional, "LIMIT")
                except Exception:
                    px, qty = price, 0.0
                local_id = None
                if qty and qty > 0:
                    try:
                        local_id = self._add_local_order_marker(
                            sym, "SELL", px, qty, order_type="LIMIT", reduce_only=False, force=True
                        )
                    except Exception:
                        local_id = None
                self._submit_order_task(self._place_click_order, sym, "SELL", price, notional, "LIMIT", px, qty, local_id)
            else:
                # MARKET SELL
                self._submit_order_task(self._place_click_market, sym, "SELL", price, notional)
            return True

        return False

    def _get_filters_for_symbol(self, sym):
        try:
            return order_placement_service._filters(sym)
        except Exception:
            return {"tick": 0.01, "step": 0.001, "qty_prec": 3, "price_prec": 2}

    def _round_step(self, value, step):
        try:
            return float(order_placement_service._round(float(value), float(step)))
        except Exception:
            try:
                if step <= 0:
                    return float(value)
                return round(round(float(value)/float(step))*float(step), 12)
            except Exception:
                return float(value)

    def _prepare_click_order_qty(self, symbol, price, notional_usd, order_type):
        sym = (symbol or "").upper()
        order_type = (order_type or "").upper()
        try:
            filters = self._get_filters_for_symbol(sym)
            tick = float(filters.get("tick") or 0.0)
            step = float(filters.get("step") or 0.0)
        except Exception:
            tick, step = 0.01, 0.001
        px = price
        if order_type == "LIMIT":
            try:
                px = float(price)
            except Exception:
                px = price
        try:
            qty = float(notional_usd) / float(px)
        except Exception:
            qty = 0.0
        qty = self._round_step(qty, step)
        return px, qty

    def _place_click_order(self, symbol, side, price, notional_usd, order_type, pre_px=None, pre_qty=None, local_id=None):
        sym = (symbol or "").upper()
        order_type = (order_type or "").upper()
        if pre_px is not None and pre_qty is not None:
            px = pre_px
            qty = pre_qty
        else:
            try:
                px, qty = self._prepare_click_order_qty(sym, price, notional_usd, order_type)
            except Exception:
                px, qty = price, 0.0
        if qty <= 0:
            if local_id:
                try:
                    self._remove_local_order_marker(sym, local_id=local_id)
                except Exception:
                    pass
            return
        if order_type == "LIMIT" and local_id is None:
            try:
                local_id = self._add_local_order_marker(
                    sym, side, px, qty, order_type="LIMIT", reduce_only=False, force=True
                )
            except Exception:
                local_id = None
        try:
            c = globals().get("client", None)
            if c is None:
                if local_id:
                    self._remove_local_order_marker(sym, local_id=local_id)
                return
        except Exception:
            pass
        try:
            if order_type == "LIMIT":
                try:
                    filters = self._get_filters_for_symbol(sym)
                    price_prec = int(filters.get("price_prec") or 8)
                except Exception:
                    price_prec = 8
                try:
                    px_str = f"{float(px):.{int(price_prec)}f}"
                except Exception:
                    px_str = str(px)
                resp = signed_request(
                    client.futures_create_order,
                    symbol=sym,
                    side=side,
                    type="LIMIT",
                    timeInForce="GTC",
                    quantity=qty,
                    price=px_str
                )
            else:
                resp = signed_request(
                    client.futures_create_order,
                    symbol=sym,
                    side=side,
                    type="MARKET",
                    quantity=qty
                )
            try:
                if isinstance(resp, dict):
                    resp_local = dict(resp)
                    resp_local["_force_add"] = True
                    need_rebuild = False
                    if order_type == "LIMIT":
                        norm = None
                        try:
                            norm = _normalize_open_order_for_book(resp_local)
                        except Exception:
                            norm = None
                        try:
                            qty_val = float(norm.get("qty") or 0.0) if isinstance(norm, dict) else 0.0
                        except Exception:
                            qty_val = 0.0
                        if (not isinstance(norm, dict)) or (
                            norm.get("price") in (None, 0, 0.0, "0", "0.0")
                            or not str(norm.get("side") or "").upper()
                            or not str(norm.get("type") or "").upper()
                            or qty_val <= 0
                        ):
                            need_rebuild = True
                    if order_type == "LIMIT" and need_rebuild:
                        try:
                            now_ms = int(time.time() * 1000)
                        except Exception:
                            now_ms = int(time.time())
                        try:
                            order_id = resp_local.get("orderId") or resp_local.get("i") or resp_local.get("id")
                        except Exception:
                            order_id = None
                        resp_local = {
                            "symbol": sym,
                            "side": side,
                            "type": "LIMIT",
                            "price": px,
                            "origQty": qty,
                            "orderId": order_id,
                            "status": "NEW",
                            "updateTime": now_ms,
                            "reduceOnly": False,
                            "_force_add": True,
                        }
                    _update_open_orders_cache_from_ws(resp_local, status="NEW")
                    if local_id:
                        try:
                            self._remove_local_order_marker(sym, local_id=local_id)
                        except Exception:
                            pass
            except Exception:
                pass
        except Exception as e:
            if local_id:
                self._remove_local_order_marker(sym, local_id=local_id)
            return

    def _place_click_limit(self, symbol, side, price, notional_usd):
        self._place_click_order(symbol, side, price, notional_usd, "LIMIT")

    def _place_click_market(self, symbol, side, ref_price, notional_usd):
        self._place_click_order(symbol, side, ref_price, notional_usd, "MARKET")

    def _place_click_pending(self, symbol, side, price, notional_usd):
        sym = (symbol or "").upper()
        side = (side or "").upper()
        if not sym or side not in ("BUY", "SELL"):
            return
        try:
            px, qty = self._prepare_click_order_qty(sym, price, notional_usd, "LIMIT")
        except Exception:
            px, qty = price, 0.0
        if qty <= 0:
            return
        try:
            c = globals().get("client", None)
            if c is None:
                return
        except Exception:
            pass
        tick = 0.0
        price_prec = 8
        try:
            filters = self._get_filters_for_symbol(sym)
            tick = float(filters.get("tick") or 0.0)
            price_prec = int(filters.get("price_prec") or 0)
        except Exception:
            tick = 0.0
            price_prec = 8
        current_price = None
        try:
            current_price, _ = price_source.get_cached_price(sym, price_kind="last")
        except Exception:
            current_price = None
        if current_price is None or float(current_price or 0.0) <= 0:
            try:
                current_price, _ = price_source.get_current_price(sym, price_kind="last")
            except Exception:
                current_price = None
        px_adj = px
        try:
            cp_val = float(current_price) if current_price is not None else None
        except Exception:
            cp_val = None
        use_stop = True
        if cp_val is not None and cp_val > 0:
            if side == "BUY" and px <= cp_val:
                use_stop = False
            elif side == "SELL" and px >= cp_val:
                use_stop = False
        if not use_stop:
            try:
                self._place_click_order(sym, side, px, notional_usd, "LIMIT", pre_px=px, pre_qty=qty)
            except Exception:
                pass
            return
        if cp_val is not None and cp_val > 0:
            if tick and tick > 0:
                if side == "BUY" and px_adj <= cp_val:
                    px_adj = _ceil_to_tick(cp_val + tick, tick, price_prec)
                elif side == "SELL" and px_adj >= cp_val:
                    px_adj = _floor_to_tick(cp_val - tick, tick, price_prec)
            else:
                buffer_abs = max(abs(cp_val) * 0.0002, 1e-6)
                if side == "BUY" and px_adj <= cp_val:
                    px_adj = cp_val + buffer_abs
                elif side == "SELL" and px_adj >= cp_val:
                    px_adj = cp_val - buffer_abs
        try:
            if px_adj and float(px_adj) > 0 and px_adj != px:
                px = px_adj
        except Exception:
            pass
        try:
            if tick and tick > 0:
                px = _round_to_tick(px, tick, price_prec) or px
            else:
                px = round(float(px), int(price_prec))
        except Exception:
            pass
        local_id = None
        try:
            use_local = bool(globals().get("OPEN_ORDERS_USE_LOCAL_MARKERS", False))
        except Exception:
            use_local = False
        if use_local:
            try:
                local_id = self._add_local_order_marker(sym, side, px, qty, order_type="STOP_MARKET", reduce_only=False)
            except Exception:
                local_id = None
        try:
            resp = create_conditional_order(
                sym,
                side,
                "STOP_MARKET",
                quantity=qty,
                stop_price=px,
                reduce_only=False,
                working_type="CONTRACT_PRICE"
            )
        except Exception as e:
            if local_id:
                try:
                    self._remove_local_order_marker(sym, local_id=local_id)
                except Exception:
                    pass
            return
        algo_id = None
        try:
            if isinstance(resp, dict):
                algo_id = resp.get("algoId") or resp.get("orderId")
        except Exception:
            algo_id = None
        if algo_id:
            try:
                _update_open_orders_cache_from_ws({
                    "symbol": sym,
                    "side": side,
                    "type": "STOP_MARKET",
                    "stopPrice": px,
                    "origQty": qty,
                    "algoId": algo_id,
                    "orderId": algo_id,
                    "reduceOnly": False,
                    "closePosition": False,
                    "_force_add": True,
                })
            except Exception:
                pass
        try:
            self._refresh_orderbook_markers()
        except Exception:
            pass

    def _place_click_stop_loss(self, symbol, stop_price):
        sym = (symbol or "").upper()
        if not sym:
            return
        try:
            c = globals().get("client", None)
            if c is None:
                return
        except Exception:
            pass
        pos = None
        try:
            pos = pos_get(sym) or {}
        except Exception:
            pos = {}
        qty = 0.0
        side_state = None
        entry_price = None
        try:
            qty = abs(float(pos.get("qty") or 0.0))
        except Exception:
            qty = 0.0
        try:
            side_state = _norm_side(pos.get("side"))
        except Exception:
            side_state = None
        try:
            entry_price = float(pos.get("entry_price") or 0.0)
        except Exception:
            entry_price = None
        if qty <= eps or not side_state:
            try:
                exch_amt, exch_entry = get_exchange_position(sym)
                qty = abs(float(exch_amt or 0.0))
                if exch_amt > 0:
                    side_state = "LONG"
                elif exch_amt < 0:
                    side_state = "SHORT"
                if exch_entry:
                    entry_price = float(exch_entry)
            except Exception:
                pass
        if qty <= eps or side_state not in ("LONG", "SHORT"):
            return
        side_api = "SELL" if side_state == "LONG" else "BUY"
        try:
            if entry_price is None or float(entry_price or 0.0) <= 0:
                if side_state == "LONG":
                    entry_price = float(stop_price or 0.0)
                else:
                    entry_price = float(stop_price or 0.0)
        except Exception:
            entry_price = float(stop_price or 0.0)
        try:
            filters = self._get_filters_for_symbol(sym)
            tick = float(filters.get("tick") or 0.0)
        except Exception:
            tick = 0.0
        px = stop_price
        if tick and tick > 0:
            try:
                px = self._round_step(stop_price, tick)
            except Exception:
                px = stop_price
        current_price = None
        try:
            current_price, _src = price_source.get_current_price(sym, prefer_ws=True, ws_wait_s=0.2, price_kind="mid")
        except Exception:
            current_price = None
        canceled_ids = []
        try:
            canceled_ids = cancel_open_closeposition_sl_orders(sym, side=side_api, position_side="BOTH")
        except Exception:
            canceled_ids = []
        try:
            if canceled_ids:
                purge_closeposition_sl_markers(sym, canceled_ids)
            else:
                purge_closeposition_sl_markers(sym)
        except Exception:
            pass
        try:
            resp = order_placement_service.place_conditional({
                "kind": "SL",
                "symbol": sym,
                "side": side_api,
                "position_side": "BOTH",
                "trigger": px,
                "quantity": qty,
                "close_position": True,
                "entry_price": entry_price,
                "current_price": current_price,
                "working_type": "CONTRACT_PRICE",
                "manual": True,
            })
        except Exception as e:
            return
        algo_id = None
        try:
            if isinstance(resp, dict):
                algo_id = resp.get("algoId") or resp.get("orderId")
        except Exception:
            algo_id = None
        if algo_id:
            try:
                _update_open_orders_cache_from_ws({
                    "symbol": sym,
                    "side": side_api,
                    "type": "STOP_MARKET",
                    "stopPrice": px,
                    "origQty": qty,
                    "algoId": algo_id,
                    "orderId": algo_id,
                    "reduceOnly": True,
                    "closePosition": True,
                    "_force_add": True,
                })
            except Exception:
                pass
        try:
            self._refresh_orderbook_markers()
        except Exception:
            pass

    def _cancel_all_orders_current_symbol(self):
        sym = (getattr(self, "current_symbol", None) or "").upper()
        if not sym:
            return
        try:
            _mark_cancel_all_suppress(sym)
        except Exception:
            pass
        try:
            order_ids = []
            algo_ids = []
            with open_orders_cache_lock:
                for it in open_orders_cache.get(sym, []) or []:
                    try:
                        oid = it.get("order_id") or it.get("orderId") or it.get("id")
                    except Exception:
                        oid = None
                    try:
                        aid = it.get("algo_id") or it.get("algoId")
                    except Exception:
                        aid = None
                    if oid not in (None, ""):
                        try:
                            oid_s = str(oid)
                        except Exception:
                            oid_s = ""
                        if oid_s and not oid_s.startswith("local-"):
                            order_ids.append(oid_s)
                    if aid not in (None, ""):
                        algo_ids.append(str(aid))
            if order_ids or algo_ids:
                _mark_cancel_ids_suppress(order_ids, algo_ids)
        except Exception:
            pass
        try:
            c = globals().get("client", None)
            if c is None:
                return
        except Exception:
            pass

        def _cancel_limits():
            try:
                signed_request(client.futures_cancel_all_open_orders, symbol=sym)
            except Exception as e:
                pass

        def _cancel_conditional():
            ids = []
            try:
                with open_orders_cache_lock:
                    for it in open_orders_cache.get(sym, []) or []:
                        try:
                            aid = it.get("algo_id") or it.get("algoId")
                        except Exception:
                            aid = None
                        if aid not in (None, ""):
                            ids.append(str(aid))
            except Exception:
                pass
            try:
                cond = get_open_conditional_orders(sym) or []
            except Exception as e:
                cond = []
            for it in cond or []:
                try:
                    oid = it.get("algoId") or it.get("orderId")
                except Exception:
                    oid = None
                if oid not in (None, ""):
                    ids.append(str(oid))
            if ids:
                try:
                    ids = list(dict.fromkeys(ids))
                except Exception:
                    pass
            if not ids:
                return
            try:
                ex = getattr(self, "_order_io_executor", None)
            except Exception:
                ex = None
            if ex is None:
                try:
                    max_workers = min(16, max(4, len(ids)))
                except Exception:
                    max_workers = 8
                try:
                    ex = ThreadPoolExecutor(max_workers=max_workers)
                except Exception:
                    ex = None
            for oid in ids:
                if ex is not None:
                    try:
                        ex.submit(cancel_conditional_order, sym, oid)
                        continue
                    except Exception:
                        pass
                try:
                    cancel_conditional_order(sym, oid)
                except Exception:
                    pass

        self._submit_order_task(_cancel_limits)
        self._submit_order_task(_cancel_conditional)
        try:
            with open_orders_cache_lock:
                open_orders_cache.pop(sym, None)
                globals()["open_orders_cache_ts"] = time.time()
        except Exception:
            pass
        try:
            self._refresh_orderbook_markers()
        except Exception:
            pass

    def _has_open_position_current_symbol(self):
        sym = (getattr(self, "current_symbol", None) or "").upper()
        if not sym:
            return False
        try:
            c = globals().get("client", None)
            if c is None:
                return False
        except Exception:
            return False
        try:
            pos_info = client.futures_position_information(symbol=sym)
            for p in pos_info:
                if p.get("symbol") == sym:
                    amt = float(p.get("positionAmt", 0) or 0)
                    if abs(amt) > 1e-12:
                        return True
        except Exception:
            return False
        return False

    def _close_position_and_cancel_current_symbol(self):
        sym = (getattr(self, "current_symbol", None) or "").upper()
        if not sym:
            return
        try:
            if not self._has_open_position_current_symbol():
                # D without position = ignore
                return
        except Exception:
            return
        # Cancel orders first, then close position
        try:
            self._cancel_all_orders_current_symbol()
        except Exception:
            pass
        # Close position by opposite market order
        try:
            pos_info = client.futures_position_information(symbol=sym)
            amt = 0.0
            for p in pos_info:
                if p.get("symbol") == sym:
                    amt = float(p.get("positionAmt", 0) or 0.0)
                    break
            if abs(amt) <= 1e-12:
                return
            side = "SELL" if amt > 0 else "BUY"
            qty = abs(amt)
            try:
                filters = self._get_filters_for_symbol(sym)
                step = float(filters.get("step") or 0.0)
            except Exception:
                step = 0.0
            if step:
                qty = self._round_step(qty, step)
            if qty <= 0:
                return
            log_message(f"🧯 Close position MARKET {side} {sym} qty={qty}")
            signed_request(
                client.futures_create_order,
                symbol=sym,
                side=side,
                type="MARKET",
                quantity=qty,
                reduceOnly=True
            )
        except Exception as e:
            try:
                log_message(f"❌ Close position failed: {e}")
            except Exception:
                pass

    def _force_center_book(self):
        try:
            # Temporarily bypass auto-center disabled
            prev = bool(globals().get("ORDERBOOK_AUTO_CENTER", True))
        except Exception:
            prev = True
        try:
            globals()['ORDERBOOK_AUTO_CENTER'] = True
        except Exception:
            pass
        try:
            try:
                self._book_force_center_pending = True
            except Exception:
                pass
            # Clear user-scroll grace and center timer
            try:
                self._book_img_user_scrolled = False
            except Exception:
                pass
            try:
                self._book_img_user_scroll_ts = 0.0
            except Exception:
                pass
            try:
                self._book_last_center_ts = 0.0
            except Exception:
                pass
            # Reset ladder anchor so force-center recenters fully even after unlimited scroll.
            try:
                self._book_start_price = None
                self._book_tick_used = 0.0
                self._book_levels_used = 0
            except Exception:
                pass
            try:
                self._book_img_offset = 0
            except Exception:
                pass
            try:
                payload = getattr(self, "_orderbook_local", None)
            except Exception:
                payload = None
            try:
                if isinstance(payload, dict) and payload and gui_bus is not None:
                    self._orderbook_force_render = True
                    gui_bus.orderbook_signal.emit(payload)
                    return
            except Exception:
                pass
            res = getattr(self, "_book_last_result", None) or {}
            ba = res.get("best_ask_row")
            bb = res.get("best_bid_row")
            if ba is None or bb is None:
                try:
                    start_price = getattr(self, "_book_start_price", None)
                except Exception:
                    start_price = None
                try:
                    tick_used = float(getattr(self, "_book_tick_used", 0.0) or getattr(self, "_book_tick", 0.0) or 0.0)
                except Exception:
                    tick_used = 0.0
                try:
                    best_bid = getattr(self, "_book_best_bid", None) or res.get("best_bid")
                except Exception:
                    best_bid = res.get("best_bid")
                try:
                    best_ask = getattr(self, "_book_best_ask", None) or res.get("best_ask")
                except Exception:
                    best_ask = res.get("best_ask")
                if best_bid is None or best_ask is None:
                    try:
                        ob = getattr(self, "_orderbook_local", None) or {}
                    except Exception:
                        ob = {}
                    try:
                        bids = ob.get("bids") or []
                    except Exception:
                        bids = []
                    try:
                        asks = ob.get("asks") or []
                    except Exception:
                        asks = []
                    if best_bid is None and bids:
                        try:
                            best_bid = float(bids[0][0])
                        except Exception:
                            best_bid = best_bid
                    if best_ask is None and asks:
                        try:
                            best_ask = float(asks[0][0])
                        except Exception:
                            best_ask = best_ask
                    if tick_used <= 0:
                        try:
                            prices = []
                            for price, _ in (bids or [])[:40]:
                                try:
                                    prices.append(float(price))
                                except Exception:
                                    continue
                            for price, _ in (asks or [])[:40]:
                                try:
                                    prices.append(float(price))
                                except Exception:
                                    continue
                            prices = sorted(set(prices))
                            min_diff = None
                            for i in range(1, len(prices)):
                                diff = prices[i] - prices[i - 1]
                                if diff > 0 and (min_diff is None or diff < min_diff):
                                    min_diff = diff
                            if min_diff and min_diff > 0:
                                tick_used = float(min_diff)
                        except Exception:
                            pass
                if start_price is None and tick_used > 0 and (best_bid is not None or best_ask is not None):
                    try:
                        levels_total = int(getattr(self, "_book_levels_used", 0) or globals().get("ORDERBOOK_LADDER_LEVELS", ORDERBOOK_LADDER_LEVELS) or ORDERBOOK_LADDER_LEVELS)
                    except Exception:
                        levels_total = int(globals().get("ORDERBOOK_LADDER_LEVELS", ORDERBOOK_LADDER_LEVELS) or ORDERBOOK_LADDER_LEVELS)
                    try:
                        center_price = best_ask if best_ask is not None else best_bid
                        if best_ask is not None and best_bid is not None:
                            center_price = (float(best_ask) + float(best_bid)) / 2.0
                        start_price = float(center_price) + (int(levels_total) // 2) * float(tick_used)
                    except Exception:
                        start_price = start_price
                if start_price is not None and tick_used > 0:
                    try:
                        if bb is None and best_bid is not None:
                            bb = int(round((float(start_price) - float(best_bid)) / float(tick_used)))
                    except Exception:
                        pass
                    try:
                        if ba is None and best_ask is not None:
                            ba = int(round((float(start_price) - float(best_ask)) / float(tick_used)))
                    except Exception:
                        pass
                if ba is None or bb is None:
                    try:
                        rows = getattr(self, "_book_last_rows", None) or []
                    except Exception:
                        rows = []
                    if rows and (best_bid is not None or best_ask is not None):
                        def _find_row_idx(target_price):
                            best_idx = None
                            best_diff = None
                            for idx, row in enumerate(rows):
                                try:
                                    if row and len(row) > OB_ROW_PRICE_VALUE and row[OB_ROW_PRICE_VALUE] is not None:
                                        price_val = float(row[OB_ROW_PRICE_VALUE])
                                    else:
                                        price_txt = str(row[OB_ROW_PRICE_TEXT] or "").strip().replace(",", "")
                                        price_val = float(price_txt)
                                except Exception:
                                    continue
                                try:
                                    diff = abs(float(price_val) - float(target_price))
                                except Exception:
                                    diff = None
                                if diff is None:
                                    continue
                                if best_diff is None or diff < best_diff:
                                    best_diff = diff
                                    best_idx = idx
                                    if diff == 0:
                                        break
                            return best_idx
                        try:
                            if bb is None and best_bid is not None:
                                bb = _find_row_idx(best_bid)
                        except Exception:
                            pass
                        try:
                            if ba is None and best_ask is not None:
                                ba = _find_row_idx(best_ask)
                        except Exception:
                            pass
                if ba is None and bb is not None:
                    ba = bb
                if bb is None and ba is not None:
                    bb = ba
            if ba is not None and bb is not None:
                try:
                    self._maybe_center_book(ba, bb, force=True)
                    try:
                        self._book_force_center_pending = False
                    except Exception:
                        pass
                except Exception:
                    pass
            else:
                try:
                    payload = getattr(self, "_orderbook_local", None)
                except Exception:
                    payload = None
                try:
                    if isinstance(payload, dict) and payload:
                        try:
                            self._orderbook_force_render = True
                        except Exception:
                            pass
                        try:
                            if gui_bus is not None:
                                gui_bus.orderbook_signal.emit(payload)
                                payload = None
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if isinstance(payload, dict) and payload:
                        self._queue_orderbook_render(
                            payload.get("bids") or [],
                            payload.get("asks") or []
                        )
                except Exception:
                    pass
                # Fallback: just call existing repaint hooks
                try:
                    self._force_book_repaint()
                except Exception:
                    pass
        finally:
            try:
                globals()['ORDERBOOK_AUTO_CENTER'] = prev
            except Exception:
                pass

    def _theme_text_color(self):
        try:
            name = str(self.current_theme or "").strip().lower()
        except Exception:
            name = ""
        if name in ("nord", "light"):
            return QColor(0, 0, 0)
        return QColor(255, 255, 255)

    def _filter_prints_by_notional(self, prints):
        """Filter prints by minimum notional in USD.

        Uses the UI spinbox value live (if available), so the filter applies immediately
        without needing a full settings/apply cycle.
        """
        min_notional = 0.0
        try:
            if hasattr(self, "prints_min_notional_spin") and self.prints_min_notional_spin is not None:
                min_notional = float(self.prints_min_notional_spin.value())
            else:
                min_notional = float(globals().get("PRINTS_MIN_NOTIONAL_USD", 0.0) or 0.0)
        except Exception:
            min_notional = 0.0
        if min_notional <= 0:
            return list(prints or [])

        filtered = []
        for item in prints or []:
            if not isinstance(item, dict):
                continue
            # Best-effort notional extraction.
            # Some payloads may include quoteQty/notional. Fallback to price*qty.
            notional = None
            try:
                for k in ("notional", "quoteQty", "quote_qty", "qQ"):
                    v = item.get(k)
                    if v is None:
                        continue
                    nv = float(v)
                    if nv > 0:
                        notional = abs(nv)
                        break
            except Exception:
                notional = None
            if notional is None:
                try:
                    price = float(item.get("price") or 0.0)
                    qty = float(item.get("qty") or 0.0)
                except Exception:
                    continue
                notional = abs(price * qty)

            if notional >= min_notional:
                filtered.append(item)
        return filtered

    def _update_position_summary(self, symbol=None, best_bid=None, best_ask=None):
        table = getattr(self, "position_summary_table", None)
        if table is None:
            return
        sym = (symbol or self.current_symbol or "").upper()
        pos = None
        try:
            with positions_lock:
                pos = open_positions.get(sym)
        except Exception:
            pos = None
        qty = 0.0
        entry_price = None
        side = None
        if isinstance(pos, dict):
            try:
                qty = float(pos.get("qty") or 0.0)
            except Exception:
                qty = 0.0
            try:
                entry_price = float(pos.get("entry_price") or 0.0)
            except Exception:
                entry_price = None
            try:
                side = _norm_side(pos.get("side"))
            except Exception:
                side = None
        if not qty or not entry_price or side not in ("LONG", "SHORT"):
            text_color = self._theme_text_color()
            empty_bg = QColor(0, 0, 0, 0)
            for col in range(3):
                item = table.item(0, col)
                if item is None:
                    item = QTableWidgetItem()
                    item.setTextAlignment(Qt.AlignCenter)
                    table.setItem(0, col, item)
                item.setText("-")
                item.setForeground(QBrush(text_color))
                item.setBackground(QBrush(empty_bg))
            return
        current_price = None
        try:
            if best_bid is not None and best_ask is not None:
                current_price = (float(best_bid) + float(best_ask)) / 2.0
            elif best_bid is not None:
                current_price = float(best_bid)
            elif best_ask is not None:
                current_price = float(best_ask)
        except Exception:
            current_price = None
        if current_price is None:
            current_price = float(entry_price)
        notional = abs(qty) * float(current_price)
        pnl_pct = 0.0
        if entry_price:
            try:
                if side == "LONG":
                    pnl_pct = (current_price - entry_price) / entry_price * 100.0
                elif side == "SHORT":
                    pnl_pct = (entry_price - current_price) / entry_price * 100.0
            except Exception:
                pnl_pct = 0.0
        try:
            p_prec = int(getattr(self, "_book_price_prec", 2) or 2)
        except Exception:
            p_prec = 2
        entry_text = f"{entry_price:.{p_prec}f}"
        notional_text = f"{notional:,.2f}"
        pnl_text = f"{pnl_pct:+.2f}%"
        text_color = self._theme_text_color()
        pnl_color = QColor(0, 220, 0) if pnl_pct >= 0 else QColor(255, 80, 80)
        empty_bg = QColor(0, 0, 0, 0)

        values = [
            (entry_text, text_color),
            (notional_text, text_color),
            (pnl_text, pnl_color),
        ]
        for col, (text, color) in enumerate(values):
            item = table.item(0, col)
            if item is None:
                item = QTableWidgetItem()
                item.setTextAlignment(Qt.AlignCenter)
                table.setItem(0, col, item)
            item.setText(text)
            item.setForeground(QBrush(color))
            item.setBackground(QBrush(empty_bg))

    
    def _on_prints_speed_auto_toggled(self, checked):
        """Toggle AUTO speed mode for prints. When enabled, lock manual speed control."""
        try:
            globals()['PRINTS_SPEED_AUTO'] = bool(checked)
        except Exception:
            pass
        try:
            if hasattr(self, 'prints_speed_spin') and self.prints_speed_spin is not None:
                self.prints_speed_spin.setEnabled(not bool(checked))
        except Exception:
            pass

    def _on_prints_min_notional_changed(self, val):
        """Apply min-notional filter instantly and purge already-rendered tiny bubbles."""
        try:
            globals()['PRINTS_MIN_NOTIONAL_USD'] = float(val)
        except Exception:
            pass
        try:
            if hasattr(self, 'prints_tape') and self.prints_tape is not None:
                self.prints_tape.prune_min_notional(float(val))
        except Exception:
            pass
        try:
            # purge pending list as well
            if hasattr(self, '_prints_pending') and self._prints_pending:
                self._prints_pending = self._filter_prints_by_notional(self._prints_pending)
        except Exception:
            pass

    def _on_prints_text_min_notional_changed(self, val):
        """Hide print text below the given USD notional (visual only)."""
        try:
            globals()['PRINTS_TEXT_MIN_NOTIONAL_USD'] = max(0.0, float(val))
        except Exception:
            pass
        try:
            if hasattr(self, 'prints_tape') and self.prints_tape is not None:
                self.prints_tape.update()
        except Exception:
            pass

    def _on_prints_agg_extra_ms_changed(self, val):
        try:
            globals()["PRINTS_AGG_WINDOW_MS_EXTRA"] = max(0, int(val))
        except Exception:
            pass
        try:
            _apply_prints_agg_extra()
        except Exception:
            pass
        try:
            save_settings_to_file()
        except Exception:
            pass

    def _on_book_paint_tick(self):
        """Drive smooth repaint of the book table and compute UI paint FPS."""
        try:
            tbl = getattr(self, 'book_table', None)
            if tbl is not None and tbl.isVisible():
                # Only repaint the viewport (faster than full widget update)
                try:
                    tbl.viewport().update()
                except Exception:
                    try:
                        tbl.update()
                    except Exception:
                        pass
        except Exception:
            pass

        # UI paint FPS (independent of depth update frequency)
        try:
            now_m = time.monotonic()
        except Exception:
            now_m = time.time()
        try:
            marks = getattr(self, '_book_ui_fps_marks', None)
            if marks is None:
                marks = deque()
                self._book_ui_fps_marks = marks
            marks.append(float(now_m))
            while marks and (float(now_m) - float(marks[0])) > 1.0:
                marks.popleft()
            self._book_ui_fps_val = float(len(marks))
        except Exception:
            pass

    def _update_prints_speedometer_ui(self):
        """Update prints flow indicator in the main UI."""
        try:
            tape = getattr(self, 'prints_tape', None)
            lbl = getattr(self, 'prints_speedometer_lbl', None)
            if tape is None or lbl is None:
                return
            cnt, win, mult = tape.get_rate_stats()
            try:
                win_f = float(win) if win else 5.0
            except Exception:
                win_f = 5.0
            if win_f <= 0:
                win_f = 5.0
            try:
                rate_ps = float(cnt) / win_f
            except Exception:
                rate_ps = 0.0
            txt = f"PRINTS: {int(cnt)}/{win_f:.0f}s ({rate_ps:.1f}/s)"
            if mult is not None:
                try:
                    txt += f" | AUTO SPEED: {float(mult):.2f}"
                except Exception:
                    pass
            lbl.setText(txt)
            # FPS indicator for the prints animation
            try:
                fps_lbl = getattr(self, 'prints_fps_lbl', None)
                if fps_lbl is not None and hasattr(tape, 'get_fps'):
                    fps = float(tape.get_fps() or 0.0)
                    fps_lbl.setText(f"{fps:.0f} FPS")
            except Exception:
                pass
            # FPS indicator for the orderbook table updates
            try:
                book_lbl = getattr(self, 'book_fps_lbl', None)
                if book_lbl is not None:
                    ui_fps = float(getattr(self, '_book_ui_fps_val', 0.0) or 0.0)
                    data_fps = float(getattr(self, '_book_data_fps_val', getattr(self, '_book_fps_val', 0.0)) or 0.0)
                    book_lbl.setText(f"{ui_fps:.0f} UI | {data_fps:.0f} DATA")
            except Exception:
                pass
        except Exception:
            return

    def _update_prints_speedometer(self):
        # Backward-compatible alias
        return self._update_prints_speedometer_ui()


    def update_prints_view(self, payload):
        if not isinstance(payload, dict):
            return
        if not bool(getattr(self, '_tape_enabled', True)):
            # drop tape workload when hidden
            return
        symbol = (payload.get('symbol') or "").upper()
        current = (self.current_symbol or "").upper()
        if symbol and current and symbol != current:
            return

        single = payload.get('print')
        if isinstance(single, dict):
            filtered = self._dedup_incoming_prints([single])
            if not filtered:
                return
            single = filtered[0]
            if single is None:
                return
            self._prints_local = [single]
            try:
                if not hasattr(self, '_prints_pending') or self._prints_pending is None:
                    self._prints_pending = []
                self._prints_pending.append(single)
            except Exception:
                pass
        else:
            prints = self._dedup_incoming_prints(payload.get('prints') or [])
            self._prints_local = prints
            try:
                if not hasattr(self, '_prints_pending') or self._prints_pending is None:
                    self._prints_pending = []
                self._prints_pending.extend(list(prints))
            except Exception:
                try:
                    self._prints_pending = list(prints)
                except Exception:
                    self._prints_pending = []
        try:
            _val = globals().get("PRINTS_MAX_PENDING", 50000)
            max_pending = int(_val) if _val is not None else 50000
        except Exception:
            max_pending = 50000
        if max_pending > 0:
            try:
                if self._prints_pending and len(self._prints_pending) > max_pending:
                    self._prints_pending = self._prints_pending[-max_pending:]
            except Exception:
                pass
        try:
            timer = getattr(self, "_prints_flush_timer", None)
            if timer is None:
                return
            if not timer.isActive():
                try:
                    v = globals().get("PRINTS_UI_FRAME_MS", 8)
                    frame_ms = int(v) if v is not None else 8
                except Exception:
                    frame_ms = 8
                # Allow higher update cadence for the prints tape (FPS).
                if frame_ms < 0:
                    frame_ms = 0
                timer.start(frame_ms)
        except Exception:
            pass

    
    def _flush_prints_pending(self):
        """Flush pending prints to the tape.

        If PRINTS_AGG_ENABLED is True, prints are aggregated inside PRINTS_AGG_WINDOW_MS
        into one bubble per direction (BUY/SELL) per time-slice.
        """
        if not bool(getattr(self, '_tape_enabled', True)):
            try:
                self._prints_pending = []
            except Exception:
                pass
            return

        # Collect pending prints emitted from WS/REST threads.
        try:
            pending = list(getattr(self, '_prints_pending', []) or [])
            self._prints_pending = []
        except Exception:
            pending = []

        if not pending:
            return


        # --- Prints aggregation (same-direction time window) ---
        try:
            agg_enabled = bool(globals().get('PRINTS_AGG_ENABLED', True))
        except Exception:
            agg_enabled = True

        try:
            agg_window_ms = int(globals().get('PRINTS_AGG_WINDOW_MS', 250) or 250)
        except Exception:
            agg_window_ms = 250
        if agg_window_ms <= 0:
            agg_window_ms = 250

        def _ts_ms_local(it: dict) -> int:
            # Best-effort timestamp (ms). Accepts seconds or ms since epoch.
            ts = None
            try:
                for k in ('ts', 'T', 'E', 'time', 'timestamp', 'transactTime'):
                    if k in it and it.get(k) is not None:
                        ts = it.get(k)
                        break
            except Exception:
                ts = None
            try:
                ts_f = float(ts)
            except Exception:
                ts_f = 0.0
            if ts_f <= 0:
                try:
                    return int(time.time() * 1000.0)
                except Exception:
                    return 0
            # ms epoch
            if ts_f > 1e11:
                # microseconds
                if ts_f > 1e15:
                    return int(ts_f / 1000.0)
                return int(ts_f)
            # seconds
            return int(ts_f * 1000.0)

        if agg_enabled and pending:
            bins = {}
            for it in pending:
                if not isinstance(it, dict):
                    continue
                try:
                    qty = float(it.get('qty') or 0.0)
                except Exception:
                    qty = 0.0
                if qty <= 0:
                    continue
                try:
                    price = float(it.get('price') or 0.0)
                except Exception:
                    price = 0.0
                if price <= 0:
                    continue
                try:
                    side = str(it.get('side') or '').upper()
                except Exception:
                    side = ''
                if side not in ('BUY', 'SELL'):
                    # fallback: keep unknown side separated to not mix
                    side = side or 'UNK'

                ts_ms = _ts_ms_local(it)
                try:
                    slice_id = int(ts_ms // int(agg_window_ms))
                except Exception:
                    slice_id = 0
                key = (side, slice_id)

                acc = bins.get(key)
                if acc is None:
                    acc = {
                        'side': side,
                        'qty': 0.0,
                        'notional': 0.0,
                        'count': 0,
                        'ts_ms': ts_ms,
                        'sample': it,
                        'last_price': price,
                    }
                    bins[key] = acc

                acc['qty'] += float(qty)
                acc['notional'] += float(qty) * float(price)
                acc['count'] += 1
                acc['last_price'] = float(price)
                if ts_ms > int(acc.get('ts_ms') or 0):
                    acc['ts_ms'] = ts_ms
                    acc['sample'] = it

            aggregated = []
            for _, acc in bins.items():
                try:
                    qty_sum = float(acc.get('qty') or 0.0)
                except Exception:
                    qty_sum = 0.0
                if qty_sum <= 0:
                    continue
                try:
                    notional_sum = float(acc.get('notional') or 0.0)
                except Exception:
                    notional_sum = 0.0
                try:
                    price_use = (notional_sum / qty_sum) if (notional_sum > 0 and qty_sum > 0) else float(acc.get('last_price') or 0.0)
                except Exception:
                    price_use = float(acc.get('last_price') or 0.0)

                try:
                    base = dict(acc.get('sample') or {})
                except Exception:
                    base = {}
                # Remove trade-id keys so the tape deduper doesn't drop aggregated prints
                for k in ('id', 'trade_id', 'tradeId', 'a', 't'):
                    try:
                        base.pop(k, None)
                    except Exception:
                        pass

                base['side'] = str(acc.get('side') or '')
                base['qty'] = float(qty_sum)
                base['price'] = float(price_use)
                base['agg_count'] = int(acc.get('count') or 1)
                # Keep ts in seconds for any UI timestamp formatting
                try:
                    base['ts'] = float(int(acc.get('ts_ms') or 0)) / 1000.0
                except Exception:
                    pass
                aggregated.append(base)

            # Preserve chronological order (important for visuals)
            try:
                aggregated.sort(key=lambda x: float(x.get('ts') or 0.0))
            except Exception:
                pass

            pending = aggregated

        # Filter by notional AFTER aggregation (small prints can combine into a visible one)
        try:
            pending = self._filter_prints_by_notional(pending)
        except Exception:
            pass

        if not pending:
            return

        # Push to tape
        try:
            max_new = int(globals().get('PRINTS_MAX_NEW_PER_FLUSH', 5000) or 5000)
        except Exception:
            max_new = 5000
        try:
            if hasattr(self, 'prints_tape') and self.prints_tape is not None:
                self.prints_tape.queue_prints(pending, max_new=max_new)
        except Exception:
            pass

    def _render_prints(self, prints):

        # Efficient table update (reuses items, avoids reallocations)
        table = getattr(self, 'prints_table', None)
        if table is None:
            return
        try:
            bid_color = QColor(46, 204, 113)
            ask_color = QColor(231, 76, 60)
        except Exception:
            bid_color = QColor(0, 200, 0)
            ask_color = QColor(200, 0, 0)

        p_prec = getattr(self, '_book_price_prec', 2)
        q_prec = getattr(self, '_book_qty_prec', 3)

        # Decide whether to display USD notional in the qty column
        show_usd = False
        try:
            show_usd = bool(globals().get('ORDERBOOK_VOL_IN_USD', False))
        except Exception:
            show_usd = False
        try:
            mn = float(globals().get('PRINTS_MIN_NOTIONAL_USD', 0.0) or 0.0)
        except Exception:
            mn = 0.0
        if mn > 0:
            show_usd = True

        prints = list(prints or [])
        try:
            table.setUpdatesEnabled(False)
        except Exception:
            pass

        try:
            if table.rowCount() != len(prints):
                table.setRowCount(len(prints))
        except Exception:
            try:
                table.setUpdatesEnabled(True)
            except Exception:
                pass
            return

        for row_idx, item in enumerate(prints):
            if not isinstance(item, dict):
                continue
            try:
                ts_val = float(item.get('ts') or 0.0)
                ts_txt = datetime.fromtimestamp(ts_val).strftime('%H:%M:%S')
            except Exception:
                ts_txt = ''

            try:
                price_f = float(item.get('price') or 0.0)
                price_txt = f'{price_f:.{p_prec}f}'
            except Exception:
                price_f = 0.0
                price_txt = str(item.get('price') or '')

            try:
                qty_f = float(item.get('qty') or 0.0)
            except Exception:
                qty_f = 0.0

            if show_usd:
                try:
                    qty_disp = abs(price_f * qty_f)
                except Exception:
                    qty_disp = 0.0
            else:
                qty_disp = qty_f

            try:
                qty_txt = f'{float(qty_disp):.{q_prec}f}'
                if show_usd:
                    qty_txt = '$' + qty_txt
            except Exception:
                qty_txt = str(qty_disp)

            side = str(item.get('side') or '').upper()
            color = bid_color if side == 'BUY' else ask_color

            # Reuse existing items (QTableWidgetItem allocations are expensive)
            try:
                ts_item = table.item(row_idx, 0)
                if ts_item is None:
                    ts_item = QTableWidgetItem()
                    ts_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                    table.setItem(row_idx, 0, ts_item)
            except Exception:
                ts_item = QTableWidgetItem()
                ts_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                table.setItem(row_idx, 0, ts_item)

            try:
                price_item = table.item(row_idx, 1)
                if price_item is None:
                    price_item = QTableWidgetItem()
                    price_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                    table.setItem(row_idx, 1, price_item)
            except Exception:
                price_item = QTableWidgetItem()
                price_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                table.setItem(row_idx, 1, price_item)

            try:
                qty_item = table.item(row_idx, 2)
                if qty_item is None:
                    qty_item = QTableWidgetItem()
                    qty_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                    table.setItem(row_idx, 2, qty_item)
            except Exception:
                qty_item = QTableWidgetItem()
                qty_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                table.setItem(row_idx, 2, qty_item)

            try:
                ts_item.setText(ts_txt)
                price_item.setText(price_txt)
                qty_item.setText(qty_txt)
            except Exception:
                pass

            try:
                price_item.setForeground(color)
                qty_item.setForeground(color)
            except Exception:
                pass

        try:
            table.setUpdatesEnabled(True)
        except Exception:
            pass

    def on_view_tab_changed(self, index):
        try:
            self.left_stack.setCurrentIndex(int(index))
        except Exception:
            pass
        try:
            if int(index) == 1:
                self.refresh_trade_journal_table()
        except Exception:
            pass

    def update_chart_indicator(self, symbol, level):
        self.current_symbol = symbol
        self.current_level = level
        self.symbol_input.setText(symbol)
        self.refresh_chart(force=True)
        try:
            self._sync_book_symbol(symbol)
        except Exception:
            pass
        log_message(f"👻 Chart highlight -> {symbol} @{level:.4f}")


    def _chart_get_embed_state(self):
        parent = getattr(self, '_chart_embed_parent', None) or self.chart_widget.parentWidget()
        layout = getattr(self, '_chart_embed_layout', None)
        if layout is None and parent is not None:
            try:
                layout = parent.layout()
            except Exception:
                layout = None
        try:
            index = int(getattr(self, '_chart_embed_index', -1))
        except Exception:
            index = -1
        try:
            if layout is not None:
                idx2 = layout.indexOf(self.chart_widget)
                if idx2 >= 0:
                    index = idx2
        except Exception:
            pass
        return {'parent': parent, 'layout': layout, 'index': index}

    def _chart_fullscreen_begin_temp(self):
        # If user already opened fullscreen manually, do not detach.
        try:
            dlg0 = getattr(self, '_chart_fullscreen_dialog', None)
            if dlg0 is not None:
                try:
                    dlg0.showMaximized()
                    QApplication.processEvents()
                except Exception:
                    pass
                return None
        except Exception:
            return None
        try:
            st = self._chart_get_embed_state()
            dlg = QDialog(self)
            dlg.setWindowTitle('Chart')
            dlg.setWindowFlags(Qt.Window)
            lay = QVBoxLayout(dlg)
            lay.setContentsMargins(0, 0, 0, 0)
            self.chart_widget.setParent(dlg)
            lay.addWidget(self.chart_widget)
            dlg.showMaximized()
            try:
                dlg.raise_()
                dlg.activateWindow()
            except Exception:
                pass
            QApplication.processEvents()
            st['dialog'] = dlg
            return st
        except Exception:
            return None

    def _chart_fullscreen_end_temp(self, st):
        if not st:
            return
        try:
            dlg = st.get('dialog')
            parent = st.get('parent')
            layout = st.get('layout')
            index = st.get('index', -1)
            self.chart_widget.setParent(parent)
            if layout is not None:
                try:
                    if index is not None and int(index) >= 0:
                        layout.insertWidget(int(index), self.chart_widget)
                    else:
                        layout.addWidget(self.chart_widget)
                except Exception:
                    try:
                        layout.addWidget(self.chart_widget)
                    except Exception:
                        pass
            self.chart_widget.show()
            try:
                if dlg is not None:
                    dlg.hide()
                    dlg.deleteLater()
            except Exception:
                pass
            QApplication.processEvents()
        except Exception:
            pass

    def open_chart_fullscreen(self):
        try:
            dlg0 = getattr(self, '_chart_fullscreen_dialog', None)
            if dlg0 is not None:
                try:
                    dlg0.showMaximized()
                except Exception:
                    pass
                return
            st = self._chart_get_embed_state()
            dlg = QDialog(self)
            dlg.setWindowTitle('Chart (fullscreen)')
            dlg.setWindowFlags(Qt.Window)
            lay = QVBoxLayout(dlg)
            lay.setContentsMargins(0, 0, 0, 0)
            self.chart_widget.setParent(dlg)
            lay.addWidget(self.chart_widget)
            dlg.showMaximized()
            try:
                dlg.raise_()
                dlg.activateWindow()
            except Exception:
                pass
            self._chart_fullscreen_state = st
            self._chart_fullscreen_dialog = dlg
            try:
                if hasattr(self, 'chart_fullscreen_btn'):
                    self.chart_fullscreen_btn.setText('BACK')
            except Exception:
                pass
            try:
                dlg.finished.connect(lambda *_: self.close_chart_fullscreen())
            except Exception:
                pass
        except Exception:
            pass

    def close_chart_fullscreen(self):
        try:
            if getattr(self, '_chart_fullscreen_restoring', False):
                return
            dlg = getattr(self, '_chart_fullscreen_dialog', None)
            st = getattr(self, '_chart_fullscreen_state', None)
            if dlg is None or st is None:
                return
            self._chart_fullscreen_restoring = True
            parent = st.get('parent')
            layout = st.get('layout')
            index = st.get('index', -1)
            self.chart_widget.setParent(parent)
            if layout is not None:
                try:
                    if index is not None and int(index) >= 0:
                        layout.insertWidget(int(index), self.chart_widget)
                    else:
                        layout.addWidget(self.chart_widget)
                except Exception:
                    try:
                        layout.addWidget(self.chart_widget)
                    except Exception:
                        pass
            self.chart_widget.show()
            try:
                dlg.hide()
                dlg.deleteLater()
            except Exception:
                pass
            self._chart_fullscreen_dialog = None
            self._chart_fullscreen_state = None
            try:
                if hasattr(self, 'chart_fullscreen_btn'):
                    self.chart_fullscreen_btn.setText('FS')
            except Exception:
                pass
        except Exception:
            pass
        finally:
            try:
                self._chart_fullscreen_restoring = False
            except Exception:
                pass

    def toggle_chart_fullscreen(self):
        try:
            if getattr(self, '_chart_fullscreen_dialog', None) is None:
                self.open_chart_fullscreen()
            else:
                self.close_chart_fullscreen()
        except Exception:
            pass
    def capture_chart_screenshot_request(self, req):
        if not isinstance(req, dict):
            return
        path = None
        fs_state = None

        # Serialize screenshot captures to avoid UI stalls during SL/TP close bursts
        try:
            if not hasattr(self, "_screenshot_capture_in_progress"):
                self._screenshot_capture_in_progress = False
                from collections import deque
                self._screenshot_pending_reqs = deque()
        except Exception:
            pass

        try:
            if getattr(self, "_screenshot_capture_in_progress", False):
                pr = str(req.get("priority") or "normal").lower()
                if bool(globals().get("SCREENSHOT_DROP_IF_BUSY", True)) and pr != "high":
                    # Drop low-priority screenshot immediately
                    try:
                        req["path"] = None
                    except Exception:
                        pass
                    try:
                        ev = req.get("event")
                        if ev:
                            ev.set()
                    except Exception:
                        pass
                    return
                # Queue high-priority (or if drop disabled)
                try:
                    maxq = int(globals().get("SCREENSHOT_QUEUE_MAX", 1) or 1)
                except Exception:
                    maxq = 1
                try:
                    q = getattr(self, "_screenshot_pending_reqs", None)
                    if q is None:
                        from collections import deque
                        q = deque()
                        self._screenshot_pending_reqs = q
                    while maxq > 0 and len(q) >= maxq:
                        old = q.popleft()
                        try:
                            old["path"] = None
                        except Exception:
                            pass
                        try:
                            oe = old.get("event")
                            if oe:
                                oe.set()
                        except Exception:
                            pass
                    q.append(req)
                except Exception:
                    try:
                        req["path"] = None
                    except Exception:
                        pass
                    try:
                        ev = req.get("event")
                        if ev:
                            ev.set()
                    except Exception:
                        pass
                return
            self._screenshot_capture_in_progress = True
        except Exception:
            pass

        try:
            symbol = req.get("symbol") or self.current_symbol
            level = req.get("level")
            clear_level = bool(req.get("clear_level"))
            if symbol:
                self.current_symbol = symbol
                try:
                    self.symbol_input.setText(symbol)
                except Exception:
                    pass
                try:
                    self._sync_book_symbol(symbol)
                except Exception:
                    pass
            if clear_level:
                self.current_level = None
            elif level is not None:
                try:
                    self.current_level = float(level)
                except Exception:
                    self.current_level = level

            # Better screenshot quality: temporarily show chart fullscreen
            try:
                if globals().get("GUI_USE_OPENGL", False):
                    self.chart_widget.useOpenGL(False)
            except Exception:
                pass
            # Better screenshot quality: temporarily show chart fullscreen
            # In fast-mode we avoid fullscreen + forced refresh (it can freeze UI on SL/TP bursts)
            try:
                fast_mode = bool(req.get("fast", globals().get("SCREENSHOT_FAST_MODE", True)))
            except Exception:
                fast_mode = True
            try:
                force_refresh = req.get("force_refresh")
            except Exception:
                force_refresh = None
            if force_refresh is None:
                force_refresh = (not fast_mode)

            try:
                if globals().get("GUI_USE_OPENGL", False):
                    self.chart_widget.useOpenGL(False)
            except Exception:
                pass
            try:
                if (not fast_mode) and bool(req.get("fullscreen", True)):
                    fs_state = self._chart_fullscreen_begin_temp()
            except Exception:
                fs_state = None

            try:
                self.refresh_chart(force=bool(force_refresh))
            except Exception:
                pass
            try:
                # Keep this lightweight to avoid stalling the whole GUI
                self.chart_widget.repaint()
                try:
                    self.chart_widget.scene().update()
                except Exception:
                    pass
                QApplication.processEvents()
            except Exception:
                pass
            out_dir = req.get("out_dir") or globals().get("TELEGRAM_LEVEL_SCREENSHOT_DIR") or BASE_DIR
            if out_dir:
                os.makedirs(out_dir, exist_ok=True)
            safe_symbol = re.sub(r"[^A-Za-z0-9_-]+", "", str(symbol or ""))
            if not safe_symbol:
                safe_symbol = "chart"
            stamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"{safe_symbol}_{stamp}.png"
            path = os.path.join(out_dir, filename)
            saved = False

            try:
                pixmap = self.chart_widget.grab()
                if pixmap and not pixmap.isNull():
                    saved = pixmap.save(path, "PNG")
            except Exception:
                saved = False

            if not saved:
                try:
                    viewport = self.chart_widget.viewport()
                    if hasattr(viewport, "grabFramebuffer"):
                        img = viewport.grabFramebuffer()
                        if img and not img.isNull():
                            saved = img.save(path, "PNG")
                except Exception:
                    saved = False

            if not saved:
                try:
                    from pyqtgraph.exporters import ImageExporter
                    exporter = ImageExporter(getattr(self, "plot_item", self.chart_widget.getPlotItem()))
                    try:
                        sw = int(QApplication.primaryScreen().size().width() or 0) if QApplication.primaryScreen() else 0
                    except Exception:
                        sw = 0
                    try:
                        exporter.parameters()["width"] = max(100, int(self.chart_widget.width() or 0), sw)
                    except Exception:
                        pass
                    exporter.export(path)
                    saved = os.path.exists(path)
                except Exception:
                    saved = False

            if not saved:
                path = None

            if path and req.get("clear_markers"):
                try:
                    chart_trade_clear(symbol)
                except Exception:
                    pass
                try:
                    self.refresh_chart(force=True)
                except Exception:
                    pass

        except Exception as e:
            try:
                log_message(f"WARN screenshot failed: {e}")
            except Exception:
                pass
            path = None
        finally:
            try:
                if fs_state:
                    self._chart_fullscreen_end_temp(fs_state)
            except Exception:
                pass

        try:
            req["path"] = path
            ev = req.get("event")
            if isinstance(ev, threading.Event):
                ev.set()
        except Exception:
            pass
        try:
            self._screenshot_capture_in_progress = False
        except Exception:
            pass
        try:
            q = getattr(self, "_screenshot_pending_reqs", None)
            if q:
                next_req = q.popleft()
                QTimer.singleShot(0, lambda r=next_req: self.capture_chart_screenshot_request(r))
        except Exception:
            pass


    def closeEvent(self, event):
        try:
            if hasattr(self, "_orderbook_render_stop"):
                self._orderbook_render_stop.set()
            if hasattr(self, "_orderbook_render_event"):
                self._orderbook_render_event.set()
        except Exception:
            pass
        try:
            self._stop_orderbook_render_process()
        except Exception:
            pass
        try:
            bal_override = None
            try:
                if last_recorded_equity_balance is not None:
                    bal_override = float(last_recorded_equity_balance)
            except Exception:
                bal_override = None
            if bal_override is None:
                try:
                    if initial_balance is not None:
                        bal_override = float(initial_balance)
                except Exception:
                    bal_override = None
            if bal_override is None:
                bal_override = 0.0
            save_pnl_snapshot_to_file(balance_override=bal_override)
        except Exception:
            pass
        try:
            try:
                shutdown_complete_event.clear()
            except Exception:
                pass
            try:
                threading.Thread(target=graceful_shutdown, kwargs={"blocking": True}, daemon=True).start()
            except Exception:
                graceful_shutdown(blocking=True)
            try:
                def _force_exit():
                    try:
                        if not shutdown_complete_event.is_set():
                            hard_exit(0)
                    except Exception:
                        try:
                            hard_exit(0)
                        except Exception:
                            pass
                t = threading.Timer(float(SHUTDOWN_FORCE_EXIT_SEC or 0), _force_exit)
                t.daemon = True
                t.start()
            except Exception:
                pass
        except Exception:
            pass
        try:
            super().closeEvent(event)
        except Exception:
            pass

    def apply_chart_settings(self):
        global CHART_CANDLE_LIMIT, CANDLE_WS_INTERVAL
        try:
            prev_limit = int(globals().get("CHART_CANDLE_LIMIT", CHART_CANDLE_LIMIT) or CHART_CANDLE_LIMIT)
        except Exception:
            prev_limit = int(CHART_CANDLE_LIMIT or 300)
        try:
            prev_interval = str(globals().get("CANDLE_WS_INTERVAL", "5m") or "5m")
        except Exception:
            prev_interval = "5m"
        try:
            new_limit = 450  # fixed candle count
        except Exception:
            new_limit = prev_limit
        try:
            new_interval = self.chart_interval_combo.currentText().strip()
        except Exception:
            new_interval = prev_interval

        changed = False
        if new_limit and new_limit != prev_limit:
            CHART_CANDLE_LIMIT = new_limit
            changed = True
            try:
                trim_all_kline_histories()
            except Exception:
                pass

        if new_interval:
            CANDLE_WS_INTERVAL = new_interval
            if new_interval != prev_interval:
                changed = True
                try:
                    stop_kline_subscription(self.current_symbol)
                except Exception:
                    pass
                try:
                    _reset_kline_cache(self.current_symbol)
                except Exception:
                    pass
                # One-time REST reconcile after timeframe change (seed chart immediately)
                try:
                    _schedule_kline_rest_reconcile(
                        self.current_symbol,
                        interval=new_interval,
                        limit=(new_limit or CHART_CANDLE_LIMIT),
                        force=True,
                    )
                except Exception:
                    pass

        if changed:
            try:
                save_settings_to_file()
            except Exception:
                pass
            self.refresh_chart(force=True)

    def apply_quick_settings(self):
        global ORDERBOOK_TICK_MULT, ORDERBOOK_VOL_IN_USD, ORDERBOOK_VOL_COMPACT, ORDERBOOK_VOL_COL_WIDTH, MIN_POS_NOTIONAL_MULT, MAX_POS_NOTIONAL_MULT, STOP_LOSS_MIN_PCT, STOP_LOSS_MAX_PCT, LOSS_CLOSE_BAN_MINUTES, PRINTS_MIN_NOTIONAL_USD, PRINTS_TEXT_MIN_NOTIONAL_USD, PRINTS_SPEED_MULT, PRINTS_SPEED_AUTO, PRINTS_AGG_ENABLED, LOG_DIR, TELEGRAM_USERS_FILE, SETTINGS_FILE, EQUITY_HISTORY_FILE, TRADE_JOURNAL_FILE, PNL_SNAPSHOT_FILE
        try:
            ORDERBOOK_TICK_MULT = int(self.book_tick_mult_spin.value())
            if ORDERBOOK_TICK_MULT < 1:
                ORDERBOOK_TICK_MULT = 1
        except Exception:
            ORDERBOOK_TICK_MULT = max(1, int(globals().get("ORDERBOOK_TICK_MULT", 1) or 1))
        try:
            if hasattr(self, "book_vol_usd_chk"):
                ORDERBOOK_VOL_IN_USD = bool(self.book_vol_usd_chk.isChecked())
        except Exception:
            pass
        try:
            if hasattr(self, "book_vol_compact_chk"):
                ORDERBOOK_VOL_COMPACT = bool(self.book_vol_compact_chk.isChecked())
        except Exception:
            pass
        try:
            if hasattr(self, "book_vol_width_spin"):
                ORDERBOOK_VOL_COL_WIDTH = int(self.book_vol_width_spin.value())
                if ORDERBOOK_VOL_COL_WIDTH < 0:
                    ORDERBOOK_VOL_COL_WIDTH = 0
        except Exception:
            pass
        try:
            MIN_POS_NOTIONAL_MULT = float(self.min_pos_notional_spin.value())
        except Exception:
            pass
        try:
            MAX_POS_NOTIONAL_MULT = float(self.max_pos_notional_spin.value())
        except Exception:
            pass
        try:
            STOP_LOSS_MIN_PCT = float(self.stop_loss_min_spin.value()) / 100.0
        except Exception:
            pass
        try:
            STOP_LOSS_MAX_PCT = float(self.stop_loss_max_spin.value()) / 100.0
        except Exception:
            pass
        try:
            if float(STOP_LOSS_MIN_PCT) > float(STOP_LOSS_MAX_PCT):
                STOP_LOSS_MAX_PCT = float(STOP_LOSS_MIN_PCT)
        except Exception:
            pass
        try:
            LOSS_CLOSE_BAN_MINUTES = int(self.loss_close_ban_spin.value())
            if LOSS_CLOSE_BAN_MINUTES < 0:
                LOSS_CLOSE_BAN_MINUTES = 0
        except Exception:
            pass
        try:
            PRINTS_MIN_NOTIONAL_USD = float(self.prints_min_notional_spin.value())
            if PRINTS_MIN_NOTIONAL_USD < 0:
                PRINTS_MIN_NOTIONAL_USD = 0.0
        except Exception:
            pass
        try:
            if hasattr(self, "prints_text_min_notional_spin"):
                PRINTS_TEXT_MIN_NOTIONAL_USD = float(self.prints_text_min_notional_spin.value())
                if PRINTS_TEXT_MIN_NOTIONAL_USD < 0:
                    PRINTS_TEXT_MIN_NOTIONAL_USD = 0.0
        except Exception:
            pass
        try:
            if hasattr(self, 'prints_speed_auto_chk') and self.prints_speed_auto_chk is not None:
                PRINTS_SPEED_AUTO = bool(self.prints_speed_auto_chk.isChecked())
        except Exception:
            pass
        try:
            PRINTS_SPEED_MULT = float(self.prints_speed_spin.value())
            # Manual speed multiplier range: PRINTS_SPEED_MIN .. PRINTS_SPEED_MAX (default 2.5).
            try:
                speed_min = float(globals().get('PRINTS_SPEED_MIN', 0.7) or 0.7)
            except Exception:
                speed_min = 0.7
            try:
                speed_max = float(globals().get('PRINTS_SPEED_MAX', 2.5) or 2.5)
            except Exception:
                speed_max = 2.5
            if PRINTS_SPEED_MULT < speed_min:
                PRINTS_SPEED_MULT = speed_min
            if PRINTS_SPEED_MULT > speed_max:
                PRINTS_SPEED_MULT = speed_max
        except Exception:
            pass
        try:
            if hasattr(self, 'prints_agg_ms_spin') and self.prints_agg_ms_spin is not None:
                globals()['PRINTS_AGG_WINDOW_MS'] = int(self.prints_agg_ms_spin.value())
            try:
                if hasattr(self, 'prints_agg_chk') and self.prints_agg_chk is not None:
                    PRINTS_AGG_ENABLED = bool(self.prints_agg_chk.isChecked())
                    globals()['PRINTS_AGG_ENABLED'] = bool(PRINTS_AGG_ENABLED)
            except Exception:
                pass
        except Exception:
            pass
        try:
            if hasattr(self, "prints_agg_extra_ms_spin") and self.prints_agg_extra_ms_spin is not None:
                globals()["PRINTS_AGG_WINDOW_MS_EXTRA"] = max(0, int(self.prints_agg_extra_ms_spin.value()))
                _apply_prints_agg_extra()
        except Exception:
            pass

        new_log_dir = self.log_dir_edit.text().strip() or LOG_DIR
        if new_log_dir:
            new_log_dir = os.path.abspath(new_log_dir)
        new_tg_file = self.telegram_file_edit.text().strip() or TELEGRAM_USERS_FILE
        if new_tg_file:
            new_tg_file = os.path.abspath(new_tg_file)

        if new_log_dir and new_log_dir != LOG_DIR:
            LOG_DIR = new_log_dir
            try:
                os.makedirs(LOG_DIR, exist_ok=True)
            except Exception as e:
                log_message(f"⚠️ Не вдалося створити каталог логів: {e}")

        if new_tg_file and new_tg_file != TELEGRAM_USERS_FILE:
            TELEGRAM_USERS_FILE = new_tg_file
            tg_dir = os.path.dirname(TELEGRAM_USERS_FILE)
            if tg_dir:
                try:
                    os.makedirs(tg_dir, exist_ok=True)
                except Exception as e:
                    log_message(f"⚠️ Не вдалося створити каталог для Telegram файлу: {e}")
            try:
                load_telegram_users()
                save_telegram_users()
            except Exception:
                pass

        new_settings_path_raw = self.settings_file_edit.text().strip() or SETTINGS_FILE or DEFAULT_SETTINGS_FILE
        new_settings_path = _normalize_settings_path(new_settings_path_raw) or SETTINGS_FILE or DEFAULT_SETTINGS_FILE
        if new_settings_path and new_settings_path != SETTINGS_FILE:
            SETTINGS_FILE = persist_settings_file_path(new_settings_path)
            settings_dir = os.path.dirname(SETTINGS_FILE)
            if settings_dir:
                try:
                    os.makedirs(settings_dir, exist_ok=True)
                except Exception as e:
                    log_message(f"⚠️ Не вдалося створити каталог для налаштувань: {e}")
            load_settings_from_file()

        new_equity_file = self.equity_file_edit.text().strip() or EQUITY_HISTORY_FILE
        if new_equity_file:
            new_equity_file = os.path.abspath(new_equity_file)
        if new_equity_file and new_equity_file != EQUITY_HISTORY_FILE:
            EQUITY_HISTORY_FILE = new_equity_file
            if not load_equity_history_from_file(emit_gui=True):
                save_equity_history_to_file()
                load_equity_history_from_file(emit_gui=True)
            self.update_equity_series(list(equity_history))

        new_trade_journal_file = self.trade_journal_file_edit.text().strip() or TRADE_JOURNAL_FILE
        if new_trade_journal_file:
            new_trade_journal_file = os.path.abspath(new_trade_journal_file)
        if new_trade_journal_file and new_trade_journal_file != TRADE_JOURNAL_FILE:
            TRADE_JOURNAL_FILE = new_trade_journal_file
            if not load_trade_journal_from_file(emit_gui=True):
                save_trade_journal_to_file()
                load_trade_journal_from_file(emit_gui=True)
            self.update_trade_journal(list(closed_trades))

        new_pnl_file = self.pnl_snapshot_edit.text().strip() or PNL_SNAPSHOT_FILE
        if new_pnl_file:
            new_pnl_file = os.path.abspath(new_pnl_file)
        if new_pnl_file and new_pnl_file != PNL_SNAPSHOT_FILE:
            PNL_SNAPSHOT_FILE = new_pnl_file

        save_settings_to_file()
        if WINDOWS_TIME_SYNC_ENABLED:
            QTimer.singleShot(600, start_windows_time_sync)
        self.refresh_chart(force=True)
        try:
            self._book_start_price = None
            self._book_tick_used = 0.0
            self._book_levels_used = 0
            self._update_book_precision(self.current_symbol)
            try:
                self._apply_book_volume_width()
            except Exception:
                pass
            if self._orderbook_local:
                self._queue_orderbook_render(self._orderbook_local.get('bids') or [], self._orderbook_local.get('asks') or [])
        except Exception:
            pass
        self.sync_quick_controls()
        log_message("ℹ️ Оновлено quick settings (pos notional limits, SL bounds, loss ban, paths)")

    def clear_persistent_data(self):
        try:
            log_dir = (self.log_dir_edit.text().strip() or LOG_DIR or "").strip()
        except Exception:
            log_dir = (LOG_DIR or "").strip()
        try:
            equity_path = (self.equity_file_edit.text().strip() or EQUITY_HISTORY_FILE or "").strip()
        except Exception:
            equity_path = (EQUITY_HISTORY_FILE or "").strip()
        try:
            journal_path = (self.trade_journal_file_edit.text().strip() or TRADE_JOURNAL_FILE or "").strip()
        except Exception:
            journal_path = (TRADE_JOURNAL_FILE or "").strip()
        try:
            pnl_path = (self.pnl_snapshot_edit.text().strip() or PNL_SNAPSHOT_FILE or "").strip()
        except Exception:
            pnl_path = (PNL_SNAPSHOT_FILE or "").strip()

        msg_lines = [
            "Ця дія видалить:",
            f"- LOG DIR: {os.path.abspath(log_dir) if log_dir else '(empty)'}",
            f"- EQUITY FILE: {os.path.abspath(equity_path) if equity_path else '(empty)'}",
            f"- TRADE JOURNAL FILE: {os.path.abspath(journal_path) if journal_path else '(empty)'}",
            f"- PNL SNAPSHOT: {os.path.abspath(pnl_path) if pnl_path else '(empty)'}",
            f"- (legacy) {os.path.abspath(BASE_DIR)}\\logs*.txt",
            "",
            "Цю дію неможливо відмінити.",
        ]
        confirm = QMessageBox.question(
            self,
            "Очистити дані",
            "\n".join(msg_lines),
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        if confirm != QMessageBox.StandardButton.Yes:
            return

        log_files_deleted = 0
        equity_deleted = False
        journal_deleted = False
        pnl_deleted = False

        # Clear on-disk logs (guard against concurrent writes)
        try:
            with _log_file_lock:
                if log_dir and os.path.isdir(log_dir):
                    for root, dirs, files in os.walk(log_dir, topdown=False):
                        for fn in files:
                            try:
                                os.remove(os.path.join(root, fn))
                                log_files_deleted += 1
                            except Exception:
                                pass
                        for dn in dirs:
                            try:
                                os.rmdir(os.path.join(root, dn))
                            except Exception:
                                pass
        except Exception:
            pass

        # Legacy root log files (older versions wrote logs_*.txt into BASE_DIR)
        try:
            base_dir = BASE_DIR
            for fn in os.listdir(base_dir):
                try:
                    low = str(fn).lower()
                except Exception:
                    low = ""
                if not (low.startswith("logs") and low.endswith(".txt")):
                    continue
                p = os.path.join(base_dir, fn)
                if os.path.isfile(p):
                    try:
                        os.remove(p)
                        log_files_deleted += 1
                    except Exception:
                        pass
        except Exception:
            pass

        # Delete equity history file + clear in-memory series
        try:
            if equity_path and os.path.exists(equity_path):
                os.remove(equity_path)
                equity_deleted = True
        except Exception:
            pass
        try:
            if journal_path and os.path.exists(journal_path):
                os.remove(journal_path)
                journal_deleted = True
        except Exception:
            pass
        try:
            global last_recorded_equity_balance
            with equity_history_lock:
                try:
                    equity_history.clear()
                except Exception:
                    pass
            last_recorded_equity_balance = None
        except Exception:
            pass
        try:
            if gui_bus is not None:
                gui_bus.equity_signal.emit([])
        except Exception:
            pass

        # Delete daily PnL snapshot file + reset trackers
        try:
            if pnl_path and os.path.exists(pnl_path):
                os.remove(pnl_path)
                pnl_deleted = True
        except Exception:
            pass
        try:
            global current_pnl_percent_display, initial_balance, last_balance_snapshot
            current_pnl_percent_display = None
            initial_balance = None
            last_balance_snapshot = None
        except Exception:
            pass
        try:
            recent_logs.clear()
        except Exception:
            pass
        try:
            closed_trades.clear()
        except Exception:
            pass
        try:
            if gui_bus is not None:
                gui_bus.trade_journal_signal.emit([])
        except Exception:
            pass

        # Clear GUI panels
        try:
            self.log_view.setPlainText("")
        except Exception:
            pass
        try:
            self.update_trade_journal([])
        except Exception:
            pass
        try:
            self.update_equity_series([])
        except Exception:
            pass

        QMessageBox.information(
            self,
            "Очистити дані",
            f"Готово.\nЛоги видалено: {log_files_deleted}\nEquity файл: {'видалено' if equity_deleted else 'не знайдено'}\nTrade journal file: {'deleted' if journal_deleted else 'not found'}\nPnL файл: {'видалено' if pnl_deleted else 'не знайдено'}",
        )

    def update_trade_journal(self, journal):
        self._trade_journal_local = journal or []
        self.refresh_trade_journal_table()

    def on_trade_journal_range_changed(self, *_args):
        self.refresh_trade_journal_table()

    def on_trade_journal_item_changed(self, item):
        try:
            if getattr(self, "_journal_updating", False):
                return
        except Exception:
            pass
        if item is None:
            return
        try:
            col = int(item.column())
        except Exception:
            return
        try:
            tag_col = int(getattr(self, "_journal_tag_col", 4))
        except Exception:
            tag_col = 4
        if col != tag_col:
            return
        try:
            jid = item.data(Qt.UserRole)
        except Exception:
            jid = None
        if not jid:
            return
        try:
            tag_val = item.text()
        except Exception:
            tag_val = ""
        tag_val = tag_val if tag_val is not None else ""
        updated = False
        try:
            data = list(getattr(self, "_trade_journal_local", []) or [])
        except Exception:
            data = []
        if data:
            for it in data:
                try:
                    it_jid = _ensure_trade_journal_uid(it)
                except Exception:
                    it_jid = it.get("jid") if isinstance(it, dict) else None
                if it_jid == jid:
                    it["tag"] = tag_val
                    updated = True
                    break
        try:
            for it in closed_trades:
                try:
                    it_jid = _ensure_trade_journal_uid(it)
                except Exception:
                    it_jid = it.get("jid") if isinstance(it, dict) else None
                if it_jid == jid:
                    it["tag"] = tag_val
                    updated = True
                    break
        except Exception:
            pass
        if updated:
            try:
                save_trade_journal_to_file()
            except Exception:
                pass

    def _filter_trade_journal(self, data):
        try:
            mode = None
            if hasattr(self, 'journal_range_combo'):
                mode = self.journal_range_combo.currentData()
            if not mode or mode == "all":
                return data
            now = _kyiv_now()
            end = None
            if mode == "today":
                start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            elif mode == "week":
                start = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)
            elif mode == "last_week":
                week_start = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)
                start = week_start - timedelta(days=7)
                end = week_start
            else:
                return data
            start_ts = float(start.timestamp())
            end_ts = float(end.timestamp()) if end is not None else None
            filtered = []
            for point in data:
                try:
                    ts_val = float(point.get("ts") or 0.0)
                except Exception:
                    continue
                if end_ts is not None:
                    if start_ts <= ts_val < end_ts:
                        filtered.append(point)
                else:
                    if ts_val >= start_ts:
                        filtered.append(point)
            return filtered
        except Exception:
            return data

    def refresh_trade_journal_table(self, journal=None):
        try:
            table = self.journal_table
        except Exception:
            return
        try:
            self._journal_updating = True
            table.blockSignals(True)
        except Exception:
            pass
        data = journal if journal is not None else getattr(self, "_trade_journal_local", [])
        if data is None:
            data = []
        data = self._filter_trade_journal(data)
        try:
            data = sorted(data, key=lambda x: float(x.get("ts") or 0.0), reverse=True)
        except Exception:
            pass
        try:
            table.setRowCount(0)
        except Exception:
            try:
                table.blockSignals(False)
                self._journal_updating = False
            except Exception:
                pass
            return
        if not data:
            try:
                table.blockSignals(False)
                self._journal_updating = False
            except Exception:
                pass
            return
        try:
            default_fg = QBrush(self._theme_text_color())
        except Exception:
            default_fg = None
        tzinfo = None
        try:
            tzinfo = _kyiv_now().tzinfo
        except Exception:
            tzinfo = None
        table.setRowCount(len(data))
        for row_idx, row in enumerate(data):
            ts_txt = ""
            try:
                ts_val = float(row.get("ts") or 0.0)
                if tzinfo is not None:
                    ts_txt = datetime.fromtimestamp(ts_val, tzinfo).strftime("%Y-%m-%d %H:%M:%S")
                else:
                    ts_txt = datetime.fromtimestamp(ts_val).strftime("%Y-%m-%d %H:%M:%S")
            except Exception:
                ts_txt = ""
            sym_txt = str(row.get("symbol") or "")
            pnl_pct = row.get("pnl_pct")
            if isinstance(pnl_pct, (int, float)):
                pct_txt = f"{pnl_pct:+.2f}%"
            else:
                pct_txt = "n/a"
            pnl_usdt = row.get("pnl_net") if row.get("pnl_net") is not None else row.get("pnl_abs")
            if isinstance(pnl_usdt, (int, float)):
                usdt_txt = f"{pnl_usdt:+.4f}"
            else:
                try:
                    usdt_txt = f"{float(pnl_usdt):+.4f}"
                except Exception:
                    usdt_txt = "n/a"
            side_norm = str(row.get("side") or "").upper()
            side_color = None
            if side_norm in ("LONG", "BUY"):
                side_color = QColor(0, 200, 0)
            elif side_norm in ("SHORT", "SELL"):
                side_color = QColor(255, 80, 80)
            pnl_sign = None
            if isinstance(pnl_pct, (int, float)):
                pnl_sign = float(pnl_pct)
            elif isinstance(pnl_usdt, (int, float)):
                pnl_sign = float(pnl_usdt)
            pnl_color = None
            if isinstance(pnl_sign, (int, float)):
                if pnl_sign > 0:
                    pnl_color = QColor(0, 200, 0)
                elif pnl_sign < 0:
                    pnl_color = QColor(255, 80, 80)
            try:
                _ensure_trade_journal_tag(row)
            except Exception:
                pass
            try:
                _ensure_trade_journal_uid(row)
            except Exception:
                pass
            tag_txt = str(row.get("tag") or "")
            values = (ts_txt, sym_txt, pct_txt, usdt_txt, tag_txt)
            try:
                tag_col = int(getattr(self, "_journal_tag_col", 4))
            except Exception:
                tag_col = 4
            for col_idx, text in enumerate(values):
                item = QTableWidgetItem(text)
                if col_idx in (2, 3):
                    item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                else:
                    item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                try:
                    flags = item.flags()
                    if col_idx == tag_col:
                        flags = flags | Qt.ItemIsEditable
                    else:
                        flags = flags & ~Qt.ItemIsEditable
                    item.setFlags(flags)
                except Exception:
                    pass
                if default_fg is not None:
                    item.setForeground(default_fg)
                if col_idx == 1 and side_color is not None:
                    item.setForeground(QBrush(side_color))
                    try:
                        item.setBackground(QBrush(QColor(side_color.red(), side_color.green(), side_color.blue(), 70)))
                    except Exception:
                        pass
                if col_idx in (2, 3) and pnl_color is not None:
                    item.setForeground(QBrush(pnl_color))
                if col_idx == tag_col:
                    try:
                        item.setData(Qt.UserRole, row.get("jid"))
                    except Exception:
                        pass
                table.setItem(row_idx, col_idx, item)
        try:
            table.resizeRowsToContents()
        except Exception:
            pass
        try:
            table.blockSignals(False)
            self._journal_updating = False
        except Exception:
            pass

    def update_equity_series(self, history):
        self._equity_history_local = history or []
        self.refresh_equity_chart()

    def on_equity_range_changed(self, *_args):
        self.refresh_equity_chart()

    def _filter_equity_history(self, data):
        try:
            mode = None
            if hasattr(self, 'equity_range_combo'):
                mode = self.equity_range_combo.currentData()
            if not mode or mode == "all":
                return data
            now = _kyiv_now()
            end = None
            if mode == "today":
                start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            elif mode == "week":
                start = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)
            elif mode == "last_week":
                week_start = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)
                start = week_start - timedelta(days=7)
                end = week_start
            else:
                return data
            start_ts = float(start.timestamp())
            end_ts = float(end.timestamp()) if end is not None else None
            filtered = []
            for point in data:
                try:
                    ts_val = float(point.get("ts") or 0.0)
                except Exception:
                    continue
                if end_ts is not None:
                    if start_ts <= ts_val < end_ts:
                        filtered.append(point)
                else:
                    if ts_val >= start_ts:
                        filtered.append(point)
            return filtered
        except Exception:
            return data

    def refresh_equity_chart(self, history=None):
        data = history if history is not None else getattr(self, "_equity_history_local", [])
        if data is None:
            data = []
        data = self._filter_equity_history(data)
        if not data:
            self.equity_curve.setData([], [])
            return
        xs = []
        ys = []
        for point in data:
            try:
                xs.append(float(point.get("ts")))
                ys.append(float(point.get("balance")))
            except Exception:
                continue
        if not xs:
            self.equity_curve.setData([], [])
            return
        self.equity_curve.setData(xs, ys)
        self.equity_chart.enableAutoRange(axis='xy', enable=True)

    def _chart_pnl_pct(self, symbol, current_price=None):
        sym = (symbol or "").upper()
        if not sym:
            return None
        try:
            pos = pos_get(sym) or {}
        except Exception:
            pos = {}
        try:
            qty = abs(float(pos.get("qty") or 0.0))
        except Exception:
            qty = 0.0
        try:
            entry_price = float(pos.get("entry_price") or 0.0)
        except Exception:
            entry_price = 0.0
        try:
            side = _norm_side(pos.get("side"))
        except Exception:
            side = None
        if qty <= float(eps or 1e-12) or entry_price <= 0 or side not in ("LONG", "SHORT"):
            try:
                _events, _sl, close_lines, _focus = chart_trade_get_snapshot(sym)
            except Exception:
                close_lines = []
            if close_lines:
                try:
                    last_ln = close_lines[-1]
                    pct_val = last_ln.get("pct")
                except Exception:
                    pct_val = None
                if pct_val is not None:
                    try:
                        return float(pct_val)
                    except Exception:
                        return None
            return None
        cp_val = current_price
        try:
            if cp_val is not None:
                cp_val = float(cp_val)
        except Exception:
            cp_val = None
        if cp_val is None or cp_val <= 0:
            try:
                cp_val, _ = price_source.get_cached_price(sym, price_kind="last")
            except Exception:
                cp_val = None
        if cp_val is None or cp_val <= 0:
            return None
        try:
            if side == "LONG":
                return (cp_val - entry_price) / entry_price * 100.0
            if side == "SHORT":
                return (entry_price - cp_val) / entry_price * 100.0
        except Exception:
            return None
        return None

    def _chart_title_html(self, symbol, suffix=None, current_price=None):
        sym = (symbol or "").upper()
        extra = (suffix or "").strip()
        pnl_pct = self._chart_pnl_pct(sym, current_price=current_price)
        if pnl_pct is None:
            if extra:
                return f"{sym} | {extra}"
            return sym
        try:
            pnl_val = float(pnl_pct)
        except Exception:
            pnl_val = None
        if pnl_val is None:
            if extra:
                return f"{sym} | {extra}"
            return sym
        color = "#2ecc71" if pnl_val >= 0 else "#e74c3c"
        pnl_txt = f"{pnl_val:+.2f}%"
        title = f"<span style='font-size:11pt; font-weight:600;'>{sym}</span>"
        title += f" <span style='font-size:14pt; font-weight:700; color:{color};'>{pnl_txt}</span>"
        if extra:
            title += f" <span style='font-size:9pt; color:#9aa0a6;'>| {extra}</span>"
        return title

    def refresh_chart(self, force=False):
        symbol = (self.current_symbol or '').upper()
        plot = getattr(self, 'plot_item', self.chart_widget.getPlotItem())
        symbol_changed = symbol != getattr(self, "_chart_last_symbol", None)
        if symbol_changed:
            force = True
        try:
            chart_interval = str(self.chart_interval_combo.currentText() or "").strip() or "5m"
        except Exception:
            chart_interval = "5m"
        try:
            globals()["CANDLE_WS_INTERVAL"] = chart_interval
        except Exception:
            pass
        try:
            ensure_kline_subscription(symbol, interval=chart_interval)
        except Exception:
            pass
        rest_key = (symbol, chart_interval)
        if symbol_changed:
            try:
                with CHART_REST_SEED_LOCK:
                    CHART_REST_SEEDED.discard(rest_key)
            except Exception:
                pass

        allow_rest_once = False
        try:
            with CHART_REST_SEED_LOCK:
                allow_rest_once = rest_key not in CHART_REST_SEEDED
        except Exception:
            allow_rest_once = True
        candles = get_chart_candles(
            symbol,
            limit=CHART_CANDLE_LIMIT,
            force_refresh=force,
            allow_rest=False,
            rest_seed_on_empty=False,
        )
        if (not candles) and allow_rest_once:
            try:
                candles = get_chart_candles(
                    symbol,
                    limit=CHART_CANDLE_LIMIT,
                    force_refresh=True,
                    allow_rest=True,
                    rest_seed_on_empty=False,
                )
            except Exception:
                pass
            if candles:
                try:
                    with CHART_REST_SEED_LOCK:
                        CHART_REST_SEEDED.add(rest_key)
                except Exception:
                    pass
        if not candles:
            self.candles_item.setData([])
            self.level_line.setVisible(False)
            self.price_line.setVisible(False)
            self.price_label.setVisible(False)
            try:
                if getattr(self, "chart_cursor_line", None) is not None:
                    self.chart_cursor_line.setVisible(False)
                if getattr(self, "chart_cursor_label", None) is not None:
                    self.chart_cursor_label.setVisible(False)
            except Exception:
                pass
            plot.setTitle(self._chart_title_html(symbol, "очікуємо дані"))
            try:
                self._chart_last_candle_ts = None
                self._chart_last_candle_sig = None
                self._chart_last_candle_count = 0
                self._chart_last_trade_id = None
                self._chart_last_level = None
                self._chart_cached_xs = None
                self._last_chart_x_bounds = None
                self._chart_last_symbol = symbol
            except Exception:
                pass
            return


        last_ts = None
        try:
            last_ts = float(candles[-1][0])
        except Exception:
            last_ts = None
        last_sig = None
        try:
            last_sig = tuple(candles[-1])
        except Exception:
            last_sig = None
        last_len = len(candles)
        full_update = bool(force or symbol_changed)
        try:
            if last_ts is not None:
                if last_ts != getattr(self, "_chart_last_candle_ts", None) or last_len != int(getattr(self, "_chart_last_candle_count", 0) or 0):
                    full_update = True
        except Exception:
            full_update = True
        try:
            if last_sig != getattr(self, "_chart_last_candle_sig", None):
                full_update = True
        except Exception:
            full_update = True

        if full_update:
            self.candles_item.setData(candles)
            xs = [c[0] for c in candles]
            ys = []
            for _, open_p, close_p, low_p, high_p in candles:
                ys.extend((open_p, close_p, low_p, high_p))
            if xs and ys:
                xmin, xmax = min(xs), max(xs)
                ymin, ymax = min(ys), max(ys)
                pad = max((ymax - ymin) * 0.05, 1e-6)
                span = max(xmax - xmin, 60)
                left_pad_ts = span * 0.1
                right_pad_ts = span * 0.25
                x_start = xmin - left_pad_ts
                x_end = xmax + right_pad_ts
                view_box = getattr(self, 'view_box', plot.getViewBox())
                view_box.setRange(xRange=(x_start, x_end), yRange=(ymin - pad, ymax + pad), padding=0.0, update=True)
                self._last_chart_x_bounds = (x_start, x_end)
            else:
                self._last_chart_x_bounds = None
            try:
                self._chart_cached_xs = xs
                self._chart_last_candle_ts = last_ts
                self._chart_last_candle_sig = last_sig
                self._chart_last_candle_count = last_len
                self._chart_last_symbol = symbol
            except Exception:
                pass
        else:
            xs = getattr(self, "_chart_cached_xs", None)
            if not xs or len(xs) != last_len:
                xs = [c[0] for c in candles]
                try:
                    self._chart_cached_xs = xs
                except Exception:
                    pass
            try:
                if not getattr(self, "_last_chart_x_bounds", None) and xs:
                    self._last_chart_x_bounds = (min(xs), max(xs))
            except Exception:
                pass
        current_price = None
        try:
            current_price, _ = price_source.get_cached_price(symbol, price_kind="last")
        except Exception:
            current_price = None
        if (current_price is None or current_price <= 0) and candles:
            try:
                current_price = float(candles[-1][2])
            except Exception:
                current_price = None
        if current_price and xs:
            try:
                chart_bounds = getattr(self, '_last_chart_x_bounds', None)
            except Exception:
                chart_bounds = None
            try:
                x_start = max(xs)
                if chart_bounds:
                    x_end = chart_bounds[1]
                else:
                    x_end = x_start
            except Exception:
                x_start = None
                x_end = None
            if x_start is not None and x_end is not None:
                if x_end <= x_start:
                    try:
                        span = (max(xs) - min(xs)) if len(xs) > 1 else 60.0
                    except Exception:
                        span = 60.0
                    x_end = x_start + max(span * 0.02, 1.0)
                self.price_line.setData([x_start, x_end], [current_price, current_price])
                self.price_line.setVisible(True)
                try:
                    if (getattr(self, "_book_symbol", None) or "").upper() == symbol:
                        price_prec = int(getattr(self, "_book_price_prec", 6) or 6)
                    else:
                        _, price_prec = get_symbol_precision(symbol)
                        price_prec = int(price_prec)
                    if price_prec < 0:
                        price_prec = 6
                except Exception:
                    price_prec = 6
                try:
                    price_text = f"{float(current_price):.{price_prec}f}"
                except Exception:
                    price_text = str(current_price)
                self.price_label.setText(price_text)
                self.price_label.setPos(x_end, current_price)
                self.price_label.setVisible(True)
            else:
                self.price_line.setVisible(False)
                self.price_label.setVisible(False)
        else:
            self.price_line.setVisible(False)
            self.price_label.setVisible(False)

        try:
            trade_id = _chart_trade_current_id(symbol)
        except Exception:
            trade_id = None
        markers_need = bool(full_update or trade_id != getattr(self, "_chart_last_trade_id", None))
        if markers_need:
            for item in getattr(self, 'hist_level_items', []):
                try:
                    self.plot_item.removeItem(item)
                except Exception:
                    pass
            self.hist_level_items = []
            for item in getattr(self, 'level_markers', []):
                try:
                    self.plot_item.removeItem(item)
                except Exception:
                    pass
            self.level_markers = []
            for item in getattr(self, 'trade_markers', []):
                try:
                    self.plot_item.removeItem(item)
                except Exception:
                    pass
            self.trade_markers = []
            for item in getattr(self, 'sl_markers', []):
                try:
                    self.plot_item.removeItem(item)
                except Exception:
                    pass
            self.sl_markers = []
            for item in getattr(self, 'close_markers', []):
                try:
                    self.plot_item.removeItem(item)
                except Exception:
                    pass
            self.close_markers = []
            chart_bounds = getattr(self, '_last_chart_x_bounds', None)

            # --- Trade markers (buy/sell triangles) + SL line ---
            try:
                trade_events, sl_marks, close_lines, focus_id = chart_trade_get_snapshot(symbol)
            except Exception:
                trade_events, sl_marks, close_lines, focus_id = [], [], [], None
            try:
                if focus_id is not None:
                    trade_events = [e for e in trade_events if e.get('trade_id') == focus_id]
                    sl_marks = [m for m in sl_marks if m.get('trade_id') == focus_id]
                    close_lines = [ln for ln in close_lines if ln.get('trade_id') == focus_id]
            except Exception:
                pass
            try:
                if chart_bounds:
                    x_min, x_max = chart_bounds
                else:
                    x_min, x_max = None, None
            except Exception:
                x_min, x_max = None, None
            try:
                if x_min is not None and x_max is not None:
                    trade_events = [
                        e for e in trade_events
                        if e.get('ts') is not None and x_min <= float(e.get('ts')) <= x_max
                    ]
                    sl_marks = [
                        m for m in sl_marks
                        if m.get('ts') is not None and x_min <= float(m.get('ts')) <= x_max
                    ]
                    close_lines = [
                        ln for ln in close_lines
                        if ln.get('entry_ts') is not None
                        and ln.get('close_ts') is not None
                        and (
                            x_min <= float(ln.get('entry_ts')) <= x_max
                            or x_min <= float(ln.get('close_ts')) <= x_max
                        )
                    ]
            except Exception:
                pass
            try:
                buy_color = '#00b0ff'
                sell_color = '#c000ff'
                buy_brush = pg.mkBrush(buy_color)
                sell_brush = pg.mkBrush(sell_color)
                buy_pen = pg.mkPen('#ffffff', width=2.0)
                sell_pen = pg.mkPen('#ffffff', width=2.0)
                marker_size = None
                try:
                    view_box = getattr(self, 'view_box', plot.getViewBox())
                    view_width = float(view_box.width() or 0)
                    if xs and len(xs) > 1 and view_width > 0:
                        diffs = [xs[i + 1] - xs[i] for i in range(len(xs) - 1) if xs[i + 1] > xs[i]]
                        if diffs:
                            diffs.sort()
                            candle_span = diffs[len(diffs) // 2]
                            if x_min is not None and x_max is not None:
                                x_span = max(x_max - x_min, 1e-6)
                            else:
                                x_span = max(max(xs) - min(xs), 1e-6)
                            candle_px = view_width * (candle_span / x_span)
                            marker_size = max(6.0, min(18.0, candle_px * 1.1))
                except Exception:
                    marker_size = None
                if not marker_size:
                    marker_size = 10.0
                # User request: make entry/exit triangles 2x larger for visibility
                try:
                    marker_size = float(marker_size) * 2.0
                except Exception:
                    pass

                buy_spots = []
                sell_spots = []
                for e in trade_events:
                    ts_val = e.get('ts')
                    price_val = e.get('price')
                    if ts_val is None or price_val is None:
                        continue
                    side_val = str(e.get('side') or '').upper()
                    if side_val not in ('BUY', 'SELL'):
                        try:
                            side_val = _side_to_api(side_val) or side_val
                        except Exception:
                            pass
                    if side_val not in ('BUY', 'SELL'):
                        continue
                    # Dotted horizontal line from marker apex to the right edge (user request)
                    try:
                        _end_x = None
                        try:
                            if x_max is not None:
                                _end_x = float(x_max)
                            elif xs:
                                _end_x = float(max(xs))
                        except Exception:
                            _end_x = None
                        if _end_x is None:
                            _end_x = float(ts_val) + 60.0
                        if float(_end_x) <= float(ts_val):
                            _end_x = float(ts_val) + 60.0
                        _dash_pen = pg.mkPen(buy_color if side_val == 'BUY' else sell_color, width=1.4, style=Qt.DashDotLine)
                        _ln = pg.PlotCurveItem([float(ts_val), float(_end_x)], [float(price_val), float(price_val)], pen=_dash_pen)
                        try:
                            _ln.setZValue(995)
                        except Exception:
                            pass
                        self.plot_item.addItem(_ln)
                        self.trade_markers.append(_ln)
                    except Exception:
                        pass

                    spot = {
                        'pos': (float(ts_val), float(price_val)),
                        'size': marker_size,
                        'symbol': CHART_TRADE_TRI_UP if side_val == 'BUY' else CHART_TRADE_TRI_DOWN,
                        'pen': buy_pen if side_val == 'BUY' else sell_pen,
                        'brush': buy_brush if side_val == 'BUY' else sell_brush,
                    }
                    if side_val == 'BUY':
                        buy_spots.append(spot)
                    else:
                        sell_spots.append(spot)
                if buy_spots:
                    buy_item = pg.ScatterPlotItem(buy_spots)
                    try:
                        buy_item.setZValue(1000)
                    except Exception:
                        pass
                    self.plot_item.addItem(buy_item)
                    self.trade_markers.append(buy_item)
                if sell_spots:
                    sell_item = pg.ScatterPlotItem(sell_spots)
                    try:
                        sell_item.setZValue(1000)
                    except Exception:
                        pass
                    self.plot_item.addItem(sell_item)
                    self.trade_markers.append(sell_item)
            except Exception:
                pass
            try:
                if sl_marks:
                    span = None
                    if x_min is not None and x_max is not None:
                        span = max((x_max - x_min) * 0.08, 60.0)
                    if span is None:
                        span = 60.0
                    for sm in sl_marks:
                        try:
                            ts_val = float(sm.get('ts'))
                            price_val = float(sm.get('price'))
                        except Exception:
                            continue
                        line = pg.PlotCurveItem(
                            [ts_val, ts_val + span],
                            [price_val, price_val],
                            pen=pg.mkPen('#f1c40f', width=2)
                        )
                        try:
                            line.setZValue(900)
                        except Exception:
                            pass
                        self.plot_item.addItem(line)
                        self.sl_markers.append(line)
                        txt = pg.TextItem("СТОП ЛОСС", color='#f1c40f', anchor=(0, 0.5))
                        txt.setPos(ts_val + span, price_val)
                        try:
                            txt.setZValue(901)
                        except Exception:
                            pass
                        self.plot_item.addItem(txt)
                        self.sl_markers.append(txt)
            except Exception:
                pass
            try:
                if close_lines:
                    try:
                        if x_min is not None and x_max is not None:
                            label_offset = max((x_max - x_min) * 0.02, 30.0)
                        else:
                            label_offset = 60.0
                    except Exception:
                        label_offset = 60.0
                    for ln in close_lines:
                        try:
                            entry_ts = float(ln.get('entry_ts'))
                            entry_price = float(ln.get('entry_price'))
                            close_ts = float(ln.get('close_ts'))
                            close_price = float(ln.get('close_price'))
                            pct_val = float(ln.get('pct') or 0.0)
                        except Exception:
                            continue
                        color = '#2ecc71' if pct_val >= 0 else '#e74c3c'
                        line = pg.PlotCurveItem(
                            [entry_ts, close_ts],
                            [entry_price, close_price],
                            pen=pg.mkPen(color, width=2)
                        )
                        try:
                            line.setZValue(700)
                        except Exception:
                            pass
                        self.plot_item.addItem(line)
                        self.close_markers.append(line)
                        mid_ts = (entry_ts + close_ts) / 2.0
                        mid_price = (entry_price + close_price) / 2.0
                        label_ts = mid_ts + label_offset
                        anchor = (0, 0.5)
                        if x_max is not None and label_ts > x_max:
                            label_ts = mid_ts - label_offset
                            anchor = (1, 0.5)
                        # PnL label on the line disabled; only show PnL near ticker title.
            except Exception:
                pass
        try:
            if markers_need:
                self._chart_last_trade_id = trade_id
        except Exception:
            pass

        if self.current_level is not None:
            cached_start = get_cached_level_display(symbol, self.current_level)
            start_ts, _ = self._level_span_from_candles(candles, self.current_level)
            if cached_start is not None:
                start_ts = cached_start
            chart_bounds = getattr(self, '_last_chart_x_bounds', None)
            chart_end = None
            if chart_bounds:
                chart_end = chart_bounds[1]
            elif xs:
                chart_end = max(xs)
            if start_ts is not None and chart_end is not None:
                if chart_end <= start_ts:
                    chart_end = start_ts + 60
                self.level_line.setData([start_ts, chart_end], [self.current_level, self.current_level])
                self.level_line.setVisible(True)
            else:
                self.level_line.setVisible(False)
            plot.setTitle(self._chart_title_html(symbol, f"рівень {self.current_level:.4f}", current_price=current_price))
        else:
            self.level_line.setVisible(False)
            plot.setTitle(self._chart_title_html(symbol, current_price=current_price))

        try:
            self._chart_last_level = self.current_level
        except Exception:
            pass

    def _level_span_from_candles(self, candles, level):
        if level is None or not candles:
            return None, None

        tol = float(globals().get('TOLERANCE', 0.0018) or 0.0018)
        doji_rel = 0.02
        denom = max(abs(level), 1e-12)
        last_close = candles[-1][2] if candles else None
        is_support = True if last_close is None else (level <= last_close)

        first_touch_any = None
        first_valid = None
        last_touch = None

        for ts, open_p, close_p, low_p, high_p in candles:
            touches_low = abs(low_p - level) / denom <= tol
            touches_high = abs(high_p - level) / denom <= tol
            touches_wick = touches_low if is_support else touches_high
            if touches_wick:
                if first_touch_any is None:
                    first_touch_any = ts
                last_touch = ts

            if first_valid is not None:
                continue

            rng = high_p - low_p if high_p - low_p > 0 else 1e-12
            body = close_p - open_p
            is_doji = abs(body) / rng < doji_rel
            if is_doji:
                continue

            if is_support:
                if touches_low and close_p < open_p:
                    first_valid = ts
            else:
                if touches_high and close_p > open_p:
                    first_valid = ts

        start_ts = first_valid if first_valid is not None else first_touch_any
        return start_ts, last_touch

    def update_chart_symbol(self):
        text = self.symbol_input.text().strip().upper()
        if text:
            prev_symbol = self.current_symbol
            if prev_symbol and prev_symbol != text:
                try:
                    stop_kline_subscription(prev_symbol)
                except Exception:
                    pass
                try:
                    _reset_kline_cache(prev_symbol)
                except Exception:
                    pass
            self.current_symbol = text
            self.current_level = None
            self.refresh_chart(force=True)
            try:
                self._sync_book_symbol(text)
            except Exception:
                pass
            log_message(f"🔄Змінено символ графіку: {text}")

    def _autostart_book_on_launch(self):
        """Запускає підписки стакану і тейпу одразу після старту UI.
        Робимо це окремо від графіка, щоб не блокувати запуск."""
        try:
            sym = None
            try:
                sym = self.symbol_input.text().strip().upper()
            except Exception:
                sym = (getattr(self, 'current_symbol', '') or '').strip().upper()
            if not sym:
                return
            # підписки WS + швидкий рендер
            self._sync_book_symbol(sym)
        except Exception:
            pass
    def apply_theme(self, name: str):
        pal = GUI_THEMES.get(name) or GUI_THEMES["Dark"]
        self.current_theme = name
        stylesheet = f"""
            QMainWindow {{
                background-color: {pal['window_bg']};
                color: {pal['text']};
            }}
            QWidget {{
                background-color: {pal['window_bg']};
                color: {pal['text']};
            }}
            QPlainTextEdit {{
                background-color: {pal['panel_bg']};
                color: {pal['text']};
                border: 1px solid {pal['muted']};
            }}
            QTableWidget {{
                background-color: {pal['panel_bg']};
                alternate-background-color: {pal['window_bg']};
                color: {pal['text']};
                gridline-color: {pal['muted']};
            }}
            QHeaderView::section {{
                background-color: {pal['panel_bg']};
                color: {pal['text']};
                border: 1px solid {pal['muted']};
            }}
            QPushButton {{
                background-color: {pal['panel_bg']};
                color: {pal['text']};
                border: 1px solid {pal['muted']};
                border-radius: 4px;
                padding: 4px 10px;
            }}
            QPushButton:hover {{
                background-color: {pal['accent']};
                color: #ffffff;
            }}
            QPushButton#clearDataButton {{
                background-color: #b03a2e;
                border-color: #b03a2e;
                color: #ffffff;
            }}
            QPushButton#clearDataButton:hover {{
                background-color: #c0392b;
                border-color: #c0392b;
                color: #ffffff;
            }}
            QLineEdit, QSpinBox, QDoubleSpinBox, QComboBox {{
                background-color: {pal['panel_bg']};
                color: {pal['text']};
                border: 1px solid {pal['muted']};
                border-radius: 3px;
            }}
            QTabWidget::pane {{
                border: 1px solid {pal['muted']};
                background: {pal['panel_bg']};
            }}
            QTabBar::tab {{
                background: {pal['panel_bg']};
                color: {pal['text']};
                padding: 6px 10px;
                border: 1px solid {pal['muted']};
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                margin-right: 2px;
            }}
            QTabBar::tab:selected {{
                background: {pal['window_bg']};
                color: {pal['text']};
                border-color: {pal['accent']};
            }}
            QTabBar::tab:hover {{
                background: {pal['accent']};
                color: #ffffff;
            }}
            QLabel {{
                color: {pal['text']};
            }}
        """
        self.setStyleSheet(stylesheet)
        # Theme equity chart
        try:
            self.equity_chart.setBackground(pal['chart_bg'])
            self.equity_chart.plotItem.getAxis('left').setTextPen(pal['text'])
            self.equity_chart.plotItem.getAxis('bottom').setTextPen(pal['text'])
            self.equity_chart.plotItem.showGrid(x=True, y=True, alpha=0.15)
            self.equity_curve.setPen(pg.mkPen(pal['chart_pen'], width=2))
        except Exception:
            pass
        # Theme main chart
        try:
            self.chart_widget.setBackground(pal['chart_bg'])
            self.plot_item.getAxis('left').setTextPen(pal['text'])
            self.plot_item.getAxis('bottom').setTextPen(pal['text'])
            self.plot_item.showGrid(x=True, y=True, alpha=0.2)
        except Exception:
            pass
        self.balance_label.setStyleSheet(f"color: {pal['accent']}; font-weight: 600;")
        self.chart_widget.setBackground(pal['chart_bg'])
        self.level_line.setPen(pg.mkPen(pal['chart_pen'], width=2, style=Qt.DashLine))
        try:
            if hasattr(self, "chart_cursor_line"):
                self.chart_cursor_line.setPen(pg.mkPen(QColor(160, 160, 160, 120), width=1))
            if hasattr(self, "chart_cursor_label"):
                self.chart_cursor_label.setColor(QColor(0, 0, 0))
                self.chart_cursor_label.setBorder(pg.mkPen(QColor(150, 150, 150, 220)))
                self.chart_cursor_label.setFill(pg.mkBrush(200, 200, 200, 220))
        except Exception:
            pass
        plot_item = self.chart_widget.getPlotItem()
        for axis_name in ('left', 'bottom'):
            axis = plot_item.getAxis(axis_name)
            if axis:
                axis.setPen(pg.mkPen(pal['text']))
                axis.setTextPen(pg.mkPen(pal['text']))
        try:
            if hasattr(self, "prints_tape") and self.prints_tape is not None:
                self.prints_tape._text_color = QColor(0, 0, 0, 255)
                self.prints_tape.update()
        except Exception:
            pass
        try:
            self._update_position_summary(self.current_symbol, getattr(self, "_book_best_bid", None), getattr(self, "_book_best_ask", None))
        except Exception:
            pass


def start_telegram_thread():
    try:
        global TELEGRAM_POLLING_ENABLED
        TELEGRAM_POLLING_ENABLED = True
        load_telegram_users()
    except Exception:
        pass
    try:
        threading.Thread(target=telegram_poll_updates_loop, daemon=True).start()
    except Exception as e:
        log_message(f"⚠️ Не вдалося стартувати telegram polling: {e}")




def _win_set_timer_resolution(ms: int = 1):
    """Best-effort: request 1ms system timer resolution on Windows.

    This helps Qt PreciseTimers reach ~8ms/16ms intervals (120/60 FPS targets).
    It is safe to call multiple times; failures are ignored.
    """
    try:
        import os
        if os.name != 'nt':
            return
        import ctypes
        winmm = ctypes.WinDLL('winmm')
        winmm.timeBeginPeriod(int(ms))
        try:
            import atexit
            atexit.register(lambda: winmm.timeEndPeriod(int(ms)))
        except Exception:
            pass
    except Exception:
        return

# =============================================================================
# ACCESS CONTROL: Supabase Auth + NOWPayments підписка + WinSparkle (автооновлення)
# =============================================================================
# Логіка:
#   1) При старті програми користувач має увійти (Supabase Auth).
#   2) Далі перевіряємо підписку в таблиці `subscriptions`.
#   3) Якщо підписка неактивна — показуємо оплату через NOWPayments (USDT TRC20).
#   4) Після оплати NOWPayments надсилає IPN webhook → Supabase Edge Function активує підписку.
#   5) Клієнтський застосунок просто опитує статус підписки і пропускає користувача далі.
#
# Важливо: API ключ NOWPayments НЕ зберігаємо в клієнті. Він має бути тільки в Supabase secrets.

import base64 as _base64
import json as _json
import datetime as _datetime
from urllib.parse import quote as _quote
from pathlib import Path as _Path

import os
import sys
import requests

from PySide6.QtCore import Qt, QTimer, QSize
from PySide6.QtWidgets import (
    QApplication,
    QDialog, QLineEdit, QMessageBox, QFormLayout, QDialogButtonBox,
    QLabel, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget, QWidget,
    QFrame, QCheckBox
)
from PySide6.QtGui import QDesktopServices, QPixmap
from PySide6.QtCore import QUrl

# --------------------
# Налаштування (публічні)
# --------------------
ACCESS_CONTROL_ENABLED = True

# Глобальний статус активації/підписки (для відображення в головному інтерфейсі)
ACCESS_SUB_ACTIVE = None   # True/False після gate; None якщо ще не визначено
ACCESS_SUB_REASON = ""
ACCESS_SUB_END_TS = 0      # unix ts (UTC) кінця поточного періоду


SUPABASE_URL = os.getenv("SUPABASE_URL", "https://sseeampmjzqyevqbfvgx.supabase.co").rstrip("/")
SUPABASE_ANON_KEY = os.getenv("SUPABASE_ANON_KEY", "sb_publishable_zkWYpmPxYu5H-Fqt4P11DQ_480jG-JX")

# Куди редіректити користувача після підтвердження емейлу (Supabase підтвердження)
EMAIL_CONFIRM_REDIRECT_URL = os.getenv("EMAIL_CONFIRM_REDIRECT_URL", "https://proud-lab-16a9.ringoosamsungj710.workers.dev/")

# Підписка: $12 / 30 днів
SUB_PRICE_USD = float(os.getenv("SUB_PRICE_USD", "12"))
SUB_PERIOD_DAYS = int(os.getenv("SUB_PERIOD_DAYS", "30"))

# NOWPayments: хочемо саме USDT TRC20
NOWPAY_PAY_CURRENCY = os.getenv("NOWPAY_PAY_CURRENCY", "usdttrc20")

# Supabase Edge Functions (імена)
FN_CREATE_PAYMENT = os.getenv("FN_CREATE_PAYMENT", "create_nowpayments_payment")

# WinSparkle appcast (опційно)
APP_VERSION = os.getenv("TETRA_APP_VERSION", "1.0.0")
APPCAST_URL = os.getenv("TETRA_APPCAST_URL", "https://raw.githubusercontent.com/dupcamen-dev/tetra-updates/main/appcast.xml")  # напр: https://.../appcast.xml

# Офлайн-грейс: якщо підписка в кеші активна і недавно був онлайн — дозволяємо запуск без інтернету
OFFLINE_GRACE_SECONDS = int(os.getenv("TETRA_OFFLINE_GRACE_SECONDS", "86400"))  # 24h

# Локальні файли (в тій же папці що й exe/py)
# --------------------
# Local storage (per-user)
# --------------------
# Зберігаємо сесію/налаштування не поруч з кодом (або _MEIPASS), а в профілі користувача.
_APPDATA_DIR = _Path(os.getenv("APPDATA") or os.getenv("LOCALAPPDATA") or str(_Path.home())) / "Tetra"
try:
    _APPDATA_DIR.mkdir(parents=True, exist_ok=True)
except Exception:
    pass

_BASE_DIR = _APPDATA_DIR
SESSION_FILE = _BASE_DIR / "tetra_session.bin"
PREF_FILE = _BASE_DIR / "tetra_prefs.json"
SUB_CACHE_FILE = _BASE_DIR / "tetra_subscription_cache.json"

# --------------------
# Nord (тема)
# --------------------
def apply_nord_theme(app: QApplication):
    """
    Легкий Nord QSS. Ставимо один раз на QApplication.
    """
    qss = r"""
    * { font-family: Segoe UI; font-size: 11pt; }
    QWidget, QDialog {
        background-color: #2E3440;
        color: #D8DEE9;
    }
    QFrame#Card {
        background-color: #3B4252;
        border: 1px solid #4C566A;
        border-radius: 14px;
    }
    QLabel#Title {
        font-size: 16pt;
        font-weight: 700;
        color: #ECEFF4;
    }
    QLabel#Muted {
        color: #A3B1C2;
    }
    QLineEdit {
        background-color: #2E3440;
        border: 1px solid #4C566A;
        border-radius: 10px;
        padding: 8px 10px;
        selection-background-color: #88C0D0;
    }
    QLineEdit:focus {
        border: 1px solid #88C0D0;
    }
    QPushButton {
        background-color: #434C5E;
        border: 1px solid #4C566A;
        border-radius: 10px;
        padding: 8px 12px;
    }
    QPushButton:hover {
        border: 1px solid #88C0D0;
    }
    QPushButton:pressed {
        background-color: #4C566A;
    }
    QPushButton#Primary {
        background-color: #5E81AC;
        border: 1px solid #5E81AC;
        color: #ECEFF4;
        font-weight: 600;
    }
    QPushButton#Primary:hover {
        background-color: #81A1C1;
        border: 1px solid #81A1C1;
    }
    QTabWidget::pane {
        border: 0px;
    }
    QTabBar::tab {
        background: #3B4252;
        padding: 8px 14px;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 6px;
        border: 1px solid #4C566A;
    }
    QTabBar::tab:selected {
        background: #434C5E;
        border: 1px solid #88C0D0;
    }
    QCheckBox {
        color: #D8DEE9;
    }
    """
    try:
        app.setStyleSheet(qss)
    except Exception:
        pass


class _Card(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("Card")
        self.setFrameShape(QFrame.NoFrame)


def _utc_now_ts() -> int:
    return int(_datetime.datetime.now(tz=_datetime.timezone.utc).timestamp())


def _parse_iso_ts(s: str) -> int:
    if not s:
        return 0
    try:
        dt = _datetime.datetime.fromisoformat(s.replace("Z", "+00:00"))
        return int(dt.timestamp())
    except Exception:
        return 0


# =============================================================================
# Supabase Manager
# =============================================================================
class AccessManager:
    def __init__(self):
        # dict: access_token, refresh_token, expires_at, user_id, email
        self.session = None
        self.last_online_ok_ts = 0

        # Prefs (local)
        self.remember_me = True
        self.pref_email = ""

    def is_configured(self) -> bool:
        return bool(SUPABASE_URL and SUPABASE_ANON_KEY)

    # --------------------
    # HTTP helpers
    # --------------------
    def _headers(self, access_token: str | None = None):
        h = {
            "apikey": SUPABASE_ANON_KEY,
            "Content-Type": "application/json",
        }
        if access_token:
            h["Authorization"] = f"Bearer {access_token}"
        return h

    def _rest_headers(self, access_token: str):
        h = self._headers(access_token)
        h["Accept"] = "application/json"
        h["Prefer"] = "return=representation"
        return h

    def _fn_url(self, fn_name: str) -> str:
        return f"{SUPABASE_URL}/functions/v1/{fn_name}"

    # --------------------
    # Session cache
    # --------------------
    def save_session(self):
        if not self.session:
            try:
                SESSION_FILE.unlink(missing_ok=True)
            except Exception:
                pass
            return
        try:
            raw = _json.dumps(self.session).encode("utf-8")
            SESSION_FILE.write_bytes(_base64.b64encode(raw))
        except Exception:
            pass

    def load_session(self):
        try:
            if not SESSION_FILE.exists():
                return
            raw = _base64.b64decode(SESSION_FILE.read_bytes())
            self.session = _json.loads(raw.decode("utf-8"))
        except Exception:
            self.session = None

    def clear_session(self):
        self.session = None
        self.save_session()
class AccessManagerFixed:
    """Виправлений менеджер доступу (Auth + підписка + оплата).
    Працює з локальними файлами SESSION_FILE / PREF_FILE / SUB_CACHE_FILE.
    """

    def __init__(self):
        # dict: access_token, refresh_token, expires_at, user_id, email
        self.session: dict | None = None
        self.last_online_ok_ts: int = 0

        # Prefs (local)
        self.remember_me: bool = True
        self.pref_email: str = ""

    def is_configured(self) -> bool:
        return bool(SUPABASE_URL and SUPABASE_ANON_KEY)

    # --------------------
    # Local prefs/session
    # --------------------
    def load_prefs(self):
        """Завантажує локальні налаштування (email + remember_me)."""
        try:
            if not PREF_FILE.exists():
                return
            js = _json.loads(PREF_FILE.read_text(encoding="utf-8"))
            self.remember_me = bool(js.get("remember_me", True))
            self.pref_email = str(js.get("email", "") or "")
        except Exception:
            self.remember_me = True
            self.pref_email = ""

    def save_prefs(self):
        try:
            js = {"remember_me": bool(self.remember_me), "email": str(self.pref_email or "")}
            PREF_FILE.write_text(_json.dumps(js), encoding="utf-8")
        except Exception:
            pass

    def save_session(self):
        try:
            if not self.session:
                return
            payload = {"session": self.session, "last_online_ok_ts": int(self.last_online_ok_ts or 0)}
            SESSION_FILE.write_bytes(_json.dumps(payload).encode("utf-8"))
        except Exception:
            pass

    def load_session(self):
        try:
            if not SESSION_FILE.exists():
                return
            payload = _json.loads(SESSION_FILE.read_bytes().decode("utf-8", errors="ignore"))
            self.session = payload.get("session") or None
            self.last_online_ok_ts = int(payload.get("last_online_ok_ts") or 0)
        except Exception:
            self.session = None

    def clear_session(self):
        self.session = None
        try:
            if SESSION_FILE.exists():
                SESSION_FILE.unlink()
        except Exception:
            pass

    def logout(self):
        """Вийти з акаунта: очистити сесію (і файл сесії, якщо був)."""
        self.clear_session()

    # --------------------
    # HTTP helpers
    # --------------------
    def _headers(self, token: str | None = None) -> dict:
        h = {
            "apikey": SUPABASE_ANON_KEY,
            "Content-Type": "application/json",
        }
        if token:
            h["Authorization"] = f"Bearer {token}"
        return h

    def _rest_headers(self, token: str) -> dict:
        h = self._headers(token)
        # PostgREST любить accept / prefer
        h["Accept"] = "application/json"
        return h

    def _fn_url(self, fn_name: str) -> str:
        return f"{SUPABASE_URL}/functions/v1/{fn_name}"

    # --------------------
    # Auth
    # --------------------
    def login(self, email: str, password: str, remember_me: bool = True) -> bool:
        if not self.is_configured():
            raise RuntimeError("Supabase не налаштований.")

        email = (email or "").strip()
        payload = {"email": email, "password": password}
        url = f"{SUPABASE_URL}/auth/v1/token?grant_type=password"
        params = {"redirect_to": EMAIL_CONFIRM_REDIRECT_URL} if EMAIL_CONFIRM_REDIRECT_URL else None

        r = requests.post(url, headers=self._headers(), params=params, data=_json.dumps(payload), timeout=20)
        if r.status_code >= 400:
            raise RuntimeError(r.text[:400])

        js = r.json()
        access = js.get("access_token")
        refresh = js.get("refresh_token")
        user = js.get("user") or {}
        user_id = user.get("id")
        expires_in = int(js.get("expires_in") or 3600)

        self.session = {
            "access_token": access,
            "refresh_token": refresh,
            "expires_at": _utc_now_ts() + expires_in - 30,
            "user_id": user_id,
            "email": email,
        }
        self.last_online_ok_ts = _utc_now_ts()

        self.remember_me = bool(remember_me)
        self.pref_email = email
        self.save_prefs()

        if self.remember_me:
            self.save_session()
        else:
            self.clear_session()
        return True

    def _refresh_if_needed(self):
        if not self.session:
            return

        now = _utc_now_ts()
        exp = int(self.session.get("expires_at") or 0)
        if exp > now + 20:
            return  # ще валідний

        refresh = self.session.get("refresh_token")
        if not refresh:
            return

        url = f"{SUPABASE_URL}/auth/v1/token?grant_type=refresh_token"
        payload = {"refresh_token": refresh}
        r = requests.post(url, headers=self._headers(), data=_json.dumps(payload), timeout=20)

        if r.status_code >= 400:
            # не оновилися → очищаємо, щоб показати логін
            self.clear_session()
            raise RuntimeError(r.text[:400])

        js = r.json()
        access = js.get("access_token")
        refresh2 = js.get("refresh_token") or refresh
        user = js.get("user") or {}
        user_id = user.get("id") or self.session.get("user_id")
        expires_in = int(js.get("expires_in") or 3600)

        self.session.update({
            "access_token": access,
            "refresh_token": refresh2,
            "expires_at": _utc_now_ts() + expires_in - 30,
            "user_id": user_id,
        })
        self.last_online_ok_ts = _utc_now_ts()
        if self.remember_me:
            self.save_session()

    def signup(self, email: str, password: str) -> bool:
        if not self.is_configured():
            raise RuntimeError("Supabase не налаштований.")

        email = (email or "").strip()
        payload = {"email": email, "password": password}
        url = f"{SUPABASE_URL}/auth/v1/signup"
        params = {"redirect_to": EMAIL_CONFIRM_REDIRECT_URL} if EMAIL_CONFIRM_REDIRECT_URL else None

        r = requests.post(url, headers=self._headers(), params=params, data=_json.dumps(payload), timeout=20)
        if r.status_code >= 400:
            raise RuntimeError(r.text[:500])
        self.last_online_ok_ts = _utc_now_ts()
        return True

    def resend_signup_email(self, email: str) -> None:
        url = f"{SUPABASE_URL}/auth/v1/resend"
        payload = {"type": "signup", "email": (email or "").strip()}
        params = {"redirect_to": EMAIL_CONFIRM_REDIRECT_URL} if EMAIL_CONFIRM_REDIRECT_URL else None

        r = requests.post(url, headers=self._headers(), params=params, data=_json.dumps(payload), timeout=20)
        if r.status_code >= 400:
            raise RuntimeError(r.text[:400])
        self.last_online_ok_ts = _utc_now_ts()

    def validate_session(self) -> bool:
        """Перевіряє, що поточний access_token дійсний для цього проєкту.
        Якщо JWT невалідний/прострочений — очищає сесію і повертає False.
        """
        if not self.session:
            return False

        # Спробуємо рефреш
        try:
            self._refresh_if_needed()
        except Exception:
            # якщо refresh провалився — сесія вже очищена
            return False

        token = self.session.get("access_token")
        if not token:
            self.clear_session()
            return False

        url = f"{SUPABASE_URL}/auth/v1/user"
        try:
            r = requests.get(url, headers=self._headers(token), timeout=15)
        except Exception:
            # офлайн — не валимо користувача, просто лишаємо сесію як є
            return True

        if r.status_code == 200:
            self.last_online_ok_ts = _utc_now_ts()
            if self.remember_me:
                self.save_session()
            return True

        # JWT битий / не з цього проекту / протух
        self.clear_session()
        return False

    # --------------------
    # Subscription
    # --------------------
    def fetch_subscription(self) -> dict | None:
        if not self.session:
            return None

        # Підстрахуємося рефрешем перед REST
        try:
            self._refresh_if_needed()
        except Exception:
            return None

        token = self.session.get("access_token")
        user_id = self.session.get("user_id")
        if not token or not user_id:
            return None

        url = f"{SUPABASE_URL}/rest/v1/subscriptions"
        params = {"user_id": f"eq.{user_id}", "select": "*", "limit": "1"}
        r = requests.get(url, headers=self._rest_headers(token), params=params, timeout=20)

        if r.status_code >= 400:
            raise RuntimeError(r.text[:400])

        arr = r.json() or []
        if not arr:
            return None

        sub = arr[0]
        try:
            SUB_CACHE_FILE.write_text(_json.dumps(sub), encoding="utf-8")
        except Exception:
            pass

        self.last_online_ok_ts = _utc_now_ts()
        if self.remember_me:
            self.save_session()
        return sub

    def load_cached_subscription(self) -> dict | None:
        try:
            if SUB_CACHE_FILE.exists():
                return _json.loads(SUB_CACHE_FILE.read_text(encoding="utf-8"))
        except Exception:
            pass
        return None

    def subscription_active(self):
        """Повертає (active:bool, reason:str, end_ts:int)."""
        now = _utc_now_ts()

        sub = None
        if self.is_configured() and self.session:
            try:
                sub = self.fetch_subscription()
            except Exception:
                sub = None

        # Offline fallback: cached subscription + grace window
        if sub is None:
            cached = self.load_cached_subscription() or {}
            cached_end = _parse_iso_ts(str(cached.get("current_period_end") or ""))
            if cached_end and cached_end > now and (now - int(self.last_online_ok_ts or 0) <= OFFLINE_GRACE_SECONDS):
                return True, "offline_grace", cached_end
            if cached_end:
                return False, "expired_or_offline", cached_end
            return False, "no_subscription_data", 0

        end_ts = _parse_iso_ts(str(sub.get("current_period_end") or ""))
        if end_ts and end_ts > now:
            return True, "active", end_ts
        return False, "expired", end_ts

    # --------------------
    # Payment (Edge Function)
    # --------------------
    def create_nowpayments_payment(self) -> dict:
        """
        Створити платіж у NOWPayments через Supabase Edge Function.
        Edge Function: /functions/v1/create_nowpayments_payment
        Повертає JSON: payment_id, pay_address, pay_amount, pay_currency, payment_status...
        """
        if not self.session:
            raise RuntimeError("Спочатку увійдіть в акаунт.")

        # Оновлюємо JWT якщо потрібно
        try:
            self._refresh_if_needed()
        except Exception:
            raise RuntimeError("Сесія прострочена. Увійдіть знову.")

        token = (self.session or {}).get("access_token")
        if not token:
            raise RuntimeError("Немає access_token. Увійдіть знову.")

        fn_url = self._fn_url(FN_CREATE_PAYMENT)

        payload = {
            "plan": os.getenv("SUB_PLAN_CODE", "monthly_12"),
            "price_amount": float(SUB_PRICE_USD),
            "price_currency": "usd",
            "pay_currency": NOWPAY_PAY_CURRENCY,
            "period_days": int(SUB_PERIOD_DAYS),
        }

        r = requests.post(
            fn_url,
            headers=self._headers(token),
            data=_json.dumps(payload),
            timeout=30
        )

        # Якщо JWT протух між запитами — оновимо і повторимо 1 раз
        if r.status_code == 401 and "Invalid JWT" in (r.text or ""):
            try:
                self._refresh_if_needed()
            except Exception:
                pass
            token2 = (self.session or {}).get("access_token")
            if token2:
                r = requests.post(
                    fn_url,
                    headers=self._headers(token2),
                    data=_json.dumps(payload),
                    timeout=30
                )

        if r.status_code >= 400:
            raise RuntimeError(f"{r.status_code}: {r.text[:600]}")

        self.last_online_ok_ts = _utc_now_ts()
        if self.remember_me:
            self.save_session()
        return r.json()



# --------------------
# Preferences (local)
# --------------------
def load_prefs(self):
    """Завантажує локальні налаштування (email + remember_me)."""
    try:
        if not PREF_FILE.exists():
            return
        js = _json.loads(PREF_FILE.read_text(encoding="utf-8"))
        self.remember_me = bool(js.get("remember_me", True))
        self.pref_email = str(js.get("email", "") or "")
    except Exception:
        # якщо зіпсований файл — просто ігноруємо
        self.remember_me = True
        self.pref_email = ""

def save_prefs(self):
    try:
        PREF_FILE.write_text(_json.dumps({
            "remember_me": bool(self.remember_me),
            "email": (self.pref_email or "").strip(),
        }, ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception:
        pass

def logout(self):
    """Вийти з акаунта: очистити сесію (і файл сесії, якщо був)."""
    self.clear_session()
    # --------------------
    # Auth
    # --------------------
    def login(self, email: str, password: str, remember_me: bool = True) -> bool:
        if not self.is_configured():
            raise RuntimeError("Supabase не налаштований.")
        url = f"{SUPABASE_URL}/auth/v1/token?grant_type=password"
        payload = {"email": email.strip(), "password": password}
        params = {"redirect_to": EMAIL_CONFIRM_REDIRECT_URL} if EMAIL_CONFIRM_REDIRECT_URL else None
        r = requests.post(url, headers=self._headers(), params=params, data=_json.dumps(payload), timeout=20)
        if r.status_code >= 400:
            raise RuntimeError(r.text[:400])
        js = r.json()
        access = js.get("access_token")
        refresh = js.get("refresh_token")
        user = js.get("user") or {}
        user_id = user.get("id")
        expires_in = int(js.get("expires_in") or 3600)
        self.session = {
            "access_token": access,
            "refresh_token": refresh,
            "expires_at": _utc_now_ts() + expires_in - 30,
            "user_id": user_id,
            "email": email.strip(),
        }
        # prefs
        self.remember_me = bool(remember_me)
        self.pref_email = email.strip()
        self.save_prefs()

        # запам’ятовуємо сесію тільки якщо користувач попросив
        if self.remember_me:
            self.save_session()
        else:
            try:
                SESSION_FILE.unlink(missing_ok=True)
            except Exception:
                pass

        self.last_online_ok_ts = _utc_now_ts()
        return True

    def _refresh_if_needed(self, force: bool = False) -> bool:
        """Оновлює access_token через refresh_token якщо час вийшов або якщо force=True.
        Повертає True якщо сесію оновлено або вона й так актуальна.
        """
        if not self.session:
            return False
        access = self.session.get("access_token")
        refresh = self.session.get("refresh_token")
        expires_at = int(self.session.get("expires_at") or 0)

        now = _utc_now_ts()
        if not force and access and expires_at and now < expires_at:
            return True
        if not refresh:
            return False

        try:
            url = f"{SUPABASE_URL}/auth/v1/token?grant_type=refresh_token"
            payload = {"refresh_token": refresh}
            r = requests.post(url, headers=self._headers(), data=_json.dumps(payload), timeout=20)
            if r.status_code >= 400:
                return False
            js = r.json() or {}
            new_access = js.get("access_token")
            new_refresh = js.get("refresh_token") or refresh
            expires_in = int(js.get("expires_in") or 3600)
            user = js.get("user") or {}
            user_id = user.get("id") or self.session.get("user_id")

            if not new_access:
                return False

            self.session.update({
                "access_token": new_access,
                "refresh_token": new_refresh,
                "expires_at": _utc_now_ts() + expires_in - 30,
                "user_id": user_id,
            })
            self.save_session()
            self.last_online_ok_ts = _utc_now_ts()
            return True
        except Exception:
            return False

    def signup(self, email: str, password: str) -> dict:
        """
        Повертає JSON Supabase. Якщо Confirm email увімкнений — session буде None.
        """
        url = f"{SUPABASE_URL}/auth/v1/signup"
        payload = {"email": email.strip(), "password": password}
        params = {"redirect_to": EMAIL_CONFIRM_REDIRECT_URL} if EMAIL_CONFIRM_REDIRECT_URL else None
        r = requests.post(url, headers=self._headers(), params=params, data=_json.dumps(payload), timeout=20)
        if r.status_code >= 400:
            raise RuntimeError(r.text[:400])
        self.last_online_ok_ts = _utc_now_ts()
        return r.json()

    def resend_signup_email(self, email: str) -> None:
        """
        Повторно надсилає лист підтвердження (Supabase Auth).
        Док: supabase.auth.resend({type:'signup', email:'...'})
        """
        url = f"{SUPABASE_URL}/auth/v1/resend"
        payload = {"type": "signup", "email": email.strip()}
        params = {"redirect_to": EMAIL_CONFIRM_REDIRECT_URL} if EMAIL_CONFIRM_REDIRECT_URL else None
        r = requests.post(url, headers=self._headers(), params=params, data=_json.dumps(payload), timeout=20)
        if r.status_code >= 400:
            raise RuntimeError(r.text[:400])
        self.last_online_ok_ts = _utc_now_ts()

    # --------------------
    # Subscription
    # --------------------
    def fetch_subscription(self) -> dict | None:
        if not self.session:
            return None
        user_id = self.session.get("user_id")
        if not user_id:
            return None

        # оновлюємо JWT якщо сесія прострочена
        self._refresh_if_needed()

        url = f"{SUPABASE_URL}/rest/v1/subscriptions?user_id=eq.{_quote(user_id)}&select=*"
        r = requests.get(url, headers=self._rest_headers(self.session.get("access_token")), timeout=20)

        # Якщо токен протух — пробуємо оновити та повторити 1 раз
        if r.status_code == 401:
            if self._refresh_if_needed(force=True):
                r = requests.get(url, headers=self._rest_headers(self.session.get("access_token")), timeout=20)

        if r.status_code >= 400:
            return None
        arr = r.json() or []
        if not arr:
            return None

        self.last_online_ok_ts = _utc_now_ts()
        # кешуємо на випадок офлайну
        try:
            SUB_CACHE_FILE.write_text(_json.dumps(arr[0]), encoding="utf-8")
        except Exception:
            pass
        return arr[0]


    def load_cached_subscription(self) -> dict | None:
        try:
            if SUB_CACHE_FILE.exists():
                return _json.loads(SUB_CACHE_FILE.read_text(encoding="utf-8"))
        except Exception:
            pass
        return None


def validate_session(self) -> bool:
    """Перевіряє, що поточний access_token дійсний для цього проєкту.
    Якщо JWT невалідний/прострочений — очищає сесію і повертає False.
    """
    if not self.session:
        return False
    # Підстрахуємося рефрешем
    try:
        self._refresh_if_needed()
    except Exception:
        pass

    token = self.session.get("access_token")
    if not token:
        self.clear_session()
        return False

    url = f"{SUPABASE_URL}/auth/v1/user"
    try:
        r = requests.get(url, headers=self._headers(token), timeout=15)
    except Exception:
        # офлайн — не валимо користувача, просто лишаємо сесію як є
        return True

    if r.status_code == 200:
        self.last_online_ok_ts = _utc_now_ts()
        return True
    if r.status_code == 401:
        # Invalid JWT / expired / project mismatch
        self.clear_session()
        return False
    # інші помилки не чіпаємо
    return True

    def subscription_active(self) -> tuple[bool, str, int]:
        """
        returns (active, reason, period_end_ts)
        """
        now = _utc_now_ts()

        sub = None
        if self.is_configured() and self.session:
            try:
                sub = self.fetch_subscription()
            except Exception:
                sub = None

        # Offline fallback: cached subscription + grace window
        if sub is None:
            cached = self.load_cached_subscription() or {}
            cached_end = _parse_iso_ts(str(cached.get("current_period_end") or ""))
            if cached_end and cached_end > now and (now - int(self.last_online_ok_ts or 0) <= OFFLINE_GRACE_SECONDS):
                return True, "offline_grace", cached_end
            if cached_end:
                return False, "expired_or_offline", cached_end
            return False, "no_subscription_data", 0

        end_ts = _parse_iso_ts(str(sub.get("current_period_end") or ""))
        if end_ts and end_ts > now:
            return True, "active", end_ts
        return False, "expired", end_ts

    # --------------------
    # Payment (Edge Function)
    # --------------------
    def create_nowpayments_payment(self) -> dict:
        """
        Створює платіж у NOWPayments через Supabase Edge Function.
        Повертає: pay_address, pay_amount, pay_currency, payment_id (та ін.).
        """
        if not self.session:
            raise RuntimeError("Немає сесії.")
        # оновлюємо JWT якщо сесія прострочена
        self._refresh_if_needed()
        fn_url = self._fn_url(FN_CREATE_PAYMENT)
        payload = {
            "plan": "monthly_12",
            "price_amount": float(SUB_PRICE_USD),
            "price_currency": "usd",
            "pay_currency": NOWPAY_PAY_CURRENCY,
            "period_days": int(SUB_PERIOD_DAYS),
        }
        r = requests.post(
            fn_url,
            headers=self._headers(self.session["access_token"]),
            data=_json.dumps(payload),
            timeout=25
        )
        # Якщо токен протух — пробуємо оновити та повторити 1 раз
        if r.status_code == 401:
            if self._refresh_if_needed(force=True):
                r = requests.post(
                    fn_url,
                    headers=self._headers(self.session.get("access_token")),
                    data=_json.dumps(payload),
                    timeout=25
                )

        if r.status_code >= 400:
            raise RuntimeError(f"{r.status_code}: {r.text[:400]}")
        self.last_online_ok_ts = _utc_now_ts()
        return r.json()


# =============================================================================
# UI: Email confirm
# =============================================================================
class EmailConfirmDialog(QDialog):
    def __init__(self, mgr: AccessManager, email: str, parent=None):
        super().__init__(parent)
        self.mgr = mgr
        self.email = email.strip()
        self.setWindowTitle("Підтвердження емейлу")
        self.setModal(True)
        self.setMinimumWidth(520)

        root = QVBoxLayout(self)

        title = QLabel("Підтвердіть свій емейл")
        title.setObjectName("Title")
        subtitle = QLabel(
            "Ми надіслали лист із посиланням для підтвердження.\n"
            "Відкрийте пошту та натисніть \"Confirm\". Після цього поверніться сюди та увійдіть."
        )
        subtitle.setObjectName("Muted")
        subtitle.setWordWrap(True)

        card = _Card()
        cl = QVBoxLayout(card)
        cl.setContentsMargins(16, 16, 16, 16)

        lbl_email = QLabel(f"Email: {self.email}")
        lbl_email.setObjectName("Muted")

        self.status = QLabel("")
        self.status.setWordWrap(True)
        self.status.setObjectName("Muted")

        btn_row = QHBoxLayout()
        self.btn_resend = QPushButton("Надіслати лист ще раз")
        self.btn_resend.clicked.connect(self.on_resend)
        self.btn_close = QPushButton("Закрити")
        self.btn_close.clicked.connect(self.reject)

        btn_row.addWidget(self.btn_resend)
        btn_row.addStretch(1)
        btn_row.addWidget(self.btn_close)

        cl.addWidget(lbl_email)
        cl.addSpacing(8)
        cl.addWidget(self.status)
        cl.addSpacing(8)
        cl.addLayout(btn_row)

        root.addWidget(title)
        root.addWidget(subtitle)
        root.addSpacing(10)
        root.addWidget(card)

    def on_resend(self):
        try:
            self.mgr.resend_signup_email(self.email)
            self.status.setText("✅ Лист повторно надіслано. Перевірте 'Вхідні' та 'Спам'.")
        except Exception as e:
            self.status.setText(f"❌ Не вдалося надіслати лист: {e}")


# =============================================================================
# UI: Login / Signup
# =============================================================================
class AuthDialog(QDialog):
    def __init__(self, mgr: AccessManager, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Вхід у Tetra")
        self.mgr = mgr
        self.setModal(True)
        self.setMinimumWidth(520)

        root = QVBoxLayout(self)

        title = QLabel("Tetra")
        title.setObjectName("Title")
        subtitle = QLabel("Авторизація потрібна для запуску та доступу до підписки.")
        subtitle.setObjectName("Muted")
        subtitle.setWordWrap(True)

        tabs = QTabWidget()

        # --- Login tab
        w_login = QWidget()
        v_login = QVBoxLayout(w_login)

        card_login = _Card()
        form = QFormLayout(card_login)
        form.setContentsMargins(16, 16, 16, 16)
        form.setSpacing(10)

        self.in_email = QLineEdit()
        self.in_email.setPlaceholderText("Email")
        # Prefill email якщо вже вводили раніше
        if getattr(self.mgr, 'pref_email', ''):
            self.in_email.setText(self.mgr.pref_email)

        self.in_pass = QLineEdit()
        self.in_pass.setPlaceholderText("Пароль")
        self.in_pass.setEchoMode(QLineEdit.Password)

        self.chk_show = QCheckBox("Показати пароль")
        self.chk_show.stateChanged.connect(self._toggle_pass)


        self.chk_remember = QCheckBox("Запам’ятати вхід на цьому ПК")
        self.chk_remember.setChecked(bool(self.mgr.remember_me))

        self.btn_login = QPushButton("Увійти")
        self.btn_login.setObjectName("Primary")
        self.btn_login.clicked.connect(self.on_login)

        self.login_status = QLabel("")
        self.login_status.setWordWrap(True)
        self.login_status.setObjectName("Muted")

        form.addRow("Email", self.in_email)
        form.addRow("Пароль", self.in_pass)
        form.addRow("", self.chk_show)
        form.addRow("", self.chk_remember)

        v_login.addWidget(card_login)
        v_login.addSpacing(10)
        v_login.addWidget(self.login_status)
        v_login.addSpacing(6)

        row1 = QHBoxLayout()
        row1.addStretch(1)
        row1.addWidget(self.btn_login)
        v_login.addLayout(row1)

        # --- Signup tab
        w_signup = QWidget()
        v_signup = QVBoxLayout(w_signup)

        card_signup = _Card()
        form2 = QFormLayout(card_signup)
        form2.setContentsMargins(16, 16, 16, 16)
        form2.setSpacing(10)

        self.up_email = QLineEdit()
        self.up_email.setPlaceholderText("Email")
        self.up_pass = QLineEdit()
        self.up_pass.setPlaceholderText("Пароль (мін. 6 символів)")
        self.up_pass.setEchoMode(QLineEdit.Password)

        self.btn_signup = QPushButton("Створити акаунт")
        self.btn_signup.setObjectName("Primary")
        self.btn_signup.clicked.connect(self.on_signup)

        self.signup_status = QLabel("")
        self.signup_status.setWordWrap(True)
        self.signup_status.setObjectName("Muted")

        form2.addRow("Email", self.up_email)
        form2.addRow("Пароль", self.up_pass)

        v_signup.addWidget(card_signup)
        v_signup.addSpacing(10)
        v_signup.addWidget(self.signup_status)
        v_signup.addSpacing(6)

        row2 = QHBoxLayout()
        row2.addStretch(1)
        row2.addWidget(self.btn_signup)
        v_signup.addLayout(row2)

        tabs.addTab(w_login, "Вхід")
        tabs.addTab(w_signup, "Реєстрація")

        root.addWidget(title)
        root.addWidget(subtitle)
        root.addSpacing(8)
        root.addWidget(tabs)

    def _toggle_pass(self):
        self.in_pass.setEchoMode(QLineEdit.Normal if self.chk_show.isChecked() else QLineEdit.Password)

    def on_login(self):
        email = self.in_email.text().strip()
        pw = self.in_pass.text()

        if not email or not pw:
            self.login_status.setText("Введіть email і пароль.")
            return

        self.login_status.setText("⏳ Підключення...")
        QApplication.processEvents()

        try:
            self.mgr.login(email, pw, remember_me=self.chk_remember.isChecked())
            self.accept()
        except Exception as e:
            msg = str(e)
            # Типові тексти помилок
            if "Email not confirmed" in msg or "email not confirmed" in msg or "not confirmed" in msg:
                EmailConfirmDialog(self.mgr, email, self).exec()
                self.login_status.setText("Підтвердіть email та спробуйте увійти ще раз.")
            else:
                self.login_status.setText(f"❌ Помилка входу: {msg[:250]}")

    def on_signup(self):
        email = self.up_email.text().strip()
        pw = self.up_pass.text()

        if not email or not pw:
            self.signup_status.setText("Введіть email і пароль.")
            return
        if len(pw) < 6:
            self.signup_status.setText("Пароль має бути мінімум 6 символів.")
            return

        self.signup_status.setText("⏳ Реєстрація...")
        QApplication.processEvents()

        try:
            res = self.mgr.signup(email, pw)
            # Якщо підтвердження email увімкнено — session буде None
            sess = (res.get("session") if isinstance(res, dict) else None)
            if not sess:
                EmailConfirmDialog(self.mgr, email, self).exec()
                self.signup_status.setText("✅ Акаунт створено. Підтвердіть email та увійдіть у вкладці \"Вхід\".")
            else:
                # рідкісний випадок, коли підтвердження вимкнене: одразу логінимось
                try:
                    self.mgr.login(email, pw)
                    self.accept()
                except Exception:
                    self.signup_status.setText("✅ Акаунт створено. Тепер увійдіть у вкладці \"Вхід\".")
        except Exception as e:
            self.signup_status.setText(f"❌ Помилка реєстрації: {str(e)[:250]}")


# =============================================================================
# UI: Subscription / Payment (NOWPayments)
# =============================================================================
SUB_DIALOG_LOGOUT = 2  # QDialog.done(code) для виходу з акаунту
class SubscriptionDialog(QDialog):
    def __init__(self, mgr: AccessManager, reason: str, end_ts: int, parent=None):
        super().__init__(parent)
        self.mgr = mgr
        self.setWindowTitle("Підписка Tetra")
        self.setModal(True)
        self.setMinimumWidth(560)

        self.payment_info = None

        root = QVBoxLayout(self)

        title = QLabel("Потрібна активна підписка")
        title.setObjectName("Title")

        info = QLabel(
            f"План: $ {SUB_PRICE_USD:.2f} / 2 місяці\n"
            f"Оплата: USDT (TRC20) через NOWPayments\n\n"
            f"Статус: {reason}"
        )
        info.setWordWrap(True)
        info.setObjectName("Muted")

        card = _Card()
        card_l = QVBoxLayout(card)
        card_l.setContentsMargins(16, 16, 16, 16)
        card_l.setSpacing(10)

        self.btn_create = QPushButton("Створити платіж")
        self.btn_create.setObjectName("Primary")
        self.btn_create.clicked.connect(self.on_create_payment)

        self.status = QLabel("")
        self.status.setWordWrap(True)
        self.status.setObjectName("Muted")

        # Деталі платежу
        self.lbl_addr = QLabel("")
        self.lbl_addr.setWordWrap(True)
        self.lbl_addr.setObjectName("Muted")

        self.lbl_amount = QLabel("")
        self.lbl_amount.setWordWrap(True)
        self.lbl_amount.setObjectName("Muted")

        self.btn_copy_addr = QPushButton("Скопіювати адресу")
        self.btn_copy_addr.clicked.connect(self.copy_addr)
        self.btn_copy_amt = QPushButton("Скопіювати суму")
        self.btn_copy_amt.clicked.connect(self.copy_amt)

        self.qr = QLabel("")
        self.qr.setAlignment(Qt.AlignCenter)

        row_copy = QHBoxLayout()
        row_copy.addWidget(self.btn_copy_addr)
        row_copy.addWidget(self.btn_copy_amt)
        row_copy.addStretch(1)

        self.btn_check = QPushButton("Перевірити статус")
        self.btn_check.clicked.connect(self.check_subscription)

        self.btn_logout = QPushButton("Вийти з акаунту")
        self.btn_logout.clicked.connect(self.on_logout)

        self.btn_close = QPushButton("Закрити програму")
        self.btn_close.clicked.connect(self.reject)

        row_bottom = QHBoxLayout()
        row_bottom.addWidget(self.btn_check)
        row_bottom.addStretch(1)
        row_bottom.addWidget(self.btn_logout)
        row_bottom.addWidget(self.btn_close)

        card_l.addWidget(self.btn_create)
        card_l.addWidget(self.status)
        card_l.addSpacing(6)
        card_l.addWidget(self.lbl_addr)
        card_l.addWidget(self.lbl_amount)
        card_l.addLayout(row_copy)
        card_l.addWidget(self.qr)
        card_l.addSpacing(8)
        card_l.addLayout(row_bottom)

        root.addWidget(title)
        root.addWidget(info)
        root.addSpacing(10)
        root.addWidget(card)

        # polling
        self.timer = QTimer(self)
        self.timer.setInterval(5000)
        self.timer.timeout.connect(self.check_subscription)

        self._set_payment_widgets_visible(False)

    def _set_payment_widgets_visible(self, vis: bool):
        self.lbl_addr.setVisible(vis)
        self.lbl_amount.setVisible(vis)
        self.btn_copy_addr.setVisible(vis)
        self.btn_copy_amt.setVisible(vis)
        self.qr.setVisible(vis)

    def on_create_payment(self):
        self.status.setText("⏳ Створюємо платіж у NOWPayments...")
        QApplication.processEvents()
        try:
            info_raw = self.mgr.create_nowpayments_payment()
            # Edge Function може повертати {"ok": true, ..., "nowpayments": {...}}
            if isinstance(info_raw, dict) and isinstance(info_raw.get("nowpayments"), dict):
                meta = {k: info_raw.get(k) for k in ("user_id", "email", "plan", "period_days")}
                info = dict(info_raw["nowpayments"])
                info["_meta"] = meta
            else:
                info = info_raw if isinstance(info_raw, dict) else {}
            self.payment_info = info

            addr = (info.get("pay_address") or "").strip()
            amt = info.get("pay_amount") or info.get("price_amount") or ""
            cur = info.get("pay_currency") or info.get("payment_currency") or NOWPAY_PAY_CURRENCY

            # красивий формат суми
            if isinstance(amt, (int, float)):
                amt_str = ("%.8f" % float(amt)).rstrip("0").rstrip(".")
            else:
                amt_str = str(amt) if amt is not None else  ""

            self.lbl_addr.setText(f"Адреса для оплати:\n{addr}")
            self.lbl_amount.setText(f"Сума:\n{amt_str} {cur.upper()}")

            self._set_payment_widgets_visible(True)
            self.btn_create.setEnabled(False)

            # QR (опційно)
            try:
                import qrcode
                qr_txt = f"{cur}:{addr}?amount={amt_str}"
                img = qrcode.make(qr_txt)
                from io import BytesIO
                buf = BytesIO()
                img.save(buf, format="PNG")
                pix = QPixmap()
                pix.loadFromData(buf.getvalue(), "PNG")
                self.qr.setPixmap(pix.scaled(QSize(220, 220), Qt.KeepAspectRatio, Qt.SmoothTransformation))
            except Exception:
                self.qr.setText("")

            self.status.setText(
                "✅ Платіж створено.\n"
                "1) Відправте USDT TRC20 на адресу вище.\n"
                "2) Після підтвердження в мережі підписка активується автоматично.\n"
                "Зазвичай це займає 1–3 хвилини."
            )

            self.timer.start()
        except Exception as e:
            self.status.setText(f"❌ Не вдалося створити платіж: {str(e)[:300]}")

    def copy_addr(self):
        try:
            if not self.payment_info:
                return
            addr = self.payment_info.get("pay_address") or ""
            QApplication.clipboard().setText(addr)
        except Exception:
            pass

    def copy_amt(self):
        try:
            if not self.payment_info:
                return
            amt = str(self.payment_info.get("pay_amount") or "")
            QApplication.clipboard().setText(amt)
        except Exception:
            pass

    def check_subscription(self):
        try:
            active, _, _ = self.mgr.subscription_active()
            if active:
                self.timer.stop()
                QMessageBox.information(self, "Готово", "✅ Підписка активована. Приємної роботи!")
                self.accept()
            else:
                # не спамимо повідомленнями — просто оновлюємо рядок статусу
                if self.payment_info:
                    self.status.setText("⏳ Очікуємо підтвердження платежу... (оновлення кожні 5 секунд)")
        except Exception:
            pass


# =============================================================================
# Bootstrap / Gate
# =============================================================================
    def on_logout(self):
        """Вийти з акаунту: очистити сесію та повернутись на екран логіну."""
        try:
            self.mgr.logout()
        except Exception:
            pass
        self.done(SUB_DIALOG_LOGOUT)

def ensure_access(app: QApplication) -> bool:
    global ACCESS_SUB_ACTIVE, ACCESS_SUB_REASON, ACCESS_SUB_END_TS
    if not ACCESS_CONTROL_ENABLED:
        return True

    apply_nord_theme(app)

    mgr = AccessManagerFixed()
    if not mgr.is_configured():
        QMessageBox.critical(None, "Доступ", "Supabase не налаштований.\nПеревір SUPABASE_URL та SUPABASE_ANON_KEY.")

        return False

    # нескінченний цикл — дозволяє "Вийти з акаунту" і повернутися на логін без закриття програми
    while True:
        mgr.load_prefs()
        mgr.session = None

        # завантажуємо локальну сесію тільки якщо користувач просив "запам’ятати вхід"
        if getattr(mgr, "remember_me", True):
            mgr.load_session()

        # якщо сесія є, але токен невалідний (з іншого проєкту / протух) — очищаємо
        if mgr.session:
            if not mgr.validate_session():
                # буде показаний логін нижче
                pass

        # Якщо немає сесії — просимо увійти
        if not mgr.session:
            dlg = AuthDialog(mgr)
            if dlg.exec() != QDialog.Accepted:
                return False

        # Перевірка підписки
        active, reason, end_ts = mgr.subscription_active()
        if active:
            try:
                ACCESS_SUB_ACTIVE = True
                ACCESS_SUB_REASON = str(reason or "")
                ACCESS_SUB_END_TS = int(end_ts or 0)
            except Exception:
                pass
            return True

        dlg2 = SubscriptionDialog(mgr, reason, end_ts)
        res = dlg2.exec()
        if res == SUB_DIALOG_LOGOUT:
            # вийшли з акаунту — повертаємось на логін
            continue
        if res != QDialog.Accepted:
            return False

        active2, reason2, end_ts2 = mgr.subscription_active()
        if active2:
            try:
                ACCESS_SUB_ACTIVE = True
                ACCESS_SUB_REASON = str(reason2 or "")
                ACCESS_SUB_END_TS = int(end_ts2 or 0)
            except Exception:
                pass
            return True


def init_winsparkle():
    """
    WinSparkle update UI (опційно).
    Потрібно:
      - pip install pywinsparkle
      - winsparkle.dll додати до exe (PyInstaller)
      - APPCAST_URL має посилатися на appcast.xml
    """
    if not APPCAST_URL:
        return None
    try:
        import pywinsparkle
    except Exception:
        return None

    try:
        pywinsparkle.win_sparkle_set_appcast_url(APPCAST_URL)
        pywinsparkle.win_sparkle_set_app_details("Tetra", "Tetra", APP_VERSION)
        pywinsparkle.win_sparkle_init()
        # показує діалог сам, якщо є оновлення:
        pywinsparkle.win_sparkle_check_update_with_ui()
        return pywinsparkle
    except Exception:
        return None


# =============================================================================
def main():
    global gui_bus, _singleton_handle
    try:
        _singleton_handle = ensure_single_instance()
    except Exception:
        pass
    try:
        enable_kill_on_parent_close()
    except Exception:
        pass
    try:
        for s in (signal.SIGINT, signal.SIGTERM):
            signal.signal(s, _on_signal)
    except Exception:
        pass
    try:
        atexit.register(graceful_shutdown)
    except Exception:
        pass
    try:
        _win_set_timer_resolution(1)
    except Exception:
        pass
    # Load lightweight settings first so UI can initialize quickly
    load_settings_from_file()
    load_settings_history_from_file()
    load_pnl_snapshot_from_file()

    # Defer heavy/IO tasks so the window appears immediately
    def _post_start_services():
        try:
            # Heavy disk/CPU work -> background
            threading.Thread(target=trim_all_kline_histories, daemon=True).start()
        except Exception:
            pass
        try:
            start_telegram_thread()
        except Exception:
            pass
        try:
            start_daily_pnl_reset()
        except Exception:
            pass
        try:
            # Admin/UAC check can block; do it after UI is visible
            threading.Thread(target=ensure_admin_rights, daemon=True).start()
        except Exception:
            pass

    gui_bus = None
    try:
        if globals().get("GUI_USE_OPENGL", False):
            # На Windows краще ANGLE/OpenGLES (D3D11) -> стабільніше та швидше
            try:
                if IS_WINDOWS:
                    QApplication.setAttribute(Qt.AA_UseOpenGLES)
                else:
                    QApplication.setAttribute(Qt.AA_UseDesktopOpenGL)
            except Exception:
                QApplication.setAttribute(Qt.AA_UseDesktopOpenGL)
    except Exception:
        pass
    # Try to disable vsync (swap interval) so OpenGL widgets can render above 60 FPS
    # when the display/GPU allow it.
    try:
        if globals().get("GUI_USE_OPENGL", False):
            fmt = QSurfaceFormat()
            try:
                # Renderable type зависит от ОС
                try:
                    if IS_WINDOWS:
                        fmt.setRenderableType(QSurfaceFormat.OpenGLES)
                    else:
                        fmt.setRenderableType(QSurfaceFormat.OpenGLES if IS_WINDOWS else QSurfaceFormat.OpenGL)
                except Exception:
                    pass
            except Exception:
                pass
            try:
                fmt.setSwapInterval(0)
            except Exception:
                pass
            try:
                fmt.setSamples(0)
            except Exception:
                pass
            try:
                fmt.setDepthBufferSize(0)
            except Exception:
                pass
            try:
                fmt.setStencilBufferSize(0)
            except Exception:
                pass
            try:
                QSurfaceFormat.setDefaultFormat(fmt)
            except Exception:
                pass
    except Exception:
        pass
    app = QApplication(sys.argv)
    gui_bus = GuiBus()

    try:
        ico = _get_app_icon()
        if ico:
            app.setWindowIcon(ico)
    except Exception:
        pass
    # --- Access gate (Supabase subscription) ---
    if not ensure_access(app):
        return

    _ws = init_winsparkle()

    window = BotWindow()
    gui_bus.log_signal.connect(window.append_log)
    gui_bus.balance_signal.connect(window.set_balance_text)
    gui_bus.chart_signal.connect(window.update_chart_indicator)
    gui_bus.equity_signal.connect(window.update_equity_series)
    gui_bus.orderbook_signal.connect(window.update_orderbook_view)
    gui_bus.orderbook_render_signal.connect(window.apply_orderbook_render)
    gui_bus.orderbook_image_signal.connect(window._on_orderbook_image_ready)
    gui_bus.prints_signal.connect(window.update_prints_view)
    gui_bus.trade_journal_signal.connect(window.update_trade_journal)
    gui_bus.advisor_signal.connect(window.update_advisor_text)
    gui_bus.ws_status_signal.connect(window.update_ws_status)
    gui_bus.offset_signal.connect(window.set_offset_text)
    gui_bus.ping_signal.connect(window.set_ping_text)
    gui_bus.screenshot_signal.connect(window.capture_chart_screenshot_request)
    window.update_equity_series(list(equity_history))
    window.update_trade_journal(list(closed_trades))
    try:
        if orderbook_socket_symbol and orderbook_state.get(orderbook_socket_symbol):
            window.update_orderbook_view(orderbook_state.get(orderbook_socket_symbol))
    except Exception:
        pass
    try:
        if trade_socket_symbol and trade_prints.get(trade_socket_symbol):
            window.update_prints_view({'symbol': trade_socket_symbol, 'prints': list(trade_prints.get(trade_socket_symbol))})
    except Exception:
        pass
    try:
        window.set_offset_text(int(time_offset))
    except Exception:
        pass
    try:
        window.update_ws_status("book", ws_status.get("book", "OFF"))
        window.update_ws_status("prints", ws_status.get("prints", "OFF"))
        window.update_ws_status("chart", ws_status.get("chart", "OFF"))
    except Exception:
        pass
    # Start maximized by default (better UX than true fullscreen; keeps taskbar and window controls).
    window.show()
    try:
        if _ws and AUTO_CHECK_UPDATES_ON_START:
            QTimer.singleShot(6000, lambda: _ws.win_sparkle_check_update_with_ui())
    except Exception:
        pass
    try:
        QTimer.singleShot(350, _post_start_services)
    except Exception:
        pass
    try:
        QTimer.singleShot(0, window.showMaximized)
        QTimer.singleShot(80, window._ensure_start_maximized)
    except Exception:
        pass
    try:
        QTimer.singleShot(200, window._subscribe_book_startup)
    except Exception:
        pass
    try:
        threading.Thread(target=binance_ping_loop, daemon=True).start()
    except Exception:
        pass
    try:
        QTimer.singleShot(600, start_windows_time_sync)
    except Exception:
        pass
    # Start GPT advisor loop if enabled
    try:
        if globals().get('GPT_ENABLED'):
            threading.Thread(target=gpt_advisor_loop, daemon=True).start()
    except Exception:
        pass
    try:
        sys.exit(app.exec())
    finally:
        graceful_shutdown()





def place_hard_stop_after_fill(symbol, side_api, entry_price, position_side="BOTH", qty=None):
    """Place static STOP_MARKET (hard SL) at entry +/- HARD_SL_OFFSET_PCT via Algo API."""
    try:
        if not bool(globals().get("USE_LEGACY_POSTFILL_PIPELINE", False)):
            return None
    except Exception:
        return None
    try:
        offset = float(globals().get("HARD_SL_OFFSET_PCT", 0.0055) or 0.0055)
    except Exception:
        offset = 0.0055
    if entry_price is None or entry_price <= 0:
        return None
    try:
        current_price, _src = price_source.get_current_price(symbol, price_kind="last")
    except Exception:
        current_price = None

    raw_sl = entry_price * (1 - offset) if (side_api or '').upper() == 'BUY' else entry_price * (1 + offset)

    try:
        filt = order_placement_service._filters(symbol)
        tick = filt.get("tick", 0.0)
        step = filt.get("step", 0.0)
    except Exception:
        tick, step = 0.0, 0.0

def on_logout(self):
    """Вихід з акаунту та повернення на екран авторизації."""
    try:
        self.mgr.logout()
    except Exception:
        pass
    self.done(SUB_DIALOG_LOGOUT)

    def _round(v, s):
        if not s:
            return v
        return round(round(float(v) / s) * s, 12)

    sl_trigger = _round(raw_sl, tick)
    close_position = qty is None

    try:
        resp = order_placement_service.place_conditional({
            "kind": "SL",
            "symbol": (symbol or "").upper(),
            "side": "SELL" if (side_api or '').upper() == 'BUY' else "BUY",
            "position_side": position_side or "BOTH",
            "trigger": sl_trigger,
            "quantity": qty,
            "close_position": close_position,
            "entry_price": entry_price,
            "current_price": current_price,
            "working_type": "CONTRACT_PRICE",
        })
        if isinstance(resp, dict):
            algo_id = resp.get("algoId") or resp.get("orderId")
            if algo_id and 'pos_set' in globals():
                try:
                    pos_set(symbol, sl_order_id=algo_id)
                except Exception:
                    pass
        try:
            log_message(f"[SL INIT] {symbol} entry={entry_price:.8f} cur={(current_price or 0):.8f} hard={sl_trigger:.8f}")
        except Exception:
            pass
        return resp
    except Exception as e:
        try:
            log_message(f"[ALGO ERR] SL place failed for {symbol}: {e}")
        except Exception:
            pass
        return None


def _post_fill_pipeline(evt):
    try:
        if not bool(globals().get("USE_LEGACY_POSTFILL_PIPELINE", False)):
            return False
    except Exception:
        return False
    try:
        o = evt.get('o', {}) if isinstance(evt, dict) else {}
        sym = (o.get('s') or o.get('symbol') or "").upper()
        side = o.get('S') or o.get('side')
        pos_side = o.get('ps') or o.get('positionSide') or "BOTH"
        entry, _ = price_source.get_entry_price(evt, symbol=sym, order_id=o.get('i') or o.get('orderId'))
        if not entry or entry <= 0:
            return False
        place_hard_stop_after_fill(sym, side, entry, position_side=pos_side, qty=None)
    except Exception as e:
        try:
            log_message(f"[POST-FILL] error: {e}")
        except Exception:
            pass
    return True

# ------------------- ENTRY1 micro-confirmation helpers (compression/sweep) -------------------
_entry1_micro_last_eval = {}
_entry1_micro_cache = {}
_entry1_micro_lock = threading.Lock()


def _entry1_get_mode():
    try:
        return str(globals().get("ENTRY1_MODE", "instant") or "instant").lower().strip()
    except Exception:
        return "instant"


def _entry1_trigger_buffer_abs(price, tick):
    buf = 0.0
    try:
        ticks = float(globals().get("ENTRY1_TRIGGER_BUFFER_TICKS", 1) or 0.0)
    except Exception:
        ticks = 0.0
    try:
        pct = float(globals().get("ENTRY1_TRIGGER_BUFFER_PCT", 0.0) or 0.0)
    except Exception:
        pct = 0.0
    try:
        t = float(tick or 0.0)
    except Exception:
        t = 0.0
    try:
        p = float(price or 0.0)
    except Exception:
        p = 0.0
    try:
        if t > 0 and ticks > 0:
            buf = max(buf, t * ticks)
    except Exception:
        pass
    try:
        if pct > 0 and p > 0:
            buf = max(buf, p * pct)
    except Exception:
        pass
    return float(buf or 0.0)


def _entry1_stop_buffer_abs(price, tick):
    buf = 0.0
    try:
        ticks = float(globals().get("ENTRY1_STOP_BUFFER_TICKS", 2) or 0.0)
    except Exception:
        ticks = 0.0
    try:
        pct = float(globals().get("ENTRY1_STOP_BUFFER_PCT", 0.0) or 0.0)
    except Exception:
        pct = 0.0
    try:
        t = float(tick or 0.0)
    except Exception:
        t = 0.0
    try:
        p = float(price or 0.0)
    except Exception:
        p = 0.0
    try:
        if t > 0 and ticks > 0:
            buf = max(buf, t * ticks)
    except Exception:
        pass
    try:
        if pct > 0 and p > 0:
            buf = max(buf, p * pct)
    except Exception:
        pass
    return float(buf or 0.0)


def _entry1_passes_atr_filter(side, last_price, level, meta):
    try:
        enabled = bool(globals().get("ENTRY1_ATR_FILTER_ENABLED", True))
    except Exception:
        enabled = True
    if not enabled:
        return True
    try:
        max_mult = float(globals().get("ENTRY1_MAX_DISTANCE_ATR", 0.35) or 0.35)
    except Exception:
        max_mult = 0.35
    if not max_mult or max_mult <= 0:
        return True
    try:
        natr = float((meta or {}).get("natr") or 0.0)
    except Exception:
        natr = 0.0
    if not natr or natr <= 0:
        return True
    try:
        lp = float(last_price or 0.0)
        lvl = float(level or 0.0)
    except Exception:
        return True
    if lp <= 0 or lvl <= 0:
        return True
    try:
        atr_abs = abs(lp) * (natr / 100.0)
    except Exception:
        atr_abs = 0.0
    if atr_abs <= 0:
        return True
    try:
        dist_abs = abs(lvl - lp)
    except Exception:
        return True
    return dist_abs <= (float(max_mult) * float(atr_abs) + 1e-12)


def _entry1_micro_fetch_candles(symbol, interval, limit):
    sym = (symbol or "").upper()
    iv = str(interval or "").strip()
    try:
        lim = int(limit or 0)
    except Exception:
        lim = 0
    if not sym or not iv or lim <= 0:
        return []

    # Small in-memory cache to avoid hammering REST in monitor loop
    now = time.time()
    cache_key = (sym, iv, lim)
    ttl = 5.0

    iv_sec = None
    try:
        s = str(iv or "").strip().lower()
        n = int(s[:-1]) if len(s) >= 2 else 0
        unit = s[-1:] if s else ""
        mult = {"m": 60, "h": 3600, "d": 86400, "w": 604800}.get(unit)
        if n > 0 and mult:
            iv_sec = int(n) * int(mult)
    except Exception:
        iv_sec = None
    try:
        with _entry1_micro_lock:
            ent = _entry1_micro_cache.get(cache_key)
            if ent:
                data = ent.get("data") or []
                try:
                    next_refresh_ts = float(ent.get("next_refresh_ts") or 0.0)
                except Exception:
                    next_refresh_ts = 0.0
                # If we know the last closed candle hasn't changed yet for this interval, skip REST entirely.
                if data and next_refresh_ts and now < next_refresh_ts:
                    return data
                # Fallback TTL cache (handles unknown/invalid interval strings).
                try:
                    if data and (now - float(ent.get("ts", 0.0))) <= ttl:
                        return data
                except Exception:
                    pass
    except Exception:
        pass

    try:
        kl = signed_request(client.futures_klines, symbol=sym, interval=iv, limit=lim + 1)
    except Exception:
        kl = None
    if not kl or len(kl) < 3:
        return []

    candles = []
    # Use closed bars only (exclude the last potentially-open candle)
    for row in kl[:-1]:
        try:
            candles.append({
                "t": float(row[0]) / 1000.0,
                "o": float(row[1]),
                "h": float(row[2]),
                "l": float(row[3]),
                "c": float(row[4]),
            })
        except Exception:
            continue

    last_close_t = None
    try:
        # Close time of the last CLOSED kline (kl[-2]) in seconds.
        last_close_t = float(kl[-2][6]) / 1000.0
    except Exception:
        last_close_t = None
    next_refresh_ts = None
    try:
        if last_close_t and iv_sec:
            next_refresh_ts = float(last_close_t) + float(iv_sec)
    except Exception:
        next_refresh_ts = None

    try:
        with _entry1_micro_lock:
            _entry1_micro_cache[cache_key] = {
                "ts": now,
                "data": candles,
                "last_close_t": last_close_t,
                "next_refresh_ts": next_refresh_ts,
            }
    except Exception:
        pass
    return candles


def _entry1_pivots(values, left=2, right=2, mode="low"):
    if not values:
        return []
    try:
        left = max(int(left or 2), 0)
    except Exception:
        left = 2
    try:
        right = max(int(right or 2), 0)
    except Exception:
        right = 2
    mode_l = str(mode or "low").lower().strip()
    n = len(values)
    end = n - right
    start = left
    if end <= start:
        return []
    pts = []
    for i in range(start, end):
        w = values[i - left:i + right + 1]
        if len(w) != (left + right + 1):
            continue
        try:
            v = values[i]
            if mode_l == "low":
                if v == min(w):
                    pts.append((i, v))
            else:
                if v == max(w):
                    pts.append((i, v))
        except Exception:
            continue
    return pts


def _entry1_signal_compression(candles, side, level, last_price, interval, tick):
    if not candles or len(candles) < 20:
        return None
    try:
        lvl = float(level or 0.0)
        lp = float(last_price or 0.0)
    except Exception:
        return None
    if lvl <= 0 or lp <= 0:
        return None
    side_up = str(side or "").upper()
    if side_up not in ("BUY", "SELL"):
        return None

    highs = [c["h"] for c in candles]
    lows = [c["l"] for c in candles]

    try:
        left = int(globals().get("ENTRY1_PIVOT_LEFT", 2) or 2)
    except Exception:
        left = 2
    try:
        right = int(globals().get("ENTRY1_PIVOT_RIGHT", 2) or 2)
    except Exception:
        right = 2
    try:
        min_piv = int(globals().get("ENTRY1_MIN_PIVOTS", 3) or 3)
    except Exception:
        min_piv = 3
    min_piv = max(2, min(min_piv, 6))

    piv_lows = _entry1_pivots(lows, left=left, right=right, mode="low")
    piv_highs = _entry1_pivots(highs, left=left, right=right, mode="high")

    if side_up == "BUY":
        if len(piv_lows) < min_piv or len(piv_highs) < 1:
            return None
        last_lows = piv_lows[-min_piv:]
        try:
            if not all(float(last_lows[i][1]) < float(last_lows[i + 1][1]) for i in range(len(last_lows) - 1)):
                return None
        except Exception:
            return None
        last_hl_idx, last_hl = last_lows[-1]
        micro_high = None
        micro_idx = None
        for idx, val in reversed(piv_highs):
            if idx > last_hl_idx:
                micro_high = val
                micro_idx = idx
                break
        if micro_high is None:
            return None
        try:
            if float(micro_high) >= float(lvl):
                return None
        except Exception:
            return None
        buf = _entry1_trigger_buffer_abs(micro_high, tick)
        trigger_px = float(micro_high) + float(buf or 0.0)
        ready = float(lp) >= float(trigger_px)
        return {
            "kind": "compression",
            "interval": str(interval),
            "ready": bool(ready),
            "trigger": float(trigger_px),
            "stop_anchor": float(last_hl),
            "micro_level": float(micro_high),
            "micro_idx": int(micro_idx) if micro_idx is not None else None,
        }

    # SELL compression: LH series above support, trigger on micro-low break, stop above last LH.
    if len(piv_highs) < min_piv or len(piv_lows) < 1:
        return None
    last_highs = piv_highs[-min_piv:]
    try:
        if not all(float(last_highs[i][1]) > float(last_highs[i + 1][1]) for i in range(len(last_highs) - 1)):
            return None
    except Exception:
        return None
    last_lh_idx, last_lh = last_highs[-1]
    micro_low = None
    micro_idx = None
    for idx, val in reversed(piv_lows):
        if idx > last_lh_idx:
            micro_low = val
            micro_idx = idx
            break
    if micro_low is None:
        return None
    try:
        if float(micro_low) <= float(lvl):
            return None  # already at/below support -> not "inside compression"
    except Exception:
        return None
    buf = _entry1_trigger_buffer_abs(micro_low, tick)
    trigger_px = float(micro_low) - float(buf or 0.0)
    ready = float(lp) <= float(trigger_px)
    return {
        "kind": "compression",
        "interval": str(interval),
        "ready": bool(ready),
        "trigger": float(trigger_px),
        "stop_anchor": float(last_lh),
        "micro_level": float(micro_low),
        "micro_idx": int(micro_idx) if micro_idx is not None else None,
    }


def _entry1_signal_swing(candles, side, level, last_price, interval, tick):
    if not candles or len(candles) < 12:
        return None
    try:
        lvl = float(level or 0.0)
        lp = float(last_price or 0.0)
    except Exception:
        return None
    if lvl <= 0 or lp <= 0:
        return None
    side_up = str(side or "").upper()
    if side_up not in ("BUY", "SELL"):
        return None

    highs = [c["h"] for c in candles]
    lows = [c["l"] for c in candles]

    try:
        left = int(globals().get("ENTRY1_PIVOT_LEFT", 2) or 2)
    except Exception:
        left = 2
    try:
        right = int(globals().get("ENTRY1_PIVOT_RIGHT", 2) or 2)
    except Exception:
        right = 2

    piv_lows = _entry1_pivots(lows, left=left, right=right, mode="low")
    piv_highs = _entry1_pivots(highs, left=left, right=right, mode="high")
    if not piv_lows or not piv_highs:
        return None

    if side_up == "BUY":
        swing_low = None
        swing_high = None
        swing_low_idx = None
        swing_high_idx = None
        for h_idx, h_val in reversed(piv_highs):
            try:
                if float(h_val) >= float(lvl):
                    continue
            except Exception:
                continue
            low_idx = None
            low_val = None
            for l_idx, l_val in reversed(piv_lows):
                if l_idx < h_idx:
                    low_idx = l_idx
                    low_val = l_val
                    break
            if low_idx is None:
                continue
            swing_low = low_val
            swing_high = h_val
            swing_low_idx = low_idx
            swing_high_idx = h_idx
            break

        if swing_high is None or swing_low is None:
            return None
        buf = _entry1_trigger_buffer_abs(swing_high, tick)
        trigger_px = float(swing_high) + float(buf or 0.0)
        if trigger_px <= 0 or trigger_px >= float(lvl):
            return None
        ready = float(lp) >= float(trigger_px)
        return {
            "kind": "swing",
            "interval": str(interval),
            "ready": bool(ready),
            "trigger": float(trigger_px),
            "stop_anchor": float(swing_low),
            "micro_level": float(swing_high),
            "swing_low": float(swing_low),
            "swing_high": float(swing_high),
            "swing_low_idx": int(swing_low_idx) if swing_low_idx is not None else None,
            "swing_high_idx": int(swing_high_idx) if swing_high_idx is not None else None,
        }

    # SELL swing: break the swing low after a swing high.
    swing_low = None
    swing_high = None
    swing_low_idx = None
    swing_high_idx = None
    for l_idx, l_val in reversed(piv_lows):
        try:
            if float(l_val) <= float(lvl):
                continue
        except Exception:
            continue
        high_idx = None
        high_val = None
        for h_idx, h_val in reversed(piv_highs):
            if h_idx < l_idx:
                high_idx = h_idx
                high_val = h_val
                break
        if high_idx is None:
            continue
        swing_low = l_val
        swing_high = high_val
        swing_low_idx = l_idx
        swing_high_idx = high_idx
        break

    if swing_low is None or swing_high is None:
        return None
    buf = _entry1_trigger_buffer_abs(swing_low, tick)
    trigger_px = float(swing_low) - float(buf or 0.0)
    if trigger_px <= 0 or trigger_px <= float(lvl):
        return None
    ready = float(lp) <= float(trigger_px)
    return {
        "kind": "swing",
        "interval": str(interval),
        "ready": bool(ready),
        "trigger": float(trigger_px),
        "stop_anchor": float(swing_high),
        "micro_level": float(swing_low),
        "swing_low": float(swing_low),
        "swing_high": float(swing_high),
        "swing_low_idx": int(swing_low_idx) if swing_low_idx is not None else None,
        "swing_high_idx": int(swing_high_idx) if swing_high_idx is not None else None,
    }


def _entry1_signal_sweep(candles, side, level, last_price, interval, tick, atr_abs):
    if not candles or len(candles) < 25:
        return None
    try:
        lp = float(last_price or 0.0)
    except Exception:
        return None
    if lp <= 0:
        return None

    side_up = str(side or "").upper()
    if side_up not in ("BUY", "SELL"):
        return None

    highs = [c["h"] for c in candles]
    lows = [c["l"] for c in candles]
    closes = [c["c"] for c in candles]
    try:
        win = int(globals().get("ENTRY1_SWEEP_WINDOW", 12) or 12)
    except Exception:
        win = 12
    win = max(5, min(win, max(5, len(candles) - 5)))
    if win >= len(candles) - 3:
        return None

    ref_highs = highs[:-win]
    ref_lows = lows[:-win]
    if not ref_highs or not ref_lows:
        return None

    # Minimum sweep size: fraction of ATR, with tick fallback.
    min_break = 0.0
    try:
        min_break = abs(float(atr_abs or 0.0)) * float(globals().get("ENTRY1_SWEEP_MIN_BREAK_ATR", 0.10) or 0.10)
    except Exception:
        min_break = 0.0
    try:
        t = float(tick or 0.0)
        if t > 0:
            min_break = max(min_break, t * 2.0)
    except Exception:
        pass

    if side_up == "BUY":
        ref_low = min(ref_lows)
        sweep_low = min(lows[-win:])
        try:
            if (float(ref_low) - float(sweep_low)) < float(min_break):
                return None
        except Exception:
            return None
        buf = _entry1_trigger_buffer_abs(ref_low, tick)
        reclaim_px = float(ref_low) + float(buf or 0.0)
        last_close = closes[-1]
        ready = float(lp) >= float(reclaim_px) and float(last_close) >= float(ref_low)
        return {
            "kind": "sweep",
            "interval": str(interval),
            "ready": bool(ready),
            "trigger": float(reclaim_px),
            "stop_anchor": float(sweep_low),
            "ref_level": float(ref_low),
            "sweep_level": float(sweep_low),
        }

    ref_high = max(ref_highs)
    sweep_high = max(highs[-win:])
    try:
        if (float(sweep_high) - float(ref_high)) < float(min_break):
            return None
    except Exception:
        return None
    buf = _entry1_trigger_buffer_abs(ref_high, tick)
    reclaim_px = float(ref_high) - float(buf or 0.0)
    last_close = closes[-1]
    ready = float(lp) <= float(reclaim_px) and float(last_close) <= float(ref_high)
    return {
        "kind": "sweep",
        "interval": str(interval),
        "ready": bool(ready),
        "trigger": float(reclaim_px),
        "stop_anchor": float(sweep_high),
        "ref_level": float(ref_high),
        "sweep_level": float(sweep_high),
    }


def _entry1_signal_range(candles, side, level, last_price, interval, tick):
    """Simple micro-range breakout fallback (always available when candles exist)."""
    if not candles or len(candles) < 8:
        return None
    try:
        lvl = float(level or 0.0)
        lp = float(last_price or 0.0)
    except Exception:
        return None
    if lvl <= 0 or lp <= 0:
        return None
    side_up = str(side or "").upper()
    if side_up not in ("BUY", "SELL"):
        return None

    try:
        win = int(globals().get("ENTRY1_RANGE_WINDOW", 12) or 12)
    except Exception:
        win = 12
    win = max(5, min(win, len(candles)))

    seg = candles[-win:]
    highs = [c.get("h") for c in seg]
    lows = [c.get("l") for c in seg]
    try:
        highs = [float(x) for x in highs if x not in (None, "", 0, False)]
        lows = [float(x) for x in lows if x not in (None, "", 0, False)]
    except Exception:
        return None
    if not highs or not lows:
        return None
    try:
        r_hi = float(max(highs))
        r_lo = float(min(lows))
    except Exception:
        return None
    if r_hi <= 0 or r_lo <= 0:
        return None

    try:
        t = float(tick or 0.0)
    except Exception:
        t = 0.0
    lvl_buf = 0.0
    try:
        lvl_buf = float(_entry1_trigger_buffer_abs(lvl, tick) or 0.0)
    except Exception:
        lvl_buf = 0.0
    if lvl_buf <= 0:
        lvl_buf = t if t > 0 else abs(float(lvl)) * 0.0001

    if side_up == "BUY":
        buf = _entry1_trigger_buffer_abs(r_hi, tick)
        trigger_px = float(r_hi) + float(buf or 0.0)
        # Keep ENTRY1 pre-breakout (do not cross the main level here).
        if trigger_px >= float(lvl):
            trigger_px = float(lvl) - float(lvl_buf)
        if trigger_px <= 0:
            return None
        ready = float(lp) >= float(trigger_px)
        return {
            "kind": "range",
            "interval": str(interval),
            "ready": bool(ready),
            "trigger": float(trigger_px),
            "stop_anchor": float(r_lo),
            "micro_level": float(r_hi),
            "range_high": float(r_hi),
            "range_low": float(r_lo),
        }

    buf = _entry1_trigger_buffer_abs(r_lo, tick)
    trigger_px = float(r_lo) - float(buf or 0.0)
    # Keep ENTRY1 pre-breakout (do not cross the main level here).
    if trigger_px <= float(lvl):
        trigger_px = float(lvl) + float(lvl_buf)
    if trigger_px <= 0:
        return None
    ready = float(lp) <= float(trigger_px)
    return {
        "kind": "range",
        "interval": str(interval),
        "ready": bool(ready),
        "trigger": float(trigger_px),
        "stop_anchor": float(r_hi),
        "micro_level": float(r_lo),
        "range_high": float(r_hi),
        "range_low": float(r_lo),
    }


def _entry1_select_signal(symbol, meta, last_price, tick, require_ready=True):
    try:
        side = str((meta or {}).get("stop_side") or "").upper()
        level = float((meta or {}).get("level") or 0.0)
    except Exception:
        return None
    if side not in ("BUY", "SELL") or not level or level <= 0:
        return None
    try:
        lp = float(last_price or 0.0)
    except Exception:
        return None
    if lp <= 0:
        return None

    # ATR removed: detect micro formations without NATR/ATR gating.
    atr_abs = None

    try:
        intervals = globals().get("ENTRY1_MICRO_INTERVALS") or ("1m", "3m")
    except Exception:
        intervals = ("1m", "3m")
    if isinstance(intervals, str):
        intervals = [intervals]

    try:
        lookback = int(globals().get("ENTRY1_MICRO_LOOKBACK", 90) or 90)
    except Exception:
        lookback = 90
    lookback = max(30, min(lookback, 400))

    try:
        prefer_sweep = bool(globals().get("ENTRY1_PREFER_SWEEP", True))
    except Exception:
        prefer_sweep = True
    try:
        swing_enabled = bool(globals().get("ENTRY1_SWING_ENABLED", True))
    except Exception:
        swing_enabled = True
    try:
        swing_intervals = globals().get("ENTRY1_SWING_INTERVALS") or ("1m",)
    except Exception:
        swing_intervals = ("1m",)
    if isinstance(swing_intervals, str):
        swing_intervals = [swing_intervals]

    best = None
    best_score = None

    def _consider(sig):
        nonlocal best, best_score
        if not sig:
            return None
        try:
            sig["side"] = side
            sig["level"] = float(level)
        except Exception:
            pass
        ready = False
        try:
            ready = bool(sig.get("ready"))
        except Exception:
            ready = False

        if require_ready:
            if ready:
                return sig
            return None

        kind = ""
        try:
            kind = str(sig.get("kind") or "").lower().strip()
        except Exception:
            kind = ""
        kind_rank = 4
        if kind == "swing":
            kind_rank = 0
        elif kind == "sweep":
            kind_rank = 1 if prefer_sweep else 2
        elif kind == "compression":
            kind_rank = 2 if prefer_sweep else 1
        elif kind == "range":
            kind_rank = 3
        elif kind in ("prelevel", "fallback"):
            kind_rank = 4

        dist = float("inf")
        try:
            trig = float(sig.get("trigger") or 0.0)
            if trig > 0:
                dist = abs(float(trig) - float(lp))
        except Exception:
            dist = float("inf")

        score = (0 if (not ready) else 1, int(kind_rank), float(dist))
        if best is None or best_score is None:
            best, best_score = sig, score
        else:
            try:
                if score < best_score:
                    best, best_score = sig, score
            except Exception:
                pass
        return None

    if swing_enabled:
        for iv in swing_intervals:
            candles = _entry1_micro_fetch_candles(symbol, iv, lookback)
            if not candles:
                continue
            sig = _entry1_signal_swing(candles, side, level, lp, iv, tick)
            out = _consider(sig)
            if out:
                return out

    for iv in intervals:
        candles = _entry1_micro_fetch_candles(symbol, iv, lookback)
        if not candles:
            continue
        if prefer_sweep:
            sig = _entry1_signal_sweep(candles, side, level, lp, iv, tick, atr_abs)
            out = _consider(sig)
            if out:
                return out
        sig2 = _entry1_signal_compression(candles, side, level, lp, iv, tick)
        out = _consider(sig2)
        if out:
            return out
        sig3 = _entry1_signal_range(candles, side, level, lp, iv, tick)
        out = _consider(sig3)
        if out:
            return out
        if (not prefer_sweep):
            sig = _entry1_signal_sweep(candles, side, level, lp, iv, tick, atr_abs)
            out = _consider(sig)
            if out:
                return out
    if require_ready:
        return None
    # If we didn't detect any micro formation in candles, still place ENTRY1:
    # assume a "micro range" right around the main level.
    if best is None:
        try:
            t = float(tick or 0.0)
        except Exception:
            t = 0.0
        buf_lvl = 0.0
        try:
            buf_lvl = float(_entry1_trigger_buffer_abs(level, tick) or 0.0)
        except Exception:
            buf_lvl = 0.0
        if buf_lvl <= 0:
            if t > 0:
                buf_lvl = t
            else:
                buf_lvl = abs(float(level)) * 0.0001
        try:
            if side == "BUY":
                trig_lvl = float(level) - float(buf_lvl)
                ready_lvl = float(lp) >= float(trig_lvl)
            else:
                trig_lvl = float(level) + float(buf_lvl)
                ready_lvl = float(lp) <= float(trig_lvl)
            if trig_lvl > 0:
                best = {
                    "kind": "prelevel",
                    "interval": "pre",
                    "ready": bool(ready_lvl),
                    "trigger": float(trig_lvl),
                    "stop_anchor": float(level),
                    "ref_level": float(level),
                }
        except Exception:
            best = None
    return best


def _entry1_stop_from_anchor(side, anchor, tick, price_prec):
    try:
        side_up = str(side or "").upper()
        a = float(anchor or 0.0)
    except Exception:
        return None
    if a <= 0 or side_up not in ("BUY", "SELL"):
        return None
    buf = _entry1_stop_buffer_abs(a, tick)
    if side_up == "BUY":
        raw = float(a) - float(buf or 0.0)
        try:
            return _floor_to_tick(raw, tick, price_prec)
        except Exception:
            return raw
    raw = float(a) + float(buf or 0.0)
    try:
        return _ceil_to_tick(raw, tick, price_prec)
    except Exception:
        return raw


def _maybe_trigger_entry1_micro(symbol, last_price):
    sym = (symbol or "").upper()
    if not sym:
        return False

    now = time.time()
    with orders_lock:
        meta = copy.deepcopy(pending_meta.get(sym) or {})

    if not isinstance(meta, dict) or not meta:
        return False

    # Per-order mode first (sticky for the setup), global ENTRY1_MODE is fallback.
    mode = ""
    try:
        mode = str((meta or {}).get("entry1_mode") or "").lower().strip()
    except Exception:
        mode = ""
    if not mode:
        try:
            mode = str(globals().get("ENTRY1_MODE", "micro") or "micro").lower().strip()
        except Exception:
            mode = "micro"
    use_pending = bool(mode in ("micro_pending", "pending", "stop_pending"))
    if mode not in ("micro", "confirm", "pattern", "micro_pending", "pending", "stop_pending"):
        return False

    # If disabled (expired/manual), never trigger ENTRY1; keep only ENTRY2.
    try:
        if _to_bool(meta.get("entry1_disabled")):
            # Best-effort: cancel any previously placed ENTRY1 pending order.
            try:
                e1_oid = meta.get("entry1_order_id")
            except Exception:
                e1_oid = None
            if e1_oid not in (None, "", 0, False):
                try:
                    signed_request(client.futures_cancel_order, symbol=sym, orderId=e1_oid)
                except Exception:
                    try:
                        cancel_conditional_order(sym, e1_oid)
                    except Exception:
                        pass
                try:
                    with orders_lock:
                        pm = pending_meta.get(sym)
                        if isinstance(pm, dict):
                            pm.pop("entry1_order_id", None)
                            pm["entry1_sent"] = False
                            pm["entry1_armed"] = False
                            pending_meta[sym] = pm
                except Exception:
                    pass
            return False
    except Exception:
        pass

    try:
        if not bool(meta.get("dual_entry")):
            return False
    except Exception:
        return False

    # ENTRY1 expiration: disable micro-trigger if it didn't fire in time after arming.
    try:
        expire_sec = float(globals().get("ENTRY1_EXPIRE_SEC", 900) or 900)
    except Exception:
        expire_sec = 900.0
    if expire_sec and float(expire_sec) > 0:
        try:
            armed_ts = float(meta.get("entry1_armed_ts") or 0.0)
        except Exception:
            armed_ts = 0.0
        if armed_ts and (now - armed_ts) > float(expire_sec):
            try:
                # Cancel an already placed ENTRY1 pending order (if any) to avoid a late unexpected entry.
                e1_oid = None
                try:
                    e1_oid = meta.get("entry1_order_id")
                except Exception:
                    e1_oid = None
                if e1_oid not in (None, "", 0, False):
                    try:
                        signed_request(client.futures_cancel_order, symbol=sym, orderId=e1_oid)
                    except Exception:
                        try:
                            cancel_conditional_order(sym, e1_oid)
                        except Exception:
                            pass
                with orders_lock:
                    pm = pending_meta.get(sym)
                    if isinstance(pm, dict):
                        pm["entry1_disabled"] = True
                        pm["entry1_armed"] = False
                        pm["entry1_expired_ts"] = now
                        pm["entry1_sent"] = False
                        pm.pop("entry1_order_id", None)
                        pending_meta[sym] = pm
            except Exception:
                pass
            try:
                log_message(f"[ENTRY1] expired {sym}: leaving only ENTRY2 (age={int(now-armed_ts)}s > {int(expire_sec)}s)")
            except Exception:
                pass
            return False

    # Throttle per-symbol evaluations (REST-heavy).
    min_gap = 5.0
    try:
        with _entry1_micro_lock:
            last_ts = float(_entry1_micro_last_eval.get(sym, 0.0) or 0.0)
            if last_ts and (now - last_ts) < float(min_gap):
                return False
            _entry1_micro_last_eval[sym] = now
    except Exception:
        pass

    # Don't place if a position is already opened (ENTRY1 should happen before ENTRY2).
    entry1_sent = False
    try:
        entry1_sent = _to_bool(meta.get("entry1_sent"))
    except Exception:
        entry1_sent = False
    entry1_oid = None
    try:
        entry1_oid = meta.get("entry1_order_id")
    except Exception:
        entry1_oid = None
    try:
        if abs(float((pos_get(sym) or {}).get("qty") or 0.0)) > eps:
            # Safety: if a position is already open, cancel any stale ENTRY1 pending stop to prevent an add-on.
            if use_pending and entry1_oid not in (None, "", 0, False):
                try:
                    signed_request(client.futures_cancel_order, symbol=sym, orderId=entry1_oid)
                except Exception:
                    try:
                        cancel_conditional_order(sym, entry1_oid)
                    except Exception:
                        pass
                try:
                    remove_order_rows(
                        lambda row, s=sym: row.get("symbol") == s and str(row.get("tp_sl") or "").startswith("ENTRY1_STOP")
                    )
                except Exception:
                    pass
                try:
                    with orders_lock:
                        pm = pending_meta.get(sym)
                        if isinstance(pm, dict):
                            pm["entry1_sent"] = False
                            pm.pop("entry1_order_id", None)
                            pending_meta[sym] = pm
                except Exception:
                    pass
            return False
    except Exception:
        pass

    if entry1_sent and (not use_pending):
        return False

    try:
        qty = float(meta.get("entry1_qty") or 0.0)
    except Exception:
        qty = 0.0
    if qty <= eps:
        return False

    try:
        side = str(meta.get("stop_side") or "").upper()
        level = float(meta.get("level") or 0.0)
        lp = float(last_price or 0.0)
    except Exception:
        return False
    if side not in ("BUY", "SELL") or level <= 0 or lp <= 0:
        return False

    # micro_pending: if ENTRY1 was already sent but orderId is missing, attempt to recover it from open orders.
    if use_pending and entry1_sent and entry1_oid in (None, "", 0, False):
        recovered = None
        try:
            entry2_oid = None
            try:
                entry2_oid = meta.get("entry2_order_id")
            except Exception:
                entry2_oid = None
            if entry2_oid in (None, "", 0, False):
                try:
                    with orders_lock:
                        entry2_oid = active_orders.get(sym)
                except Exception:
                    entry2_oid = None

            stop_hint = None
            try:
                sig_hint = meta.get("entry1_signal")
                if isinstance(sig_hint, dict):
                    stop_hint = sig_hint.get("pending_stop")
            except Exception:
                stop_hint = None
            try:
                stop_hint = float(stop_hint) if stop_hint not in (None, "", 0, False) else None
            except Exception:
                stop_hint = None

            qty_tol = max(abs(float(qty)) * 0.005, eps * 10.0, 1e-8)
            oo = signed_request(client.futures_get_open_orders, symbol=sym)
            candidates = []
            for o in (oo or []):
                try:
                    if str(o.get("type") or "").upper() != "STOP_MARKET":
                        continue
                    if str(o.get("side") or "").upper() != side:
                        continue
                    oid = o.get("orderId")
                    if entry2_oid not in (None, "", 0, False) and oid not in (None, "", 0, False) and str(oid) == str(entry2_oid):
                        continue
                    if _to_bool(o.get("reduceOnly")) or _to_bool(o.get("closePosition")):
                        continue
                    try:
                        oq = abs(float(o.get("origQty") or o.get("quantity") or 0.0))
                    except Exception:
                        oq = 0.0
                    if oq <= eps or abs(float(oq) - float(qty)) > float(qty_tol):
                        continue
                    try:
                        sp = float(o.get("stopPrice") or 0.0)
                    except Exception:
                        sp = 0.0
                    if sp <= 0:
                        continue
                    dist = None
                    try:
                        if stop_hint is not None:
                            dist = abs(float(sp) - float(stop_hint))
                    except Exception:
                        dist = None
                    candidates.append((dist, o))
                except Exception:
                    continue
            if candidates:
                candidates.sort(key=lambda x: (float("inf") if x[0] is None else float(x[0])))
                recovered = (candidates[0][1] or {}).get("orderId")
        except Exception:
            recovered = None

        if recovered not in (None, "", 0, False):
            try:
                entry1_oid = int(recovered)
            except Exception:
                entry1_oid = recovered
            try:
                with orders_lock:
                    pm = pending_meta.get(sym)
                    if isinstance(pm, dict):
                        pm["entry1_order_id"] = entry1_oid
                        pending_meta[sym] = pm
            except Exception:
                pass
            try:
                log_message(f"[ENTRY1] recovered open STOP_MARKET for {sym}: orderId={entry1_oid}")
            except Exception:
                pass
        else:
            # Avoid duplicates: wait a bit, then allow re-arm if the orderId never arrives.
            try:
                sent_ts = float(meta.get("entry1_sent_ts") or 0.0)
            except Exception:
                sent_ts = 0.0
            if sent_ts and (now - sent_ts) < 10.0:
                return False
            try:
                with orders_lock:
                    pm = pending_meta.get(sym)
                    if isinstance(pm, dict):
                        pm["entry1_sent"] = False
                        pm.pop("entry1_order_id", None)
                        pending_meta[sym] = pm
                entry1_sent = False
                entry1_oid = None
            except Exception:
                return False

    # If main level is already crossed, ENTRY1 still must be placed,
    # but it becomes a MARKET entry (by fact of micro-breakout).
    broke = False
    try:
        if side == "BUY" and lp >= level:
            broke = True
        if side == "SELL" and lp <= level:
            broke = True
    except Exception:
        broke = True

    # Symbol filters for tick/precision.
    try:
        filt = order_placement_service._filters(sym)
        tick = float(filt.get("tick", 0.0) or 0.0)
        price_prec = int(filt.get("price_prec", 8) or 8)
    except Exception:
        tick = 0.0
        price_prec = 8

    sig = _entry1_select_signal(sym, meta, lp, tick, require_ready=(not use_pending))
    if not sig:
        return False

    micro_ready = False
    try:
        micro_ready = _to_bool(sig.get("ready"))
    except Exception:
        micro_ready = False
    if broke:
        micro_ready = True

    stop_anchor = sig.get("stop_anchor")
    sl_plan = _entry1_stop_from_anchor(side, stop_anchor, tick, price_prec)
    if not sl_plan or float(sl_plan) <= 0:
        return False

    order_type = "STOP_MARKET" if (use_pending and (not micro_ready)) else "MARKET"
    pending_stop_px = None
    if order_type == "STOP_MARKET":
        try:
            trig = float(sig.get("trigger") or 0.0)
        except Exception:
            trig = 0.0
        if trig <= 0:
            return False
        try:
            if side == "BUY":
                pending_stop_px = _ceil_to_tick(trig, tick, price_prec)
            else:
                pending_stop_px = _floor_to_tick(trig, tick, price_prec)
        except Exception:
            pending_stop_px = trig
        if pending_stop_px is None or float(pending_stop_px) <= 0:
            order_type = "MARKET"
            pending_stop_px = None
        # Ensure the pending stop is still pre-breakout (ENTRY1 must not trigger at/after the main level).
        if order_type == "STOP_MARKET":
            try:
                if side == "BUY" and float(pending_stop_px) >= float(level):
                    order_type = "MARKET"
                    pending_stop_px = None
                elif side == "SELL" and float(pending_stop_px) <= float(level):
                    order_type = "MARKET"
                    pending_stop_px = None
            except Exception:
                order_type = "MARKET"
                pending_stop_px = None
        # If the stop would immediately trigger, switch to MARKET (ENTRY1 must always be placed).
        if order_type == "STOP_MARKET":
            try:
                if side == "BUY" and float(pending_stop_px) <= float(lp):
                    order_type = "MARKET"
                    pending_stop_px = None
                elif side == "SELL" and float(pending_stop_px) >= float(lp):
                    order_type = "MARKET"
                    pending_stop_px = None
            except Exception:
                order_type = "MARKET"
                pending_stop_px = None

    # micro_pending: if an ENTRY1 STOP_MARKET is already placed, optionally cancel/replace it when the trigger changes.
    if use_pending and entry1_sent:
        if entry1_oid in (None, "", 0, False):
            return False

        existing = None
        try:
            existing = signed_request(client.futures_get_order, symbol=sym, orderId=entry1_oid)
        except BinanceAPIException as be:
            code = getattr(be, "code", None)
            msg = str(be).lower()
            if code in (-2013, -2011) or "unknown order" in msg:
                existing = None
            else:
                existing = None
        except Exception:
            existing = None

        if not isinstance(existing, dict) or not existing:
            # If the order is unknown but a position is already open, do nothing (avoid duplicates).
            try:
                exch_amt, _ = get_exchange_position(sym)
                if abs(float(exch_amt or 0.0)) > eps:
                    return False
            except Exception:
                pass
            # Otherwise, clear local tracking and fall through to re-place.
            try:
                with orders_lock:
                    pm = pending_meta.get(sym)
                    if isinstance(pm, dict):
                        pm["entry1_sent"] = False
                        pm.pop("entry1_order_id", None)
                        pending_meta[sym] = pm
                entry1_sent = False
                entry1_oid = None
            except Exception:
                return False
        else:
            try:
                ex_status = str(existing.get("status") or "").upper()
            except Exception:
                ex_status = ""
            try:
                ex_type = str(existing.get("type") or "").upper()
            except Exception:
                ex_type = ""

            if ex_status == "FILLED":
                try:
                    _emit_rest_fill_event(sym, existing, status_hint=ex_status)
                except Exception:
                    pass
                return False
            if ex_status in ("CANCELED", "EXPIRED", "REJECTED"):
                try:
                    with orders_lock:
                        pm = pending_meta.get(sym)
                        if isinstance(pm, dict):
                            pm["entry1_sent"] = False
                            pm.pop("entry1_order_id", None)
                            pending_meta[sym] = pm
                    entry1_sent = False
                    entry1_oid = None
                except Exception:
                    return False
            elif ex_type != "STOP_MARKET" or ex_status not in ("NEW", "PENDING_CANCEL"):
                # Not an open STOP_MARKET entry -> never attempt to place another one.
                return False
            else:
                # Open STOP_MARKET exists: update only when stopPrice meaningfully changed.
                cur_stop = 0.0
                try:
                    cur_stop = float(existing.get("stopPrice") or 0.0)
                except Exception:
                    cur_stop = 0.0
                if cur_stop <= 0:
                    return False

                # If new evaluation suggests MARKET, cancel the stop and execute now.
                if order_type != "STOP_MARKET":
                    canceled_ok = False
                    try:
                        signed_request(client.futures_cancel_order, symbol=sym, orderId=entry1_oid)
                        canceled_ok = True
                    except Exception:
                        canceled_ok = False
                    if not canceled_ok:
                        try:
                            chk = signed_request(client.futures_get_order, symbol=sym, orderId=entry1_oid)
                            st_chk = str((chk or {}).get("status") or "").upper()
                            if st_chk == "FILLED":
                                try:
                                    _emit_rest_fill_event(sym, chk, status_hint=st_chk)
                                except Exception:
                                    pass
                                return False
                            if st_chk in ("CANCELED", "EXPIRED", "REJECTED"):
                                canceled_ok = True
                        except Exception:
                            canceled_ok = False
                    if not canceled_ok:
                        return False

                    try:
                        remove_order_rows(
                            lambda row, s=sym: row.get("symbol") == s and str(row.get("tp_sl") or "").startswith("ENTRY1_STOP")
                        )
                    except Exception:
                        pass

                    # Update plan before MARKET send (avoid FILLED race).
                    try:
                        with orders_lock:
                            pm = pending_meta.get(sym)
                            if isinstance(pm, dict):
                                pm["entry1_hard_sl_trigger"] = float(sl_plan)
                                pm["entry1_hard_sl_source"] = f"entry1:{sig.get('kind')}:{sig.get('interval')}"
                                pm["entry1_sent"] = True
                                pm["entry1_sent_ts"] = time.time()
                                pm["entry1_anchor_price"] = float(lp) if lp not in (None, "", 0, False) else pm.get("entry1_anchor_price")
                                pm["entry1_armed"] = False
                                pm["entry1_signal"] = {
                                    "kind": sig.get("kind"),
                                    "interval": sig.get("interval"),
                                    "trigger": sig.get("trigger"),
                                    "pending_stop": None,
                                    "order_type": "MARKET",
                                    "stop_anchor": stop_anchor,
                                    "micro_level": sig.get("micro_level"),
                                    "ref_level": sig.get("ref_level"),
                                    "sweep_level": sig.get("sweep_level"),
                                    "ts": time.time(),
                                }
                                pm.pop("entry1_order_id", None)
                                pm["entry1_replace_ts"] = time.time()
                                pending_meta[sym] = pm
                    except Exception:
                        pass

                    try:
                        resp_now = signed_request(
                            client.futures_create_order,
                            symbol=sym,
                            side=side,
                            type="MARKET",
                            quantity=qty,
                        )
                        try:
                            if isinstance(resp_now, dict) and resp_now.get("orderId") not in (None, "", 0, False):
                                with orders_lock:
                                    pm = pending_meta.get(sym)
                                    if isinstance(pm, dict):
                                        pm["entry1_order_id"] = int(resp_now.get("orderId"))
                                        pending_meta[sym] = pm
                        except Exception:
                            pass
                        try:
                            add_order_row(sym, side, qty, lp, f"ENTRY1:{sig.get('kind')}")
                        except Exception:
                            pass
                        try:
                            log_message(f"[ENTRY1] REPLACE->MARKET {sym} side={side} qty={qty} resp={resp_now}")
                        except Exception:
                            pass
                        return True
                    except Exception:
                        return False

                # STOP->STOP replace path
                if pending_stop_px is None:
                    return False
                new_stop = float(pending_stop_px)
                diff = abs(float(new_stop) - float(cur_stop))
                try:
                    min_ticks = float(globals().get("ENTRY1_PENDING_REPLACE_TICKS", 1) or 1)
                except Exception:
                    min_ticks = 1.0
                try:
                    t = float(tick or 0.0)
                except Exception:
                    t = 0.0
                if t > 0 and diff < (t * float(min_ticks) - 1e-12):
                    return False
                if t <= 0 and diff <= 1e-12:
                    return False

                try:
                    min_gap_replace = float(globals().get("ENTRY1_PENDING_REPLACE_MIN_GAP", 15) or 15)
                except Exception:
                    min_gap_replace = 15.0
                try:
                    last_rep = float(meta.get("entry1_replace_ts") or 0.0)
                except Exception:
                    last_rep = 0.0
                if last_rep and (now - last_rep) < float(min_gap_replace):
                    return False

                canceled_ok = False
                try:
                    signed_request(client.futures_cancel_order, symbol=sym, orderId=entry1_oid)
                    canceled_ok = True
                except Exception:
                    canceled_ok = False
                if not canceled_ok:
                    try:
                        chk = signed_request(client.futures_get_order, symbol=sym, orderId=entry1_oid)
                        st_chk = str((chk or {}).get("status") or "").upper()
                        if st_chk == "FILLED":
                            try:
                                _emit_rest_fill_event(sym, chk, status_hint=st_chk)
                            except Exception:
                                pass
                            return False
                        if st_chk in ("CANCELED", "EXPIRED", "REJECTED"):
                            canceled_ok = True
                    except Exception:
                        canceled_ok = False
                if not canceled_ok:
                    return False

                try:
                    resp_new = signed_request(
                        client.futures_create_order,
                        symbol=sym,
                        side=side,
                        type="STOP_MARKET",
                        quantity=qty,
                        stopPrice=float(new_stop),
                    )
                except BinanceAPIException as be_new:
                    code_new = getattr(be_new, "code", None)
                    msg_new = str(be_new).lower()
                    if code_new == -2021 or "immediately trigger" in msg_new:
                        # If replacement would trigger immediately, just execute MARKET now.
                        try:
                            resp_new = signed_request(
                                client.futures_create_order,
                                symbol=sym,
                                side=side,
                                type="MARKET",
                                quantity=qty,
                            )
                            order_type = "MARKET"
                            pending_stop_px = None
                        except Exception:
                            return False
                    else:
                        return False
                except Exception:
                    return False

                new_oid = None
                try:
                    if isinstance(resp_new, dict) and resp_new.get("orderId") not in (None, "", 0, False):
                        new_oid = int(resp_new.get("orderId"))
                except Exception:
                    new_oid = None

                try:
                    with orders_lock:
                        pm = pending_meta.get(sym)
                        if isinstance(pm, dict):
                            pm["entry1_hard_sl_trigger"] = float(sl_plan)
                            pm["entry1_hard_sl_source"] = f"entry1:{sig.get('kind')}:{sig.get('interval')}"
                            pm["entry1_sent"] = True
                            pm["entry1_sent_ts"] = time.time()
                            pm["entry1_anchor_price"] = float(lp) if lp not in (None, "", 0, False) else pm.get("entry1_anchor_price")
                            pm["entry1_armed"] = False
                            pm["entry1_signal"] = {
                                "kind": sig.get("kind"),
                                "interval": sig.get("interval"),
                                "trigger": sig.get("trigger"),
                                "pending_stop": float(new_stop) if order_type == "STOP_MARKET" else None,
                                "order_type": str(order_type),
                                "stop_anchor": stop_anchor,
                                "micro_level": sig.get("micro_level"),
                                "ref_level": sig.get("ref_level"),
                                "sweep_level": sig.get("sweep_level"),
                                "ts": time.time(),
                            }
                            pm["entry1_replace_ts"] = time.time()
                            if new_oid is not None:
                                pm["entry1_order_id"] = new_oid
                            else:
                                pm.pop("entry1_order_id", None)
                            pending_meta[sym] = pm
                except Exception:
                    pass

                try:
                    remove_order_rows(
                        lambda row, s=sym: row.get("symbol") == s and str(row.get("tp_sl") or "").startswith("ENTRY1_STOP")
                    )
                except Exception:
                    pass
                try:
                    if order_type == "STOP_MARKET":
                        add_order_row(sym, side, qty, float(new_stop), f"ENTRY1_STOP:{sig.get('kind')}")
                    else:
                        add_order_row(sym, side, qty, lp, f"ENTRY1:{sig.get('kind')}")
                except Exception:
                    pass
                try:
                    log_message(
                        f"[ENTRY1] REPLACED {sym} side={side} {cur_stop:.8f}->{float(new_stop):.8f} "
                        f"kind={sig.get('kind')} iv={sig.get('interval')} oid={new_oid}"
                    )
                except Exception:
                    pass
                return True

    # Persist stop plan + mark ENTRY1 as sent BEFORE creating the order (avoid race with WS FILLED).
    pre_marked = False
    old_vals = {}
    MISSING = object()
    try:
        with orders_lock:
            pm = pending_meta.get(sym)
            if isinstance(pm, dict):
                keys = (
                    "entry1_hard_sl_trigger",
                    "entry1_hard_sl_source",
                    "entry1_sent",
                    "entry1_sent_ts",
                    "entry1_anchor_price",
                    "entry1_signal",
                    "entry1_armed",
                    "entry1_order_id",
                )
                for k in keys:
                    old_vals[k] = pm[k] if k in pm else MISSING
                pm["entry1_hard_sl_trigger"] = float(sl_plan)
                pm["entry1_hard_sl_source"] = f"entry1:{sig.get('kind')}:{sig.get('interval')}"
                pm["entry1_sent"] = True
                pm["entry1_sent_ts"] = time.time()
                pm["entry1_anchor_price"] = float(lp) if lp not in (None, "", 0, False) else pm.get("entry1_anchor_price")
                pm["entry1_armed"] = False
                pm["entry1_signal"] = {
                    "kind": sig.get("kind"),
                    "interval": sig.get("interval"),
                    "trigger": sig.get("trigger"),
                    "pending_stop": float(pending_stop_px) if pending_stop_px is not None else None,
                    "order_type": str(order_type),
                    "stop_anchor": stop_anchor,
                    "micro_level": sig.get("micro_level"),
                    "ref_level": sig.get("ref_level"),
                    "sweep_level": sig.get("sweep_level"),
                    "ts": time.time(),
                }
                pending_meta[sym] = pm
                pre_marked = True
    except Exception:
        pre_marked = False

    try:
        resp_mkt = None
        if order_type == "STOP_MARKET":
            resp_mkt = signed_request(
                client.futures_create_order,
                symbol=sym,
                side=side,
                type="STOP_MARKET",
                quantity=qty,
                stopPrice=float(pending_stop_px),
            )
        else:
            resp_mkt = signed_request(
                client.futures_create_order,
                symbol=sym,
                side=side,
                type="MARKET",
                quantity=qty,
            )
        log_message(
            f"[ENTRY1] {'PENDING' if order_type=='STOP_MARKET' else 'TRIGGER'} {sym} side={side} qty={qty} "
            f"kind={sig.get('kind')} iv={sig.get('interval')} trigger={sig.get('trigger')} "
            f"{('stop='+str(pending_stop_px)+' ') if (pending_stop_px is not None) else ''}"
            f"sl={sl_plan} resp={resp_mkt}"
        )
        try:
            if isinstance(resp_mkt, dict) and resp_mkt.get("orderId") not in (None, "", 0, False):
                with orders_lock:
                    pm = pending_meta.get(sym)
                    if isinstance(pm, dict):
                        pm["entry1_order_id"] = int(resp_mkt.get("orderId"))
                        pending_meta[sym] = pm
        except Exception:
            pass
        try:
            if order_type == "STOP_MARKET":
                add_order_row(sym, side, qty, float(pending_stop_px or 0.0), f"ENTRY1_STOP:{sig.get('kind')}")
            else:
                add_order_row(sym, side, qty, lp, f"ENTRY1:{sig.get('kind')}")
        except Exception:
            pass
        return True
    except Exception as e:
        try:
            log_message(f"❌ ENTRY1 {order_type} send failed for {sym}: {e}")
            log_message(traceback.format_exc())
        except Exception:
            pass
        # STOP_MARKET immediate-trigger edge case: fallback to MARKET.
        if order_type == "STOP_MARKET":
            try:
                code = getattr(e, "code", None)
                msg = str(e).lower()
                if code == -2021 or "immediately trigger" in msg:
                    try:
                        resp_fb = signed_request(
                            client.futures_create_order,
                            symbol=sym,
                            side=side,
                            type="MARKET",
                            quantity=qty,
                        )
                        log_message(
                            f"[ENTRY1] fallback MARKET {sym} side={side} qty={qty} kind={sig.get('kind')} "
                            f"iv={sig.get('interval')} sl={sl_plan} resp={resp_fb}"
                        )
                        try:
                            if isinstance(resp_fb, dict) and resp_fb.get("orderId") not in (None, "", 0, False):
                                with orders_lock:
                                    pm = pending_meta.get(sym)
                                    if isinstance(pm, dict):
                                        pm["entry1_order_id"] = int(resp_fb.get("orderId"))
                                        pending_meta[sym] = pm
                        except Exception:
                            pass
                        try:
                            add_order_row(sym, side, qty, lp, f"ENTRY1:{sig.get('kind')}")
                        except Exception:
                            pass
                        return True
                    except Exception:
                        pass
            except Exception:
                pass

        # Roll back only if we are confident the request didn't open a position.
        # (The create_order call may have succeeded even if we got an exception.)
        entry_open = False
        stop_exists = False
        stop_oid = None
        if order_type == "STOP_MARKET":
            # The request may have created an OPEN stop order even if we got an exception.
            try:
                oo = signed_request(client.futures_get_open_orders, symbol=sym)
                for o in (oo or []):
                    try:
                        if str(o.get("type") or "").upper() != "STOP_MARKET":
                            continue
                        if str(o.get("side") or "").upper() != str(side or "").upper():
                            continue
                        sp = float(o.get("stopPrice") or 0.0)
                        if pending_stop_px is not None and abs(sp - float(pending_stop_px)) <= max(float(tick or 0.0) * 2.0, 1e-12):
                            stop_exists = True
                            stop_oid = o.get("orderId")
                            break
                    except Exception:
                        continue
            except Exception:
                stop_exists = False
                stop_oid = None
        else:
            try:
                exch_amt, _ = get_exchange_position(sym)
                entry_open = abs(float(exch_amt or 0.0)) > eps
            except Exception:
                entry_open = False

        if stop_exists:
            try:
                if stop_oid not in (None, "", 0, False):
                    with orders_lock:
                        pm = pending_meta.get(sym)
                        if isinstance(pm, dict):
                            pm["entry1_order_id"] = int(stop_oid)
                            pending_meta[sym] = pm
            except Exception:
                pass
            try:
                log_message(f"[ENTRY1] stop send errored but an OPEN stop exists for {sym} -> keep entry1_sent")
            except Exception:
                pass
            return True

        if entry_open:
            try:
                log_message(f"[ENTRY1] micro send errored but position is open for {sym} -> keep entry1_sent")
            except Exception:
                pass
            return True

        if pre_marked:
            try:
                with orders_lock:
                    pm = pending_meta.get(sym)
                    if isinstance(pm, dict):
                        for k, v in old_vals.items():
                            if v is MISSING:
                                pm.pop(k, None)
                            else:
                                pm[k] = v
                        pending_meta[sym] = pm
            except Exception:
                pass
        return False


if __name__ == "__main__":
    try:
        main()
    except SystemExit:
        raise
    except Exception:
        crash_path = None
        try:
            os.makedirs(LOG_DIR, exist_ok=True)
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            crash_path = os.path.join(LOG_DIR, f"crash_{ts}.txt")
            with open(crash_path, "w", encoding="utf-8") as f:
                f.write("Tetra crash log\n")
                f.write(f"timestamp={ts}\n")
                f.write(f"python={sys.executable}\n")
                f.write(f"cwd={os.getcwd()}\n")
                f.write(f"argv={sys.argv}\n")
                try:
                    f.write(f"SETTINGS_FILE={SETTINGS_FILE}\n")
                except Exception:
                    pass
                try:
                    f.write(f"API_KEY={_secret_fingerprint(globals().get('API_KEY'))}\n")
                    f.write(f"API_SECRET={_secret_fingerprint(globals().get('API_SECRET'))}\n")
                except Exception:
                    pass
                f.write("\n")
                f.write(traceback.format_exc())
        except Exception:
            crash_path = None
        try:
            if IS_WINDOWS:
                msg = "Програма впала (crash).\n\n"
                if crash_path:
                    msg += f"Crash log: {crash_path}\n"
                else:
                    msg += "Crash log: (не вдалося записати)\n"
                ctypes.windll.user32.MessageBoxW(0, msg, "Tetra", 0x10)
        except Exception:
            pass
        raise